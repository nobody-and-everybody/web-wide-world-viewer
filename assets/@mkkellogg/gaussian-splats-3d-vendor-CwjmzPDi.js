var bn=Object.defineProperty;var Rn=(A,e,s)=>e in A?bn(A,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):A[e]=s;var P=(A,e,s)=>Rn(A,typeof e!="symbol"?e+"":e,s);import{D as yt,Q as Ce,B as un,M as lt,a as ee,V as D,b as We,c as ls,R as Mn,P as Pn,d as q,S as On,e as kn,O as hn,W as Ln,C as Pt,f as pn,g as Fe,h as ht,i as Ve,j as Nt,U as pt,k as Mt,F as Fs,l as Hn,H as Un,m as zn,n as Qn,o as _n,p as Nn,q as Vn,r as ft,s as bs,t as Rs,u as Gn,v as Ms,w as qn,x as nt,y as $t,z as cs,A as Wn,E as Ps,G as Kn,I as Je,T as Ze,J as Os,K as jn,L as Yn,N as Xn,X as Jn,Y as fn,Z as ks,_ as Zn}from"../three-vendor-CQf01eWO.js";const je=class je{constructor(e,s){let t,r;this.promise=new Promise((l,c)=>{t=l,r=c});const n=t.bind(this),o=r.bind(this),i=(...l)=>{n(...l)},a=l=>{o(l)};e(i.bind(this),a.bind(this)),this.abortHandler=s,this.id=je.idGen++}then(e){return new je((s,t)=>{this.promise=this.promise.then((...r)=>{const n=e(...r);n instanceof Promise||n instanceof je?n.then((...o)=>{s(...o)}):s(n)}).catch(r=>{t(r)})},this.abortHandler)}catch(e){return new je(s=>{this.promise=this.promise.then((...t)=>{s(...t)}).catch(e)},this.abortHandler)}abort(e){this.abortHandler&&this.abortHandler(e)}};P(je,"idGen",0);let xt=je;class mn extends Error{constructor(e){super(e)}}(function(){const A=new Float32Array(1),e=new Int32Array(A.buffer);return function(s){A[0]=s;const t=e[0];let r=t>>16&32768,n=t>>12&2047;const o=t>>23&255;return o<103?r:o>142?(r|=31744,r|=(o==255?0:1)&&t&8388607,r):o<113?(n|=2048,r|=(n>>114-o)+(n>>113-o&1),r):(r|=o-112<<10|n>>1,r+=n&1,r)}})();const Vt=(function(){const A=new Float32Array(1),e=new Int32Array(A.buffer);return function(s){return A[0]=s,e[0]}})(),$n=function(A,e){return A[e]+(A[e+1]<<8)+(A[e+2]<<16)+(A[e+3]<<24)},zt=function(A,e,s=!0,t){const r=new AbortController,n=r.signal;let o=!1;const i=c=>{r.abort(c),o=!0};let a=!1;const l=(c,d,h,u)=>{e&&!a&&(e(c,d,h,u),c===100&&(a=!0))};return new xt((c,d)=>{const h={signal:n};t&&(h.headers=t),fetch(A,h).then(async u=>{if(!u.ok){const x=await u.text();d(new Error(`Fetch failed: ${u.status} ${u.statusText} ${x}`));return}const p=u.body.getReader();let f=0,m=u.headers.get("Content-Length"),S=m?parseInt(m):void 0;const g=[];for(;!o;)try{const{value:x,done:T}=await p.read();if(T){if(l(100,"100%",x,S),s){const y=new Blob(g).arrayBuffer();c(y)}else c();break}f+=x.length;let C,v;S!==void 0&&(C=f/S*100,v=`${C.toFixed(2)}%`),s&&g.push(x),l(C,v,x,S)}catch(x){d(x);return}}).catch(u=>{d(new mn(u))})},i)},ie=function(A,e,s){return Math.max(Math.min(A,s),e)},$e=function(){return performance.now()/1e3},st=A=>{if(A.geometry&&(A.geometry.dispose(),A.geometry=null),A.material&&(A.material.dispose(),A.material=null),A.children)for(let e of A.children)st(e)},be=(A,e)=>new Promise(s=>{window.setTimeout(()=>{s(A?A():void 0)},e?1:50)}),ot=(A=0)=>{let e=0;if(A===1)e=9;else if(A===2)e=24;else if(A===3)e=45;else if(A>3)throw new Error("getSphericalHarmonicsComponentCountForDegree() -> Invalid spherical harmonics degree");return e},ds=()=>{let A,e;return{promise:new Promise((t,r)=>{A=t,e=r}),resolve:A,reject:e}},Gt=A=>{let e,s;return A||(A=()=>{}),{promise:new xt((r,n)=>{e=r,s=n},A),resolve:e,reject:s}};class er{constructor(e,s,t){this.major=e,this.minor=s,this.patch=t}toString(){return`${this.major}_${this.minor}_${this.patch}`}}function us(){const A=navigator.userAgent;return A.indexOf("iPhone")>0||A.indexOf("iPad")>0}function An(){if(us()){const A=navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);return new er(parseInt(A[1]||0,10),parseInt(A[2]||0,10),parseInt(A[3]||0,10))}else return null}const tr=14,Ct=class Ct{constructor(e=0){this.sphericalHarmonicsDegree=e,this.sphericalHarmonicsCount=ot(this.sphericalHarmonicsDegree),this.componentCount=this.sphericalHarmonicsCount+tr,this.defaultSphericalHarmonics=new Array(this.sphericalHarmonicsCount).fill(0),this.splats=[],this.splatCount=0}static createSplat(e=0){const s=[0,0,0,1,1,1,1,0,0,0,0,0,0,0];let t=ot(e);for(let r=0;r<t;r++)s.push(0);return s}addSplat(e){this.splats.push(e),this.splatCount++}getSplat(e){return this.splats[e]}addDefaultSplat(){const e=Ct.createSplat(this.sphericalHarmonicsDegree);return this.addSplat(e),e}addSplatFromComonents(e,s,t,r,n,o,i,a,l,c,d,h,u,p,...f){const m=[e,s,t,r,n,o,i,a,l,c,d,h,u,p,...this.defaultSphericalHarmonics];for(let S=0;S<f.length&&S<this.sphericalHarmonicsCount;S++)m[S]=f[S];return this.addSplat(m),m}addSplatFromArray(e,s){const t=e.splats[s],r=Ct.createSplat(this.sphericalHarmonicsDegree);for(let n=0;n<this.componentCount&&n<t.length;n++)r[n]=t[n];this.addSplat(r)}};P(Ct,"OFFSET",{X:0,Y:1,Z:2,SCALE0:3,SCALE1:4,SCALE2:5,ROTATION0:6,ROTATION1:7,ROTATION2:8,ROTATION3:9,FDC0:10,FDC1:11,FDC2:12,OPACITY:13,FRC0:14,FRC1:15,FRC2:16,FRC3:17,FRC4:18,FRC5:19,FRC6:20,FRC7:21,FRC8:22,FRC9:23,FRC10:24,FRC11:25,FRC12:26,FRC13:27,FRC14:28,FRC15:29,FRC16:30,FRC17:31,FRC18:32,FRC19:33,FRC20:34,FRC21:35,FRC22:36,FRC23:37});let L=Ct;class G{}P(G,"DefaultSplatSortDistanceMapPrecision",16),P(G,"MemoryPageSize",65536),P(G,"BytesPerFloat",4),P(G,"BytesPerInt",4),P(G,"MaxScenes",32),P(G,"ProgressiveLoadSectionSize",262144),P(G,"ProgressiveLoadSectionDelayDuration",15),P(G,"SphericalHarmonics8BitCompressionRange",3);const sr=G.SphericalHarmonics8BitCompressionRange,Ge=sr/2,Se=yt.toHalfFloat.bind(yt),hs=yt.fromHalfFloat.bind(yt),oe=(A,e,s=!1,t,r)=>{if(e===0)return A;if(e===1||e===2&&!s)return yt.fromHalfFloat(A);if(e===2)return ps(A,t,r)},mt=(A,e,s)=>{A=ie(A,e,s);const t=s-e;return ie(Math.floor((A-e)/t*255),0,255)},ps=(A,e,s)=>{const t=s-e;return A/255*t+e},gn=(A,e,s)=>mt(hs(A,e,s)),nr=(A,e,s)=>Se(ps(A,e,s)),j=(A,e,s,t=!1)=>s===0?A.getFloat32(e*4,!0):s===1||s===2&&!t?A.getUint16(e*2,!0):A.getUint8(e,!0),rr=(function(){const A=e=>e;return function(e,s,t,r=!1){if(s===t)return e;let n=A;return s===2&&r?t===1?n=nr:t==0&&(n=ps):s===2||s===1?t===0?n=hs:t==2&&(r?n=gn:n=A):s===0&&(t===1?n=Se:t==2&&(r?n=mt:n=Se)),n(e)}})(),et=(A,e,s,t,r=0)=>{const n=new Uint8Array(A,e),o=new Uint8Array(s,t);for(let i=0;i<r;i++)o[i]=n[i]},E=class E{constructor(e,s=!0){P(this,"getSplatScaleAndRotation",(function(){const e=new ee,s=new ee,t=new ee,r=new D,n=new D,o=new Ce;return function(i,a,l,c,d){const h=this.globalSplatIndexToSectionMap[i],u=this.sections[h],p=i-u.splatCountOffset,f=u.bytesPerSplat*p+E.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,m=new DataView(this.bufferData,u.dataBase+f);n.set(oe(j(m,0,this.compressionLevel),this.compressionLevel),oe(j(m,1,this.compressionLevel),this.compressionLevel),oe(j(m,2,this.compressionLevel),this.compressionLevel)),d&&(d.x!==void 0&&(n.x=d.x),d.y!==void 0&&(n.y=d.y),d.z!==void 0&&(n.z=d.z)),o.set(oe(j(m,4,this.compressionLevel),this.compressionLevel),oe(j(m,5,this.compressionLevel),this.compressionLevel),oe(j(m,6,this.compressionLevel),this.compressionLevel),oe(j(m,3,this.compressionLevel),this.compressionLevel)),c?(e.makeScale(n.x,n.y,n.z),s.makeRotationFromQuaternion(o),t.copy(e).multiply(s).multiply(c),t.decompose(r,l,a)):(a.copy(n),l.copy(o))}})());P(this,"fillSplatScaleRotationArray",(function(){const e=new ee,s=new ee,t=new ee,r=new D,n=new Ce,o=new D,i=a=>{const l=a.w<0?-1:1;a.x*=l,a.y*=l,a.z*=l,a.w*=l};return function(a,l,c,d,h,u,p,f){const m=this.splatCount;d=d||0,h=h||m-1,u===void 0&&(u=d);const S=(g,x)=>rr(g,x,p);for(let g=d;g<=h;g++){const x=this.globalSplatIndexToSectionMap[g],T=this.sections[x],C=g-T.splatCountOffset,v=T.bytesPerSplat*C+E.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,y=(g-d+u)*E.ScaleComponentCount,B=(g-d+u)*E.RotationComponentCount,F=new DataView(this.bufferData,T.dataBase+v),w=f&&f.x!==void 0?f.x:j(F,0,this.compressionLevel),M=f&&f.y!==void 0?f.y:j(F,1,this.compressionLevel),O=f&&f.z!==void 0?f.z:j(F,2,this.compressionLevel),R=j(F,3,this.compressionLevel),b=j(F,4,this.compressionLevel),k=j(F,5,this.compressionLevel),H=j(F,6,this.compressionLevel);r.set(oe(w,this.compressionLevel),oe(M,this.compressionLevel),oe(O,this.compressionLevel)),n.set(oe(b,this.compressionLevel),oe(k,this.compressionLevel),oe(H,this.compressionLevel),oe(R,this.compressionLevel)).normalize(),c&&(o.set(0,0,0),e.makeScale(r.x,r.y,r.z),s.makeRotationFromQuaternion(n),t.identity().premultiply(e).premultiply(s),t.premultiply(c),t.decompose(o,n,r),n.normalize()),i(n),a&&(a[y]=S(r.x,0),a[y+1]=S(r.y,0),a[y+2]=S(r.z,0)),l&&(l[B]=S(n.x,0),l[B+1]=S(n.y,0),l[B+2]=S(n.z,0),l[B+3]=S(n.w,0))}}})());P(this,"fillSphericalHarmonicsArray",(function(){for(let b=0;b<15;b++)new D;const e=new We,s=new ee,t=new D,r=new D,n=new Ce,o=[],i=[],a=[],l=[],c=[],d=[],h=[],u=[],p=[],f=[],m=[],S=[],g=[],x=[],T=[],C=[],v=[],y=[],B=b=>b,F=(b,k,H,Q)=>{b[0]=k,b[1]=H,b[2]=Q},w=(b,k,H,Q,N)=>{b[0]=j(k,Q,N,!0),b[1]=j(k,Q+H,N,!0),b[2]=j(k,Q+H+H,N,!0)},M=(b,k)=>{k[0]=b[0],k[1]=b[1],k[2]=b[2]},O=(b,k,H,Q)=>{k[H]=Q(b[0]),k[H+1]=Q(b[1]),k[H+2]=Q(b[2])},R=(b,k,H,Q,N)=>(k[0]=oe(b[0],H,!0,Q,N),k[1]=oe(b[1],H,!0,Q,N),k[2]=oe(b[2],H,!0,Q,N),k);return function(b,k,H,Q,N,U,V){const J=this.splatCount;Q=Q||0,N=N||J-1,U===void 0&&(U=Q),H&&k>=1&&(s.copy(H),s.decompose(t,n,r),n.normalize(),s.makeRotationFromQuaternion(n),e.setFromMatrix4(s),F(o,e.elements[4],-e.elements[7],e.elements[1]),F(i,-e.elements[5],e.elements[8],-e.elements[2]),F(a,e.elements[3],-e.elements[6],e.elements[0]));const ce=W=>gn(W,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff),Z=W=>mt(W,this.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff);for(let W=Q;W<=N;W++){const te=this.globalSplatIndexToSectionMap[W],K=this.sections[te];k=Math.min(k,K.sphericalHarmonicsDegree);const $=ot(k),de=W-K.splatCountOffset,ue=K.bytesPerSplat*de+E.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,ae=new DataView(this.bufferData,K.dataBase+ue),xe=(W-Q+U)*$;let me=H?0:this.compressionLevel,re=B;me!==V&&(me===1?V===0?re=hs:V==2&&(re=ce):me===0&&(V===1?re=Se:V==2&&(re=Z)));const Ae=this.minSphericalHarmonicsCoeff,se=this.maxSphericalHarmonicsCoeff;k>=1&&(w(p,ae,3,0,this.compressionLevel),w(f,ae,3,1,this.compressionLevel),w(m,ae,3,2,this.compressionLevel),H?(R(p,p,this.compressionLevel,Ae,se),R(f,f,this.compressionLevel,Ae,se),R(m,m,this.compressionLevel,Ae,se),E.rotateSphericalHarmonics3(p,f,m,o,i,a,x,T,C)):(M(p,x),M(f,T),M(m,C)),O(x,b,xe,re),O(T,b,xe+3,re),O(C,b,xe+6,re),k>=2&&(w(p,ae,5,9,this.compressionLevel),w(f,ae,5,10,this.compressionLevel),w(m,ae,5,11,this.compressionLevel),w(S,ae,5,12,this.compressionLevel),w(g,ae,5,13,this.compressionLevel),H?(R(p,p,this.compressionLevel,Ae,se),R(f,f,this.compressionLevel,Ae,se),R(m,m,this.compressionLevel,Ae,se),R(S,S,this.compressionLevel,Ae,se),R(g,g,this.compressionLevel,Ae,se),E.rotateSphericalHarmonics5(p,f,m,S,g,o,i,a,l,c,d,h,u,x,T,C,v,y)):(M(p,x),M(f,T),M(m,C),M(S,v),M(g,y)),O(x,b,xe+9,re),O(T,b,xe+12,re),O(C,b,xe+15,re),O(v,b,xe+18,re),O(y,b,xe+21,re)))}}})());this.constructFromBuffer(e,s)}getSplatCount(){return this.splatCount}getMaxSplatCount(){return this.maxSplatCount}getMinSphericalHarmonicsDegree(){let e=0;for(let s=0;s<this.sections.length;s++){const t=this.sections[s];(s===0||t.sphericalHarmonicsDegree<e)&&(e=t.sphericalHarmonicsDegree)}return e}getBucketIndex(e,s){let t;const r=e.fullBucketCount*e.bucketSize;if(s<r)t=Math.floor(s/e.bucketSize);else{let n=r;t=e.fullBucketCount;let o=0;for(;n<e.splatCount;){let i=e.partiallyFilledBucketLengths[o];if(s>=n&&s<n+i)break;n+=i,t++,o++}}return t}getSplatCenter(e,s,t){const r=this.globalSplatIndexToSectionMap[e],n=this.sections[r],o=e-n.splatCountOffset,i=n.bytesPerSplat*o,a=new DataView(this.bufferData,n.dataBase+i),l=j(a,0,this.compressionLevel),c=j(a,1,this.compressionLevel),d=j(a,2,this.compressionLevel);if(this.compressionLevel>=1){const u=this.getBucketIndex(n,o)*E.BucketStorageSizeFloats,p=n.compressionScaleFactor,f=n.compressionScaleRange;s.x=(l-f)*p+n.bucketArray[u],s.y=(c-f)*p+n.bucketArray[u+1],s.z=(d-f)*p+n.bucketArray[u+2]}else s.x=l,s.y=c,s.z=d;t&&s.applyMatrix4(t)}getSplatColor(e,s){const t=this.globalSplatIndexToSectionMap[e],r=this.sections[t],n=e-r.splatCountOffset,o=r.bytesPerSplat*n+E.CompressionLevels[this.compressionLevel].ColorOffsetBytes,i=new Uint8Array(this.bufferData,r.dataBase+o,4);s.set(i[0],i[1],i[2],i[3])}fillSplatCenterArray(e,s,t,r,n){const o=this.splatCount;t=t||0,r=r||o-1,n===void 0&&(n=t);const i=new D;for(let a=t;a<=r;a++){const l=this.globalSplatIndexToSectionMap[a],c=this.sections[l],d=a-c.splatCountOffset,h=(a-t+n)*E.CenterComponentCount,u=c.bytesPerSplat*d,p=new DataView(this.bufferData,c.dataBase+u),f=j(p,0,this.compressionLevel),m=j(p,1,this.compressionLevel),S=j(p,2,this.compressionLevel);if(this.compressionLevel>=1){const x=this.getBucketIndex(c,d)*E.BucketStorageSizeFloats,T=c.compressionScaleFactor,C=c.compressionScaleRange;i.x=(f-C)*T+c.bucketArray[x],i.y=(m-C)*T+c.bucketArray[x+1],i.z=(S-C)*T+c.bucketArray[x+2]}else i.x=f,i.y=m,i.z=S;s&&i.applyMatrix4(s),e[h]=i.x,e[h+1]=i.y,e[h+2]=i.z}}fillSplatCovarianceArray(e,s,t,r,n,o){const i=this.splatCount,a=new D,l=new Ce;t=t||0,r=r||i-1,n===void 0&&(n=t);for(let c=t;c<=r;c++){const d=this.globalSplatIndexToSectionMap[c],h=this.sections[d],u=c-h.splatCountOffset,p=(c-t+n)*E.CovarianceComponentCount,f=h.bytesPerSplat*u+E.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,m=new DataView(this.bufferData,h.dataBase+f);a.set(oe(j(m,0,this.compressionLevel),this.compressionLevel),oe(j(m,1,this.compressionLevel),this.compressionLevel),oe(j(m,2,this.compressionLevel),this.compressionLevel)),l.set(oe(j(m,4,this.compressionLevel),this.compressionLevel),oe(j(m,5,this.compressionLevel),this.compressionLevel),oe(j(m,6,this.compressionLevel),this.compressionLevel),oe(j(m,3,this.compressionLevel),this.compressionLevel)),E.computeCovariance(a,l,s,e,p,o)}}fillSplatColorArray(e,s,t,r,n){const o=this.splatCount;t=t||0,r=r||o-1,n===void 0&&(n=t);for(let i=t;i<=r;i++){const a=this.globalSplatIndexToSectionMap[i],l=this.sections[a],c=i-l.splatCountOffset,d=(i-t+n)*E.ColorComponentCount,h=l.bytesPerSplat*c+E.CompressionLevels[this.compressionLevel].ColorOffsetBytes,u=new Uint8Array(this.bufferData,l.dataBase+h);let p=u[3];p=p>=s?p:0,e[d]=u[0],e[d+1]=u[1],e[d+2]=u[2],e[d+3]=p}}static parseHeader(e){const s=new Uint8Array(e,0,E.HeaderSizeBytes),t=new Uint16Array(e,0,E.HeaderSizeBytes/2),r=new Uint32Array(e,0,E.HeaderSizeBytes/4),n=new Float32Array(e,0,E.HeaderSizeBytes/4),o=s[0],i=s[1],a=r[1],l=r[2],c=r[3],d=r[4],h=t[10],u=new D(n[6],n[7],n[8]),p=n[9]||-Ge,f=n[10]||Ge;return{versionMajor:o,versionMinor:i,maxSectionCount:a,sectionCount:l,maxSplatCount:c,splatCount:d,compressionLevel:h,sceneCenter:u,minSphericalHarmonicsCoeff:p,maxSphericalHarmonicsCoeff:f}}static writeHeaderCountsToBuffer(e,s,t){const r=new Uint32Array(t,0,E.HeaderSizeBytes/4);r[2]=e,r[4]=s}static writeHeaderToBuffer(e,s){const t=new Uint8Array(s,0,E.HeaderSizeBytes),r=new Uint16Array(s,0,E.HeaderSizeBytes/2),n=new Uint32Array(s,0,E.HeaderSizeBytes/4),o=new Float32Array(s,0,E.HeaderSizeBytes/4);t[0]=e.versionMajor,t[1]=e.versionMinor,t[2]=0,t[3]=0,n[1]=e.maxSectionCount,n[2]=e.sectionCount,n[3]=e.maxSplatCount,n[4]=e.splatCount,r[10]=e.compressionLevel,o[6]=e.sceneCenter.x,o[7]=e.sceneCenter.y,o[8]=e.sceneCenter.z,o[9]=e.minSphericalHarmonicsCoeff||-Ge,o[10]=e.maxSphericalHarmonicsCoeff||Ge}static parseSectionHeaders(e,s,t=0,r){const n=e.compressionLevel,o=e.maxSectionCount,i=new Uint16Array(s,t,o*E.SectionHeaderSizeBytes/2),a=new Uint32Array(s,t,o*E.SectionHeaderSizeBytes/4),l=new Float32Array(s,t,o*E.SectionHeaderSizeBytes/4),c=[];let d=0,h=d/2,u=d/4,p=E.HeaderSizeBytes+e.maxSectionCount*E.SectionHeaderSizeBytes,f=0;for(let m=0;m<o;m++){const S=a[u+1],g=a[u+2],x=a[u+3],T=l[u+4],C=T/2,v=i[h+10],y=a[u+6]||E.CompressionLevels[n].ScaleRange,B=a[u+8],F=a[u+9],w=F*4,M=v*x+w,O=i[h+20],{bytesPerSplat:R}=E.calculateComponentStorage(n,O),b=R*S,k=b+M,H={bytesPerSplat:R,splatCountOffset:f,splatCount:r?S:0,maxSplatCount:S,bucketSize:g,bucketCount:x,bucketBlockSize:T,halfBucketBlockSize:C,bucketStorageSizeBytes:v,bucketsStorageSizeBytes:M,splatDataStorageSizeBytes:b,storageSizeBytes:k,compressionScaleRange:y,compressionScaleFactor:C/y,base:p,bucketsBase:p+w,dataBase:p+M,fullBucketCount:B,partiallyFilledBucketCount:F,sphericalHarmonicsDegree:O};c[m]=H,p+=k,d+=E.SectionHeaderSizeBytes,h=d/2,u=d/4,f+=S}return c}static writeSectionHeaderToBuffer(e,s,t,r=0){const n=new Uint16Array(t,r,E.SectionHeaderSizeBytes/2),o=new Uint32Array(t,r,E.SectionHeaderSizeBytes/4),i=new Float32Array(t,r,E.SectionHeaderSizeBytes/4);o[0]=e.splatCount,o[1]=e.maxSplatCount,o[2]=s>=1?e.bucketSize:0,o[3]=s>=1?e.bucketCount:0,i[4]=s>=1?e.bucketBlockSize:0,n[10]=s>=1?E.BucketStorageSizeBytes:0,o[6]=s>=1?e.compressionScaleRange:0,o[7]=e.storageSizeBytes,o[8]=s>=1?e.fullBucketCount:0,o[9]=s>=1?e.partiallyFilledBucketCount:0,n[20]=e.sphericalHarmonicsDegree}static writeSectionHeaderSplatCountToBuffer(e,s,t=0){const r=new Uint32Array(s,t,E.SectionHeaderSizeBytes/4);r[0]=e}constructFromBuffer(e,s){this.bufferData=e,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSectionMap=[];const t=E.parseHeader(this.bufferData);this.versionMajor=t.versionMajor,this.versionMinor=t.versionMinor,this.maxSectionCount=t.maxSectionCount,this.sectionCount=s?t.maxSectionCount:0,this.maxSplatCount=t.maxSplatCount,this.splatCount=s?t.maxSplatCount:0,this.compressionLevel=t.compressionLevel,this.sceneCenter=new D().copy(t.sceneCenter),this.minSphericalHarmonicsCoeff=t.minSphericalHarmonicsCoeff,this.maxSphericalHarmonicsCoeff=t.maxSphericalHarmonicsCoeff,this.sections=E.parseSectionHeaders(t,this.bufferData,E.HeaderSizeBytes,s),this.linkBufferArrays(),this.buildMaps()}static calculateComponentStorage(e,s){const t=E.CompressionLevels[e].BytesPerCenter,r=E.CompressionLevels[e].BytesPerScale,n=E.CompressionLevels[e].BytesPerRotation,o=E.CompressionLevels[e].BytesPerColor,i=ot(s),a=E.CompressionLevels[e].BytesPerSphericalHarmonicsComponent*i,l=t+r+n+o+a;return{bytesPerCenter:t,bytesPerScale:r,bytesPerRotation:n,bytesPerColor:o,sphericalHarmonicsComponentsPerSplat:i,sphericalHarmonicsBytesPerSplat:a,bytesPerSplat:l}}linkBufferArrays(){for(let e=0;e<this.maxSectionCount;e++){const s=this.sections[e];s.bucketArray=new Float32Array(this.bufferData,s.bucketsBase,s.bucketCount*E.BucketStorageSizeFloats),s.partiallyFilledBucketCount>0&&(s.partiallyFilledBucketLengths=new Uint32Array(this.bufferData,s.base,s.partiallyFilledBucketCount))}}buildMaps(){let e=0;for(let s=0;s<this.maxSectionCount;s++){const t=this.sections[s];for(let r=0;r<t.maxSplatCount;r++){const n=e+r;this.globalSplatIndexToLocalSplatIndexMap[n]=r,this.globalSplatIndexToSectionMap[n]=s}e+=t.maxSplatCount}}updateLoadedCounts(e,s){E.writeHeaderCountsToBuffer(e,s,this.bufferData),this.sectionCount=e,this.splatCount=s}updateSectionLoadedCounts(e,s){const t=E.HeaderSizeBytes+E.SectionHeaderSizeBytes*e;E.writeSectionHeaderSplatCountToBuffer(s,this.bufferData,t),this.sections[e].splatCount=s}static generateFromUncompressedSplatArrays(e,s,t,r,n,o,i=[]){let a=0;for(let C=0;C<e.length;C++){const v=e[C];a=Math.max(v.sphericalHarmonicsDegree,a)}let l,c;for(let C=0;C<e.length;C++){const v=e[C];for(let y=0;y<v.splats.length;y++){const B=v.splats[y];for(let F=L.OFFSET.FRC0;F<L.OFFSET.FRC23&&F<B.length;F++)(!l||B[F]<l)&&(l=B[F]),(!c||B[F]>c)&&(c=B[F])}}l=l||-Ge,c=c||Ge;const{bytesPerSplat:d}=E.calculateComponentStorage(t,a),h=E.CompressionLevels[t].ScaleRange,u=[],p=[];let f=0;for(let C=0;C<e.length;C++){const v=e[C],y=new L(a);for(let te=0;te<v.splatCount;te++){const K=v.splats[te];(K[L.OFFSET.OPACITY]||0)>=s&&y.addSplat(K)}const B=i[C]||{},F=(B.blockSizeFactor||1)*(n||E.BucketBlockSize),w=Math.ceil((B.bucketSizeFactor||1)*(o||E.BucketSize)),M=E.computeBucketsForUncompressedSplatArray(y,F,w),O=M.fullBuckets.length,R=M.partiallyFullBuckets.map(te=>te.splats.length),b=R.length,k=[...M.fullBuckets,...M.partiallyFullBuckets],H=y.splats.length*d,Q=b*4,N=t>=1?k.length*E.BucketStorageSizeBytes+Q:0,U=H+N,V=new ArrayBuffer(U),J=h/(F*.5),ce=new D;let Z=0;for(let te=0;te<k.length;te++){const K=k[te];ce.fromArray(K.center);for(let $=0;$<K.splats.length;$++){let de=K.splats[$];const ue=y.splats[de],ae=N+Z*d;E.writeSplatDataToSectionBuffer(ue,V,ae,t,a,ce,J,h,l,c),Z++}}if(f+=Z,t>=1){const te=new Uint32Array(V,0,R.length*4);for(let $=0;$<R.length;$++)te[$]=R[$];const K=new Float32Array(V,Q,k.length*E.BucketStorageSizeFloats);for(let $=0;$<k.length;$++){const de=k[$],ue=$*3;K[ue]=de.center[0],K[ue+1]=de.center[1],K[ue+2]=de.center[2]}}u.push(V);const W=new ArrayBuffer(E.SectionHeaderSizeBytes);E.writeSectionHeaderToBuffer({maxSplatCount:Z,splatCount:Z,bucketSize:w,bucketCount:k.length,bucketBlockSize:F,compressionScaleRange:h,storageSizeBytes:U,fullBucketCount:O,partiallyFilledBucketCount:b,sphericalHarmonicsDegree:a},t,W,0),p.push(W)}let m=0;for(let C of u)m+=C.byteLength;const S=E.HeaderSizeBytes+E.SectionHeaderSizeBytes*u.length+m,g=new ArrayBuffer(S);E.writeHeaderToBuffer({versionMajor:0,versionMinor:1,maxSectionCount:u.length,sectionCount:u.length,maxSplatCount:f,splatCount:f,compressionLevel:t,sceneCenter:r,minSphericalHarmonicsCoeff:l,maxSphericalHarmonicsCoeff:c},g);let x=E.HeaderSizeBytes;for(let C of p)new Uint8Array(g,x,E.SectionHeaderSizeBytes).set(new Uint8Array(C)),x+=E.SectionHeaderSizeBytes;for(let C of u)new Uint8Array(g,x,C.byteLength).set(new Uint8Array(C)),x+=C.byteLength;return new E(g)}static computeBucketsForUncompressedSplatArray(e,s,t){let r=e.splatCount;const n=s/2,o=new D,i=new D;for(let f=0;f<r;f++){const m=e.splats[f],S=[m[L.OFFSET.X],m[L.OFFSET.Y],m[L.OFFSET.Z]];(f===0||S[0]<o.x)&&(o.x=S[0]),(f===0||S[0]>i.x)&&(i.x=S[0]),(f===0||S[1]<o.y)&&(o.y=S[1]),(f===0||S[1]>i.y)&&(i.y=S[1]),(f===0||S[2]<o.z)&&(o.z=S[2]),(f===0||S[2]>i.z)&&(i.z=S[2])}const a=new D().copy(i).sub(o),l=Math.ceil(a.y/s),c=Math.ceil(a.z/s),d=new D,h=[],u={};for(let f=0;f<r;f++){const m=e.splats[f],S=[m[L.OFFSET.X],m[L.OFFSET.Y],m[L.OFFSET.Z]],g=Math.floor((S[0]-o.x)/s),x=Math.floor((S[1]-o.y)/s),T=Math.floor((S[2]-o.z)/s);d.x=g*s+o.x+n,d.y=x*s+o.y+n,d.z=T*s+o.z+n;const C=g*(l*c)+x*c+T;let v=u[C];v||(u[C]=v={splats:[],center:d.toArray()}),v.splats.push(f),v.splats.length>=t&&(h.push(v),u[C]=null)}const p=[];for(let f in u)if(u.hasOwnProperty(f)){const m=u[f];m&&p.push(m)}return{fullBuckets:h,partiallyFullBuckets:p}}static preallocateUncompressed(e,s){const t=E.CompressionLevels[0].SphericalHarmonicsDegrees[s],r=E.HeaderSizeBytes+E.SectionHeaderSizeBytes,n=r+t.BytesPerSplat*e,o=new ArrayBuffer(n);return E.writeHeaderToBuffer({versionMajor:E.CurrentMajorVersion,versionMinor:E.CurrentMinorVersion,maxSectionCount:1,sectionCount:1,maxSplatCount:e,splatCount:e,compressionLevel:0,sceneCenter:new D},o),E.writeSectionHeaderToBuffer({maxSplatCount:e,splatCount:e,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:s},0,o,E.HeaderSizeBytes),{splatBuffer:new E(o,!0),splatBufferDataOffsetBytes:r}}};P(E,"CurrentMajorVersion",0),P(E,"CurrentMinorVersion",1),P(E,"CenterComponentCount",3),P(E,"ScaleComponentCount",3),P(E,"RotationComponentCount",4),P(E,"ColorComponentCount",4),P(E,"CovarianceComponentCount",6),P(E,"SplatScaleOffsetFloat",3),P(E,"SplatRotationOffsetFloat",6),P(E,"CompressionLevels",{0:{BytesPerCenter:12,BytesPerScale:12,BytesPerRotation:16,BytesPerColor:4,ScaleOffsetBytes:12,RotationffsetBytes:24,ColorOffsetBytes:40,SphericalHarmonicsOffsetBytes:44,ScaleRange:1,BytesPerSphericalHarmonicsComponent:4,SphericalHarmonicsOffsetFloat:11,SphericalHarmonicsDegrees:{0:{BytesPerSplat:44},1:{BytesPerSplat:80},2:{BytesPerSplat:140}}},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:2,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:42},2:{BytesPerSplat:72}}},2:{BytesPerCenter:6,BytesPerScale:6,BytesPerRotation:8,BytesPerColor:4,ScaleOffsetBytes:6,RotationffsetBytes:12,ColorOffsetBytes:20,SphericalHarmonicsOffsetBytes:24,ScaleRange:32767,BytesPerSphericalHarmonicsComponent:1,SphericalHarmonicsOffsetFloat:12,SphericalHarmonicsDegrees:{0:{BytesPerSplat:24},1:{BytesPerSplat:33},2:{BytesPerSplat:48}}}}),P(E,"CovarianceSizeFloats",6),P(E,"HeaderSizeBytes",4096),P(E,"SectionHeaderSizeBytes",1024),P(E,"BucketStorageSizeBytes",12),P(E,"BucketStorageSizeFloats",3),P(E,"BucketBlockSize",5),P(E,"BucketSize",256),P(E,"computeCovariance",(function(){const e=new ee,s=new We,t=new We,r=new We,n=new We,o=new We,i=new We;return function(a,l,c,d,h=0,u){e.makeScale(a.x,a.y,a.z),s.setFromMatrix4(e),e.makeRotationFromQuaternion(l),t.setFromMatrix4(e),r.copy(t).multiply(s),n.copy(r).transpose().premultiply(r),c&&(o.setFromMatrix4(c),i.copy(o).transpose(),n.multiply(i),n.premultiply(o)),u>=1?(d[h]=Se(n.elements[0]),d[h+1]=Se(n.elements[3]),d[h+2]=Se(n.elements[6]),d[h+3]=Se(n.elements[4]),d[h+4]=Se(n.elements[7]),d[h+5]=Se(n.elements[8])):(d[h]=n.elements[0],d[h+1]=n.elements[3],d[h+2]=n.elements[6],d[h+3]=n.elements[4],d[h+4]=n.elements[7],d[h+5]=n.elements[8])}})()),P(E,"dot3",(e,s,t,r,n)=>{n[0]=n[1]=n[2]=0;const o=r[0],i=r[1],a=r[2];E.addInto3(e[0]*o,e[1]*o,e[2]*o,n),E.addInto3(s[0]*i,s[1]*i,s[2]*i,n),E.addInto3(t[0]*a,t[1]*a,t[2]*a,n)}),P(E,"addInto3",(e,s,t,r)=>{r[0]=r[0]+e,r[1]=r[1]+s,r[2]=r[2]+t}),P(E,"dot5",(e,s,t,r,n,o,i)=>{i[0]=i[1]=i[2]=0;const a=o[0],l=o[1],c=o[2],d=o[3],h=o[4];E.addInto3(e[0]*a,e[1]*a,e[2]*a,i),E.addInto3(s[0]*l,s[1]*l,s[2]*l,i),E.addInto3(t[0]*c,t[1]*c,t[2]*c,i),E.addInto3(r[0]*d,r[1]*d,r[2]*d,i),E.addInto3(n[0]*h,n[1]*h,n[2]*h,i)}),P(E,"rotateSphericalHarmonics3",(e,s,t,r,n,o,i,a,l)=>{E.dot3(e,s,t,r,i),E.dot3(e,s,t,n,a),E.dot3(e,s,t,o,l)}),P(E,"rotateSphericalHarmonics5",(e,s,t,r,n,o,i,a,l,c,d,h,u,p,f,m,S,g)=>{const x=Math.sqrt(.25),T=Math.sqrt(3/4),C=Math.sqrt(1/3),v=Math.sqrt(4/3),y=Math.sqrt(1/12);l[0]=x*(a[2]*o[0]+a[0]*o[2]+(o[2]*a[0]+o[0]*a[2])),l[1]=a[1]*o[0]+o[1]*a[0],l[2]=T*(a[1]*o[1]+o[1]*a[1]),l[3]=a[1]*o[2]+o[1]*a[2],l[4]=x*(a[2]*o[2]-a[0]*o[0]+(o[2]*a[2]-o[0]*a[0])),E.dot5(e,s,t,r,n,l,p),c[0]=x*(i[2]*o[0]+i[0]*o[2]+(o[2]*i[0]+o[0]*i[2])),c[1]=i[1]*o[0]+o[1]*i[0],c[2]=T*(i[1]*o[1]+o[1]*i[1]),c[3]=i[1]*o[2]+o[1]*i[2],c[4]=x*(i[2]*o[2]-i[0]*o[0]+(o[2]*i[2]-o[0]*i[0])),E.dot5(e,s,t,r,n,c,f),d[0]=C*(i[2]*i[0]+i[0]*i[2])+-y*(a[2]*a[0]+a[0]*a[2]+(o[2]*o[0]+o[0]*o[2])),d[1]=v*i[1]*i[0]+-C*(a[1]*a[0]+o[1]*o[0]),d[2]=i[1]*i[1]+-x*(a[1]*a[1]+o[1]*o[1]),d[3]=v*i[1]*i[2]+-C*(a[1]*a[2]+o[1]*o[2]),d[4]=C*(i[2]*i[2]-i[0]*i[0])+-y*(a[2]*a[2]-a[0]*a[0]+(o[2]*o[2]-o[0]*o[0])),E.dot5(e,s,t,r,n,d,m),h[0]=x*(i[2]*a[0]+i[0]*a[2]+(a[2]*i[0]+a[0]*i[2])),h[1]=i[1]*a[0]+a[1]*i[0],h[2]=T*(i[1]*a[1]+a[1]*i[1]),h[3]=i[1]*a[2]+a[1]*i[2],h[4]=x*(i[2]*a[2]-i[0]*a[0]+(a[2]*i[2]-a[0]*i[0])),E.dot5(e,s,t,r,n,h,S),u[0]=x*(a[2]*a[0]+a[0]*a[2]-(o[2]*o[0]+o[0]*o[2])),u[1]=a[1]*a[0]-o[1]*o[0],u[2]=T*(a[1]*a[1]-o[1]*o[1]),u[3]=a[1]*a[2]-o[1]*o[2],u[4]=x*(a[2]*a[2]-a[0]*a[0]-(o[2]*o[2]-o[0]*o[0])),E.dot5(e,s,t,r,n,u,g)}),P(E,"writeSplatDataToSectionBuffer",(function(){const e=new ArrayBuffer(12),s=new ArrayBuffer(12),t=new ArrayBuffer(16),r=new ArrayBuffer(4),n=new ArrayBuffer(256),o=new Ce,i=new D,a=new D,{X:l,Y:c,Z:d,SCALE0:h,SCALE1:u,SCALE2:p,ROTATION0:f,ROTATION1:m,ROTATION2:S,ROTATION3:g,FDC0:x,FDC1:T,FDC2:C,OPACITY:v,FRC0:y,FRC9:B}=L.OFFSET,F=(w,M,O)=>{const R=O*2+1;return w=Math.round(w*M)+O,ie(w,0,R)};return function(w,M,O,R,b,k,H,Q,N=-Ge,U=Ge){const V=ot(b),J=E.CompressionLevels[R].BytesPerCenter,ce=E.CompressionLevels[R].BytesPerScale,Z=E.CompressionLevels[R].BytesPerRotation,W=E.CompressionLevels[R].BytesPerColor,te=O,K=te+J,$=K+ce,de=$+Z,ue=de+W;if(w[f]!==void 0?(o.set(w[f],w[m],w[S],w[g]),o.normalize()):o.set(1,0,0,0),w[h]!==void 0?i.set(w[h]||0,w[u]||0,w[p]||0):i.set(0,0,0),R===0){const xe=new Float32Array(M,te,E.CenterComponentCount),me=new Float32Array(M,$,E.RotationComponentCount),re=new Float32Array(M,K,E.ScaleComponentCount);if(me.set([o.x,o.y,o.z,o.w]),re.set([i.x,i.y,i.z]),xe.set([w[l],w[c],w[d]]),b>0){const Ae=new Float32Array(M,ue,V);if(b>=1){for(let se=0;se<9;se++)Ae[se]=w[y+se]||0;if(b>=2)for(let se=0;se<15;se++)Ae[se+9]=w[B+se]||0}}}else{const xe=new Uint16Array(e,0,E.CenterComponentCount),me=new Uint16Array(t,0,E.RotationComponentCount),re=new Uint16Array(s,0,E.ScaleComponentCount);if(me.set([Se(o.x),Se(o.y),Se(o.z),Se(o.w)]),re.set([Se(i.x),Se(i.y),Se(i.z)]),a.set(w[l],w[c],w[d]).sub(k),a.x=F(a.x,H,Q),a.y=F(a.y,H,Q),a.z=F(a.z,H,Q),xe.set([a.x,a.y,a.z]),b>0){const Ae=R===1?Uint16Array:Uint8Array,se=R===1?2:1,Re=new Ae(n,0,V);if(b>=1){for(let ye=0;ye<9;ye++){const we=w[y+ye]||0;Re[ye]=R===1?Se(we):mt(we,N,U)}const Pe=9*se;if(et(Re.buffer,0,M,ue,Pe),b>=2){for(let ye=0;ye<15;ye++){const we=w[B+ye]||0;Re[ye+9]=R===1?Se(we):mt(we,N,U)}et(Re.buffer,Pe,M,ue+Pe,15*se)}}}et(xe.buffer,0,M,te,6),et(re.buffer,0,M,K,6),et(me.buffer,0,M,$,8)}const ae=new Uint8ClampedArray(r,0,4);ae.set([w[x]||0,w[T]||0,w[C]||0]),ae[3]=w[v]||0,et(ae.buffer,0,M,de,4)}})());let z=E;const Ls=new Uint8Array([112,108,121,10]),Hs=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),qt="end_header",Wt=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]),Oe=(A,e)=>{const s=(1<<e)-1;return(A&s)/s},Us=(A,e)=>{A.x=Oe(e>>>21,11),A.y=Oe(e>>>11,10),A.z=Oe(e,11)},or=(A,e)=>{A.x=Oe(e>>>24,8),A.y=Oe(e>>>16,8),A.z=Oe(e>>>8,8),A.w=Oe(e,8)},ir=(A,e)=>{const s=1/(Math.sqrt(2)*.5),t=(Oe(e>>>20,10)-.5)*s,r=(Oe(e>>>10,10)-.5)*s,n=(Oe(e,10)-.5)*s,o=Math.sqrt(1-(t*t+r*r+n*n));switch(e>>>30){case 0:A.set(o,t,r,n);break;case 1:A.set(t,o,r,n);break;case 2:A.set(t,r,o,n);break;case 3:A.set(t,r,n,o);break}},He=(A,e,s)=>A*(1-s)+e*s,le=(A,e)=>{var s;return(s=A.properties.find(t=>t.name===e&&t.storage))==null?void 0:s.storage},X=class X{static decodeHeaderText(e){let s,t,r,n;const o=e.split(`
`).filter(d=>!d.startsWith("comment "));let i=0,a=!1;for(let d=1;d<o.length;++d){const h=o[d].split(" ");switch(h[0]){case"format":if(h[1]!=="binary_little_endian")throw new Error("Unsupported ply format");break;case"element":s={name:h[1],count:parseInt(h[2],10),properties:[],storageSizeBytes:0},s.name==="chunk"?t=s:s.name==="vertex"?r=s:s.name==="sh"&&(n=s);break;case"property":{if(!Wt.has(h[1]))throw new Error(`Unrecognized property data type '${h[1]}' in ply header`);const u=Wt.get(h[1]),p=u.BYTES_PER_ELEMENT*s.count;s.name==="vertex"&&(i+=u.BYTES_PER_ELEMENT),s.properties.push({type:h[1],name:h[2],storage:null,byteSize:u.BYTES_PER_ELEMENT,storageSizeByes:p}),s.storageSizeBytes+=p;break}case qt:a=!0;break;default:throw new Error(`Unrecognized header value '${h[0]}' in ply header`)}if(a)break}let l=0,c=0;return n&&(c=n.properties.length,n.properties.length>=45?l=3:n.properties.length>=24?l=2:n.properties.length>=9&&(l=1)),{chunkElement:t,vertexElement:r,shElement:n,bytesPerSplat:i,headerSizeBytes:e.indexOf(qt)+qt.length+1,sphericalHarmonicsDegree:l,sphericalHarmonicsPerSplat:c}}static decodeHeader(e){const s=(u,p)=>{const f=u.length-p.length;let m,S;for(m=0;m<=f;++m){for(S=0;S<p.length&&u[m+S]===p[S];++S);if(S===p.length)return m}return-1},t=(u,p)=>{if(u.length<p.length)return!1;for(let f=0;f<p.length;++f)if(u[f]!==p[f])return!1;return!0};let r=new Uint8Array(e),n;if(r.length>=Ls.length&&!t(r,Ls))throw new Error("Invalid PLY header");if(n=s(r,Hs),n===-1)throw new Error("End of PLY header not found");const o=new TextDecoder("ascii").decode(r.slice(0,n)),{chunkElement:i,vertexElement:a,shElement:l,sphericalHarmonicsDegree:c,sphericalHarmonicsPerSplat:d,bytesPerSplat:h}=X.decodeHeaderText(o);return{headerSizeBytes:n+Hs.length,bytesPerSplat:h,chunkElement:i,vertexElement:a,shElement:l,sphericalHarmonicsDegree:c,sphericalHarmonicsPerSplat:d}}static readElementData(e,s,t,r,n,o=null){let i=s instanceof DataView?s:new DataView(s);r=r||0,n=n||e.count-1;for(let a=r;a<=n;++a)for(let l=0;l<e.properties.length;++l){const c=e.properties[l],d=Wt.get(c.type),h=d.BYTES_PER_ELEMENT*e.count;if((!c.storage||c.storage.byteLength<h)&&(!o||o(c.name))&&(c.storage=new d(e.count)),c.storage)switch(c.type){case"char":c.storage[a]=i.getInt8(t);break;case"uchar":c.storage[a]=i.getUint8(t);break;case"short":c.storage[a]=i.getInt16(t,!0);break;case"ushort":c.storage[a]=i.getUint16(t,!0);break;case"int":c.storage[a]=i.getInt32(t,!0);break;case"uint":c.storage[a]=i.getUint32(t,!0);break;case"float":c.storage[a]=i.getFloat32(t,!0);break;case"double":c.storage[a]=i.getFloat64(t,!0);break}t+=c.byteSize}return t}static readPly(e,s=null){const t=X.decodeHeader(e);let r=X.readElementData(t.chunkElement,e,t.headerSizeBytes,null,null,s);return r=X.readElementData(t.vertexElement,e,r,null,null,s),X.readElementData(t.shElement,e,r,null,null,s),{chunkElement:t.chunkElement,vertexElement:t.vertexElement,shElement:t.shElement,sphericalHarmonicsDegree:t.sphericalHarmonicsDegree,sphericalHarmonicsPerSplat:t.sphericalHarmonicsPerSplat}}static getElementStorageArrays(e,s,t){const r={};if(s){const n=le(e,"min_r"),o=le(e,"min_g"),i=le(e,"min_b"),a=le(e,"max_r"),l=le(e,"max_g"),c=le(e,"max_b"),d=le(e,"min_x"),h=le(e,"min_y"),u=le(e,"min_z"),p=le(e,"max_x"),f=le(e,"max_y"),m=le(e,"max_z"),S=le(e,"min_scale_x"),g=le(e,"min_scale_y"),x=le(e,"min_scale_z"),T=le(e,"max_scale_x"),C=le(e,"max_scale_y"),v=le(e,"max_scale_z"),y=le(s,"packed_position"),B=le(s,"packed_rotation"),F=le(s,"packed_scale"),w=le(s,"packed_color");r.colorExtremes={minR:n,maxR:a,minG:o,maxG:l,minB:i,maxB:c},r.positionExtremes={minX:d,maxX:p,minY:h,maxY:f,minZ:u,maxZ:m},r.scaleExtremes={minScaleX:S,maxScaleX:T,minScaleY:g,maxScaleY:C,minScaleZ:x,maxScaleZ:v},r.position=y,r.rotation=B,r.scale=F,r.color=w}if(t){const n={};for(let o=0;o<45;o++){const i=`f_rest_${o}`,a=le(t,i);if(a)n[i]=a;else break}r.sh=n}return r}static parseToUncompressedSplatBufferSection(e,s,t,r,n,o,i,a,l=null){X.readElementData(s,o,0,t,r,l);const c=z.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,{positionExtremes:d,scaleExtremes:h,colorExtremes:u,position:p,rotation:f,scale:m,color:S}=X.getElementStorageArrays(e,s),g=L.createSplat();for(let x=t;x<=r;++x){X.decompressBaseSplat(x,n,p,d,m,h,f,u,S,g);const T=x*c+a;z.writeSplatDataToSectionBuffer(g,i,T,0,0)}}static parseToUncompressedSplatArraySection(e,s,t,r,n,o,i,a=null){X.readElementData(s,o,0,t,r,a);const{positionExtremes:l,scaleExtremes:c,colorExtremes:d,position:h,rotation:u,scale:p,color:f}=X.getElementStorageArrays(e,s);for(let m=t;m<=r;++m){const S=L.createSplat();X.decompressBaseSplat(m,n,h,l,p,c,u,d,f,S),i.addSplat(S)}}static parseSphericalHarmonicsToUncompressedSplatArraySection(e,s,t,r,n,o,i,a,l,c=null){X.readElementData(s,n,o,t,r,c);const{sh:d}=X.getElementStorageArrays(e,void 0,s),h=Object.values(d);for(let u=t;u<=r;++u)X.decompressSphericalHarmonics(u,h,i,a,l.splats[u])}static parseToUncompressedSplatArray(e,s){const{chunkElement:t,vertexElement:r,shElement:n,sphericalHarmonicsDegree:o}=X.readPly(e);s=Math.min(s,o);const i=new L(s),{positionExtremes:a,scaleExtremes:l,colorExtremes:c,position:d,rotation:h,scale:u,color:p}=X.getElementStorageArrays(t,r);let f;if(s>0){const{sh:m}=X.getElementStorageArrays(t,void 0,n);f=Object.values(m)}for(let m=0;m<r.count;++m){i.addDefaultSplat();const S=i.getSplat(i.splatCount-1);X.decompressBaseSplat(m,0,d,a,u,l,h,c,p,S),s>0&&X.decompressSphericalHarmonics(m,f,s,o,S)}return i}static parseToUncompressedSplatBuffer(e,s){const{chunkElement:t,vertexElement:r,shElement:n,sphericalHarmonicsDegree:o}=X.readPly(e);s=Math.min(s,o);const{splatBuffer:i,splatBufferDataOffsetBytes:a}=z.preallocateUncompressed(r.count,s),{positionExtremes:l,scaleExtremes:c,colorExtremes:d,position:h,rotation:u,scale:p,color:f}=X.getElementStorageArrays(t,r);let m;if(s>0){const{sh:x}=X.getElementStorageArrays(t,void 0,n);m=Object.values(x)}const S=z.CompressionLevels[0].SphericalHarmonicsDegrees[s].BytesPerSplat,g=L.createSplat(s);for(let x=0;x<r.count;++x){X.decompressBaseSplat(x,0,h,l,p,c,u,d,f,g),s>0&&X.decompressSphericalHarmonics(x,m,s,o,g);const T=x*S+a;z.writeSplatDataToSectionBuffer(g,i.bufferData,T,0,s)}return i}};P(X,"decompressBaseSplat",(function(){const e=new D,s=new Ce,t=new D,r=new ls,n=L.OFFSET;return function(o,i,a,l,c,d,h,u,p,f){f=f||L.createSplat();const m=Math.floor((i+o)/256);return Us(e,a[o]),ir(s,h[o]),Us(t,c[o]),or(r,p[o]),f[n.X]=He(l.minX[m],l.maxX[m],e.x),f[n.Y]=He(l.minY[m],l.maxY[m],e.y),f[n.Z]=He(l.minZ[m],l.maxZ[m],e.z),f[n.ROTATION0]=s.x,f[n.ROTATION1]=s.y,f[n.ROTATION2]=s.z,f[n.ROTATION3]=s.w,f[n.SCALE0]=Math.exp(He(d.minScaleX[m],d.maxScaleX[m],t.x)),f[n.SCALE1]=Math.exp(He(d.minScaleY[m],d.maxScaleY[m],t.y)),f[n.SCALE2]=Math.exp(He(d.minScaleZ[m],d.maxScaleZ[m],t.z)),u.minR&&u.maxR?f[n.FDC0]=ie(Math.round(He(u.minR[m],u.maxR[m],r.x)*255),0,255):f[n.FDC0]=ie(Math.floor(r.x*255),0,255),u.minG&&u.maxG?f[n.FDC1]=ie(Math.round(He(u.minG[m],u.maxG[m],r.y)*255),0,255):f[n.FDC1]=ie(Math.floor(r.y*255),0,255),u.minB&&u.maxB?f[n.FDC2]=ie(Math.round(He(u.minB[m],u.maxB[m],r.z)*255),0,255):f[n.FDC2]=ie(Math.floor(r.z*255),0,255),f[n.OPACITY]=ie(Math.floor(r.w*255),0,255),f}})()),P(X,"decompressSphericalHarmonics",(function(){const e=[0,3,8,15],s=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(t,r,n,o,i){i=i||L.createSplat();let a=e[n],l=e[o];for(let c=0;c<3;++c)for(let d=0;d<15;++d){const h=s[c*15+d];d<a&&d<l&&(i[L.OFFSET.FRC0+h]=r[c*l+d][t]*(8/255)-4)}return i}})());let ze=X;const Te={INRIAV1:0,INRIAV2:1,PlayCanvasCompressed:2},[Sn,fs,ms,As,gs,Ss,Cs]=[0,1,2,3,4,5,6],zs={double:Sn,int:fs,uint:ms,float:As,short:gs,ushort:Ss,uchar:Cs},ar={[Sn]:8,[fs]:4,[ms]:4,[As]:4,[gs]:2,[Ss]:2,[Cs]:1},Be=class Be{static decodeSectionHeader(e,s,t=0){const r=[];let n=!1,o=-1,i=0,a=!1,l=null;const c=[],d=[],h=[],u={};for(let S=t;S<e.length;S++){const g=e[S].trim();if(g.startsWith("element"))if(n){o--;break}else{n=!0,t=S,o=S;const x=g.split(" ");let T=0;for(let C of x){const v=C.trim();v.length>0&&(T++,T===2?l=v:T===3&&(i=parseInt(v)))}}else if(g.startsWith("property")){const x=g.match(/(\w+)\s+(\w+)\s+(\w+)/);if(x){const T=x[2],C=x[3];h.push(C);const v=s[C];u[C]=T;const y=zs[T];v!==void 0&&(c.push(v),d[v]=y)}}if(g===Be.HeaderEndToken){a=!0;break}n&&(r.push(g),o++)}const p=[];let f=0;for(let S of h){const g=u[S];if(u.hasOwnProperty(S)){const x=s[S];x!==void 0&&(p[x]=f)}f+=ar[zs[g]]}const m=Be.decodeSphericalHarmonicsFromSectionHeader(h,s);return{headerLines:r,headerStartLine:t,headerEndLine:o,fieldTypes:d,fieldIds:c,fieldOffsets:p,bytesPerVertex:f,vertexCount:i,dataSizeBytes:f*i,endOfHeader:a,sectionName:l,sphericalHarmonicsDegree:m.degree,sphericalHarmonicsCoefficientsPerChannel:m.coefficientsPerChannel,sphericalHarmonicsDegree1Fields:m.degree1Fields,sphericalHarmonicsDegree2Fields:m.degree2Fields}}static decodeSphericalHarmonicsFromSectionHeader(e,s){let t=0,r=0;for(let a of e)a.startsWith("f_rest")&&t++;r=t/3;let n=0;r>=3&&(n=1),r>=8&&(n=2);let o=[],i=[];for(let a=0;a<3;a++){if(n>=1)for(let l=0;l<3;l++)o.push(s["f_rest_"+(l+r*a)]);if(n>=2)for(let l=0;l<5;l++)i.push(s["f_rest_"+(l+r*a+3)])}return{degree:n,coefficientsPerChannel:r,degree1Fields:o,degree2Fields:i}}static getHeaderSectionNames(e){const s=[];for(let t of e)if(t.startsWith("element")){const r=t.split(" ");let n=0;for(let o of r){const i=o.trim();i.length>0&&(n++,n===2&&s.push(i))}}return s}static checkTextForEndHeader(e){return!!e.includes(Be.HeaderEndToken)}static checkBufferForEndHeader(e,s,t,r){const n=new Uint8Array(e,Math.max(0,s-t),t),o=r.decode(n);return Be.checkTextForEndHeader(o)}static extractHeaderFromBufferToText(e){const s=new TextDecoder;let t=0,r="";const n=100;for(;;){if(t+n>=e.byteLength)throw new Error("End of file reached while searching for end of header");const o=new Uint8Array(e,t,n);if(r+=s.decode(o),t+=n,Be.checkBufferForEndHeader(e,t,n*2,s))break}return r}static readHeaderFromBuffer(e){const s=new TextDecoder;let t=0,r="";const n=100;for(;;){if(t+n>=e.byteLength)throw new Error("End of file reached while searching for end of header");const o=new Uint8Array(e,t,n);if(r+=s.decode(o),t+=n,Be.checkBufferForEndHeader(e,t,n*2,s))break}return r}static convertHeaderTextToLines(e){const s=e.split(`
`),t=[];for(let r=0;r<s.length;r++){const n=s[r].trim();if(t.push(n),n===Be.HeaderEndToken)break}return t}static determineHeaderFormatFromHeaderText(e){const s=Be.convertHeaderTextToLines(e);let t=Te.INRIAV1;for(let r=0;r<s.length;r++){const n=s[r].trim();if(n.startsWith("element chunk")||n.match(/[A-Za-z]*packed_[A-Za-z]*/))t=Te.PlayCanvasCompressed;else if(n.startsWith("element codebook_centers"))t=Te.INRIAV2;else if(n===Be.HeaderEndToken)break}return t}static determineHeaderFormatFromPlyBuffer(e){const s=Be.extractHeaderFromBufferToText(e);return Be.determineHeaderFormatFromHeaderText(s)}static readVertex(e,s,t,r,n,o,i=!0){const a=t*s.bytesPerVertex+r,l=s.fieldOffsets,c=s.fieldTypes;for(let d of n){const h=c[d];h===As?o[d]=e.getFloat32(a+l[d],!0):h===gs?o[d]=e.getInt16(a+l[d],!0):h===Ss?o[d]=e.getUint16(a+l[d],!0):h===fs?o[d]=e.getInt32(a+l[d],!0):h===ms?o[d]=e.getUint32(a+l[d],!0):h===Cs&&(i?o[d]=e.getUint8(a+l[d])/255:o[d]=e.getUint8(a+l[d]))}}};P(Be,"HeaderEndToken","end_header");let pe=Be;const Cn=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0"],lr=Cn.map((A,e)=>e),[Qs,cr,dr,ur,hr,pr,fr,mr,Ar,gr,_s,Sr,Cr,Ns,Vs,yr,xr,Ir]=lr,Me=class Me{static decodeHeaderLines(e){let s=0;e.forEach(c=>{c.includes("f_rest_")&&s++});let t=0;s>=45?t=45:s>=24?t=24:s>=9&&(t=9);let n=Array.from(Array(Math.max(t-1,0))).map((c,d)=>`f_rest_${d+1}`);const o=[...Cn,...n],i=o.map((c,d)=>d),a=i.reduce((c,d)=>(c[o[d]]=d,c),{}),l=pe.decodeSectionHeader(e,a,0);return l.splatCount=l.vertexCount,l.bytesPerSplat=l.bytesPerVertex,l.fieldsToReadIndexes=i,l}static decodeHeaderText(e){const s=pe.convertHeaderTextToLines(e),t=Me.decodeHeaderLines(s);return t.headerText=e,t.headerSizeBytes=e.indexOf(pe.HeaderEndToken)+pe.HeaderEndToken.length+1,t}static decodeHeaderFromBuffer(e){const s=pe.readHeaderFromBuffer(e);return Me.decodeHeaderText(s)}static findSplatData(e,s){return new DataView(e,s.headerSizeBytes)}static parseToUncompressedSplatBufferSection(e,s,t,r,n,o,i,a=0){a=Math.min(a,e.sphericalHarmonicsDegree);const l=z.CompressionLevels[0].SphericalHarmonicsDegrees[a].BytesPerSplat;for(let c=s;c<=t;c++){const d=Me.parseToUncompressedSplat(r,c,e,n,a),h=c*l+i;z.writeSplatDataToSectionBuffer(d,o,h,0,a)}}static parseToUncompressedSplatArraySection(e,s,t,r,n,o,i=0){i=Math.min(i,e.sphericalHarmonicsDegree);for(let a=s;a<=t;a++){const l=Me.parseToUncompressedSplat(r,a,e,n,i);o.addSplat(l)}}static decodeSectionSplatData(e,s,t,r,n=!0){if(r=Math.min(r,t.sphericalHarmonicsDegree),n){const o=new L(r);for(let i=0;i<s;i++){const a=Me.parseToUncompressedSplat(e,i,t,0,r);o.addSplat(a)}return o}else{const{splatBuffer:o,splatBufferDataOffsetBytes:i}=z.preallocateUncompressed(s,r);return Me.parseToUncompressedSplatBufferSection(t,0,s-1,e,0,o.bufferData,i,r),o}}static readSplat(e,s,t,r,n){return pe.readVertex(e,s,t,r,s.fieldsToReadIndexes,n,!0)}static parseToUncompressedSplatArray(e,s=0){const{header:t,splatCount:r,splatData:n}=Gs(e);return Me.decodeSectionSplatData(n,r,t,s,!0)}static parseToUncompressedSplatBuffer(e,s=0){const{header:t,splatCount:r,splatData:n}=Gs(e);return Me.decodeSectionSplatData(n,r,t,s,!1)}};P(Me,"parseToUncompressedSplat",(function(){let e=[];const s=new Ce,t=L.OFFSET.X,r=L.OFFSET.Y,n=L.OFFSET.Z,o=L.OFFSET.SCALE0,i=L.OFFSET.SCALE1,a=L.OFFSET.SCALE2,l=L.OFFSET.ROTATION0,c=L.OFFSET.ROTATION1,d=L.OFFSET.ROTATION2,h=L.OFFSET.ROTATION3,u=L.OFFSET.FDC0,p=L.OFFSET.FDC1,f=L.OFFSET.FDC2,m=L.OFFSET.OPACITY,S=[];for(let g=0;g<45;g++)S[g]=L.OFFSET.FRC0+g;return function(g,x,T,C=0,v=0){v=Math.min(v,T.sphericalHarmonicsDegree),Me.readSplat(g,T,x,C,e);const y=L.createSplat(v);if(e[Qs]!==void 0?(y[o]=Math.exp(e[Qs]),y[i]=Math.exp(e[cr]),y[a]=Math.exp(e[dr])):(y[o]=.01,y[i]=.01,y[a]=.01),e[_s]!==void 0){const B=.28209479177387814;y[u]=(.5+B*e[_s])*255,y[p]=(.5+B*e[Sr])*255,y[f]=(.5+B*e[Cr])*255}else e[Vs]!==void 0?(y[u]=e[Vs]*255,y[p]=e[yr]*255,y[f]=e[xr]*255):(y[u]=0,y[p]=0,y[f]=0);if(e[Ns]!==void 0&&(y[m]=1/(1+Math.exp(-e[Ns]))*255),y[u]=ie(Math.floor(y[u]),0,255),y[p]=ie(Math.floor(y[p]),0,255),y[f]=ie(Math.floor(y[f]),0,255),y[m]=ie(Math.floor(y[m]),0,255),v>=1&&e[Ir]!==void 0){for(let B=0;B<9;B++)y[S[B]]=e[T.sphericalHarmonicsDegree1Fields[B]];if(v>=2)for(let B=0;B<15;B++)y[S[9+B]]=e[T.sphericalHarmonicsDegree2Fields[B]]}return s.set(e[ur],e[hr],e[pr],e[fr]),s.normalize(),y[l]=s.x,y[c]=s.y,y[d]=s.z,y[h]=s.w,y[t]=e[mr],y[r]=e[Ar],y[n]=e[gr],y}})());let Qe=Me;function Gs(A){const e=Qe.decodeHeaderFromBuffer(A),s=e.splatCount,t=Qe.findSplatData(A,e);return{header:e,splatCount:s,splatData:t}}const yn=["features_dc","features_rest_0","features_rest_1","features_rest_2","features_rest_3","features_rest_4","features_rest_5","features_rest_6","features_rest_7","features_rest_8","features_rest_9","features_rest_10","features_rest_11","features_rest_12","features_rest_13","features_rest_14","opacity","scaling","rotation_re","rotation_im"],vt=yn.map((A,e)=>e),[Et,Tr,Br,qs,wt,vr,Kt]=[0,1,4,16,17,18,19],xn=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","red","green","blue","f_rest_0","f_rest_1","f_rest_2","f_rest_3","f_rest_4","f_rest_5","f_rest_6","f_rest_7","f_rest_8","f_rest_9","f_rest_10","f_rest_11","f_rest_12","f_rest_13","f_rest_14","f_rest_15","f_rest_16","f_rest_17","f_rest_18","f_rest_19","f_rest_20","f_rest_21","f_rest_22","f_rest_23","f_rest_24","f_rest_25","f_rest_26","f_rest_27","f_rest_28","f_rest_29","f_rest_30","f_rest_31","f_rest_32","f_rest_33","f_rest_34","f_rest_35","f_rest_36","f_rest_37","f_rest_38","f_rest_39","f_rest_40","f_rest_41","f_rest_42","f_rest_43","f_rest_44","f_rest_45"],es=xn.map((A,e)=>e),[Ws,Er,wr,Dr,Fr,br,Rr,Mr,Pr,Or,ts,In,Tn,Ks]=es,js=ts,kr=In,Lr=Tn,Dt=A=>{const e=(31744&A)>>10,s=1023&A;return(A>>15?-1:1)*(e?e===31?s?NaN:1/0:Math.pow(2,e-15)*(1+s/1024):s/1024*6103515625e-14)},ve=class ve{static decodeSectionHeadersFromHeaderLines(e){const s=es.reduce((c,d)=>(c[xn[d]]=d,c),{}),t=vt.reduce((c,d)=>(c[yn[d]]=d,c),{}),r=pe.getHeaderSectionNames(e);let n;for(let c=0;c<r.length;c++)r[c]==="codebook_centers"&&(n=c);let o=0,i=!1;const a=[];let l=0;for(;!i;){let c;l===n?c=pe.decodeSectionHeader(e,t,o):c=pe.decodeSectionHeader(e,s,o),i=c.endOfHeader,o=c.headerEndLine+1,i||(c.splatCount=c.vertexCount,c.bytesPerSplat=c.bytesPerVertex),a.push(c),l++}return a}static decodeSectionHeadersFromHeaderText(e){const s=pe.convertHeaderTextToLines(e);return ve.decodeSectionHeadersFromHeaderLines(s)}static getSplatCountFromSectionHeaders(e){let s=0;for(let t of e)t.sectionName!=="codebook_centers"&&(s+=t.vertexCount);return s}static decodeHeaderFromHeaderText(e){const s=e.indexOf(pe.HeaderEndToken)+pe.HeaderEndToken.length+1,t=ve.decodeSectionHeadersFromHeaderText(e),r=ve.getSplatCountFromSectionHeaders(t);return{headerSizeBytes:s,sectionHeaders:t,splatCount:r}}static decodeHeaderFromBuffer(e){const s=pe.readHeaderFromBuffer(e);return ve.decodeHeaderFromHeaderText(s)}static findVertexData(e,s,t){let r=s.headerSizeBytes;for(let n=0;n<t&&n<s.sectionHeaders.length;n++){const o=s.sectionHeaders[n];r+=o.dataSizeBytes}return new DataView(e,r,s.sectionHeaders[t].dataSizeBytes)}static decodeCodeBook(e,s){const t=[],r=[];for(let n=0;n<s.vertexCount;n++){pe.readVertex(e,s,n,0,vt,t);for(let o of vt){const i=vt[o];let a=r[i];a||(r[i]=a=[]),a.push(t[o])}}for(let n=0;n<r.length;n++){const o=r[n],i=.28209479177387814;for(let a=0;a<o.length;a++){const l=Dt(o[a]);n===qs?o[a]=Math.round(1/(1+Math.exp(-l))*255):n===Et?o[a]=Math.round((.5+i*l)*255):n===wt?o[a]=Math.exp(l):o[a]=l}}return r}static decodeSectionSplatData(e,s,t,r,n){n=Math.min(n,t.sphericalHarmonicsDegree);const o=new L(n);for(let i=0;i<s;i++){const a=ve.parseToUncompressedSplat(e,i,t,r,0,n);o.addSplat(a)}return o}static readSplat(e,s,t,r,n){return pe.readVertex(e,s,t,r,es,n,!1)}static parseToUncompressedSplatArray(e,s=0){const t=[],r=ve.decodeHeaderFromBuffer(e,s);let n;for(let i=0;i<r.sectionHeaders.length;i++){const a=r.sectionHeaders[i];if(a.sectionName==="codebook_centers"){const l=ve.findVertexData(e,r,i);n=ve.decodeCodeBook(l,a)}}for(let i=0;i<r.sectionHeaders.length;i++){const a=r.sectionHeaders[i];if(a.sectionName!=="codebook_centers"){const l=a.vertexCount,c=ve.findVertexData(e,r,i),d=ve.decodeSectionSplatData(c,l,a,n,s);t.push(d)}}const o=new L(s);for(let i of t)for(let a of i.splats)o.addSplat(a);return o}};P(ve,"parseToUncompressedSplat",(function(){let e=[];const s=new Ce,t=L.OFFSET.X,r=L.OFFSET.Y,n=L.OFFSET.Z,o=L.OFFSET.SCALE0,i=L.OFFSET.SCALE1,a=L.OFFSET.SCALE2,l=L.OFFSET.ROTATION0,c=L.OFFSET.ROTATION1,d=L.OFFSET.ROTATION2,h=L.OFFSET.ROTATION3,u=L.OFFSET.FDC0,p=L.OFFSET.FDC1,f=L.OFFSET.FDC2,m=L.OFFSET.OPACITY,S=[];for(let g=0;g<45;g++)S[g]=L.OFFSET.FRC0+g;return function(g,x,T,C,v=0,y=0){y=Math.min(y,T.sphericalHarmonicsDegree),ve.readSplat(g,T,x,v,e);const B=L.createSplat(y);if(e[Ws]!==void 0?(B[o]=C[wt][e[Ws]],B[i]=C[wt][e[Er]],B[a]=C[wt][e[wr]]):(B[o]=.01,B[i]=.01,B[a]=.01),e[ts]!==void 0?(B[u]=C[Et][e[ts]],B[p]=C[Et][e[In]],B[f]=C[Et][e[Tn]]):e[js]!==void 0?(B[u]=e[js]*255,B[p]=e[kr]*255,B[f]=e[Lr]*255):(B[u]=0,B[p]=0,B[f]=0),e[Ks]!==void 0&&(B[m]=C[qs][e[Ks]]),B[u]=ie(Math.floor(B[u]),0,255),B[p]=ie(Math.floor(B[p]),0,255),B[f]=ie(Math.floor(B[f]),0,255),B[m]=ie(Math.floor(B[m]),0,255),y>=1&&T.sphericalHarmonicsDegree>=1){for(let R=0;R<9;R++){const b=C[Tr+R%3];B[S[R]]=b[e[T.sphericalHarmonicsDegree1Fields[R]]]}if(y>=2&&T.sphericalHarmonicsDegree>=2)for(let R=0;R<15;R++){const b=C[Br+R%5];B[S[9+R]]=b[e[T.sphericalHarmonicsDegree2Fields[R]]]}}const F=C[vr][e[Dr]],w=C[Kt][e[Fr]],M=C[Kt][e[br]],O=C[Kt][e[Rr]];return s.set(F,w,M,O),s.normalize(),B[l]=s.x,B[c]=s.y,B[d]=s.z,B[h]=s.w,B[t]=Dt(e[Mr]),B[r]=Dt(e[Pr]),B[n]=Dt(e[Or]),B}})());let ss=ve;class Ys{static parseToUncompressedSplatArray(e,s=0){const t=pe.determineHeaderFormatFromPlyBuffer(e);if(t===Te.PlayCanvasCompressed)return ze.parseToUncompressedSplatArray(e,s);if(t===Te.INRIAV1)return Qe.parseToUncompressedSplatArray(e,s);if(t===Te.INRIAV2)return ss.parseToUncompressedSplatArray(e,s)}static parseToUncompressedSplatBuffer(e,s=0){const t=pe.determineHeaderFormatFromPlyBuffer(e);if(t===Te.PlayCanvasCompressed)return ze.parseToUncompressedSplatBuffer(e,s);if(t===Te.INRIAV1)return Qe.parseToUncompressedSplatBuffer(e,s);if(t===Te.INRIAV2)throw new Error("parseToUncompressedSplatBuffer() is not implemented for INRIA V2 PLY files")}}class ys{constructor(e,s,t,r){this.sectionCount=e,this.sectionFilters=s,this.groupingParameters=t,this.partitionGenerator=r}partitionUncompressedSplatArray(e){let s,t,r;if(this.partitionGenerator){const o=this.partitionGenerator(e);s=o.groupingParameters,t=o.sectionCount,r=o.sectionFilters}else s=this.groupingParameters,t=this.sectionCount,r=this.sectionFilters;const n=[];for(let o=0;o<t;o++){const i=new L(e.sphericalHarmonicsDegree),a=r[o];for(let l=0;l<e.splatCount;l++)a(l)&&i.addSplat(e.splats[l]);n.push(i)}return{splatArrays:n,parameters:s}}static getStandardPartitioner(e=0,s=new D,t=z.BucketBlockSize,r=z.BucketSize){const n=o=>{const i=L.OFFSET.X,a=L.OFFSET.Y,l=L.OFFSET.Z;e<=0&&(e=o.splatCount);const c=new D,d=.5,h=S=>{S.x=Math.floor(S.x/d)*d,S.y=Math.floor(S.y/d)*d,S.z=Math.floor(S.z/d)*d};o.splats.forEach(S=>{c.set(S[i],S[a],S[l]).sub(s),h(c),S.centerDist=c.lengthSq()}),o.splats.sort((S,g)=>{let x=S.centerDist,T=g.centerDist;return x>T?1:-1});const u=[],p=[];e=Math.min(o.splatCount,e);const f=Math.ceil(o.splatCount/e);let m=0;for(let S=0;S<f;S++){let g=m;u.push(x=>x>=g&&x<g+e),p.push({blocksSize:t,bucketSize:r}),m+=e}return{sectionCount:u.length,sectionFilters:u,groupingParameters:p}};return new ys(void 0,void 0,void 0,n)}}class It{constructor(e,s,t,r,n,o,i){this.splatPartitioner=e,this.alphaRemovalThreshold=s,this.compressionLevel=t,this.sectionSize=r,this.sceneCenter=n?new D().copy(n):void 0,this.blockSize=o,this.bucketSize=i}generateFromUncompressedSplatArray(e){const s=this.splatPartitioner.partitionUncompressedSplatArray(e);return z.generateFromUncompressedSplatArrays(s.splatArrays,this.alphaRemovalThreshold,this.compressionLevel,this.sceneCenter,this.blockSize,this.bucketSize,s.parameters)}static getStandardGenerator(e=1,s=1,t=0,r=new D,n=z.BucketBlockSize,o=z.BucketSize){const i=ys.getStandardPartitioner(t,r,n,o);return new It(i,e,s,t,r,n,o)}}const fe={Downloading:0,Processing:1,Done:2};class Ot extends Error{constructor(e){super(e)}}const ne={ProgressiveToSplatBuffer:0,ProgressiveToSplatArray:1,DownloadBeforeProcessing:2};function Xs(A,e){let s=0;for(let r of A)s+=r.sizeBytes;(!e||e.byteLength<s)&&(e=new ArrayBuffer(s));let t=0;for(let r of A)new Uint8Array(e,t,r.sizeBytes).set(r.data),t+=r.sizeBytes;return e}function Js(A,e,s,t,r,n,o,i){return e?It.getStandardGenerator(s,t,r,n,o,i).generateFromUncompressedSplatArray(A):z.generateFromUncompressedSplatArrays([A],s,0,new D)}class xs{static loadFromURL(e,s,t,r,n,o,i=!0,a=0,l,c,d,h,u){let p;!t&&!i?p=ne.DownloadBeforeProcessing:i?p=ne.ProgressiveToSplatArray:p=ne.ProgressiveToSplatBuffer;const f=G.ProgressiveLoadSectionSize,m=z.HeaderSizeBytes+z.SectionHeaderSizeBytes,S=1;let g,x,T,C,v,y=0,B=0,F=0,w=!1,M=!1,O=!1;const R=ds();let b=0,k=0,H=0,Q=0,N="",U=null,V=[],J;const ce=new TextDecoder,Z=(W,te,K)=>{const $=W>=100;if(K&&(V.push({data:K,sizeBytes:K.byteLength,startBytes:H,endBytes:H+K.byteLength}),H+=K.byteLength),p===ne.DownloadBeforeProcessing)$&&R.resolve(V);else{if(w){if(g===Te.PlayCanvasCompressed&&!M){const de=U.headerSizeBytes+U.chunkElement.storageSizeBytes;v=Xs(V,v),v.byteLength>=de&&(ze.readElementData(U.chunkElement,v,U.headerSizeBytes),b=de,k=de,M=!0)}}else if(N+=ce.decode(K),pe.checkTextForEndHeader(N)){if(g=pe.determineHeaderFormatFromHeaderText(N),g===Te.INRIAV1)U=Qe.decodeHeaderText(N),a=Math.min(a,U.sphericalHarmonicsDegree),y=U.splatCount,M=!0,Q=U.headerSizeBytes+U.bytesPerSplat*y;else if(g===Te.PlayCanvasCompressed){if(U=ze.decodeHeaderText(N),a=Math.min(a,U.sphericalHarmonicsDegree),p===ne.ProgressiveToSplatBuffer&&a>0)throw new Ot("PlyLoader.loadFromURL() -> Selected PLY format has spherical harmonics data that cannot be progressively loaded.");y=U.vertexElement.count,Q=U.headerSizeBytes+U.bytesPerSplat*y+U.chunkElement.storageSizeBytes}else{if(p===ne.ProgressiveToSplatBuffer)throw new Ot("PlyLoader.loadFromURL() -> Selected PLY format cannot be progressively loaded.");p=ne.DownloadBeforeProcessing;return}if(p===ne.ProgressiveToSplatBuffer){const de=z.CompressionLevels[0].SphericalHarmonicsDegrees[a],ue=m+de.BytesPerSplat*y;T=new ArrayBuffer(ue),z.writeHeaderToBuffer({versionMajor:z.CurrentMajorVersion,versionMinor:z.CurrentMinorVersion,maxSectionCount:S,sectionCount:S,maxSplatCount:y,splatCount:0,compressionLevel:0,sceneCenter:new D},T)}else J=new L(a);b=U.headerSizeBytes,k=U.headerSizeBytes,w=!0}if(w&&M&&V.length>0&&(x=Xs(V,x),H-b>f||H>=Q&&!O||$)){const ue=O?U.sphericalHarmonicsPerSplat:U.bytesPerSplat,xe=(O?H:Math.min(Q,H))-k,me=Math.floor(xe/ue),re=me*ue,Ae=H-k-re,se=k-V[0].startBytes,Re=new DataView(x,se,re);if(O)g===Te.PlayCanvasCompressed&&p===ne.ProgressiveToSplatArray&&(ze.parseSphericalHarmonicsToUncompressedSplatArraySection(U.chunkElement,U.shElement,F,F+me-1,Re,0,a,U.sphericalHarmonicsDegree,J),F+=me);else{if(p===ne.ProgressiveToSplatBuffer){const Pe=z.CompressionLevels[0].SphericalHarmonicsDegrees[a],ye=B*Pe.BytesPerSplat+m;g===Te.PlayCanvasCompressed?ze.parseToUncompressedSplatBufferSection(U.chunkElement,U.vertexElement,0,me-1,B,Re,T,ye):Qe.parseToUncompressedSplatBufferSection(U,0,me-1,Re,0,T,ye,a)}else g===Te.PlayCanvasCompressed?ze.parseToUncompressedSplatArraySection(U.chunkElement,U.vertexElement,0,me-1,B,Re,J):Qe.parseToUncompressedSplatArraySection(U,0,me-1,Re,0,J,a);B+=me,p===ne.ProgressiveToSplatBuffer&&(C||(z.writeSectionHeaderToBuffer({maxSplatCount:y,splatCount:B,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0,sphericalHarmonicsDegree:a},0,T,z.HeaderSizeBytes),C=new z(T,!1)),C.updateLoadedCounts(1,B)),H>=Q&&(O=!0)}if(Ae===0)V=[];else{let Pe=[],ye=0;for(let we=V.length-1;we>=0;we--){const _e=V[we];if(ye+=_e.sizeBytes,Pe.unshift(_e),ye>=Ae)break}V=Pe}b+=f,k+=re}r&&C&&r(C,$),$&&(p===ne.ProgressiveToSplatBuffer?R.resolve(C):R.resolve(J))}s&&s(W,te,fe.Downloading)};return s&&s(0,"0%",fe.Downloading),zt(e,Z,!1,l).then(()=>(s&&s(0,"0%",fe.Processing),R.promise.then(W=>{if(s&&s(100,"100%",fe.Done),p===ne.DownloadBeforeProcessing){const te=V.map(K=>K.data);return new Blob(te).arrayBuffer().then(K=>xs.loadFromFileData(K,n,o,i,a,c,d,h,u))}else return p===ne.ProgressiveToSplatBuffer?W:be(()=>Js(W,i,n,o,c,d,h,u))})))}static loadFromFileData(e,s,t,r,n=0,o,i,a,l){return r?be(()=>Ys.parseToUncompressedSplatArray(e,n)).then(c=>Js(c,r,s,t,o,i,a,l)):be(()=>Ys.parseToUncompressedSplatBuffer(e,n))}}const Hr=A=>new ReadableStream({async start(e){e.enqueue(A),e.close()}});async function Ur(A){try{const e=Hr(A);if(!e)throw new Error("Failed to create stream from data");return await zr(e)}catch(e){throw console.error("Error decompressing gzipped data:",e),e}}async function zr(A){const e=A.pipeThrough(new DecompressionStream("gzip")),t=await new Response(e).arrayBuffer();return new Uint8Array(t)}const Qr=1347635022,_r=1,Nr=.15;function Vr(A){const e=A>>15&1,s=A>>10&31,t=A&1023,r=e===1?-1:1;return s===0?r*Math.pow(2,-14)*t/1024:s===31?t!==0?NaN:r*(1/0):r*Math.pow(2,s-15)*(1+t/1024)}function Gr(A){return(A-128)/128}function Ye(A){switch(A){case 0:return 0;case 1:return 3;case 2:return 8;case 3:return 15;default:return console.error(`[SPZ: ERROR] Unsupported SH degree: ${A}`),0}}const qr=(function(){let A=[];const e=new Ce,s=L.OFFSET.X,t=L.OFFSET.Y,r=L.OFFSET.Z,n=L.OFFSET.SCALE0,o=L.OFFSET.SCALE1,i=L.OFFSET.SCALE2,a=L.OFFSET.ROTATION0,l=L.OFFSET.ROTATION1,c=L.OFFSET.ROTATION2,d=L.OFFSET.ROTATION3,h=L.OFFSET.FDC0,u=L.OFFSET.FDC1,p=L.OFFSET.FDC2,f=L.OFFSET.OPACITY,m=[Ye(0),Ye(1),Ye(2),Ye(3)],S=[0,1,2,9,10,11,12,13,24,25,26,27,28,29,30,3,4,5,14,15,16,17,18,31,32,33,34,35,36,37,6,7,8,19,20,21,22,23,38,39,40,41,42,43,44];return function(g,x,T){T=Math.min(x,T);const C=L.createSplat(T);g.scale[0]!==void 0?(C[n]=g.scale[0],C[o]=g.scale[1],C[i]=g.scale[2]):(C[n]=.01,C[o]=.01,C[i]=.01),g.color[0]!==void 0?(C[h]=g.color[0],C[u]=g.color[1],C[p]=g.color[2]):A[RED]!==void 0?(C[h]=A[RED]*255,C[u]=A[GREEN]*255,C[p]=A[BLUE]*255):(C[h]=0,C[u]=0,C[p]=0),g.alpha!==void 0&&(C[f]=g.alpha),C[h]=ie(Math.floor(C[h]),0,255),C[u]=ie(Math.floor(C[u]),0,255),C[p]=ie(Math.floor(C[p]),0,255),C[f]=ie(Math.floor(C[f]),0,255);let v=m[T],y=m[x];for(let B=0;B<3;++B)for(let F=0;F<15;++F){const w=S[B*15+F];F<v&&F<y&&(C[L.OFFSET.FRC0+w]=g.sh[B*y+F])}return e.set(g.rotation[3],g.rotation[0],g.rotation[1],g.rotation[2]),e.normalize(),C[a]=e.x,C[l]=e.y,C[c]=e.z,C[d]=e.w,C[s]=g.position[0],C[t]=g.position[1],C[r]=g.position[2],C}})();function Wr(A,e,s,t){return!(A.positions.length!==e*3*(t?2:3)||A.scales.length!==e*3||A.rotations.length!==e*3||A.alphas.length!==e||A.colors.length!==e*3||A.sh.length!==e*s*3)}function Zs(A,e,s,t,r){e=Math.min(e,A.shDegree);const n=A.numPoints,o=Ye(A.shDegree),i=A.positions.length===n*3*2;if(!Wr(A,n,o,i))return null;const a={position:[],scale:[],rotation:[],alpha:void 0,color:[],sh:[]};let l;i&&(l=new Uint16Array(A.positions.buffer,A.positions.byteOffset,n*3));const c=1/(1<<A.fractionalBits),d=Ye(A.shDegree),h=.28209479177387814;for(let u=0;u<n;u++){if(i)for(let g=0;g<3;g++)a.position[g]=Vr(l[u*3+g]);else for(let g=0;g<3;g++){const x=u*9+g*3;let T=A.positions[x];T|=A.positions[x+1]<<8,T|=A.positions[x+2]<<16,T|=T&8388608?4278190080:0,a.position[g]=T*c}for(let g=0;g<3;g++)a.scale[g]=Math.exp(A.scales[u*3+g]/16-10);const p=A.rotations.subarray(u*3,u*3+3),f=[p[0]/127.5-1,p[1]/127.5-1,p[2]/127.5-1];a.rotation[0]=f[0],a.rotation[1]=f[1],a.rotation[2]=f[2];const m=f[0]*f[0]+f[1]*f[1]+f[2]*f[2];a.rotation[3]=Math.sqrt(Math.max(0,1-m)),a.alpha=Math.floor(A.alphas[u]);for(let g=0;g<3;g++)a.color[g]=Math.floor(((A.colors[u*3+g]/255-.5)/Nr*h+.5)*255);for(let g=0;g<3;g++)for(let x=0;x<d;x++)a.sh[g*d+x]=Gr(A.sh[d*3*u+x*3+g]);const S=qr(a,A.shDegree,e);if(s){const g=z.CompressionLevels[0].SphericalHarmonicsDegrees[e].BytesPerSplat,x=u*g+r;z.writeSplatDataToSectionBuffer(S,t,x,0,e)}else t.addSplat(S)}}const Kr=16,jr=1e7;function Yr(A){const e=new DataView(A);let s=0;const t={magic:e.getUint32(s,!0),version:e.getUint32(s+4,!0),numPoints:e.getUint32(s+8,!0),shDegree:e.getUint8(s+12),fractionalBits:e.getUint8(s+13),flags:e.getUint8(s+14),reserved:e.getUint8(s+15)};if(s+=Kr,t.magic!==Qr)return console.error("[SPZ ERROR] deserializePackedGaussians: header not found"),null;if(t.version<1||t.version>2)return console.error(`[SPZ ERROR] deserializePackedGaussians: version not supported: ${t.version}`),null;if(t.numPoints>jr)return console.error(`[SPZ ERROR] deserializePackedGaussians: Too many points: ${t.numPoints}`),null;if(t.shDegree>3)return console.error(`[SPZ ERROR] deserializePackedGaussians: Unsupported SH degree: ${t.shDegree}`),null;const r=t.numPoints,n=Ye(t.shDegree),o=t.version===1,i={numPoints:r,shDegree:t.shDegree,fractionalBits:t.fractionalBits,antialiased:(t.flags&_r)!==0,positions:new Uint8Array(r*3*(o?2:3)),scales:new Uint8Array(r*3),rotations:new Uint8Array(r*3),alphas:new Uint8Array(r),colors:new Uint8Array(r*3),sh:new Uint8Array(r*n*3)};try{const a=new Uint8Array(A);let l=i.positions.length,c=s;if(i.positions.set(a.slice(c,c+l)),c+=l,i.alphas.set(a.slice(c,c+i.alphas.length)),c+=i.alphas.length,i.colors.set(a.slice(c,c+i.colors.length)),c+=i.colors.length,i.scales.set(a.slice(c,c+i.scales.length)),c+=i.scales.length,i.rotations.set(a.slice(c,c+i.rotations.length)),c+=i.rotations.length,i.sh.set(a.slice(c,c+i.sh.length)),c+i.sh.length!==A.byteLength)return console.error("[SPZ ERROR] deserializePackedGaussians: incorrect buffer size"),null}catch(a){return console.error("[SPZ ERROR] deserializePackedGaussians: read error",a),null}return i}async function Xr(A){try{const e=await Ur(A);return Yr(e.buffer)}catch(e){return console.error("[SPZ ERROR] loadSpzPacked: decompression error",e),null}}class Is{static loadFromURL(e,s,t,r,n=!0,o=0,i,a,l,c,d){return s&&s(0,"0%",fe.Downloading),zt(e,s,!0,i).then(h=>(s&&s(0,"0%",fe.Processing),Is.loadFromFileData(h,t,r,n,o,a,l,c,d)))}static async loadFromFileData(e,s,t,r,n=0,o,i,a,l){await be();const c=await Xr(e);n=Math.min(c.shDegree,n);const d=new L(n);if(r)return Zs(c,n,!1,d,0),It.getStandardGenerator(s,t,o,i,a,l).generateFromUncompressedSplatArray(d);{const{splatBuffer:h,splatBufferDataOffsetBytes:u}=z.preallocateUncompressed(c.numPoints,n);return Zs(c,n,!0,h.bufferData,u),h}}}const Y=class Y{static parseToUncompressedSplatBufferSection(e,s,t,r,n,o){const i=z.CompressionLevels[0].BytesPerCenter,a=z.CompressionLevels[0].BytesPerScale,l=z.CompressionLevels[0].BytesPerRotation,c=z.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;for(let d=e;d<=s;d++){const h=d*Y.RowSizeBytes+r,u=new Float32Array(t,h,3),p=new Float32Array(t,h+Y.CenterSizeBytes,3),f=new Uint8Array(t,h+Y.CenterSizeBytes+Y.ScaleSizeBytes,4),m=new Uint8Array(t,h+Y.CenterSizeBytes+Y.ScaleSizeBytes+Y.RotationSizeBytes,4),S=new Ce((m[1]-128)/128,(m[2]-128)/128,(m[3]-128)/128,(m[0]-128)/128);S.normalize();const g=d*c+o,x=new Float32Array(n,g,3),T=new Float32Array(n,g+i,3),C=new Float32Array(n,g+i+a,4),v=new Uint8Array(n,g+i+a+l,4);x[0]=u[0],x[1]=u[1],x[2]=u[2],T[0]=p[0],T[1]=p[1],T[2]=p[2],C[0]=S.w,C[1]=S.x,C[2]=S.y,C[3]=S.z,v[0]=f[0],v[1]=f[1],v[2]=f[2],v[3]=f[3]}}static parseToUncompressedSplatArraySection(e,s,t,r,n){for(let o=e;o<=s;o++){const i=o*Y.RowSizeBytes+r,a=new Float32Array(t,i,3),l=new Float32Array(t,i+Y.CenterSizeBytes,3),c=new Uint8Array(t,i+Y.CenterSizeBytes+Y.ScaleSizeBytes,4),d=new Uint8Array(t,i+Y.CenterSizeBytes+Y.ScaleSizeBytes+Y.RotationSizeBytes,4),h=new Ce((d[1]-128)/128,(d[2]-128)/128,(d[3]-128)/128,(d[0]-128)/128);h.normalize(),n.addSplatFromComonents(a[0],a[1],a[2],l[0],l[1],l[2],h.w,h.x,h.y,h.z,c[0],c[1],c[2],c[3])}}static parseStandardSplatToUncompressedSplatArray(e){const s=e.byteLength/Y.RowSizeBytes,t=new L;for(let r=0;r<s;r++){const n=r*Y.RowSizeBytes,o=new Float32Array(e,n,3),i=new Float32Array(e,n+Y.CenterSizeBytes,3),a=new Uint8Array(e,n+Y.CenterSizeBytes+Y.ScaleSizeBytes,4),l=new Uint8Array(e,n+Y.CenterSizeBytes+Y.ScaleSizeBytes+Y.ColorSizeBytes,4),c=new Ce((l[1]-128)/128,(l[2]-128)/128,(l[3]-128)/128,(l[0]-128)/128);c.normalize(),t.addSplatFromComonents(o[0],o[1],o[2],i[0],i[1],i[2],c.w,c.x,c.y,c.z,a[0],a[1],a[2],a[3])}return t}};P(Y,"RowSizeBytes",32),P(Y,"CenterSizeBytes",12),P(Y,"ScaleSizeBytes",12),P(Y,"RotationSizeBytes",4),P(Y,"ColorSizeBytes",4);let Ke=Y;function $s(A,e,s,t,r,n,o,i){return e?It.getStandardGenerator(s,t,r,n,o,i).generateFromUncompressedSplatArray(A):z.generateFromUncompressedSplatArrays([A],s,0,new D)}class Ts{static loadFromURL(e,s,t,r,n,o,i=!0,a,l,c,d,h){let u=t?ne.ProgressiveToSplatBuffer:ne.ProgressiveToSplatArray;i&&(u=ne.ProgressiveToSplatArray);const p=z.HeaderSizeBytes+z.SectionHeaderSizeBytes,f=G.ProgressiveLoadSectionSize,m=1;let S,g,x,T=0,C=0,v;const y=ds();let B=0,F=0,w=[];const M=(O,R,b,k)=>{const H=O>=100;if(b&&w.push(b),u===ne.DownloadBeforeProcessing){H&&y.resolve(w);return}if(!k){if(t)throw new Ot("Cannon directly load .splat because no file size info is available.");u=ne.DownloadBeforeProcessing;return}if(!S){T=k/Ke.RowSizeBytes,S=new ArrayBuffer(k);const Q=z.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,N=p+Q*T;u===ne.ProgressiveToSplatBuffer?(g=new ArrayBuffer(N),z.writeHeaderToBuffer({versionMajor:z.CurrentMajorVersion,versionMinor:z.CurrentMinorVersion,maxSectionCount:m,sectionCount:m,maxSplatCount:T,splatCount:C,compressionLevel:0,sceneCenter:new D},g)):v=new L(0)}if(b){new Uint8Array(S,F,b.byteLength).set(new Uint8Array(b)),F+=b.byteLength;const Q=F-B;if(Q>f||H){const U=(H?Q:f)/Ke.RowSizeBytes,V=C+U;u===ne.ProgressiveToSplatBuffer?Ke.parseToUncompressedSplatBufferSection(C,V-1,S,0,g,p):Ke.parseToUncompressedSplatArraySection(C,V-1,S,0,v),C=V,u===ne.ProgressiveToSplatBuffer&&(x||(z.writeSectionHeaderToBuffer({maxSplatCount:T,splatCount:C,bucketSize:0,bucketCount:0,bucketBlockSize:0,compressionScaleRange:0,storageSizeBytes:0,fullBucketCount:0,partiallyFilledBucketCount:0},0,g,z.HeaderSizeBytes),x=new z(g,!1)),x.updateLoadedCounts(1,C),r&&r(x,H)),B+=f}}H&&(u===ne.ProgressiveToSplatBuffer?y.resolve(x):y.resolve(v)),s&&s(O,R,fe.Downloading)};return s&&s(0,"0%",fe.Downloading),zt(e,M,!1,a).then(()=>(s&&s(0,"0%",fe.Processing),y.promise.then(O=>(s&&s(100,"100%",fe.Done),u===ne.DownloadBeforeProcessing?new Blob(w).arrayBuffer().then(R=>Ts.loadFromFileData(R,n,o,i,l,c,d,h)):u===ne.ProgressiveToSplatBuffer?O:be(()=>$s(O,i,n,o,l,c,d,h))))))}static loadFromFileData(e,s,t,r,n,o,i,a){return be(()=>{const l=Ke.parseStandardSplatToUncompressedSplatArray(e);return $s(l,r,s,t,n,o,i,a)})}}const rt=class rt{static checkVersion(e){const s=z.CurrentMajorVersion,t=z.CurrentMinorVersion,r=z.parseHeader(e);if(r.versionMajor===s&&r.versionMinor>=t||r.versionMajor>s)return!0;throw new Error(`KSplat version not supported: v${r.versionMajor}.${r.versionMinor}. Minimum required: v${s}.${t}`)}static loadFromURL(e,s,t,r,n){let o,i,a,l,c=!1,d=!1,h,u=[],p=!1,f=!1,m=0,S=0,g=0,x=!1,T=!1,C=!1,v=[];const y=ds(),B=()=>{!c&&!d&&m>=z.HeaderSizeBytes&&(d=!0,new Blob(v).arrayBuffer().then(k=>{a=new ArrayBuffer(z.HeaderSizeBytes),new Uint8Array(a).set(new Uint8Array(k,0,z.HeaderSizeBytes)),rt.checkVersion(a),d=!1,c=!0,l=z.parseHeader(a),window.setTimeout(()=>{M()},1)}))};let F=0;const w=()=>{F===0&&(F++,window.setTimeout(()=>{F--,O()},1))},M=()=>{const b=()=>{f=!0,new Blob(v).arrayBuffer().then(H=>{f=!1,p=!0,h=new ArrayBuffer(l.maxSectionCount*z.SectionHeaderSizeBytes),new Uint8Array(h).set(new Uint8Array(H,z.HeaderSizeBytes,l.maxSectionCount*z.SectionHeaderSizeBytes)),u=z.parseSectionHeaders(l,h,0,!1);let Q=0;for(let U=0;U<l.maxSectionCount;U++)Q+=u[U].storageSizeBytes;const N=z.HeaderSizeBytes+l.maxSectionCount*z.SectionHeaderSizeBytes+Q;if(!o){o=new ArrayBuffer(N);let U=0;for(let V=0;V<v.length;V++){const J=v[V];new Uint8Array(o,U,J.byteLength).set(new Uint8Array(J)),U+=J.byteLength}}g=z.HeaderSizeBytes+z.SectionHeaderSizeBytes*l.maxSectionCount;for(let U=0;U<=u.length&&U<l.maxSectionCount;U++)g+=u[U].storageSizeBytes;w()})};!f&&!p&&c&&m>=z.HeaderSizeBytes+z.SectionHeaderSizeBytes*l.maxSectionCount&&b()},O=()=>{if(C)return;C=!0;const b=()=>{if(C=!1,p){if(T)return;if(x=m>=g,m-S>G.ProgressiveLoadSectionSize||x){S+=G.ProgressiveLoadSectionSize,T=S>=g,i||(i=new z(o,!1));const H=z.HeaderSizeBytes+z.SectionHeaderSizeBytes*l.maxSectionCount;let Q=0,N=0,U=0;for(let ce=0;ce<l.maxSectionCount;ce++){const Z=u[ce],W=Q+Z.partiallyFilledBucketCount*4+Z.bucketStorageSizeBytes*Z.bucketCount,te=H+W;if(S>=te){N++;const K=S-te,ue=z.CompressionLevels[l.compressionLevel].SphericalHarmonicsDegrees[Z.sphericalHarmonicsDegree].BytesPerSplat;let ae=Math.floor(K/ue);ae=Math.min(ae,Z.maxSplatCount),U+=ae,i.updateLoadedCounts(N,U),i.updateSectionLoadedCounts(ce,ae)}else break;Q+=Z.storageSizeBytes}r(i,T);const V=S/g*100,J=V.toFixed(2)+"%";s&&s(V,J,fe.Downloading),T?y.resolve(i):O()}}};window.setTimeout(b,G.ProgressiveLoadSectionDelayDuration)};return zt(e,(b,k,H)=>{H&&(v.push(H),o&&new Uint8Array(o,m,H.byteLength).set(new Uint8Array(H)),m+=H.byteLength),t?(B(),M(),O()):s&&s(b,k,fe.Downloading)},!t,n).then(b=>(s&&s(0,"0%",fe.Processing),(t?y.promise:rt.loadFromFileData(b)).then(H=>(s&&s(100,"100%",fe.Done),H))))}static loadFromFileData(e){return be(()=>(rt.checkVersion(e),new z(e)))}};P(rt,"downloadFile",(function(){let e;return function(s,t){const r=new Blob([s.bufferData],{type:"application/octet-stream"});e||(e=document.createElement("a"),document.body.appendChild(e)),e.download=t,e.href=URL.createObjectURL(r),e.click()}})());let ns=rt;const Ee={Splat:0,KSplat:1,Ply:2,Spz:3},en=A=>A.endsWith(".ply")?Ee.Ply:A.endsWith(".splat")?Ee.Splat:A.endsWith(".ksplat")?Ee.KSplat:A.endsWith(".spz")?Ee.Spz:null,tn={type:"change"},jt={type:"start"},sn={type:"end"},Ft=new Mn,nn=new Pn,Jr=Math.cos(70*pn.DEG2RAD);class bt extends Kn{constructor(e,s){super(),this.object=e,this.domElement=s,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new D,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:Je.ROTATE,MIDDLE:Je.DOLLY,RIGHT:Je.PAN},this.touches={ONE:Ze.ROTATE,TWO:Ze.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return i.phi},this.getAzimuthalAngle=function(){return i.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(I){I.addEventListener("keydown",Qt),this._domElementKeyEvents=I},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Qt),this._domElementKeyEvents=null},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,this.clearDampedRotation(),this.clearDampedPan(),t.object.updateProjectionMatrix(),t.dispatchEvent(tn),t.update(),n=r.NONE},this.clearDampedRotation=function(){a.theta=0,a.phi=0},this.clearDampedPan=function(){c.set(0,0,0)},this.update=(function(){const I=new D,_=new Ce().setFromUnitVectors(e.up,new D(0,1,0)),he=_.clone().invert(),ge=new D,De=new Ce,Xe=new D,Ne=2*Math.PI;return function(){_.setFromUnitVectors(e.up,new D(0,1,0)),he.copy(_).invert();const Ds=t.object.position;I.copy(Ds).sub(t.target),I.applyQuaternion(_),i.setFromVector3(I),t.autoRotate&&n===r.NONE&&M(F()),t.enableDamping?(i.theta+=a.theta*t.dampingFactor,i.phi+=a.phi*t.dampingFactor):(i.theta+=a.theta,i.phi+=a.phi);let ke=t.minAzimuthAngle,Le=t.maxAzimuthAngle;isFinite(ke)&&isFinite(Le)&&(ke<-Math.PI?ke+=Ne:ke>Math.PI&&(ke-=Ne),Le<-Math.PI?Le+=Ne:Le>Math.PI&&(Le-=Ne),ke<=Le?i.theta=Math.max(ke,Math.min(Le,i.theta)):i.theta=i.theta>(ke+Le)/2?Math.max(ke,i.theta):Math.min(Le,i.theta)),i.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,i.phi)),i.makeSafe(),t.enableDamping===!0?t.target.addScaledVector(c,t.dampingFactor):t.target.add(c),t.zoomToCursor&&v||t.object.isOrthographicCamera?i.radius=U(i.radius):i.radius=U(i.radius*l),I.setFromSpherical(i),I.applyQuaternion(he),Ds.copy(t.target).add(I),t.object.lookAt(t.target),t.enableDamping===!0?(a.theta*=1-t.dampingFactor,a.phi*=1-t.dampingFactor,c.multiplyScalar(1-t.dampingFactor)):(a.set(0,0,0),c.set(0,0,0));let Tt=!1;if(t.zoomToCursor&&v){let dt=null;if(t.object.isPerspectiveCamera){const ut=I.length();dt=U(ut*l);const Bt=ut-dt;t.object.position.addScaledVector(T,Bt),t.object.updateMatrixWorld()}else if(t.object.isOrthographicCamera){const ut=new D(C.x,C.y,0);ut.unproject(t.object),t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/l)),t.object.updateProjectionMatrix(),Tt=!0;const Bt=new D(C.x,C.y,0);Bt.unproject(t.object),t.object.position.sub(Bt).add(ut),t.object.updateMatrixWorld(),dt=I.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),t.zoomToCursor=!1;dt!==null&&(this.screenSpacePanning?t.target.set(0,0,-1).transformDirection(t.object.matrix).multiplyScalar(dt).add(t.object.position):(Ft.origin.copy(t.object.position),Ft.direction.set(0,0,-1).transformDirection(t.object.matrix),Math.abs(t.object.up.dot(Ft.direction))<Jr?e.lookAt(t.target):(nn.setFromNormalAndCoplanarPoint(t.object.up,t.target),Ft.intersectPlane(nn,t.target))))}else t.object.isOrthographicCamera&&(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/l)),t.object.updateProjectionMatrix(),Tt=!0);return l=1,v=!1,Tt||ge.distanceToSquared(t.object.position)>o||8*(1-De.dot(t.object.quaternion))>o||Xe.distanceToSquared(t.target)>0?(t.dispatchEvent(tn),ge.copy(t.object.position),De.copy(t.object.quaternion),Xe.copy(t.target),Tt=!1,!0):!1}})(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",Es),t.domElement.removeEventListener("pointerdown",ye),t.domElement.removeEventListener("pointercancel",_e),t.domElement.removeEventListener("wheel",vs),t.domElement.removeEventListener("pointermove",we),t.domElement.removeEventListener("pointerup",_e),t._domElementKeyEvents!==null&&(t._domElementKeyEvents.removeEventListener("keydown",Qt),t._domElementKeyEvents=null)};const t=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let n=r.NONE;const o=1e-6,i=new Os,a=new Os;let l=1;const c=new D,d=new q,h=new q,u=new q,p=new q,f=new q,m=new q,S=new q,g=new q,x=new q,T=new D,C=new q;let v=!1;const y=[],B={};function F(){return 2*Math.PI/60/60*t.autoRotateSpeed}function w(){return Math.pow(.95,t.zoomSpeed)}function M(I){a.theta-=I}function O(I){a.phi-=I}const R=(function(){const I=new D;return function(he,ge){I.setFromMatrixColumn(ge,0),I.multiplyScalar(-he),c.add(I)}})(),b=(function(){const I=new D;return function(he,ge){t.screenSpacePanning===!0?I.setFromMatrixColumn(ge,1):(I.setFromMatrixColumn(ge,0),I.crossVectors(t.object.up,I)),I.multiplyScalar(he),c.add(I)}})(),k=(function(){const I=new D;return function(he,ge){const De=t.domElement;if(t.object.isPerspectiveCamera){const Xe=t.object.position;I.copy(Xe).sub(t.target);let Ne=I.length();Ne*=Math.tan(t.object.fov/2*Math.PI/180),R(2*he*Ne/De.clientHeight,t.object.matrix),b(2*ge*Ne/De.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(R(he*(t.object.right-t.object.left)/t.object.zoom/De.clientWidth,t.object.matrix),b(ge*(t.object.top-t.object.bottom)/t.object.zoom/De.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}})();function H(I){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?l/=I:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function Q(I){t.object.isPerspectiveCamera||t.object.isOrthographicCamera?l*=I:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function N(I){if(!t.zoomToCursor)return;v=!0;const _=t.domElement.getBoundingClientRect(),he=I.clientX-_.left,ge=I.clientY-_.top,De=_.width,Xe=_.height;C.x=he/De*2-1,C.y=-(ge/Xe)*2+1,T.set(C.x,C.y,1).unproject(e).sub(e.position).normalize()}function U(I){return Math.max(t.minDistance,Math.min(t.maxDistance,I))}function V(I){d.set(I.clientX,I.clientY)}function J(I){N(I),S.set(I.clientX,I.clientY)}function ce(I){p.set(I.clientX,I.clientY)}function Z(I){h.set(I.clientX,I.clientY),u.subVectors(h,d).multiplyScalar(t.rotateSpeed);const _=t.domElement;M(2*Math.PI*u.x/_.clientHeight),O(2*Math.PI*u.y/_.clientHeight),d.copy(h),t.update()}function W(I){g.set(I.clientX,I.clientY),x.subVectors(g,S),x.y>0?H(w()):x.y<0&&Q(w()),S.copy(g),t.update()}function te(I){f.set(I.clientX,I.clientY),m.subVectors(f,p).multiplyScalar(t.panSpeed),k(m.x,m.y),p.copy(f),t.update()}function K(I){N(I),I.deltaY<0?Q(w()):I.deltaY>0&&H(w()),t.update()}function $(I){let _=!1;switch(I.code){case t.keys.UP:I.ctrlKey||I.metaKey||I.shiftKey?O(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):k(0,t.keyPanSpeed),_=!0;break;case t.keys.BOTTOM:I.ctrlKey||I.metaKey||I.shiftKey?O(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):k(0,-t.keyPanSpeed),_=!0;break;case t.keys.LEFT:I.ctrlKey||I.metaKey||I.shiftKey?M(2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):k(t.keyPanSpeed,0),_=!0;break;case t.keys.RIGHT:I.ctrlKey||I.metaKey||I.shiftKey?M(-2*Math.PI*t.rotateSpeed/t.domElement.clientHeight):k(-t.keyPanSpeed,0),_=!0;break}_&&(I.preventDefault(),t.update())}function de(){if(y.length===1)d.set(y[0].pageX,y[0].pageY);else{const I=.5*(y[0].pageX+y[1].pageX),_=.5*(y[0].pageY+y[1].pageY);d.set(I,_)}}function ue(){if(y.length===1)p.set(y[0].pageX,y[0].pageY);else{const I=.5*(y[0].pageX+y[1].pageX),_=.5*(y[0].pageY+y[1].pageY);p.set(I,_)}}function ae(){const I=y[0].pageX-y[1].pageX,_=y[0].pageY-y[1].pageY,he=Math.sqrt(I*I+_*_);S.set(0,he)}function xe(){t.enableZoom&&ae(),t.enablePan&&ue()}function me(){t.enableZoom&&ae(),t.enableRotate&&de()}function re(I){if(y.length==1)h.set(I.pageX,I.pageY);else{const he=_t(I),ge=.5*(I.pageX+he.x),De=.5*(I.pageY+he.y);h.set(ge,De)}u.subVectors(h,d).multiplyScalar(t.rotateSpeed);const _=t.domElement;M(2*Math.PI*u.x/_.clientHeight),O(2*Math.PI*u.y/_.clientHeight),d.copy(h)}function Ae(I){if(y.length===1)f.set(I.pageX,I.pageY);else{const _=_t(I),he=.5*(I.pageX+_.x),ge=.5*(I.pageY+_.y);f.set(he,ge)}m.subVectors(f,p).multiplyScalar(t.panSpeed),k(m.x,m.y),p.copy(f)}function se(I){const _=_t(I),he=I.pageX-_.x,ge=I.pageY-_.y,De=Math.sqrt(he*he+ge*ge);g.set(0,De),x.set(0,Math.pow(g.y/S.y,t.zoomSpeed)),H(x.y),S.copy(g)}function Re(I){t.enableZoom&&se(I),t.enablePan&&Ae(I)}function Pe(I){t.enableZoom&&se(I),t.enableRotate&&re(I)}function ye(I){t.enabled!==!1&&(y.length===0&&(t.domElement.setPointerCapture(I.pointerId),t.domElement.addEventListener("pointermove",we),t.domElement.addEventListener("pointerup",_e)),Dn(I),I.pointerType==="touch"?En(I):Bn(I))}function we(I){t.enabled!==!1&&(I.pointerType==="touch"?wn(I):vn(I))}function _e(I){Fn(I),y.length===0&&(t.domElement.releasePointerCapture(I.pointerId),t.domElement.removeEventListener("pointermove",we),t.domElement.removeEventListener("pointerup",_e)),t.dispatchEvent(sn),n=r.NONE}function Bn(I){let _;switch(I.button){case 0:_=t.mouseButtons.LEFT;break;case 1:_=t.mouseButtons.MIDDLE;break;case 2:_=t.mouseButtons.RIGHT;break;default:_=-1}switch(_){case Je.DOLLY:if(t.enableZoom===!1)return;J(I),n=r.DOLLY;break;case Je.ROTATE:if(I.ctrlKey||I.metaKey||I.shiftKey){if(t.enablePan===!1)return;ce(I),n=r.PAN}else{if(t.enableRotate===!1)return;V(I),n=r.ROTATE}break;case Je.PAN:if(I.ctrlKey||I.metaKey||I.shiftKey){if(t.enableRotate===!1)return;V(I),n=r.ROTATE}else{if(t.enablePan===!1)return;ce(I),n=r.PAN}break;default:n=r.NONE}n!==r.NONE&&t.dispatchEvent(jt)}function vn(I){switch(n){case r.ROTATE:if(t.enableRotate===!1)return;Z(I);break;case r.DOLLY:if(t.enableZoom===!1)return;W(I);break;case r.PAN:if(t.enablePan===!1)return;te(I);break}}function vs(I){t.enabled===!1||t.enableZoom===!1||n!==r.NONE||(I.preventDefault(),t.dispatchEvent(jt),K(I),t.dispatchEvent(sn))}function Qt(I){t.enabled===!1||t.enablePan===!1||$(I)}function En(I){switch(ws(I),y.length){case 1:switch(t.touches.ONE){case Ze.ROTATE:if(t.enableRotate===!1)return;de(),n=r.TOUCH_ROTATE;break;case Ze.PAN:if(t.enablePan===!1)return;ue(),n=r.TOUCH_PAN;break;default:n=r.NONE}break;case 2:switch(t.touches.TWO){case Ze.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;xe(),n=r.TOUCH_DOLLY_PAN;break;case Ze.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;me(),n=r.TOUCH_DOLLY_ROTATE;break;default:n=r.NONE}break;default:n=r.NONE}n!==r.NONE&&t.dispatchEvent(jt)}function wn(I){switch(ws(I),n){case r.TOUCH_ROTATE:if(t.enableRotate===!1)return;re(I),t.update();break;case r.TOUCH_PAN:if(t.enablePan===!1)return;Ae(I),t.update();break;case r.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Re(I),t.update();break;case r.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;Pe(I),t.update();break;default:n=r.NONE}}function Es(I){t.enabled!==!1&&I.preventDefault()}function Dn(I){y.push(I)}function Fn(I){delete B[I.pointerId];for(let _=0;_<y.length;_++)if(y[_].pointerId==I.pointerId){y.splice(_,1);return}}function ws(I){let _=B[I.pointerId];_===void 0&&(_=new q,B[I.pointerId]=_),_.set(I.pageX,I.pageY)}function _t(I){const _=I.pointerId===y[0].pointerId?y[1]:y[0];return B[_.pointerId]}t.domElement.addEventListener("contextmenu",Es),t.domElement.addEventListener("pointerdown",ye),t.domElement.addEventListener("pointercancel",_e),t.domElement.addEventListener("wheel",vs,{passive:!1}),this.update()}}const Zr=(A,e,s,t,r)=>{const n=performance.now();let o=A.style.display==="none"?0:parseFloat(A.style.opacity);isNaN(o)&&(o=1);const i=window.setInterval(()=>{const l=performance.now()-n;let c=Math.min(l/t,1);c>.999&&(c=1);let d;e?(d=(1-c)*o,d<1e-4&&(d=0)):d=(1-o)*c+o,d>0?(A.style.display=s,A.style.opacity=d):A.style.display="none",c>=1&&(r&&r(),window.clearInterval(i))},16);return i},$r=500,Ht=class Ht{constructor(e,s){this.taskIDGen=0,this.elementID=Ht.elementIDGen++,this.tasks=[],this.message=e||"Loading...",this.container=s||document.body,this.spinnerContainerOuter=document.createElement("div"),this.spinnerContainerOuter.className=`spinnerOuterContainer${this.elementID}`,this.spinnerContainerOuter.style.display="none",this.spinnerContainerPrimary=document.createElement("div"),this.spinnerContainerPrimary.className=`spinnerContainerPrimary${this.elementID}`,this.spinnerPrimary=document.createElement("div"),this.spinnerPrimary.classList.add(`spinner${this.elementID}`,`spinnerPrimary${this.elementID}`),this.messageContainerPrimary=document.createElement("div"),this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`,`messageContainerPrimary${this.elementID}`),this.messageContainerPrimary.innerHTML=this.message,this.spinnerContainerMin=document.createElement("div"),this.spinnerContainerMin.className=`spinnerContainerMin${this.elementID}`,this.spinnerMin=document.createElement("div"),this.spinnerMin.classList.add(`spinner${this.elementID}`,`spinnerMin${this.elementID}`),this.messageContainerMin=document.createElement("div"),this.messageContainerMin.classList.add(`messageContainer${this.elementID}`,`messageContainerMin${this.elementID}`),this.messageContainerMin.innerHTML=this.message,this.spinnerContainerPrimary.appendChild(this.spinnerPrimary),this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary),this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary),this.spinnerContainerMin.appendChild(this.spinnerMin),this.spinnerContainerMin.appendChild(this.messageContainerMin),this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);const t=document.createElement("style");t.innerHTML=`

            .spinnerOuterContainer${this.elementID} {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .messageContainer${this.elementID} {
                height: 20px;
                font-family: arial;
                font-size: 12pt;
                color: #ffffff;
                text-align: center;
                vertical-align: middle;
            }

            .spinner${this.elementID} {
                padding: 15px;
                background: #07e8d6;
                z-index:99999;
            
                aspect-ratio: 1;
                border-radius: 50%;
                --_m: 
                    conic-gradient(#0000,#000),
                    linear-gradient(#000 0 0) content-box;
                -webkit-mask: var(--_m);
                    mask: var(--_m);
                -webkit-mask-composite: source-out;
                    mask-composite: subtract;
                box-sizing: border-box;
                animation: load 1s linear infinite;
            }

            .spinnerContainerPrimary${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 10px;
                margin: 0;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-80px, -80px);
                width: 180px;
                pointer-events: auto;
            }

            .spinnerPrimary${this.elementID} {
                width: 120px;
                margin-left: 30px;
            }

            .messageContainerPrimary${this.elementID} {
                padding-top: 15px;
            }

            .spinnerContainerMin${this.elementID} {
                z-index:99999;
                background-color: rgba(128, 128, 128, 0.75);
                border: #666666 1px solid;
                border-radius: 5px;
                padding-top: 20px;
                padding-bottom: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                display: flex;
                flex-direction: left;
                pointer-events: auto;
                min-width: 250px;
            }

            .messageContainerMin${this.elementID} {
                margin-right: 15px;
            }

            .spinnerMin${this.elementID} {
                width: 50px;
                height: 50px;
                margin-left: 15px;
                margin-right: 25px;
            }

            .messageContainerMin${this.elementID} {
                padding-top: 15px;
            }
            
            @keyframes load {
                to{transform: rotate(1turn)}
            }

        `,this.spinnerContainerOuter.appendChild(t),this.container.appendChild(this.spinnerContainerOuter),this.setMinimized(!1,!0),this.fadeTransitions=[]}addTask(e){const s={message:e,id:this.taskIDGen++};return this.tasks.push(s),this.update(),s.id}removeTask(e){let s=0;for(let t of this.tasks){if(t.id===e){this.tasks.splice(s,1);break}s++}this.update()}removeAllTasks(){this.tasks=[],this.update()}setMessageForTask(e,s){for(let t of this.tasks)if(t.id===e){t.message=s;break}this.update()}update(){this.tasks.length>0?(this.show(),this.setMessage(this.tasks[this.tasks.length-1].message)):this.hide()}show(){this.spinnerContainerOuter.style.display="block",this.visible=!0}hide(){this.spinnerContainerOuter.style.display="none",this.visible=!1}setContainer(e){this.container&&this.spinnerContainerOuter.parentElement===this.container&&this.container.removeChild(this.spinnerContainerOuter),e&&(this.container=e,this.container.appendChild(this.spinnerContainerOuter),this.spinnerContainerOuter.style.zIndex=this.container.style.zIndex+1)}setMinimized(e,s){const t=(r,n,o,i,a)=>{o?r.style.display=n?i:"none":this.fadeTransitions[a]=Zr(r,!n,i,$r,()=>{this.fadeTransitions[a]=null})};t(this.spinnerContainerPrimary,!e,s,"block",0),t(this.spinnerContainerMin,e,s,"flex",1),this.minimized=e}setMessage(e){this.messageContainerPrimary.innerHTML=e,this.messageContainerMin.innerHTML=e}};P(Ht,"elementIDGen",0);let rs=Ht;class eo{constructor(e){this.idGen=0,this.tasks=[],this.container=e||document.body,this.progressBarContainerOuter=document.createElement("div"),this.progressBarContainerOuter.className="progressBarOuterContainer",this.progressBarContainerOuter.style.display="none",this.progressBarBox=document.createElement("div"),this.progressBarBox.className="progressBarBox",this.progressBarBackground=document.createElement("div"),this.progressBarBackground.className="progressBarBackground",this.progressBar=document.createElement("div"),this.progressBar.className="progressBar",this.progressBarBackground.appendChild(this.progressBar),this.progressBarBox.appendChild(this.progressBarBackground),this.progressBarContainerOuter.appendChild(this.progressBarBox);const s=document.createElement("style");s.innerHTML=`

            .progressBarOuterContainer {
                width: 100%;
                height: 100%;
                margin: 0;
                top: 0;
                left: 0;
                position: absolute;
                pointer-events: none;
            }

            .progressBarBox {
                z-index:99999;
                padding: 7px 9px 5px 7px;
                background-color: rgba(190, 190, 190, 0.75);
                border: #555555 1px solid;
                border-radius: 15px;
                margin: 0;
                position: absolute;
                bottom: 50px;
                left: 50%;
                transform: translate(-50%, 0);
                width: 180px;
                height: 30px;
                pointer-events: auto;
            }

            .progressBarBackground {
                width: 100%;
                height: 25px;
                border-radius:10px;
                background-color: rgba(128, 128, 128, 0.75);
                border: #444444 1px solid;
                box-shadow: inset 0 0 10px #333333;
            }

            .progressBar {
                height: 25px;
                width: 0px;
                border-radius:10px;
                background-color: rgba(0, 200, 0, 0.75);
                box-shadow: inset 0 0 10px #003300;
            }

        `,this.progressBarContainerOuter.appendChild(s),this.container.appendChild(this.progressBarContainerOuter)}show(){this.progressBarContainerOuter.style.display="block"}hide(){this.progressBarContainerOuter.style.display="none"}setProgress(e){this.progressBar.style.width=e+"%"}setContainer(e){this.container&&this.progressBarContainerOuter.parentElement===this.container&&this.container.removeChild(this.progressBarContainerOuter),e&&(this.container=e,this.container.appendChild(this.progressBarContainerOuter),this.progressBarContainerOuter.style.zIndex=this.container.style.zIndex+1)}}class to{constructor(e){P(this,"update",function(e,s,t,r,n,o,i,a,l,c,d,h,u,p){const f=`${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}`;if(this.infoCells.cameraPosition.innerHTML!==f&&(this.infoCells.cameraPosition.innerHTML=f),t){const S=t,g=`${S.x.toFixed(5)}, ${S.y.toFixed(5)}, ${S.z.toFixed(5)}`;this.infoCells.cameraLookAt.innerHTML!==g&&(this.infoCells.cameraLookAt.innerHTML=g)}const m=`${r.x.toFixed(5)}, ${r.y.toFixed(5)}, ${r.z.toFixed(5)}`;if(this.infoCells.cameraUp.innerHTML!==m&&(this.infoCells.cameraUp.innerHTML=m),this.infoCells.orthographicCamera.innerHTML=n?"Orthographic":"Perspective",o){const S=o,g=`${S.x.toFixed(5)}, ${S.y.toFixed(5)}, ${S.z.toFixed(5)}`;this.infoCells.cursorPosition.innerHTML=g}else this.infoCells.cursorPosition.innerHTML="N/A";this.infoCells.fps.innerHTML=i,this.infoCells.renderWindow.innerHTML=`${e.x} x ${e.y}`,this.infoCells.renderSplatCount.innerHTML=`${l} splats out of ${a} (${c.toFixed(2)}%)`,this.infoCells.sortTime.innerHTML=`${d.toFixed(3)} ms`,this.infoCells.focalAdjustment.innerHTML=`${h.toFixed(3)}`,this.infoCells.splatScale.innerHTML=`${u.toFixed(3)}`,this.infoCells.pointCloudMode.innerHTML=`${p}`});this.container=e||document.body,this.infoCells={};const s=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Camera mode","orthographicCamera"],["Cursor position","cursorPosition"],["FPS","fps"],["Rendering:","renderSplatCount"],["Sort time","sortTime"],["Render window","renderWindow"],["Focal adjustment","focalAdjustment"],["Splat scale","splatScale"],["Point cloud mode","pointCloudMode"]];this.infoPanelContainer=document.createElement("div");const t=document.createElement("style");t.innerHTML=`

            .infoPanel {
                width: 430px;
                padding: 10px;
                background-color: rgba(50, 50, 50, 0.85);
                border: #555555 2px solid;
                color: #dddddd;
                border-radius: 10px;
                z-index: 9999;
                font-family: arial;
                font-size: 11pt;
                text-align: left;
                margin: 0;
                top: 10px;
                left:10px;
                position: absolute;
                pointer-events: auto;
            }

            .info-panel-cell {
                margin-bottom: 5px;
                padding-bottom: 2px;
            }

            .label-cell {
                font-weight: bold;
                font-size: 12pt;
                width: 140px;
            }

        `,this.infoPanelContainer.append(t),this.infoPanel=document.createElement("div"),this.infoPanel.className="infoPanel";const r=document.createElement("div");r.style.display="table";for(let n of s){const o=document.createElement("div");o.style.display="table-row",o.className="info-panel-row";const i=document.createElement("div");i.style.display="table-cell",i.innerHTML=`${n[0]}: `,i.classList.add("info-panel-cell","label-cell");const a=document.createElement("div");a.style.display="table-cell",a.style.width="10px",a.innerHTML=" ",a.className="info-panel-cell";const l=document.createElement("div");l.style.display="table-cell",l.innerHTML="",l.className="info-panel-cell",this.infoCells[n[1]]=l,o.appendChild(i),o.appendChild(a),o.appendChild(l),r.appendChild(o)}this.infoPanel.appendChild(r),this.infoPanelContainer.append(this.infoPanel),this.infoPanelContainer.style.display="none",this.container.appendChild(this.infoPanelContainer),this.visible=!1}setContainer(e){this.container&&this.infoPanelContainer.parentElement===this.container&&this.container.removeChild(this.infoPanelContainer),e&&(this.container=e,this.container.appendChild(this.infoPanelContainer),this.infoPanelContainer.style.zIndex=this.container.style.zIndex+1)}show(){this.infoPanelContainer.style.display="block",this.visible=!0}hide(){this.infoPanelContainer.style.display="none",this.visible=!1}}const rn=new D;class so extends nt{constructor(e=new D(0,0,1),s=new D(0,0,0),t=1,r=.1,n=16776960,o=t*.2,i=o*.2){super(),this.type="ArrowHelper";const a=new ks(r,r,t,32);a.translate(0,t/2,0);const l=new ks(0,i,o,32);l.translate(0,t,0),this.position.copy(s),this.line=new Fe(a,new lt({color:n,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Fe(l,new lt({color:n,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{rn.set(e.z,0,-e.x).normalize();const s=Math.acos(e.y);this.quaternion.setFromAxisAngle(rn,s)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class At{constructor(e){P(this,"updateFocusMarker",(function(){const e=new D,s=new ee,t=new D;return function(r,n,o){s.copy(n.matrixWorld).invert(),e.copy(r).applyMatrix4(s),e.normalize().multiplyScalar(10),e.applyMatrix4(n.matrixWorld),t.copy(n.position).sub(r);const i=t.length();this.focusMarker.position.copy(r),this.focusMarker.scale.set(i,i,i),this.focusMarker.material.uniforms.realFocusPosition.value.copy(r),this.focusMarker.material.uniforms.viewport.value.copy(o),this.focusMarker.material.uniformsNeedUpdate=!0}})());P(this,"positionAndOrientControlPlane",(function(){const e=new Ce,s=new D(0,1,0);return function(t,r){e.setFromUnitVectors(s,r),this.controlPlane.position.copy(t),this.controlPlane.quaternion.copy(e)}})());this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(e,s){this.destroySplatRendertarget(),this.splatRenderTarget=new _n(e,s,{format:Mt,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new Nn(e,s),this.splatRenderTarget.depthTexture.format=Vn,this.splatRenderTarget.depthTexture.type=pt}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const e={sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},s=new ft({vertexShader:`
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4( position.xy, 0.0, 1.0 );    
                }
            `,fragmentShader:`
                #include <common>
                #include <packing>
                varying vec2 vUv;
                uniform sampler2D sourceColorTexture;
                uniform sampler2D sourceDepthTexture;
                void main() {
                    vec4 color = texture2D(sourceColorTexture, vUv);
                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;
                    gl_FragDepth = fragDepth;
                    gl_FragColor = vec4(color.rgb, color.a * 2.0);
              }
            `,uniforms:e,depthWrite:!1,depthTest:!1,transparent:!0,blending:Gn,blendSrc:Rs,blendSrcAlpha:Rs,blendDst:bs,blendDstAlpha:bs});s.extensions.fragDepth=!0,this.renderTargetCopyQuad=new Fe(new Ms(2,2),s),this.renderTargetCopyCamera=new hn(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(st(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const e=new qn(.5,1.5,32),s=new lt({color:16777215}),t=new Fe(e,s);t.rotation.set(0,0,Math.PI),t.position.set(0,1,0);const r=new Fe(e,s);r.position.set(0,-1,0);const n=new Fe(e,s);n.rotation.set(0,0,Math.PI/2),n.position.set(1,0,0);const o=new Fe(e,s);o.rotation.set(0,0,-Math.PI/2),o.position.set(-1,0,0),this.meshCursor=new nt,this.meshCursor.add(t),this.meshCursor.add(r),this.meshCursor.add(n),this.meshCursor.add(o),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(st(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}getMeschCursorVisibility(){return this.meshCursor.visible}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,s){this.meshCursor.position.copy(e),this.meshCursor.up.copy(s.up),this.meshCursor.lookAt(s.position)}setupFocusMarker(){if(!this.focusMarker){const e=new $t(.5,32,32),s=At.buildFocusMarkerMaterial();s.depthTest=!1,s.depthWrite=!1,s.transparent=!0,this.focusMarker=new Fe(e,s)}}destroyFocusMarker(){this.focusMarker&&(st(this.focusMarker),this.focusMarker=null)}setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const e=new Ms(1,1);e.rotateX(-Math.PI/2);const s=new lt({color:16777215});s.transparent=!0,s.opacity=.6,s.depthTest=!1,s.depthWrite=!1,s.side=cs;const t=new Fe(e,s),r=new D(0,1,0);r.normalize();const n=new D(0,0,0),o=.5,i=.01,a=56576,l=new so(r,n,o,i,a,.1,.03);this.controlPlane=new nt,this.controlPlane.add(t),this.controlPlane.add(l)}}destroyControlPlane(){this.controlPlane&&(st(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(st(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(e){const s=new $t(1,32,32),t=new nt,r=(n,o)=>{let i=new Fe(s,At.buildDebugMaterial(n));i.renderOrder=e,t.add(i),i.position.fromArray(o)};return r(16711680,[-50,0,0]),r(16711680,[50,0,0]),r(65280,[0,0,-50]),r(65280,[0,0,50]),r(16755200,[5,0,5]),t}createSecondaryDebugMeshes(e){const s=new Wn(3,3,3),t=new nt;let r=12303291;const n=i=>{let a=new Fe(s,At.buildDebugMaterial(r));a.renderOrder=e,t.add(a),a.position.fromArray(i)};let o=10;return n([-o,0,-o]),n([-o,0,o]),n([o,0,-o]),n([o,0,o]),t}static buildDebugMaterial(e){const s=`
            #include <common>
            varying float ndcDepth;

            void main() {
                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);
                ndcDepth = gl_Position.z / gl_Position.w;
                gl_Position.x = gl_Position.x / gl_Position.w;
                gl_Position.y = gl_Position.y / gl_Position.w;
                gl_Position.z = 0.0;
                gl_Position.w = 1.0;
    
            }
        `,t=`
            #include <common>
            uniform vec3 color;
            varying float ndcDepth;
            void main() {
                gl_FragDepth = (ndcDepth + 1.0) / 2.0;
                gl_FragColor = vec4(color.rgb, 0.0);
            }
        `,r={color:{type:"v3",value:new Pt(e)}},n=new ft({uniforms:r,vertexShader:s,fragmentShader:t,transparent:!1,depthTest:!0,depthWrite:!0,side:Ps});return n.extensions.fragDepth=!0,n}static buildFocusMarkerMaterial(e){const s=`
            #include <common>

            uniform vec2 viewport;
            uniform vec3 realFocusPosition;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                float radius = 0.01;

                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);
                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);

                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);

                ndcPosition = projectionMatrix * viewPosition;
                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);
                ndcCenter = projectionMatrix * viewCenter;
                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);

                ndcFocusPosition = projectionMatrix * viewFocusPosition;
                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);

                gl_Position = projectionMatrix * viewPosition;

            }
        `,t=`
            #include <common>
            uniform vec3 color;
            uniform vec2 viewport;
            uniform float opacity;

            varying vec4 ndcPosition;
            varying vec4 ndcCenter;
            varying vec4 ndcFocusPosition;

            void main() {
                vec2 screenPosition = vec2(ndcPosition) * viewport;
                vec2 screenCenter = vec2(ndcCenter) * viewport;

                vec2 screenVec = screenPosition - screenCenter;

                float projectedRadius = length(screenVec);

                float lineWidth = 0.0005 * viewport.y;
                float aaRange = 0.0025 * viewport.y;
                float radius = 0.06 * viewport.y;
                float radDiff = abs(projectedRadius - radius) - lineWidth;
                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); 

                gl_FragColor = vec4(color.rgb, alpha * opacity);
            }
        `,r={color:{type:"v3",value:new Pt(e)},realFocusPosition:{type:"v3",value:new D},viewport:{type:"v2",value:new q},opacity:{value:0}};return new ft({uniforms:r,vertexShader:s,fragmentShader:t,transparent:!0,depthTest:!1,depthWrite:!1,side:Ps})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const no=new D(1,0,0),ro=new D(0,1,0),oo=new D(0,0,1);class Yt{constructor(e=new D,s=new D){P(this,"intersectBox",(function(){const e=new D,s=[],t=[],r=[];return function(n,o){if(t[0]=this.origin.x,t[1]=this.origin.y,t[2]=this.origin.z,r[0]=this.direction.x,r[1]=this.direction.y,r[2]=this.direction.z,this.boxContainsPoint(n,this.origin,1e-4))return o&&(o.origin.copy(this.origin),o.normal.set(0,0,0),o.distance=-1),!0;for(let i=0;i<3;i++){if(r[i]==0)continue;const a=i==0?no:i==1?ro:oo,l=r[i]<0?n.max:n.min;let c=-Math.sign(r[i]);s[0]=i==0?l.x:i==1?l.y:l.z;let d=s[0]-t[i];if(d*c<0){const h=(i+1)%3,u=(i+2)%3;if(s[2]=r[h]/r[i]*d+t[h],s[1]=r[u]/r[i]*d+t[u],e.set(s[i],s[u],s[h]),this.boxContainsPoint(n,e,1e-4))return o&&(o.origin.copy(e),o.normal.copy(a).multiplyScalar(c),o.distance=e.sub(this.origin).length()),!0}}return!1}})());P(this,"intersectSphere",(function(){const e=new D;return function(s,t,r){e.copy(s).sub(this.origin);const n=e.dot(this.direction),o=n*n,a=e.dot(e)-o,l=t*t;if(a>l)return!1;const c=Math.sqrt(l-a),d=n-c,h=n+c;if(h<0)return!1;let u=d<0?h:d;return r&&(r.origin.copy(this.origin).addScaledVector(this.direction,u),r.normal.copy(r.origin).sub(s).normalize(),r.distance=u),!0}})());this.origin=new D,this.direction=new D,this.setParameters(e,s)}setParameters(e,s){this.origin.copy(e),this.direction.copy(s).normalize()}boxContainsPoint(e,s,t){return!(s.x<e.min.x-t||s.x>e.max.x+t||s.y<e.min.y-t||s.y>e.max.y+t||s.z<e.min.z-t||s.z>e.max.z+t)}}class Bs{constructor(){this.origin=new D,this.normal=new D,this.distance=0,this.splatIndex=0}set(e,s,t,r){this.origin.copy(e),this.normal.copy(s),this.distance=t,this.splatIndex=r}clone(){const e=new Bs;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}const Ue={ThreeD:0,TwoD:1};class io{constructor(e,s,t=!1){P(this,"setFromCameraAndScreenPosition",(function(){const e=new q;return function(s,t,r){if(e.x=t.x/r.x*2-1,e.y=(r.y-t.y)/r.y*2-1,s.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(s.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(s).sub(this.ray.origin).normalize(),this.camera=s;else if(s.isOrthographicCamera)this.ray.origin.set(e.x,e.y,(s.near+s.far)/(s.near-s.far)).unproject(s),this.ray.direction.set(0,0,-1).transformDirection(s.matrixWorld),this.camera=s;else throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type")}})());P(this,"intersectSplatMesh",(function(){const e=new ee,s=new ee,t=new ee,r=new Yt,n=new D;return function(o,i=[]){const a=o.getSplatTree();if(a){for(let l=0;l<a.subTrees.length;l++){const c=a.subTrees[l];s.copy(o.matrixWorld),o.dynamicMode&&(o.getSceneTransform(l,t),s.multiply(t)),e.copy(s).invert(),r.origin.copy(this.ray.origin).applyMatrix4(e),r.direction.copy(this.ray.origin).add(this.ray.direction),r.direction.applyMatrix4(e).sub(r.origin).normalize();const d=[];c.rootNode&&this.castRayAtSplatTreeNode(r,a,c.rootNode,d),d.forEach(h=>{h.origin.applyMatrix4(s),h.normal.applyMatrix4(s).normalize(),h.distance=n.copy(h.origin).sub(this.ray.origin).length()}),i.push(...d)}return i.sort((l,c)=>l.distance>c.distance?1:-1),i}}})());P(this,"castRayAtSplatTreeNode",(function(){const e=new ls,s=new D,t=new D,r=new Ce,n=new Bs,o=1e-7,i=new D(0,0,0),a=new ee,l=new ee,c=new ee,d=new ee,h=new ee,u=new Yt;return function(p,f,m,S=[]){if(p.intersectBox(m.boundingBox)){if(m.data&&m.data.indexes&&m.data.indexes.length>0)for(let g=0;g<m.data.indexes.length;g++){const x=m.data.indexes[g],T=f.splatMesh.getSceneIndexForSplat(x);if(f.splatMesh.getScene(T).visible&&(f.splatMesh.getSplatColor(x,e),f.splatMesh.getSplatCenter(x,s),f.splatMesh.getSplatScaleAndRotation(x,t,r),!(t.x<=o||t.y<=o||f.splatMesh.splatRenderMode===Ue.ThreeD&&t.z<=o)))if(this.raycastAgainstTrueSplatEllipsoid){l.makeScale(t.x,t.y,t.z),c.makeRotationFromQuaternion(r);const v=Math.log10(e.w)*2;if(a.makeScale(v,v,v),h.copy(a).multiply(c).multiply(l),d.copy(h).invert(),u.origin.copy(p.origin).sub(s).applyMatrix4(d),u.direction.copy(p.origin).add(p.direction).sub(s),u.direction.applyMatrix4(d).sub(u.origin).normalize(),u.intersectSphere(i,1,n)){const y=n.clone();y.splatIndex=x,y.origin.applyMatrix4(h).add(s),S.push(y)}}else{let v=t.x+t.y,y=2;if(f.splatMesh.splatRenderMode===Ue.ThreeD&&(v+=t.z,y=3),v=v/y,p.intersectSphere(s,v,n)){const B=n.clone();B.splatIndex=x,S.push(B)}}}if(m.children&&m.children.length>0)for(let g of m.children)this.castRayAtSplatTreeNode(p,f,g,S);return S}}})());this.ray=new Yt(e,s),this.raycastAgainstTrueSplatEllipsoid=t}}class it{static buildVertexShaderBase(e=!1,s=!1,t=0,r=""){let n=`
        precision highp float;
        #include <common>

        attribute uint splatIndex;
        uniform highp usampler2D centersColorsTexture;
        uniform highp sampler2D sphericalHarmonicsTexture;
        uniform highp sampler2D sphericalHarmonicsTextureR;
        uniform highp sampler2D sphericalHarmonicsTextureG;
        uniform highp sampler2D sphericalHarmonicsTextureB;

        uniform highp usampler2D sceneIndexesTexture;
        uniform vec2 sceneIndexesTextureSize;
        uniform int sceneCount;
    `;return s&&(n+=`
            uniform float sceneOpacity[${G.MaxScenes}];
            uniform int sceneVisibility[${G.MaxScenes}];
        `),e&&(n+=`
            uniform highp mat4 transforms[${G.MaxScenes}];
        `),n+=`
        ${r}
        uniform vec2 focal;
        uniform float orthoZoom;
        uniform int orthographicMode;
        uniform int pointCloudModeEnabled;
        uniform float inverseFocalAdjustment;
        uniform vec2 viewport;
        uniform vec2 basisViewport;
        uniform vec2 centersColorsTextureSize;
        uniform int sphericalHarmonicsDegree;
        uniform vec2 sphericalHarmonicsTextureSize;
        uniform int sphericalHarmonics8BitMode;
        uniform int sphericalHarmonicsMultiTextureMode;
        uniform float visibleRegionRadius;
        uniform float visibleRegionFadeStartRadius;
        uniform float firstRenderTime;
        uniform float currentTime;
        uniform int fadeInComplete;
        uniform vec3 sceneCenter;
        uniform float splatScale;
        uniform float sphericalHarmonics8BitCompressionRangeMin[${G.MaxScenes}];
        uniform float sphericalHarmonics8BitCompressionRangeMax[${G.MaxScenes}];

        varying vec4 vColor;
        varying vec2 vUv;
        varying vec2 vPosition;

        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {
            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);
        
            return mat3(
                1. - 2. * (y * y + z * z),
                2. * (x * y + w * z),
                2. * (x * z - w * y),
                2. * (x * y - w * z),
                1. - 2. * (x * x + z * z),
                2. * (y * z + w * x),
                2. * (x * z + w * y),
                2. * (y * z - w * x),
                1. - 2. * (x * x + y * y)
            );
        }

        const float sqrt8 = sqrt(8.0);
        const float minAlpha = 1.0 / 255.0;

        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
        const uvec4 shift4 = uvec4(0, 8, 16, 24);
        vec4 uintToRGBAVec (uint u) {
           uvec4 urgba = mask4 & u;
           urgba = urgba >> shift4;
           vec4 rgba = vec4(urgba) * encodeNorm4;
           return rgba;
        }

        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {
            vec2 samplerUV = vec2(0.0, 0.0);
            float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;
            samplerUV.y = float(floor(d)) / dimensions.y;
            samplerUV.x = fract(d);
            return samplerUV;
        }

        const float SH_C1 = 0.4886025119029199f;
        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);

        void main () {

            uint oddOffset = splatIndex & uint(0x00000001);
            uint doubleOddOffset = oddOffset * uint(2);
            bool isEven = oddOffset == uint(0);
            uint nearestEvenIndex = splatIndex - oddOffset;
            float fOddOffset = float(oddOffset);

            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));

            uint sceneIndex = uint(0);
            if (sceneCount > 1) {
                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;
            }
            `,s&&(n+=`
                float splatOpacityFromScene = sceneOpacity[sceneIndex];
                int sceneVisible = sceneVisibility[sceneIndex];
                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {
                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                    return;
                }
            `),e?n+=`
                mat4 transform = transforms[sceneIndex];
                mat4 transformModelViewMatrix = viewMatrix * transform;
            `:n+="mat4 transformModelViewMatrix = modelViewMatrix;",n+=`
            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];
            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];
            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;
            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;
            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);

            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);

            vec4 clipCenter = projectionMatrix * viewCenter;

            float clip = 1.2 * clipCenter.w;
            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {
                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                return;
            }

            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

            vPosition = position.xy;
            vColor = uintToRGBAVec(sampledCenterColor.r);
        `,t>=1&&(n+=`   
            if (sphericalHarmonicsDegree >= 1) {
            `,e?n+=`
                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));
                `:n+=`
                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);
                `,n+=`
                vec3 sh1;
                vec3 sh2;
                vec3 sh3;
            `,t>=2&&(n+=`
                    vec3 sh4;
                    vec3 sh5;
                    vec3 sh6;
                    vec3 sh7;
                    vec3 sh8;
                `),t===1?n+=`
                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);
                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);
                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);
                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);
                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);
                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;
                    } else {
                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;
                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;
                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);
                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);
                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);
                    }
                `:t===2&&(n+=`
                    vec4 sampledSH0123;
                    vec4 sampledSH4567;
                    vec4 sampledSH891011;

                    vec4 sampledSH0123R;
                    vec4 sampledSH0123G;
                    vec4 sampledSH0123B;

                    if (sphericalHarmonicsMultiTextureMode == 0) {
                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));
                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));
                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));
                        sh1 = sampledSH0123.rgb;
                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);
                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);
                    } else {
                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));
                        sh1 = vec3(sampledSH0123R.rgb);
                        sh2 = vec3(sampledSH0123G.rgb);
                        sh3 = vec3(sampledSH0123B.rgb);
                    }
                `),n+=`
                    if (sphericalHarmonics8BitMode == 1) {
                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                    }
                    float x = worldViewDir.x;
                    float y = worldViewDir.y;
                    float z = worldViewDir.z;
                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);
            `,t>=2&&(n+=`
                    if (sphericalHarmonicsDegree >= 2) {
                        float xx = x * x;
                        float yy = y * y;
                        float zz = z * z;
                        float xy = x * y;
                        float yz = y * z;
                        float xz = x * z;
                `,t===2&&(n+=`
                        if (sphericalHarmonicsMultiTextureMode == 0) {
                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));
                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));
                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));
                            sh4 = sampledSH891011.gba;
                            sh5 = sampledSH12131415.rgb;
                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);
                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);
                            sh8 = sampledSH20212223.gba;
                        } else {
                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));
                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);
                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);
                            sh6 = vec3(sampledSH4567G.rgb);
                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);
                            sh8 = vec3(sampledSH4567B.gba);
                        }
                    `),n+=`
                        if (sphericalHarmonics8BitMode == 1) {
                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;
                        }

                        vColor.rgb +=
                            (SH_C2[0] * xy) * sh4 +
                            (SH_C2[1] * yz) * sh5 +
                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +
                            (SH_C2[3] * xz) * sh7 +
                            (SH_C2[4] * (xx - yy)) * sh8;
                    }
                `),n+=`

                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));

            }

            `),n}static getVertexShaderFadeIn(){return`
            if (fadeInComplete == 0) {
                float opacityAdjust = 1.0;
                float centerDist = length(splatCenter - sceneCenter);
                float renderTime = max(currentTime - firstRenderTime, 0.0);

                float fadeDistance = 0.75;
                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);
                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +
                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *
                                        distanceLoadFadeInFactor;
                opacityAdjust *= distanceLoadFadeInFactor;
                vColor.a *= opacityAdjust;
            }
        `}static getUniforms(e=!1,s=!1,t=0,r=1,n=!1){const o={sceneCenter:{type:"v3",value:new D},fadeInComplete:{type:"i",value:0},orthographicMode:{type:"i",value:0},visibleRegionFadeStartRadius:{type:"f",value:0},visibleRegionRadius:{type:"f",value:0},currentTime:{type:"f",value:0},firstRenderTime:{type:"f",value:0},centersColorsTexture:{type:"t",value:null},sphericalHarmonicsTexture:{type:"t",value:null},sphericalHarmonicsTextureR:{type:"t",value:null},sphericalHarmonicsTextureG:{type:"t",value:null},sphericalHarmonicsTextureB:{type:"t",value:null},sphericalHarmonics8BitCompressionRangeMin:{type:"f",value:[]},sphericalHarmonics8BitCompressionRangeMax:{type:"f",value:[]},focal:{type:"v2",value:new q},orthoZoom:{type:"f",value:1},inverseFocalAdjustment:{type:"f",value:1},viewport:{type:"v2",value:new q},basisViewport:{type:"v2",value:new q},debugColor:{type:"v3",value:new Pt},centersColorsTextureSize:{type:"v2",value:new q(1024,1024)},sphericalHarmonicsDegree:{type:"i",value:t},sphericalHarmonicsTextureSize:{type:"v2",value:new q(1024,1024)},sphericalHarmonics8BitMode:{type:"i",value:0},sphericalHarmonicsMultiTextureMode:{type:"i",value:0},splatScale:{type:"f",value:r},pointCloudModeEnabled:{type:"i",value:n?1:0},sceneIndexesTexture:{type:"t",value:null},sceneIndexesTextureSize:{type:"v2",value:new q(1024,1024)},sceneCount:{type:"i",value:1}};for(let i=0;i<G.MaxScenes;i++)o.sphericalHarmonics8BitCompressionRangeMin.value.push(-3/2),o.sphericalHarmonics8BitCompressionRangeMax.value.push(G.SphericalHarmonics8BitCompressionRange/2);if(s){const i=[];for(let l=0;l<G.MaxScenes;l++)i.push(1);o.sceneOpacity={type:"f",value:i};const a=[];for(let l=0;l<G.MaxScenes;l++)a.push(1);o.sceneVisibility={type:"i",value:a}}if(e){const i=[];for(let a=0;a<G.MaxScenes;a++)i.push(new ee);o.transforms={type:"mat4",value:i}}return o}}class kt{static build(e=!1,s=!1,t=!1,r=2048,n=1,o=!1,i=0,a=.3){let c=it.buildVertexShaderBase(e,s,i,`
            uniform vec2 covariancesTextureSize;
            uniform highp sampler2D covariancesTexture;
            uniform highp usampler2D covariancesTextureHalfFloat;
            uniform int covariancesAreHalfFloat;

            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {
                vec2 r = unpackHalf2x16(val.r);
                vec2 g = unpackHalf2x16(val.g);
                vec2 b = unpackHalf2x16(val.b);

                first = vec4(r.x, r.y, g.x, g.y);
                second = vec4(b.x, b.y, 0.0, 0.0);
            }
        `);c+=kt.buildVertexShaderProjection(t,s,r,a);const d=kt.buildFragmentShader(),h=it.getUniforms(e,s,i,n,o);return h.covariancesTextureSize={type:"v2",value:new q(1024,1024)},h.covariancesTexture={type:"t",value:null},h.covariancesTextureHalfFloat={type:"t",value:null},h.covariancesAreHalfFloat={type:"i",value:0},new ft({uniforms:h,vertexShader:c,fragmentShader:d,transparent:!0,alphaTest:1,blending:fn,depthTest:!0,depthWrite:!1,side:cs})}static buildVertexShaderProjection(e,s,t,r){let n=`

            vec4 sampledCovarianceA;
            vec4 sampledCovarianceB;
            vec3 cov3D_M11_M12_M13;
            vec3 cov3D_M22_M23_M33;
            if (covariancesAreHalfFloat == 0) {
                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,
                                                                            covariancesTextureSize));
                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),
                                                                            covariancesTextureSize));

                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +
                                    vec3(sampledCovarianceB.gba) * fOddOffset;
            } else {
                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));
                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);
                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;
                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);
            }
        
            // Construct the 3D covariance matrix
            mat3 Vrk = mat3(
                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
            );

            mat3 J;
            if (orthographicMode == 1) {
                // Since the projection is linear, we don't need an approximation
                J = transpose(mat3(orthoZoom, 0.0, 0.0,
                                0.0, orthoZoom, 0.0,
                                0.0, 0.0, 0.0));
            } else {
                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the
                // 3D covariance matrix instead of using the actual projection matrix because that transformation would
                // require a non-linear component (perspective division) which would yield a non-gaussian result.
                float s = 1.0 / (viewCenter.z * viewCenter.z);
                J = mat3(
                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
                    0., 0., 0.
                );
            }

            // Concatenate the projection approximation with the model-view transformation
            mat3 W = transpose(mat3(transformModelViewMatrix));
            mat3 T = W * J;

            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix
            mat3 cov2Dm = transpose(T) * Vrk * T;
            `;return e?n+=`
                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                cov2Dm[0][0] += ${r};
                cov2Dm[1][1] += ${r};
                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));
                if (vColor.a < minAlpha) return;
            `:n+=`
                cov2Dm[0][0] += ${r};
                cov2Dm[1][1] += ${r};
            `,n+=`

            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
            // need cov2Dm[1][0] because it is a symetric matrix.
            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);

            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix
            // so that we can determine the 2D basis for the splat. This is done using the method described
            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat
            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is
            // equal to scaling them by sqrt(8) standard deviations.
            //
            // This is a different approach than in the original work at INRIA. In that work they compute the
            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle
            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0
            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse
            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by
            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity
            float a = cov2Dv.x;
            float d = cov2Dv.z;
            float b = cov2Dv.y;
            float D = a * d - b * b;
            float trace = a + d;
            float traceOver2 = 0.5 * trace;
            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));
            float eigenValue1 = traceOver2 + term2;
            float eigenValue2 = traceOver2 - term2;

            if (pointCloudModeEnabled == 1) {
                eigenValue1 = eigenValue2 = 0.2;
            }

            if (eigenValue2 <= 0.0) return;

            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
            // since the eigen vectors are orthogonal, we derive the second one from the first
            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);

            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.
            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(t)}.0);
            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(t)}.0);
            `,s&&(n+=`
                vColor.a *= splatOpacityFromScene;
            `),n+=`
            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *
                             basisViewport * 2.0 * inverseFocalAdjustment;

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            // Scale the position data we send to the fragment shader
            vPosition *= sqrt8;
        `,n+=it.getVertexShaderFadeIn(),n+="}",n}static buildFragmentShader(){let e=`
            precision highp float;
            #include <common>
 
            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
        `;return e+=`
            void main () {
                // Compute the positional squared distance from the center of the splat to the current fragment.
                float A = dot(vPosition, vPosition);
                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be
                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse
                // defined by the rectangle formed by vPosition. It also means it's farther
                // away than sqrt(8) standard deviations from the mean.
                if (A > 8.0) discard;
                vec3 color = vColor.rgb;

                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of
                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),
                // and since 'mean' is zero, we have X * X, which is the same as A:
                float opacity = exp(-0.5 * A) * vColor.a;

                gl_FragColor = vec4(color.rgb, opacity);
            }
        `,e}}class Lt{static build(e=!1,s=!1,t=1,r=!1,n=0){let i=it.buildVertexShaderBase(e,s,n,`
            uniform vec2 scaleRotationsTextureSize;
            uniform highp sampler2D scaleRotationsTexture;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;
        `);i+=Lt.buildVertexShaderProjection();const a=Lt.buildFragmentShader(),l=it.getUniforms(e,s,n,t,r);return l.scaleRotationsTexture={type:"t",value:null},l.scaleRotationsTextureSize={type:"v2",value:new q(1024,1024)},new ft({uniforms:l,vertexShader:i,fragmentShader:a,transparent:!0,alphaTest:1,blending:fn,depthTest:!0,depthWrite:!1,side:cs})}static buildVertexShaderProjection(){let e=`

            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset, scaleRotationsTextureSize));
            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,
                                                                            oddOffset + uint(1), scaleRotationsTextureSize));

            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;
            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +
                                    vec3(scaleRotationB.gba) * fOddOffset;

            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *
                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);
            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);
            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,
                            0.0, scaleRotation123.g, 0.0,
                            0.0, 0.0, scaleRotation123.b);
            
            mat3 L = R * S;

            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);

            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),
                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),
                                    vec4(0.0, 0.0, 0.0, 1.0));

            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;
            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));
        `;return e+=`

                mat4 splat2World4 = mat4(vec4(L[0], 0.0),
                                        vec4(L[1], 0.0),
                                        vec4(L[2], 0.0),
                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));

                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);

                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);
                tempPoint1 /= tempPoint1.w;

                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);
                tempPoint2 /= tempPoint2.w;

                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);
                center /= center.w;

                vec2 basisVector1 = tempPoint1.xy - center.xy;
                vec2 basisVector2 = tempPoint2.xy - center.xy;

                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;
                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;

                const float minPix = 1.;
                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {
                    
            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);
            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);
            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);

            vec3 tempPoint = vec3(1.0, 1.0, -1.0);
            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);
            vec3 f = (1.0 / distance) * tempPoint;
            if (abs(distance) < 0.00001) return;

            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);
            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);
            vec2 pointImage = vec2(pointImageX, pointImageY);

            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);
            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);
            vec2 temp = vec2(tempX, tempY);

            vec2 halfExtend = pointImage * pointImage - temp;
            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));
            float radius = max(extent.x, extent.y);

            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);

            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
            gl_Position = quadPos;

            vT = T;
            vQuadCenter = pointImage;
            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
        
                } else {
                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;
                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
                    gl_Position = quadPos;

                    vT = T;
                    vQuadCenter = center.xy;
                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;
                }
            `,e+=it.getVertexShaderFadeIn(),e+="}",e}static buildFragmentShader(){return`
            precision highp float;
            #include <common>

            uniform vec3 debugColor;

            varying vec4 vColor;
            varying vec2 vUv;
            varying vec2 vPosition;
            varying mat3 vT;
            varying vec2 vQuadCenter;
            varying vec2 vFragCoord;

            void main () {

                const float FilterInvSquare = 2.0;
                const float near_n = 0.2;
                const float T = 1.0;

                vec2 xy = vQuadCenter;
                vec3 Tu = vT[0];
                vec3 Tv = vT[1];
                vec3 Tw = vT[2];
                vec3 k = vFragCoord.x * Tw - Tu;
                vec3 l = vFragCoord.y * Tw - Tv;
                vec3 p = cross(k, l);
                if (p.z == 0.0) discard;
                vec2 s = vec2(p.x / p.z, p.y / p.z);
                float rho3d = (s.x * s.x + s.y * s.y); 
                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);
                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); 

                // compute intersection and depth
                float rho = min(rho3d, rho2d);
                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; 
                if (depth < near_n) discard;
                //  vec4 nor_o = collected_normal_opacity[j];
                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};
                float opa = vColor.a;

                float power = -0.5f * rho;
                if (power > 0.0f) discard;

                // Eq. (2) from 3D Gaussian splatting paper.
                // Obtain alpha by multiplying with Gaussian opacity
                // and its exponential falloff from mean.
                // Avoid numerical instabilities (see paper appendix). 
                float alpha = min(0.99f, opa * exp(power));
                if (alpha < 1.0f / 255.0f) discard;
                float test_T = T * (1.0 - alpha);
                if (test_T < 0.0001)discard;

                float w = alpha * T;
                gl_FragColor = vec4(vColor.rgb, w);
            }
        `}}class ao{static build(e){const s=new un;s.setIndex([0,1,2,0,2,3]);const t=new Float32Array(12),r=new jn(t,3);s.setAttribute("position",r),r.setXYZ(0,-1,-1,0),r.setXYZ(1,-1,1,0),r.setXYZ(2,1,1,0),r.setXYZ(3,1,-1,0),r.needsUpdate=!0;const n=new Yn().copy(s),o=new Uint32Array(e),i=new Xn(o,1,!1);return i.setUsage(Jn),n.setAttribute("splatIndex",i),n.instanceCount=0,n}}class lo extends nt{constructor(e,s=new D,t=new Ce,r=new D(1,1,1),n=1,o=1,i=!0){super(),this.splatBuffer=e,this.position.copy(s),this.quaternion.copy(t),this.scale.copy(r),this.transform=new ee,this.minimumAlpha=n,this.opacity=o,this.visible=i}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(e){e?(this.matrixWorldAutoUpdate&&this.updateWorldMatrix(!0,!1),this.transform.copy(this.matrixWorld)):(this.matrixAutoUpdate&&this.updateMatrix(),this.transform.copy(this.matrix))}}const Ut=class Ut{constructor(e,s,t,r){this.min=new D().copy(e),this.max=new D().copy(s),this.boundingBox=new ht(this.min,this.max),this.center=new D().copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=t,this.children=[],this.data=null,this.id=r||Ut.idGen++}};P(Ut,"idGen",0);let os=Ut;class gt{constructor(e,s){this.maxDepth=e,this.maxCentersPerNode=s,this.sceneDimensions=new D,this.sceneMin=new D,this.sceneMax=new D,this.rootNode=null,this.nodesWithIndexes=[],this.splatMesh=null}static convertWorkerSubTreeNode(e){const s=new D().fromArray(e.min),t=new D().fromArray(e.max),r=new os(s,t,e.depth,e.id);if(e.data.indexes){r.data={indexes:[]};for(let n of e.data.indexes)r.data.indexes.push(n)}if(e.children)for(let n of e.children)r.children.push(gt.convertWorkerSubTreeNode(n));return r}static convertWorkerSubTree(e,s){const t=new gt(e.maxDepth,e.maxCentersPerNode);t.sceneMin=new D().fromArray(e.sceneMin),t.sceneMax=new D().fromArray(e.sceneMax),t.splatMesh=s,t.rootNode=gt.convertWorkerSubTreeNode(e.rootNode);const r=(n,o)=>{n.children.length===0&&o(n);for(let i of n.children)r(i,o)};return t.nodesWithIndexes=[],r(t.rootNode,n=>{n.data&&n.data.indexes&&n.data.indexes.length>0&&t.nodesWithIndexes.push(n)}),t}}function co(A){let e=0;class s{constructor(a,l){this.min=[a[0],a[1],a[2]],this.max=[l[0],l[1],l[2]]}containsPoint(a){return a[0]>=this.min[0]&&a[0]<=this.max[0]&&a[1]>=this.min[1]&&a[1]<=this.max[1]&&a[2]>=this.min[2]&&a[2]<=this.max[2]}}class t{constructor(a,l){this.maxDepth=a,this.maxCentersPerNode=l,this.sceneDimensions=[],this.sceneMin=[],this.sceneMax=[],this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[],this.splatMesh=null,this.disposed=!1}}class r{constructor(a,l,c,d){this.min=[a[0],a[1],a[2]],this.max=[l[0],l[1],l[2]],this.center=[(l[0]-a[0])*.5+a[0],(l[1]-a[1])*.5+a[1],(l[2]-a[2])*.5+a[2]],this.depth=c,this.children=[],this.data=null,this.id=d||e++}}processSplatTreeNode=function(i,a,l,c){const d=a.data.indexes.length;if(d<i.maxCentersPerNode||a.depth>i.maxDepth){const g=[];for(let x=0;x<a.data.indexes.length;x++)i.addedIndexes[a.data.indexes[x]]||(g.push(a.data.indexes[x]),i.addedIndexes[a.data.indexes[x]]=!0);a.data.indexes=g,a.data.indexes.sort((x,T)=>x>T?1:-1),i.nodesWithIndexes.push(a);return}const h=[a.max[0]-a.min[0],a.max[1]-a.min[1],a.max[2]-a.min[2]],u=[h[0]*.5,h[1]*.5,h[2]*.5],p=[a.min[0]+u[0],a.min[1]+u[1],a.min[2]+u[2]],f=[new s([p[0]-u[0],p[1],p[2]-u[2]],[p[0],p[1]+u[1],p[2]]),new s([p[0],p[1],p[2]-u[2]],[p[0]+u[0],p[1]+u[1],p[2]]),new s([p[0],p[1],p[2]],[p[0]+u[0],p[1]+u[1],p[2]+u[2]]),new s([p[0]-u[0],p[1],p[2]],[p[0],p[1]+u[1],p[2]+u[2]]),new s([p[0]-u[0],p[1]-u[1],p[2]-u[2]],[p[0],p[1],p[2]]),new s([p[0],p[1]-u[1],p[2]-u[2]],[p[0]+u[0],p[1],p[2]]),new s([p[0],p[1]-u[1],p[2]],[p[0]+u[0],p[1],p[2]+u[2]]),new s([p[0]-u[0],p[1]-u[1],p[2]],[p[0],p[1],p[2]+u[2]])],m=[];for(let g=0;g<f.length;g++)m[g]=[];const S=[0,0,0];for(let g=0;g<d;g++){const x=a.data.indexes[g],T=l[x];S[0]=c[T],S[1]=c[T+1],S[2]=c[T+2];for(let C=0;C<f.length;C++)f[C].containsPoint(S)&&m[C].push(x)}for(let g=0;g<f.length;g++){const x=new r(f[g].min,f[g].max,a.depth+1);x.data={indexes:m[g]},a.children.push(x)}a.data={};for(let g of a.children)processSplatTreeNode(i,g,l,c)};const n=(i,a,l)=>{const c=[0,0,0],d=[0,0,0],h=[],u=Math.floor(i.length/4);for(let f=0;f<u;f++){const m=f*4,S=i[m],g=i[m+1],x=i[m+2],T=Math.round(i[m+3]);(f===0||S<c[0])&&(c[0]=S),(f===0||S>d[0])&&(d[0]=S),(f===0||g<c[1])&&(c[1]=g),(f===0||g>d[1])&&(d[1]=g),(f===0||x<c[2])&&(c[2]=x),(f===0||x>d[2])&&(d[2]=x),h.push(T)}const p=new t(a,l);return p.sceneMin=c,p.sceneMax=d,p.rootNode=new r(p.sceneMin,p.sceneMax,0),p.rootNode.data={indexes:h},p};function o(i,a,l){const c=[];for(let h of i){const u=Math.floor(h.length/4);for(let p=0;p<u;p++){const f=p*4,m=Math.round(h[f+3]);c[m]=f}}const d=[];for(let h of i){const u=n(h,a,l);d.push(u),processSplatTreeNode(u,u.rootNode,c,h)}A.postMessage({subTrees:d})}A.onmessage=i=>{i.data.process&&o(i.data.process.centers,i.data.process.maxDepth,i.data.process.maxCentersPerNode)}}function uo(A,e,s,t,r){A.postMessage({process:{centers:e,maxDepth:t,maxCentersPerNode:r}},s)}function ho(){return new Worker(URL.createObjectURL(new Blob(["(",co.toString(),")(self)"],{type:"application/javascript"})))}class po{constructor(e,s){P(this,"processSplatMesh",function(e,s=()=>!0,t,r){this.splatTreeWorker||(this.splatTreeWorker=ho()),this.splatMesh=e,this.subTrees=[];const n=new D,o=(i,a)=>{const l=new Float32Array(a*4);let c=0;for(let d=0;d<a;d++){const h=d+i;if(s(h)){e.getSplatCenter(h,n);const u=c*4;l[u]=n.x,l[u+1]=n.y,l[u+2]=n.z,l[u+3]=h,c++}}return l};return new Promise(i=>{const a=()=>this.disposed?(this.diposeSplatTreeWorker(),i(),!0):!1;t&&t(!1),be(()=>{if(a())return;const l=[];if(e.dynamicMode){let c=0;for(let d=0;d<e.scenes.length;d++){const u=e.getScene(d).splatBuffer.getSplatCount(),p=o(c,u);l.push(p),c+=u}}else{const c=o(0,e.getSplatCount());l.push(c)}this.splatTreeWorker.onmessage=c=>{a()||c.data.subTrees&&(r&&r(!1),be(()=>{if(!a()){for(let d of c.data.subTrees){const h=gt.convertWorkerSubTree(d,e);this.subTrees.push(h)}this.diposeSplatTreeWorker(),r&&r(!0),be(()=>{i()})}}))},be(()=>{if(a())return;t&&t(!0);const c=l.map(d=>d.buffer);uo(this.splatTreeWorker,l,c,this.maxDepth,this.maxCentersPerNode)})})})});this.maxDepth=e,this.maxCentersPerNode=s,this.subTrees=[],this.splatMesh=null}dispose(){this.diposeSplatTreeWorker(),this.disposed=!0}diposeSplatTreeWorker(){this.splatTreeWorker&&this.splatTreeWorker.terminate(),this.splatTreeWorker=null}countLeaves(){let e=0;return this.visitLeaves(()=>{e++}),e}visitLeaves(e){const s=(t,r)=>{t.children.length===0&&r(t);for(let n of t.children)s(n,r)};for(let t of this.subTrees)s(t.rootNode,e)}}function fo(A){const e={};function s(t){if(e[t]!==void 0)return e[t];let r;switch(t){case"WEBGL_depth_texture":r=A.getExtension("WEBGL_depth_texture")||A.getExtension("MOZ_WEBGL_depth_texture")||A.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=A.getExtension("EXT_texture_filter_anisotropic")||A.getExtension("MOZ_EXT_texture_filter_anisotropic")||A.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=A.getExtension("WEBGL_compressed_texture_s3tc")||A.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=A.getExtension("WEBGL_compressed_texture_pvrtc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=A.getExtension(t)}return e[t]=r,r}return{has:function(t){return s(t)!==null},init:function(t){t.isWebGL2?(s("EXT_color_buffer_float"),s("WEBGL_clip_cull_distance")):(s("WEBGL_depth_texture"),s("OES_texture_float"),s("OES_texture_half_float"),s("OES_texture_half_float_linear"),s("OES_standard_derivatives"),s("OES_element_index_uint"),s("OES_vertex_array_object"),s("ANGLE_instanced_arrays")),s("OES_texture_float_linear"),s("EXT_color_buffer_half_float"),s("WEBGL_multisampled_render_to_texture")},get:function(t){const r=s(t);return r===null&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),r}}}function mo(A,e,s){let t;function r(){if(t!==void 0)return t;if(e.has("EXT_texture_filter_anisotropic")===!0){const y=e.get("EXT_texture_filter_anisotropic");t=A.getParameter(y.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else t=0;return t}function n(y){if(y==="highp"){if(A.getShaderPrecisionFormat(A.VERTEX_SHADER,A.HIGH_FLOAT).precision>0&&A.getShaderPrecisionFormat(A.FRAGMENT_SHADER,A.HIGH_FLOAT).precision>0)return"highp";y="mediump"}return y==="mediump"&&A.getShaderPrecisionFormat(A.VERTEX_SHADER,A.MEDIUM_FLOAT).precision>0&&A.getShaderPrecisionFormat(A.FRAGMENT_SHADER,A.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&A.constructor.name==="WebGL2RenderingContext";let i=s.precision!==void 0?s.precision:"highp";const a=n(i);a!==i&&(console.warn("THREE.WebGLRenderer:",i,"not supported, using",a,"instead."),i=a);const l=o||e.has("WEBGL_draw_buffers"),c=s.logarithmicDepthBuffer===!0,d=A.getParameter(A.MAX_TEXTURE_IMAGE_UNITS),h=A.getParameter(A.MAX_VERTEX_TEXTURE_IMAGE_UNITS),u=A.getParameter(A.MAX_TEXTURE_SIZE),p=A.getParameter(A.MAX_CUBE_MAP_TEXTURE_SIZE),f=A.getParameter(A.MAX_VERTEX_ATTRIBS),m=A.getParameter(A.MAX_VERTEX_UNIFORM_VECTORS),S=A.getParameter(A.MAX_VARYING_VECTORS),g=A.getParameter(A.MAX_FRAGMENT_UNIFORM_VECTORS),x=h>0,T=o||e.has("OES_texture_float"),C=x&&T,v=o?A.getParameter(A.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:l,getMaxAnisotropy:r,getMaxPrecision:n,precision:i,logarithmicDepthBuffer:c,maxTextures:d,maxVertexTextures:h,maxTextureSize:u,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:S,maxFragmentUniforms:g,vertexTextures:x,floatFragmentTextures:T,floatVertexTextures:C,maxSamples:v}}const St={Default:0,Instant:2},at={None:0,Info:3},on=new un,Ao=new lt,Rt=6,go=4,So=4,Co=4,yo=6,xo=8,Xt=4,Jt=4,an=1,Io=.012,To=.003,ln=1,cn=16777216;class Ie extends Fe{constructor(s=Ue.ThreeD,t=!1,r=!1,n=!1,o=1,i=!0,a=!1,l=!1,c=1024,d=at.None,h=0,u=1,p=.3){super(on,Ao);P(this,"buildSplatTree",function(s=[],t,r){return new Promise(n=>{this.disposeSplatTree(),this.baseSplatTree=new po(8,1e3);const o=performance.now(),i=new ls;this.baseSplatTree.processSplatMesh(this,a=>{this.getSplatColor(a,i);const l=this.getSceneIndexForSplat(a),c=s[l]||1;return i.w>=c},t,r).then(()=>{const a=performance.now()-o;if(this.logLevel>=at.Info&&console.log("SplatTree build: "+a+" ms"),this.disposed)n();else{this.splatTree=this.baseSplatTree,this.baseSplatTree=null;let l=0,c=0,d=0;this.splatTree.visitLeaves(h=>{const u=h.data.indexes.length;u>0&&(c+=u,d++,l++)}),this.logLevel>=at.Info&&(console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${l}`),c=c/d,console.log(`Avg splat count per node: ${c}`),console.log(`Total splat count: ${this.getSplatCount()}`)),n()}})})});P(this,"updateUniforms",(function(){const s=new q;return function(t,r,n,o,i,a){if(this.getSplatCount()>0){if(s.set(t.x*this.devicePixelRatio,t.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(s),this.material.uniforms.basisViewport.value.set(1/s.x,1/s.y),this.material.uniforms.focal.value.set(r,n),this.material.uniforms.orthographicMode.value=o?1:0,this.material.uniforms.orthoZoom.value=i,this.material.uniforms.inverseFocalAdjustment.value=a,this.dynamicMode)for(let c=0;c<this.scenes.length;c++)this.material.uniforms.transforms.value[c].copy(this.getScene(c).transform);if(this.enableOptionalEffects)for(let c=0;c<this.scenes.length;c++)this.material.uniforms.sceneOpacity.value[c]=ie(this.getScene(c).opacity,0,1),this.material.uniforms.sceneVisibility.value[c]=this.getScene(c).visible?1:0,this.material.uniformsNeedUpdate=!0;this.material.uniformsNeedUpdate=!0}}})());P(this,"setupDistancesComputationTransformFeedback",(function(){let s;return function(){const t=this.getMaxSplatCount();if(!this.renderer)return;const r=this.lastRenderer!==this.renderer,n=s!==t;if(!r&&!n)return;r?this.disposeDistancesComputationGPUResources():n&&this.disposeDistancesComputationGPUBufferResources();const o=this.renderer.getContext(),i=(u,p,f)=>{const m=u.createShader(p);if(!m)return console.error("Fatal error: gl could not create a shader object."),null;if(u.shaderSource(m,f),u.compileShader(m),!u.getShaderParameter(m,u.COMPILE_STATUS)){let g="unknown";p===u.VERTEX_SHADER?g="vertex shader":p===u.FRAGMENT_SHADER&&(g="fragement shader");const x=u.getShaderInfoLog(m);return console.error("Failed to compile "+g+" with these errors:"+x),u.deleteShader(m),null}return m};let a;this.integerBasedDistancesComputation?(a=`#version 300 es
                in ivec4 center;
                flat out int distance;`,this.dynamicMode?a+=`
                        in uint sceneIndex;
                        uniform ivec4 transforms[${G.MaxScenes}];
                        void main(void) {
                            ivec4 transform = transforms[sceneIndex];
                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;
                        }
                    `:a+=`
                        uniform ivec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `):(a=`#version 300 es
                in vec4 center;
                flat out float distance;`,this.dynamicMode?a+=`
                        in uint sceneIndex;
                        uniform mat4 transforms[${G.MaxScenes}];
                        void main(void) {
                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);
                            distance = transformedCenter.z;
                        }
                    `:a+=`
                        uniform vec3 modelViewProj;
                        void main(void) {
                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                        }
                    `);const l=`#version 300 es
                precision lowp float;
                out vec4 fragColor;
                void main(){}
            `,c=o.getParameter(o.VERTEX_ARRAY_BINDING),d=o.getParameter(o.CURRENT_PROGRAM),h=d?o.getProgramParameter(d,o.DELETE_STATUS):!1;if(r&&(this.distancesTransformFeedback.vao=o.createVertexArray()),o.bindVertexArray(this.distancesTransformFeedback.vao),r){const u=o.createProgram(),p=i(o,o.VERTEX_SHADER,a),f=i(o,o.FRAGMENT_SHADER,l);if(!p||!f)throw new Error("Could not compile shaders for distances computation on GPU.");if(o.attachShader(u,p),o.attachShader(u,f),o.transformFeedbackVaryings(u,["distance"],o.SEPARATE_ATTRIBS),o.linkProgram(u),!o.getProgramParameter(u,o.LINK_STATUS)){const S=o.getProgramInfoLog(u);throw console.error("Fatal error: Failed to link program: "+S),o.deleteProgram(u),o.deleteShader(f),o.deleteShader(p),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=u,this.distancesTransformFeedback.vertexShader=p,this.distancesTransformFeedback.vertexShader=f}if(o.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.sceneIndexesLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"sceneIndex");for(let u=0;u<this.scenes.length;u++)this.distancesTransformFeedback.transformsLocs[u]=o.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${u}]`)}else this.distancesTransformFeedback.modelViewProjLoc=o.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(r||n)&&(this.distancesTransformFeedback.centersBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,o.INT,0,0):o.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,o.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.sceneIndexesBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),o.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,o.UNSIGNED_INT,0,0))),(r||n)&&(this.distancesTransformFeedback.outDistancesBuffer=o.createBuffer()),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),o.bufferData(o.ARRAY_BUFFER,t*4,o.STATIC_READ),r&&(this.distancesTransformFeedback.id=o.createTransformFeedback()),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),d&&h!==!0&&o.useProgram(d),c&&o.bindVertexArray(c),this.lastRenderer=this.renderer,s=t}})());P(this,"fillTransformsArray",(function(){const s=[];return function(t){s.length!==t.length&&(s.length=t.length);for(let r=0;r<this.scenes.length;r++){const o=this.getScene(r).transform.elements;for(let i=0;i<16;i++)s[r*16+i]=o[i]}t.set(s)}})());P(this,"computeDistancesOnGPU",(function(){const s=new ee;return function(t,r){if(!this.renderer)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING),i=n.getParameter(n.CURRENT_PROGRAM),a=i?n.getProgramParameter(i,n.DELETE_STATUS):!1;if(n.bindVertexArray(this.distancesTransformFeedback.vao),n.useProgram(this.distancesTransformFeedback.program),n.enable(n.RASTERIZER_DISCARD),this.dynamicMode)for(let d=0;d<this.scenes.length;d++)if(s.copy(this.getScene(d).transform),s.premultiply(t),this.integerBasedDistancesComputation){const h=Ie.getIntegerMatrixArray(s),u=[h[2],h[6],h[10],h[14]];n.uniform4i(this.distancesTransformFeedback.transformsLocs[d],u[0],u[1],u[2],u[3])}else n.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[d],!1,s.elements);else if(this.integerBasedDistancesComputation){const d=Ie.getIntegerMatrixArray(t),h=[d[2],d[6],d[10]];n.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,h[0],h[1],h[2])}else{const d=[t.elements[2],t.elements[6],t.elements[10]];n.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,d[0],d[1],d[2])}n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?n.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,n.INT,0,0):n.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,4,n.FLOAT,!1,0,0),this.dynamicMode&&(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc),n.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc,1,n.UNSIGNED_INT,0,0)),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),n.beginTransformFeedback(n.POINTS),n.drawArrays(n.POINTS,0,this.getSplatCount()),n.endTransformFeedback(),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,null),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null),n.disable(n.RASTERIZER_DISCARD);const l=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush();const c=new Promise(d=>{const h=()=>{if(this.disposed)d();else switch(n.clientWaitSync(l,0,0)){case n.TIMEOUT_EXPIRED:return this.computeDistancesOnGPUSyncTimeout=setTimeout(h),this.computeDistancesOnGPUSyncTimeout;case n.WAIT_FAILED:throw new Error("should never get here");default:this.computeDistancesOnGPUSyncTimeout=null,n.deleteSync(l);const m=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao),n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),n.getBufferSubData(n.ARRAY_BUFFER,0,r),n.bindBuffer(n.ARRAY_BUFFER,null),m&&n.bindVertexArray(m),d()}};this.computeDistancesOnGPUSyncTimeout=setTimeout(h)});return i&&a!==!0&&n.useProgram(i),o&&n.bindVertexArray(o),c}})());P(this,"getSplatCenter",(function(){const s={};return function(t,r,n){this.getLocalSplatParameters(t,s,n),s.splatBuffer.getSplatCenter(s.localIndex,r,s.sceneTransform)}})());P(this,"getSplatScaleAndRotation",(function(){const s={},t=new D;return function(r,n,o,i){this.getLocalSplatParameters(r,s,i),t.x=void 0,t.y=void 0,t.z=void 0,this.splatRenderMode===Ue.TwoD&&(t.z=0),s.splatBuffer.getSplatScaleAndRotation(s.localIndex,n,o,s.sceneTransform,t)}})());P(this,"getSplatColor",(function(){const s={};return function(t,r){this.getLocalSplatParameters(t,s),s.splatBuffer.getSplatColor(s.localIndex,r)}})());this.renderer=void 0,this.splatRenderMode=s,this.dynamicMode=t,this.enableOptionalEffects=r,this.halfPrecisionCovariancesOnGPU=n,this.devicePixelRatio=o,this.enableDistancesComputationOnGPU=i,this.integerBasedDistancesComputation=a,this.antialiased=l,this.kernel2DSize=p,this.maxScreenSpaceSplatSize=c,this.logLevel=d,this.sphericalHarmonicsDegree=h,this.minSphericalHarmonicsDegree=0,this.sceneFadeInRateMultiplier=u,this.scenes=[],this.splatTree=null,this.baseSplatTree=null,this.splatDataTextures={},this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new ht,this.calculatedSceneCenter=new D,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!1,this.lastRenderer=null,this.visible=!1}static buildScenes(s,t,r){const n=[];n.length=t.length;for(let o=0;o<t.length;o++){const i=t[o],a=r[o]||{};let l=a.position||[0,0,0],c=a.rotation||[0,0,0,1],d=a.scale||[1,1,1];const h=new D().fromArray(l),u=new Ce().fromArray(c),p=new D().fromArray(d),f=Ie.createScene(i,h,u,p,a.splatAlphaRemovalThreshold||1,a.opacity,a.visible);s.add(f),n[o]=f}return n}static createScene(s,t,r,n,o,i=1,a=!0){return new lo(s,t,r,n,o,i,a)}static buildSplatIndexMaps(s){const t=[],r=[];let n=0;for(let o=0;o<s.length;o++){const a=s[o].getMaxSplatCount();for(let l=0;l<a;l++)t[n]=l,r[n]=o,n++}return{localSplatIndexMap:t,sceneIndexMap:r}}build(s,t,r=!0,n=!1,o,i,a=!0){this.sceneOptions=t,this.finalBuild=n;const l=Ie.getTotalMaxSplatCountForSplatBuffers(s),c=Ie.buildScenes(this,s,t);if(r)for(let m=0;m<this.scenes.length&&m<c.length;m++){const S=c[m],g=this.getScene(m);S.copyTransformData(g)}this.scenes=c;let d=3;for(let m of s){const S=m.getMinSphericalHarmonicsDegree();S<d&&(d=S)}this.minSphericalHarmonicsDegree=Math.min(d,this.sphericalHarmonicsDegree);let h=!1;if(s.length!==this.lastBuildScenes.length)h=!0;else for(let m=0;m<s.length;m++)if(s[m]!==this.lastBuildScenes[m].splatBuffer){h=!0;break}let u=!0;if((this.scenes.length!==1||this.lastBuildSceneCount!==this.scenes.length||this.lastBuildMaxSplatCount!==l||h)&&(u=!1),!u){this.boundingBox=new ht,a||(this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.firstRenderTime=-1),this.lastBuildScenes=[],this.lastBuildSplatCount=0,this.lastBuildMaxSplatCount=0,this.disposeMeshData(),this.geometry=ao.build(l),this.splatRenderMode===Ue.ThreeD?this.material=kt.build(this.dynamicMode,this.enableOptionalEffects,this.antialiased,this.maxScreenSpaceSplatSize,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree,this.kernel2DSize):this.material=Lt.build(this.dynamicMode,this.enableOptionalEffects,this.splatScale,this.pointCloudModeEnabled,this.minSphericalHarmonicsDegree);const m=Ie.buildSplatIndexMaps(s);this.globalSplatIndexToLocalSplatIndexMap=m.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=m.sceneIndexMap}const p=this.getSplatCount(!0);this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback();const f=this.refreshGPUDataFromSplatBuffers(u);for(let m=0;m<this.scenes.length;m++)this.lastBuildScenes[m]=this.scenes[m];return this.lastBuildSplatCount=p,this.lastBuildMaxSplatCount=this.getMaxSplatCount(),this.lastBuildSceneCount=this.scenes.length,n&&this.scenes.length>0&&this.buildSplatTree(t.map(m=>m.splatAlphaRemovalThreshold||1),o,i).then(()=>{this.onSplatTreeReadyCallback&&this.onSplatTreeReadyCallback(this.splatTree),this.onSplatTreeReadyCallback=null}),this.visible=this.scenes.length>0,f}freeIntermediateSplatData(){const s=t=>{delete t.source.data,delete t.image,t.onUpdate=null};delete this.splatDataTextures.baseData.covariances,delete this.splatDataTextures.baseData.centers,delete this.splatDataTextures.baseData.colors,delete this.splatDataTextures.baseData.sphericalHarmonics,delete this.splatDataTextures.centerColors.data,delete this.splatDataTextures.covariances.data,this.splatDataTextures.sphericalHarmonics&&delete this.splatDataTextures.sphericalHarmonics.data,this.splatDataTextures.sceneIndexes&&delete this.splatDataTextures.sceneIndexes.data,this.splatDataTextures.centerColors.texture.needsUpdate=!0,this.splatDataTextures.centerColors.texture.onUpdate=()=>{s(this.splatDataTextures.centerColors.texture)},this.splatDataTextures.covariances.texture.needsUpdate=!0,this.splatDataTextures.covariances.texture.onUpdate=()=>{s(this.splatDataTextures.covariances.texture)},this.splatDataTextures.sphericalHarmonics&&(this.splatDataTextures.sphericalHarmonics.texture?(this.splatDataTextures.sphericalHarmonics.texture.needsUpdate=!0,this.splatDataTextures.sphericalHarmonics.texture.onUpdate=()=>{s(this.splatDataTextures.sphericalHarmonics.texture)}):this.splatDataTextures.sphericalHarmonics.textures.forEach(t=>{t.needsUpdate=!0,t.onUpdate=()=>{s(t)}})),this.splatDataTextures.sceneIndexes&&(this.splatDataTextures.sceneIndexes.texture.needsUpdate=!0,this.splatDataTextures.sceneIndexes.texture.onUpdate=()=>{s(this.splatDataTextures.sceneIndexes.texture)})}dispose(){this.disposeMeshData(),this.disposeTextures(),this.disposeSplatTree(),this.enableDistancesComputationOnGPU&&(this.computeDistancesOnGPUSyncTimeout&&(clearTimeout(this.computeDistancesOnGPUSyncTimeout),this.computeDistancesOnGPUSyncTimeout=null),this.disposeDistancesComputationGPUResources()),this.scenes=[],this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,sceneIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,sceneIndexesLoc:-1,transformsLocs:[]},this.renderer=null,this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[],this.lastBuildSplatCount=0,this.lastBuildScenes=[],this.lastBuildMaxSplatCount=0,this.lastBuildSceneCount=0,this.firstRenderTime=-1,this.finalBuild=!1,this.webGLUtils=null,this.boundingBox=new ht,this.calculatedSceneCenter=new D,this.maxSplatDistanceFromSceneCenter=0,this.visibleRegionBufferRadius=0,this.visibleRegionRadius=0,this.visibleRegionFadeStartRadius=0,this.visibleRegionChanging=!1,this.splatScale=1,this.pointCloudModeEnabled=!1,this.disposed=!0,this.lastRenderer=null,this.visible=!1}disposeMeshData(){this.geometry&&this.geometry!==on&&(this.geometry.dispose(),this.geometry=null),this.material&&(this.material.dispose(),this.material=null)}disposeTextures(){for(let s in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(s)){const t=this.splatDataTextures[s];t.texture&&(t.texture.dispose(),t.texture=null)}this.splatDataTextures=null}disposeSplatTree(){this.splatTree&&(this.splatTree.dispose(),this.splatTree=null),this.baseSplatTree&&(this.baseSplatTree.dispose(),this.baseSplatTree=null)}getSplatTree(){return this.splatTree}onSplatTreeReady(s){this.onSplatTreeReadyCallback=s}getDataForDistancesComputation(s,t){const r=this.integerBasedDistancesComputation?this.getIntegerCenters(s,t,!0):this.getFloatCenters(s,t,!0),n=this.getSceneIndexes(s,t);return{centers:r,sceneIndexes:n}}refreshGPUDataFromSplatBuffers(s){const t=this.getSplatCount(!0);this.refreshDataTexturesFromSplatBuffers(s);const r=s?this.lastBuildSplatCount:0,{centers:n,sceneIndexes:o}=this.getDataForDistancesComputation(r,t-1);return this.enableDistancesComputationOnGPU&&this.refreshGPUBuffersForDistancesComputation(n,o,s),{from:r,to:t-1,count:t-r,centers:n,sceneIndexes:o}}refreshGPUBuffersForDistancesComputation(s,t,r=!1){const n=r?this.lastBuildSplatCount:0;this.updateGPUCentersBufferForDistancesComputation(r,s,n),this.updateGPUTransformIndexesBufferForDistancesComputation(r,t,n)}refreshDataTexturesFromSplatBuffers(s){const t=this.getSplatCount(!0),r=this.lastBuildSplatCount,n=t-1;s?this.updateBaseDataFromSplatBuffers(r,n):(this.setupDataTextures(),this.updateBaseDataFromSplatBuffers()),this.updateDataTexturesFromBaseData(r,n),this.updateVisibleRegion(s)}setupDataTextures(){const s=this.getMaxSplatCount(),t=this.getSplatCount(!0);this.disposeTextures();const r=(B,F)=>{const w=new q(4096,1024);for(;w.x*w.y*B<s*F;)w.y*=2;return w},n=B=>B>=1?yo:So,o=B=>{const F=n(B),w=r(F,6);return{elementsPerTexelStored:F,texSize:w}};let i=this.getTargetCovarianceCompressionLevel();const a=0,l=this.getTargetSphericalHarmonicsCompressionLevel();let c,d,h;if(this.splatRenderMode===Ue.ThreeD){const B=o(i);B.texSize.x*B.texSize.y>cn&&i===0&&(i=1),c=new Float32Array(s*Rt)}else d=new Float32Array(s*3),h=new Float32Array(s*4);const u=new Float32Array(s*3),p=new Uint8Array(s*4);let f=Float32Array;l===1?f=Uint16Array:l===2&&(f=Uint8Array);const m=ot(this.minSphericalHarmonicsDegree),S=this.minSphericalHarmonicsDegree?new f(s*m):void 0,g=r(Jt,4),x=new Uint32Array(g.x*g.y*Jt);Ie.updateCenterColorsPaddedData(0,t-1,u,p,x);const T=new Ve(x,g.x,g.y,Nt,pt);if(T.internalFormat="RGBA32UI",T.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=T,this.material.uniforms.centersColorsTextureSize.value.copy(g),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={baseData:{covariances:c,scales:d,rotations:h,centers:u,colors:p,sphericalHarmonics:S},centerColors:{data:x,texture:T,size:g}},this.splatRenderMode===Ue.ThreeD){const B=o(i),F=B.elementsPerTexelStored,w=B.texSize;let M=i>=1?Uint32Array:Float32Array;const O=i>=1?xo:Co,R=new M(w.x*w.y*O);i===0?R.set(c):Ie.updatePaddedCompressedCovariancesTextureData(c,R,0,0,c.length);let b;if(i>=1)b=new Ve(R,w.x,w.y,Nt,pt),b.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=b;else{b=new Ve(R,w.x,w.y,Mt,Fs),this.material.uniforms.covariancesTexture.value=b;const k=new Ve(new Uint32Array(32),2,2,Nt,pt);k.internalFormat="RGBA32UI",this.material.uniforms.covariancesTextureHalfFloat.value=k,k.needsUpdate=!0}b.needsUpdate=!0,this.material.uniforms.covariancesAreHalfFloat.value=i>=1?1:0,this.material.uniforms.covariancesTextureSize.value.copy(w),this.splatDataTextures.covariances={data:R,texture:b,size:w,compressionLevel:i,elementsPerTexelStored:F,elementsPerTexelAllocated:O}}else{const F=r(Xt,6);let w=Float32Array,M=Fs;const O=new w(F.x*F.y*Xt);Ie.updateScaleRotationsPaddedData(0,t-1,d,h,O);const R=new Ve(O,F.x,F.y,Mt,M);R.needsUpdate=!0,this.material.uniforms.scaleRotationsTexture.value=R,this.material.uniforms.scaleRotationsTextureSize.value.copy(F),this.splatDataTextures.scaleRotations={data:O,texture:R,size:F,compressionLevel:a}}if(S){const B=l===2?Hn:Un;let F=m;F%2!==0&&F++;const w=4,M=Mt;let O=r(w,F);if(O.x*O.y<=cn){const R=O.x*O.y*w,b=new f(R);for(let H=0;H<t;H++){const Q=m*H,N=F*H;for(let U=0;U<m;U++)b[N+U]=S[Q+U]}const k=new Ve(b,O.x,O.y,M,B);k.needsUpdate=!0,this.material.uniforms.sphericalHarmonicsTexture.value=k,this.splatDataTextures.sphericalHarmonics={componentCount:m,paddedComponentCount:F,data:b,textureCount:1,texture:k,size:O,compressionLevel:l,elementsPerTexel:w}}else{const R=m/3;F=R,F%2!==0&&F++,O=r(w,F);const b=O.x*O.y*w,k=[this.material.uniforms.sphericalHarmonicsTextureR,this.material.uniforms.sphericalHarmonicsTextureG,this.material.uniforms.sphericalHarmonicsTextureB],H=[],Q=[];for(let N=0;N<3;N++){const U=new f(b);H.push(U);for(let J=0;J<t;J++){const ce=m*J,Z=F*J;if(R>=3){for(let W=0;W<3;W++)U[Z+W]=S[ce+N*3+W];if(R>=8)for(let W=0;W<5;W++)U[Z+3+W]=S[ce+9+N*5+W]}}const V=new Ve(U,O.x,O.y,M,B);Q.push(V),V.needsUpdate=!0,k[N].value=V}this.material.uniforms.sphericalHarmonicsMultiTextureMode.value=1,this.splatDataTextures.sphericalHarmonics={componentCount:m,componentCountPerChannel:R,paddedComponentCount:F,data:H,textureCount:3,textures:Q,size:O,compressionLevel:l,elementsPerTexel:w}}this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(O),this.material.uniforms.sphericalHarmonics8BitMode.value=l===2?1:0;for(let R=0;R<this.scenes.length;R++){const b=this.scenes[R].splatBuffer;this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[R]=b.minSphericalHarmonicsCoeff,this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[R]=b.maxSphericalHarmonicsCoeff}this.material.uniformsNeedUpdate=!0}const C=r(an,4),v=new Uint32Array(C.x*C.y*an);for(let B=0;B<t;B++)v[B]=this.globalSplatIndexToSceneIndexMap[B];const y=new Ve(v,C.x,C.y,zn,pt);y.internalFormat="R32UI",y.needsUpdate=!0,this.material.uniforms.sceneIndexesTexture.value=y,this.material.uniforms.sceneIndexesTextureSize.value.copy(C),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.sceneIndexes={data:v,texture:y,size:C},this.material.uniforms.sceneCount.value=this.scenes.length}updateBaseDataFromSplatBuffers(s,t){const r=this.splatDataTextures.covariances,n=r?r.compressionLevel:void 0,o=this.splatDataTextures.scaleRotations,i=o?o.compressionLevel:void 0,a=this.splatDataTextures.sphericalHarmonics,l=a?a.compressionLevel:0;this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,this.splatDataTextures.baseData.sphericalHarmonics,void 0,n,i,l,s,t,s)}updateDataTexturesFromBaseData(s,t){const r=this.splatDataTextures.covariances,n=r?r.compressionLevel:void 0,o=this.splatDataTextures.scaleRotations,i=o?o.compressionLevel:void 0,a=this.splatDataTextures.sphericalHarmonics,l=a?a.compressionLevel:0,c=this.splatDataTextures.centerColors,d=c.data,h=c.texture;Ie.updateCenterColorsPaddedData(s,t,this.splatDataTextures.baseData.centers,this.splatDataTextures.baseData.colors,d);const u=this.renderer?this.renderer.properties.get(h):null;if(!u||!u.__webglTexture?h.needsUpdate=!0:this.updateDataTexture(d,c.texture,c.size,u,Jt,go,4,s,t),r){const x=r.texture,T=s*Rt,C=t*Rt;if(n===0)for(let y=T;y<=C;y++){const B=this.splatDataTextures.baseData.covariances[y];r.data[y]=B}else Ie.updatePaddedCompressedCovariancesTextureData(this.splatDataTextures.baseData.covariances,r.data,s*r.elementsPerTexelAllocated,T,C);const v=this.renderer?this.renderer.properties.get(x):null;!v||!v.__webglTexture?x.needsUpdate=!0:n===0?this.updateDataTexture(r.data,r.texture,r.size,v,r.elementsPerTexelStored,Rt,4,s,t):this.updateDataTexture(r.data,r.texture,r.size,v,r.elementsPerTexelAllocated,r.elementsPerTexelAllocated,2,s,t)}if(o){const x=o.data,T=o.texture,C=6,v=i===0?4:2;Ie.updateScaleRotationsPaddedData(s,t,this.splatDataTextures.baseData.scales,this.splatDataTextures.baseData.rotations,x);const y=this.renderer?this.renderer.properties.get(T):null;!y||!y.__webglTexture?T.needsUpdate=!0:this.updateDataTexture(x,o.texture,o.size,y,Xt,C,v,s,t)}const p=this.splatDataTextures.baseData.sphericalHarmonics;if(p){let x=4;l===1?x=2:l===2&&(x=1);const T=(y,B,F,w,M)=>{const O=this.renderer?this.renderer.properties.get(y):null;!O||!O.__webglTexture?y.needsUpdate=!0:this.updateDataTexture(w,y,B,O,F,M,x,s,t)},C=a.componentCount,v=a.paddedComponentCount;if(a.textureCount===1){const y=a.data;for(let B=s;B<=t;B++){const F=C*B,w=v*B;for(let M=0;M<C;M++)y[w+M]=p[F+M]}T(a.texture,a.size,a.elementsPerTexel,y,v)}else{const y=a.componentCountPerChannel;for(let B=0;B<3;B++){const F=a.data[B];for(let w=s;w<=t;w++){const M=C*w,O=v*w;if(y>=3){for(let R=0;R<3;R++)F[O+R]=p[M+B*3+R];if(y>=8)for(let R=0;R<5;R++)F[O+3+R]=p[M+9+B*5+R]}}T(a.textures[B],a.size,a.elementsPerTexel,F,v)}}}const f=this.splatDataTextures.sceneIndexes,m=f.data;for(let x=this.lastBuildSplatCount;x<=t;x++)m[x]=this.globalSplatIndexToSceneIndexMap[x];const S=f.texture,g=this.renderer?this.renderer.properties.get(S):null;!g||!g.__webglTexture?S.needsUpdate=!0:this.updateDataTexture(m,f.texture,f.size,g,1,1,1,this.lastBuildSplatCount,t)}getTargetCovarianceCompressionLevel(){return this.halfPrecisionCovariancesOnGPU?1:0}getTargetSphericalHarmonicsCompressionLevel(){return Math.max(1,this.getMaximumSplatBufferCompressionLevel())}getMaximumSplatBufferCompressionLevel(){let s;for(let t=0;t<this.scenes.length;t++){const n=this.getScene(t).splatBuffer;(t===0||n.compressionLevel>s)&&(s=n.compressionLevel)}return s}getMinimumSplatBufferCompressionLevel(){let s;for(let t=0;t<this.scenes.length;t++){const n=this.getScene(t).splatBuffer;(t===0||n.compressionLevel<s)&&(s=n.compressionLevel)}return s}static computeTextureUpdateRegion(s,t,r,n,o){const i=o/n,a=s*i,l=Math.floor(a/r),c=l*r*n,d=t*i,h=Math.floor(d/r),u=h*r*n+r*n;return{dataStart:c,dataEnd:u,startRow:l,endRow:h}}updateDataTexture(s,t,r,n,o,i,a,l,c){const d=this.renderer.getContext(),h=Ie.computeTextureUpdateRegion(l,c,r.x,o,i),u=h.dataEnd-h.dataStart,p=new s.constructor(s.buffer,h.dataStart*a,u),f=h.endRow-h.startRow+1,m=this.webGLUtils.convert(t.type),S=this.webGLUtils.convert(t.format,t.colorSpace),g=d.getParameter(d.TEXTURE_BINDING_2D);d.bindTexture(d.TEXTURE_2D,n.__webglTexture),d.texSubImage2D(d.TEXTURE_2D,0,0,h.startRow,r.x,f,S,m,p),d.bindTexture(d.TEXTURE_2D,g)}static updatePaddedCompressedCovariancesTextureData(s,t,r,n,o){let i=new DataView(t.buffer),a=r,l=0;for(let c=n;c<=o;c+=2)i.setUint16(a*2,s[c],!0),i.setUint16(a*2+2,s[c+1],!0),a+=2,l++,l>=3&&(a+=2,l=0)}static updateCenterColorsPaddedData(s,t,r,n,o){for(let i=s;i<=t;i++){const a=i*4,l=i*3,c=i*4;o[c]=$n(n,a),o[c+1]=Vt(r[l]),o[c+2]=Vt(r[l+1]),o[c+3]=Vt(r[l+2])}}static updateScaleRotationsPaddedData(s,t,r,n,o){for(let a=s;a<=t;a++){const l=a*3,c=a*4,d=a*6;o[d]=r[l],o[d+1]=r[l+1],o[d+2]=r[l+2],o[d+3]=n[c],o[d+4]=n[c+1],o[d+5]=n[c+2]}}updateVisibleRegion(s){const t=this.getSplatCount(!0),r=new D;if(!s){const o=new D;this.scenes.forEach(i=>{o.add(i.splatBuffer.sceneCenter)}),o.multiplyScalar(1/this.scenes.length),this.calculatedSceneCenter.copy(o),this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter),this.material.uniformsNeedUpdate=!0}const n=s?this.lastBuildSplatCount:0;for(let o=n;o<t;o++){this.getSplatCenter(o,r,!0);const i=r.sub(this.calculatedSceneCenter).length();i>this.maxSplatDistanceFromSceneCenter&&(this.maxSplatDistanceFromSceneCenter=i)}this.maxSplatDistanceFromSceneCenter-this.visibleRegionBufferRadius>ln&&(this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter,this.visibleRegionRadius=Math.max(this.visibleRegionBufferRadius-ln,0)),this.finalBuild&&(this.visibleRegionRadius=this.visibleRegionBufferRadius=this.maxSplatDistanceFromSceneCenter),this.updateVisibleRegionFadeDistance()}updateVisibleRegionFadeDistance(s=St.Default){const t=Io*this.sceneFadeInRateMultiplier,r=To*this.sceneFadeInRateMultiplier,n=this.finalBuild?t:r,o=s===St.Default?n:r;this.visibleRegionFadeStartRadius=(this.visibleRegionRadius-this.visibleRegionFadeStartRadius)*o+this.visibleRegionFadeStartRadius;const a=(this.visibleRegionBufferRadius>0?this.visibleRegionFadeStartRadius/this.visibleRegionBufferRadius:0)>.99,l=a||s===St.Instant?1:0;this.material.uniforms.visibleRegionFadeStartRadius.value=this.visibleRegionFadeStartRadius,this.material.uniforms.visibleRegionRadius.value=this.visibleRegionRadius,this.material.uniforms.firstRenderTime.value=this.firstRenderTime,this.material.uniforms.currentTime.value=performance.now(),this.material.uniforms.fadeInComplete.value=l,this.material.uniformsNeedUpdate=!0,this.visibleRegionChanging=!a}updateRenderIndexes(s,t){const r=this.geometry;r.attributes.splatIndex.set(s),r.attributes.splatIndex.needsUpdate=!0,t>0&&this.firstRenderTime===-1&&(this.firstRenderTime=performance.now()),r.instanceCount=t,r.setDrawRange(0,t)}updateTransforms(){for(let s=0;s<this.scenes.length;s++)this.getScene(s).updateTransform(this.dynamicMode)}setSplatScale(s=1){this.splatScale=s,this.material.uniforms.splatScale.value=s,this.material.uniformsNeedUpdate=!0}getSplatScale(){return this.splatScale}setPointCloudModeEnabled(s){this.pointCloudModeEnabled=s,this.material.uniforms.pointCloudModeEnabled.value=s?1:0,this.material.uniformsNeedUpdate=!0}getPointCloudModeEnabled(){return this.pointCloudModeEnabled}getSplatDataTextures(){return this.splatDataTextures}getSplatCount(s=!1){return s?Ie.getTotalSplatCountForScenes(this.scenes):this.lastBuildSplatCount}static getTotalSplatCountForScenes(s){let t=0;for(let r of s)r&&r.splatBuffer&&(t+=r.splatBuffer.getSplatCount());return t}static getTotalSplatCountForSplatBuffers(s){let t=0;for(let r of s)t+=r.getSplatCount();return t}getMaxSplatCount(){return Ie.getTotalMaxSplatCountForScenes(this.scenes)}static getTotalMaxSplatCountForScenes(s){let t=0;for(let r of s)r&&r.splatBuffer&&(t+=r.splatBuffer.getMaxSplatCount());return t}static getTotalMaxSplatCountForSplatBuffers(s){let t=0;for(let r of s)t+=r.getMaxSplatCount();return t}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const s=this.renderer.getContext();this.distancesTransformFeedback.vao&&(s.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(s.deleteProgram(this.distancesTransformFeedback.program),s.deleteShader(this.distancesTransformFeedback.vertexShader),s.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(s.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const s=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,s.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(s.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(s){if(s!==this.renderer){this.renderer=s;const t=this.renderer.getContext(),r=new fo(t),n=new mo(t,r,{});if(r.init(n),this.webGLUtils=new Qn(t,r),this.enableDistancesComputationOnGPU&&this.getSplatCount()>0){this.setupDistancesComputationTransformFeedback();const{centers:o,sceneIndexes:i}=this.getDataForDistancesComputation(0,this.getSplatCount()-1);this.refreshGPUBuffersForDistancesComputation(o,i)}}}updateGPUCentersBufferForDistancesComputation(s,t,r){if(!this.renderer)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=this.integerBasedDistancesComputation?Uint32Array:Float32Array,a=16,l=r*a;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),s)n.bufferSubData(n.ARRAY_BUFFER,l,t);else{const c=new i(this.getMaxSplatCount()*a);c.set(t),n.bufferData(n.ARRAY_BUFFER,c,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),o&&n.bindVertexArray(o)}updateGPUTransformIndexesBufferForDistancesComputation(s,t,r){if(!this.renderer||!this.dynamicMode)return;const n=this.renderer.getContext(),o=n.getParameter(n.VERTEX_ARRAY_BINDING);n.bindVertexArray(this.distancesTransformFeedback.vao);const i=r*4;if(n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.sceneIndexesBuffer),s)n.bufferSubData(n.ARRAY_BUFFER,i,t);else{const a=new Uint32Array(this.getMaxSplatCount()*4);a.set(t),n.bufferData(n.ARRAY_BUFFER,a,n.STATIC_DRAW)}n.bindBuffer(n.ARRAY_BUFFER,null),o&&n.bindVertexArray(o)}getSceneIndexes(s,t){let r;const n=t-s+1;r=new Uint32Array(n);for(let o=s;o<=t;o++)r[o]=this.globalSplatIndexToSceneIndexMap[o];return r}getLocalSplatParameters(s,t,r){r==null&&(r=!this.dynamicMode),t.splatBuffer=this.getSplatBufferForSplat(s),t.localIndex=this.getSplatLocalIndex(s),t.sceneTransform=r?this.getSceneTransformForSplat(s):null}fillSplatDataArrays(s,t,r,n,o,i,a,l=0,c=0,d=1,h,u,p=0,f){const m=new D;m.x=void 0,m.y=void 0,this.splatRenderMode===Ue.ThreeD?m.z=void 0:m.z=1;const S=new ee;let g=0,x=this.scenes.length-1;f!=null&&f>=0&&f<=this.scenes.length&&(g=f,x=f);for(let T=g;T<=x;T++){a==null&&(a=!this.dynamicMode);const C=this.getScene(T),v=C.splatBuffer;let y;if(a&&(this.getSceneTransform(T,S),y=S),s&&v.fillSplatCovarianceArray(s,y,h,u,p,l),t||r){if(!t||!r)throw new Error('SplatMesh::fillSplatDataArrays() -> "scales" and "rotations" must both be valid.');v.fillSplatScaleRotationArray(t,r,y,h,u,p,c,m)}n&&v.fillSplatCenterArray(n,y,h,u,p),o&&v.fillSplatColorArray(o,C.minimumAlpha,h,u,p),i&&v.fillSphericalHarmonicsArray(i,this.minSphericalHarmonicsDegree,y,h,u,p,d),p+=v.getSplatCount()}}getIntegerCenters(s,t,r=!1){const n=t-s+1,o=new Float32Array(n*3);this.fillSplatDataArrays(null,null,null,o,null,null,void 0,void 0,void 0,void 0,s);let i,a=r?4:3;i=new Int32Array(n*a);for(let l=0;l<n;l++){for(let c=0;c<3;c++)i[l*a+c]=Math.round(o[l*3+c]*1e3);r&&(i[l*a+3]=1e3)}return i}getFloatCenters(s,t,r=!1){const n=t-s+1,o=new Float32Array(n*3);if(this.fillSplatDataArrays(null,null,null,o,null,null,void 0,void 0,void 0,void 0,s),!r)return o;let i=new Float32Array(n*4);for(let a=0;a<n;a++){for(let l=0;l<3;l++)i[a*4+l]=o[a*3+l];i[a*4+3]=1}return i}getSceneTransform(s,t){const r=this.getScene(s);r.updateTransform(this.dynamicMode),t.copy(r.transform)}getScene(s){if(s<0||s>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[s]}getSceneCount(){return this.scenes.length}getSplatBufferForSplat(s){return this.getScene(this.globalSplatIndexToSceneIndexMap[s]).splatBuffer}getSceneIndexForSplat(s){return this.globalSplatIndexToSceneIndexMap[s]}getSceneTransformForSplat(s){return this.getScene(this.globalSplatIndexToSceneIndexMap[s]).transform}getSplatLocalIndex(s){return this.globalSplatIndexToLocalSplatIndexMap[s]}static getIntegerMatrixArray(s){const t=s.elements,r=[];for(let n=0;n<16;n++)r[n]=Math.round(t[n]*1e3);return r}computeBoundingBox(s=!1,t){let r=this.getSplatCount();if(t!=null){if(t<0||t>=this.scenes.length)throw new Error("SplatMesh::computeBoundingBox() -> Invalid scene index.");r=this.scenes[t].splatBuffer.getSplatCount()}const n=new Float32Array(r*3);this.fillSplatDataArrays(null,null,null,n,null,null,s,void 0,void 0,void 0,void 0,t);const o=new D,i=new D;for(let a=0;a<r;a++){const l=a*3,c=n[l],d=n[l+1],h=n[l+2];(a===0||c<o.x)&&(o.x=c),(a===0||d<o.y)&&(o.y=d),(a===0||h<o.z)&&(o.z=h),(a===0||c>i.x)&&(i.x=c),(a===0||d>i.y)&&(i.y=d),(a===0||h>i.z)&&(i.z=h)}return new ht(o,i)}}var Bo="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",dn="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",vo="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",Eo="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";function wo(A){let e,s,t,r,n,o,i,a,l,c,d,h,u,p,f,m,S,g,x,T;function C(v,y,B,F,w,M,O){const R=performance.now();if(!t&&(new Uint32Array(s,i,w.byteLength/T.BytesPerInt).set(w),new Float32Array(s,c,O.byteLength/T.BytesPerFloat).set(O),F)){let N;r?N=new Int32Array(s,d,M.byteLength/T.BytesPerInt):N=new Float32Array(s,d,M.byteLength/T.BytesPerFloat),N.set(M)}m||(m=new Uint32Array(g)),new Float32Array(s,f,16).set(B),new Uint32Array(s,u,g).set(m),e.exports.sortIndexes(i,p,d,h,u,f,a,l,c,g,v,y,o,F,r,n);const b={sortDone:!0,splatSortCount:v,splatRenderCount:y,sortTime:0};if(!t){const H=new Uint32Array(s,a,y);(!S||S.length<y)&&(S=new Uint32Array(y)),S.set(H),b.sortedIndexes=S}const k=performance.now();b.sortTime=k-R,A.postMessage(b)}A.onmessage=v=>{if(v.data.centers)centers=v.data.centers,sceneIndexes=v.data.sceneIndexes,r?new Int32Array(s,p+v.data.range.from*T.BytesPerInt*4,v.data.range.count*4).set(new Int32Array(centers)):new Float32Array(s,p+v.data.range.from*T.BytesPerFloat*4,v.data.range.count*4).set(new Float32Array(centers)),n&&new Uint32Array(s,l+v.data.range.from*4,v.data.range.count).set(new Uint32Array(sceneIndexes)),x=v.data.range.from+v.data.range.count;else if(v.data.sort){const y=Math.min(v.data.sort.splatRenderCount||0,x),B=Math.min(v.data.sort.splatSortCount||0,x),F=v.data.sort.usePrecomputedDistances;let w,M,O;t||(w=v.data.sort.indexesToSort,O=v.data.sort.transforms,F&&(M=v.data.sort.precomputedDistances)),C(B,y,v.data.sort.modelViewProj,F,w,M,O)}else if(v.data.init){T=v.data.init.Constants,o=v.data.init.splatCount,t=v.data.init.useSharedMemory,r=v.data.init.integerBasedSort,n=v.data.init.dynamicMode,g=v.data.init.distanceMapRange,x=0;const y=r?T.BytesPerInt*4:T.BytesPerFloat*4,B=new Uint8Array(v.data.init.sorterWasmBytes),F=16*T.BytesPerFloat,w=o*T.BytesPerInt,M=o*y,O=F,R=r?o*T.BytesPerInt:o*T.BytesPerFloat,b=o*T.BytesPerInt,k=o*T.BytesPerInt,H=r?g*T.BytesPerInt*2:g*T.BytesPerFloat*2,Q=n?o*T.BytesPerInt:0,N=n?T.MaxScenes*F:0,U=T.MemoryPageSize*32,V=w+M+O+R+b+H+k+Q+N+U,J=Math.floor(V/T.MemoryPageSize)+1,ce={module:{},env:{memory:new WebAssembly.Memory({initial:J,maximum:J,shared:!0})}};WebAssembly.compile(B).then(Z=>WebAssembly.instantiate(Z,ce)).then(Z=>{e=Z,i=0,p=i+w,f=p+M,d=f+O,h=d+R,u=h+b,a=u+H,l=a+k,c=l+Q,s=ce.env.memory.buffer,t?A.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:s,indexesToSortOffset:i,sortedIndexesBuffer:s,sortedIndexesOffset:a,precomputedDistancesBuffer:s,precomputedDistancesOffset:d,transformsBuffer:s,transformsOffset:c}):A.postMessage({sortSetupPhase1Complete:!0})})}}}function Do(A,e,s,t,r,n=G.DefaultSplatSortDistanceMapPrecision){const o=new Worker(URL.createObjectURL(new Blob(["(",wo.toString(),")(self)"],{type:"application/javascript"})));let i=Bo;const a=us()?An():null;!s&&!e?(i=dn,a&&a.major<=16&&a.minor<4&&(i=Eo)):s?e||a&&a.major<=16&&a.minor<4&&(i=vo):i=dn;const l=atob(i),c=new Uint8Array(l.length);for(let d=0;d<l.length;d++)c[d]=l.charCodeAt(d);return o.postMessage({init:{sorterWasmBytes:c.buffer,splatCount:A,useSharedMemory:e,integerBasedSort:t,dynamicMode:r,distanceMapRange:1<<n,Constants:{BytesPerFloat:G.BytesPerFloat,BytesPerInt:G.BytesPerInt,MemoryPageSize:G.MemoryPageSize,MaxScenes:G.MaxScenes}}}),o}const tt={None:0,VR:1,AR:2};class ct{static createButton(e,s={}){const t=document.createElement("button");function r(){let l=null;async function c(u){u.addEventListener("end",d),await e.xr.setSession(u),t.textContent="EXIT VR",l=u}function d(){l.removeEventListener("end",d),t.textContent="ENTER VR",l=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR";const h={...s,optionalFeatures:["local-floor","bounded-floor","layers",...s.optionalFeatures||[]]};t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){l===null?navigator.xr.requestSession("immersive-vr",h).then(c):(l.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",h).then(c).catch(u=>{console.warn(u)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",h).then(c).catch(u=>{console.warn(u)})}function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function o(){n(),t.textContent="VR NOT SUPPORTED"}function i(l){n(),console.warn("Exception when trying to call xr.isSessionSupported",l),t.textContent="VR NOT ALLOWED"}function a(l){l.style.position="absolute",l.style.bottom="20px",l.style.padding="12px 6px",l.style.border="1px solid #fff",l.style.borderRadius="4px",l.style.background="rgba(0,0,0,0.1)",l.style.color="#fff",l.style.font="normal 13px sans-serif",l.style.textAlign="center",l.style.opacity="0.5",l.style.outline="none",l.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",a(t),navigator.xr.isSessionSupported("immersive-vr").then(function(l){l?r():o(),l&&ct.xrSessionIsGranted&&t.click()}).catch(i),t;{const l=document.createElement("a");return window.isSecureContext===!1?(l.href=document.location.href.replace(/^http:/,"https:"),l.innerHTML="WEBXR NEEDS HTTPS"):(l.href="https://immersiveweb.dev/",l.innerHTML="WEBXR NOT AVAILABLE"),l.style.left="calc(50% - 90px)",l.style.width="180px",l.style.textDecoration="none",a(l),l}}static registerSessionGrantedListener(){if(typeof navigator<"u"&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",()=>{ct.xrSessionIsGranted=!0})}}}ct.xrSessionIsGranted=!1;ct.registerSessionGrantedListener();class Fo{static createButton(e,s={}){const t=document.createElement("button");function r(){if(s.domOverlay===void 0){const h=document.createElement("div");h.style.display="none",document.body.appendChild(h);const u=document.createElementNS("http://www.w3.org/2000/svg","svg");u.setAttribute("width",38),u.setAttribute("height",38),u.style.position="absolute",u.style.right="20px",u.style.top="20px",u.addEventListener("click",function(){l.end()}),h.appendChild(u);const p=document.createElementNS("http://www.w3.org/2000/svg","path");p.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),p.setAttribute("stroke","#fff"),p.setAttribute("stroke-width",2),u.appendChild(p),s.optionalFeatures===void 0&&(s.optionalFeatures=[]),s.optionalFeatures.push("dom-overlay"),s.domOverlay={root:h}}let l=null;async function c(h){h.addEventListener("end",d),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(h),t.textContent="STOP AR",s.domOverlay.root.style.display="",l=h}function d(){l.removeEventListener("end",d),t.textContent="START AR",s.domOverlay.root.style.display="none",l=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="START AR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){l===null?navigator.xr.requestSession("immersive-ar",s).then(c):(l.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",s).then(c).catch(h=>{console.warn(h)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-ar",s).then(c).catch(h=>{console.warn(h)})}function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function o(){n(),t.textContent="AR NOT SUPPORTED"}function i(l){n(),console.warn("Exception when trying to call xr.isSessionSupported",l),t.textContent="AR NOT ALLOWED"}function a(l){l.style.position="absolute",l.style.bottom="20px",l.style.padding="12px 6px",l.style.border="1px solid #fff",l.style.borderRadius="4px",l.style.background="rgba(0,0,0,0.1)",l.style.color="#fff",l.style.font="normal 13px sans-serif",l.style.textAlign="center",l.style.opacity="0.5",l.style.outline="none",l.style.zIndex="999"}if("xr"in navigator)return t.id="ARButton",t.style.display="none",a(t),navigator.xr.isSessionSupported("immersive-ar").then(function(l){l?r():o()}).catch(i),t;{const l=document.createElement("a");return window.isSecureContext===!1?(l.href=document.location.href.replace(/^http:/,"https:"),l.innerHTML="WEBXR NEEDS HTTPS"):(l.href="https://immersiveweb.dev/",l.innerHTML="WEBXR NOT AVAILABLE"),l.style.left="calc(50% - 90px)",l.style.width="180px",l.style.textDecoration="none",a(l),l}}}const Zt={Always:0,Never:2},bo=50,Ro=.75,Mo=15e5,Po=10,Oo=2.5,ko=60,qe=class qe{constructor(e={}){P(this,"onKeyDown",(function(){const e=new D,s=new ee,t=new ee;return function(r){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),s.makeRotationAxis(e,Math.PI/128),t.makeRotationAxis(e,-Math.PI/128),r.code){case"KeyG":this.focalAdjustment+=.02,this.forceRenderNextFrame();break;case"KeyF":this.focalAdjustment-=.02,this.forceRenderNextFrame();break;case"ArrowLeft":this.camera.up.transformDirection(s);break;case"ArrowRight":this.camera.up.transformDirection(t);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyU":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.show():this.infoPanel.hide();break;case"KeyO":this.usingExternalCamera||this.setOrthographicMode(!this.camera.isOrthographicCamera);break;case"KeyP":this.usingExternalCamera||this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());break;case"Equal":this.usingExternalCamera||this.splatMesh.setSplatScale(this.splatMesh.getSplatScale()+.05);break;case"Minus":this.usingExternalCamera||this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale()-.05,0));break}}})());P(this,"onMouseUp",(function(){const e=new q;return function(s){e.copy(this.mousePosition).sub(this.mouseDownPosition),$e()-this.mouseDownTime<.5&&e.length()<2&&this.onMouseClick(s)}})());P(this,"checkForFocalPointChange",(function(){const e=new q,s=new D,t=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(e),t.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.raycaster.intersectSplatMesh(this.splatMesh,t),t.length>0)){const n=t[0].origin;s.copy(n).sub(this.camera.position),s.length()>Ro&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(n),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=$e())}}})());P(this,"updateSplatMesh",(function(){const e=new q;return function(){if(!this.splatMesh)return;if(this.splatMesh.getSplatCount()>0){this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode),this.splatMesh.updateTransforms(),this.getRenderDimensions(e);const t=this.camera.projectionMatrix.elements[0]*.5*this.devicePixelRatio*e.x,r=this.camera.projectionMatrix.elements[5]*.5*this.devicePixelRatio*e.y,n=this.camera.isOrthographicCamera?1/this.devicePixelRatio:1,o=this.focalAdjustment*n,i=1/o;this.adjustForWebXRStereo(e),this.splatMesh.updateUniforms(e,t*o,r*o,this.camera.isOrthographicCamera,this.camera.zoom||1,i)}}})());P(this,"addSplatBuffers",(function(){return function(e,s=[],t=!0,r=!0,n=!0,o=!1,i=!1,a=!0){if(this.isDisposingOrDisposed())return Promise.resolve();let l=null;const c=()=>{l!==null&&(this.loadingSpinner.removeTask(l),l=null)};return this.splatRenderReady=!1,new Promise(d=>{r&&(l=this.loadingSpinner.addTask("Processing splats...")),be(()=>{if(this.isDisposingOrDisposed())d();else{const h=this.addSplatBuffersToMesh(e,s,t,n,o,a),u=this.splatMesh.getMaxSplatCount();this.sortWorker&&this.sortWorker.maxSplatCount!==u&&this.disposeSortWorker(),this.gpuAcceleratedSort||this.preSortMessages.push({centers:h.centers.buffer,sceneIndexes:h.sceneIndexes.buffer,range:{from:h.from,to:h.to,count:h.count}}),(!this.sortWorker&&u>0?this.setupSortWorker(this.splatMesh):Promise.resolve()).then(()=>{this.isDisposingOrDisposed()||this.runSplatSort(!0,!0).then(f=>{!this.sortWorker||!f?(this.splatRenderReady=!0,c(),d()):(i?this.splatRenderReady=!0:this.runAfterNextSort.push(()=>{this.splatRenderReady=!0}),this.runAfterNextSort.push(()=>{c(),d()}))})})}},!0)})}})());P(this,"addSplatBuffersToMesh",(function(){let e;return function(s,t,r=!0,n=!1,o=!1,i=!0){if(this.isDisposingOrDisposed())return;let a=[],l=[];o||(a=this.splatMesh.scenes.map(u=>u.splatBuffer)||[],l=this.splatMesh.sceneOptions?this.splatMesh.sceneOptions.map(u=>u):[]),a.push(...s),l.push(...t),this.renderer&&this.splatMesh.setRenderer(this.renderer);const c=u=>{if(this.isDisposingOrDisposed())return;const p=this.splatMesh.getSplatCount();n&&p>=Mo&&!u&&!e&&(this.loadingSpinner.setMinimized(!0,!0),e=this.loadingSpinner.addTask("Optimizing data structures..."))},d=u=>{this.isDisposingOrDisposed()||u&&e&&(this.loadingSpinner.removeTask(e),e=null)},h=this.splatMesh.build(a,l,!0,r,c,d,i);return r&&this.freeIntermediateSplatData&&this.splatMesh.freeIntermediateSplatData(),h}})());P(this,"shouldRender",(function(){let e=0;const s=new D,t=new Ce,r=1e-4;return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return!1;let n=!1,o=!1;if(this.camera){const i=this.camera.position,a=this.camera.quaternion;o=Math.abs(i.x-s.x)>r||Math.abs(i.y-s.y)>r||Math.abs(i.z-s.z)>r||Math.abs(a.x-t.x)>r||Math.abs(a.y-t.y)>r||Math.abs(a.z-t.z)>r||Math.abs(a.w-t.w)>r}return n=this.renderMode!==Zt.Never&&(e===0||this.splatMesh.visibleRegionChanging||o||this.renderMode===Zt.Always||this.dynamicMode===!0||this.renderNextFrame),this.camera&&(s.copy(this.camera.position),t.copy(this.camera.quaternion)),e++,n}})());P(this,"render",(function(){return function(){if(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())return;const e=t=>{for(let r of t.children)if(r.visible)return!0;return!1},s=this.renderer.autoClear;e(this.threeScene)&&(this.renderer.render(this.threeScene,this.camera),this.renderer.autoClear=!1),this.renderer.render(this.splatMesh,this.camera),this.renderer.autoClear=!1,this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=s}})());P(this,"updateFPS",(function(){let e=$e(),s=0;return function(){if(this.consecutiveRenderFrames>ko){const t=$e();t-e>=1?(this.currentFPS=s,s=0,e=t):s++}else this.currentFPS=null}})());P(this,"updateForRendererSizeChanges",(function(){const e=new q,s=new q;let t;return function(){this.usingExternalCamera||(this.renderer.getSize(s),(t===void 0||t!==this.camera.isOrthographicCamera||s.x!==e.x||s.y!==e.y)&&(this.camera.isOrthographicCamera?(this.camera.left=-s.x/2,this.camera.right=s.x/2,this.camera.top=s.y/2,this.camera.bottom=-s.y/2):this.camera.aspect=s.x/s.y,this.camera.updateProjectionMatrix(),e.copy(s),t=this.camera.isOrthographicCamera))}})());P(this,"timingSensitiveUpdates",(function(){let e;return function(){const s=$e();e||(e=s);const t=s-e;this.updateCameraTransition(s),this.updateFocusMarker(t),e=s}})());P(this,"updateCameraTransition",(function(){let e=new D,s=new D,t=new D;return function(r){if(this.transitioningCameraTarget){s.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),t.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const n=Math.acos(s.dot(t)),i=(n/(Math.PI/3)*.65+.3)/n*(r-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,i),this.camera.lookAt(e),this.controls.target.copy(e),i>=1&&(this.transitioningCameraTarget=!1)}}})());P(this,"updateFocusMarker",(function(){const e=new q;let s=!1;return function(t){if(this.getRenderDimensions(e),this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const r=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let n=Math.min(r+Po*t,1);this.sceneHelper.setFocusMarkerOpacity(n),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),s=!0,this.forceRenderNextFrame()}else{let r;if(s?r=1:r=Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),r>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let n=Math.max(r-Oo*t,0);this.sceneHelper.setFocusMarkerOpacity(n),n===0&&this.sceneHelper.setFocusMarkerVisibility(!1)}r>0&&this.forceRenderNextFrame(),s=!1}}})());P(this,"updateMeshCursor",(function(){const e=[],s=new q;return function(){this.showMeshCursor?(this.forceRenderNextFrame(),this.getRenderDimensions(s),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,s),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):(this.sceneHelper.getMeschCursorVisibility()&&this.forceRenderNextFrame(),this.sceneHelper.setMeshCursorVisibility(!1))}})());P(this,"updateInfoPanel",(function(){const e=new q;return function(){if(!this.showInfo)return;const s=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const t=this.controls?this.controls.target:null,r=this.showMeshCursor?this.sceneHelper.meshCursor.position:null,n=s>0?this.splatRenderCount/s*100:0;this.infoPanel.update(e,this.camera.position,t,this.camera.up,this.camera.isOrthographicCamera,r,this.currentFPS||"N/A",s,this.splatRenderCount,n,this.lastSortTime,this.focalAdjustment,this.splatMesh.getSplatScale(),this.splatMesh.getPointCloudModeEnabled())}})());P(this,"runSplatSort",(function(){const e=new ee,s=[],t=new D(0,0,-1),r=new D(0,0,-1),n=new D,o=new D,i=[],a=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return function(l=!1,c=!1){if(!this.initialized)return Promise.resolve(!1);if(this.sortRunning)return Promise.resolve(!0);if(this.splatMesh.getSplatCount()<=0)return this.splatRenderCount=0,Promise.resolve(!1);let d=0,h=0,u=!1,p=!1;if(r.set(0,0,-1).applyQuaternion(this.camera.quaternion),d=r.dot(t),h=o.copy(this.camera.position).sub(n).length(),!l&&!this.splatMesh.dynamicMode&&i.length===0&&(d<=.99&&(u=!0),h>=1&&(p=!0),!u&&!p))return Promise.resolve(!1);this.sortRunning=!0;let{splatRenderCount:f,shouldSortAll:m}=this.gatherSceneNodesForSort();m=m||c,this.splatRenderCount=f,e.copy(this.camera.matrixWorld).invert();const S=this.perspectiveCamera||this.camera;e.premultiply(S.projectionMatrix),this.splatMesh.dynamicMode||e.multiply(this.splatMesh.matrixWorld);let g=Promise.resolve(!0);return this.gpuAcceleratedSort&&(i.length<=1||i.length%2===0)&&(g=this.splatMesh.computeDistancesOnGPU(e,this.sortWorkerPrecomputedDistances)),g.then(()=>{if(i.length===0)if(this.splatMesh.dynamicMode||m)i.push(this.splatRenderCount);else{for(let C of a)if(d<C.angleThreshold){for(let v of C.sortFractions)i.push(Math.floor(this.splatRenderCount*v));break}i.push(this.splatRenderCount)}let x=Math.min(i.shift(),this.splatRenderCount);this.splatSortCount=x,s[0]=this.camera.position.x,s[1]=this.camera.position.y,s[2]=this.camera.position.z;const T={modelViewProj:e.elements,cameraPosition:s,splatRenderCount:this.splatRenderCount,splatSortCount:x,usePrecomputedDistances:this.gpuAcceleratedSort};return this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(T.indexesToSort=this.sortWorkerIndexesToSort,T.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(T.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortPromise=new Promise(C=>{this.sortPromiseResolver=C}),this.preSortMessages.length>0&&(this.preSortMessages.forEach(C=>{this.sortWorker.postMessage(C)}),this.preSortMessages=[]),this.sortWorker.postMessage({sort:T}),i.length===0&&(n.copy(this.camera.position),t.copy(r)),!0}),g}})());P(this,"gatherSceneNodesForSort",(function(){const e=[];let s=null;const t=new D,r=new D,n=new D,o=new ee,i=new ee,a=new ee,l=new D,c=new D(0,0,-1),d=new D,h=u=>d.copy(u.max).sub(u.min).length();return function(u=!1){this.getRenderDimensions(l);const p=l.y/2/Math.tan(this.camera.fov/2*pn.DEG2RAD),f=Math.atan(l.x/2/p),m=Math.atan(l.y/2/p),S=Math.cos(f),g=Math.cos(m),x=this.splatMesh.getSplatTree();if(x){i.copy(this.camera.matrixWorld).invert(),this.splatMesh.dynamicMode||i.multiply(this.splatMesh.matrixWorld);let T=0,C=0;for(let y=0;y<x.subTrees.length;y++){const B=x.subTrees[y];o.copy(i),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(y,a),o.multiply(a));const F=B.nodesWithIndexes.length;for(let w=0;w<F;w++){const M=B.nodesWithIndexes[w];if(!M.data||!M.data.indexes||M.data.indexes.length===0)continue;n.copy(M.center).applyMatrix4(o);const O=n.length();n.normalize(),t.copy(n).setX(0).normalize(),r.copy(n).setY(0).normalize();const R=c.dot(r),b=c.dot(t),k=h(M),H=b<g-.6,Q=R<S-.6;!u&&(Q||H)&&O>k||(C+=M.data.indexes.length,e[T]=M,M.data.distanceToNode=O,T++)}}e.length=T,e.sort((y,B)=>y.data.distanceToNode<B.data.distanceToNode?-1:1);let v=C*G.BytesPerInt;for(let y=0;y<T;y++){const B=e[y],F=B.data.indexes.length,w=F*G.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,v-w,F).set(B.data.indexes),v-=w}return{splatRenderCount:C,shouldSortAll:!1}}else{const T=this.splatMesh.getSplatCount();if(!s||s.length!==T){s=new Uint32Array(T);for(let C=0;C<T;C++)s[C]=C}return this.sortWorkerIndexesToSort.set(s),{splatRenderCount:T,shouldSortAll:!0}}}})());if(e.cameraUp||(e.cameraUp=[0,1,0]),this.cameraUp=new D().fromArray(e.cameraUp),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),this.initialCameraPosition=new D().fromArray(e.initialCameraPosition),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=new D().fromArray(e.initialCameraLookAt),this.dropInMode=e.dropInMode||!1,(e.selfDrivenMode===void 0||e.selfDrivenMode===null)&&(e.selfDrivenMode=!0),this.selfDrivenMode=e.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),e.useBuiltInControls===void 0&&(e.useBuiltInControls=!0),this.useBuiltInControls=e.useBuiltInControls,this.rootElement=e.rootElement,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio||1,this.halfPrecisionCovariancesOnGPU=e.halfPrecisionCovariancesOnGPU||!1,this.threeScene=e.threeScene,this.renderer=e.renderer,this.camera=e.camera,this.gpuAcceleratedSort=e.gpuAcceleratedSort||!1,(e.integerBasedSort===void 0||e.integerBasedSort===null)&&(e.integerBasedSort=!0),this.integerBasedSort=e.integerBasedSort,(e.sharedMemoryForWorkers===void 0||e.sharedMemoryForWorkers===null)&&(e.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=e.sharedMemoryForWorkers,this.dynamicScene=!!e.dynamicScene,this.antialiased=e.antialiased||!1,this.kernel2DSize=e.kernel2DSize===void 0?.3:e.kernel2DSize,this.webXRMode=e.webXRMode||tt.None,this.webXRMode!==tt.None&&(this.gpuAcceleratedSort=!1),this.webXRActive=!1,this.webXRSessionInit=e.webXRSessionInit||{},this.renderMode=e.renderMode||Zt.Always,this.sceneRevealMode=e.sceneRevealMode||St.Default,this.focalAdjustment=e.focalAdjustment||1,this.maxScreenSpaceSplatSize=e.maxScreenSpaceSplatSize||1024,this.logLevel=e.logLevel||at.None,this.sphericalHarmonicsDegree=e.sphericalHarmonicsDegree||0,this.enableOptionalEffects=e.enableOptionalEffects||!1,(e.enableSIMDInSort===void 0||e.enableSIMDInSort===null)&&(e.enableSIMDInSort=!0),this.enableSIMDInSort=e.enableSIMDInSort,(e.inMemoryCompressionLevel===void 0||e.inMemoryCompressionLevel===null)&&(e.inMemoryCompressionLevel=0),this.inMemoryCompressionLevel=e.inMemoryCompressionLevel,(e.optimizeSplatData===void 0||e.optimizeSplatData===null)&&(e.optimizeSplatData=!0),this.optimizeSplatData=e.optimizeSplatData,(e.freeIntermediateSplatData===void 0||e.freeIntermediateSplatData===null)&&(e.freeIntermediateSplatData=!1),this.freeIntermediateSplatData=e.freeIntermediateSplatData,us()){const t=An();t.major<17&&(this.enableSIMDInSort=!1),t.major<16&&(this.sharedMemoryForWorkers=!1)}(e.splatRenderMode===void 0||e.splatRenderMode===null)&&(e.splatRenderMode=Ue.ThreeD),this.splatRenderMode=e.splatRenderMode,this.sceneFadeInRateMultiplier=e.sceneFadeInRateMultiplier||1,this.splatSortDistanceMapPrecision=e.splatSortDistanceMapPrecision||G.DefaultSplatSortDistanceMapPrecision;const s=this.integerBasedSort?20:24;this.splatSortDistanceMapPrecision=ie(this.splatSortDistanceMapPrecision,10,s),this.onSplatMeshChangedCallback=null,this.createSplatMesh(),this.controls=null,this.perspectiveControls=null,this.orthographicControls=null,this.orthographicCamera=null,this.perspectiveCamera=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.splatSortCount=0,this.lastSplatSortCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.preSortMessages=[],this.runAfterNextSort=[],this.selfDrivenModeRunning=!1,this.splatRenderReady=!1,this.raycaster=new io,this.infoPanel=null,this.startInOrthographicMode=!1,this.currentFPS=0,this.lastSortTime=0,this.consecutiveRenderFrames=0,this.previousCameraTarget=new D,this.nextCameraTarget=new D,this.mousePosition=new q,this.mouseDownPosition=new q,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.splatSceneDownloadPromises={},this.splatSceneDownloadAndBuildPromise=null,this.splatSceneRemovalPromise=null,this.loadingSpinner=new rs(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.loadingProgressBar=new eo(this.rootElement||document.body),this.loadingProgressBar.hide(),this.infoPanel=new to(this.rootElement||document.body),this.infoPanel.hide(),this.usingExternalCamera=!!(this.dropInMode||this.camera),this.usingExternalRenderer=!!(this.dropInMode||this.renderer),this.initialized=!1,this.disposing=!1,this.disposed=!1,this.disposePromise=null,this.dropInMode||this.init()}createSplatMesh(){this.splatMesh=new Ie(this.splatRenderMode,this.dynamicScene,this.enableOptionalEffects,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort,this.antialiased,this.maxScreenSpaceSplatSize,this.logLevel,this.sphericalHarmonicsDegree,this.sceneFadeInRateMultiplier,this.kernel2DSize),this.splatMesh.frustumCulled=!1,this.onSplatMeshChangedCallback&&this.onSplatMeshChangedCallback()}init(){this.initialized||(this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement))),this.setupCamera(),this.setupRenderer(),this.setupWebXR(this.webXRSessionInit),this.setupControls(),this.setupEventHandlers(),this.threeScene=this.threeScene||new On,this.sceneHelper=new At(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.loadingProgressBar.setContainer(this.rootElement),this.loadingSpinner.setContainer(this.rootElement),this.infoPanel.setContainer(this.rootElement),this.initialized=!0)}setupCamera(){if(!this.usingExternalCamera){const e=new q;this.getRenderDimensions(e),this.perspectiveCamera=new kn(bo,e.x/e.y,.1,1e3),this.orthographicCamera=new hn(e.x/-2,e.x/2,e.y/2,e.y/-2,.1,1e3),this.camera=this.startInOrthographicMode?this.orthographicCamera:this.perspectiveCamera,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)}}setupRenderer(){if(!this.usingExternalRenderer){const e=new q;this.getRenderDimensions(e),this.renderer=new Ln({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new Pt(0),0),this.renderer.setSize(e.x,e.y),this.resizeObserver=new ResizeObserver(()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y),this.forceRenderNextFrame()}),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}}setupWebXR(e){this.webXRMode&&(this.webXRMode===tt.VR?this.rootElement.appendChild(ct.createButton(this.renderer,e)):this.webXRMode===tt.AR&&this.rootElement.appendChild(Fo.createButton(this.renderer,e)),this.renderer.xr.addEventListener("sessionstart",s=>{this.webXRActive=!0}),this.renderer.xr.addEventListener("sessionend",s=>{this.webXRActive=!1}),this.renderer.xr.enabled=!0,this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt))}setupControls(){if(this.useBuiltInControls&&this.webXRMode===tt.None){this.usingExternalCamera?this.camera.isOrthographicCamera?this.orthographicControls=new bt(this.camera,this.renderer.domElement):this.perspectiveControls=new bt(this.camera,this.renderer.domElement):(this.perspectiveControls=new bt(this.perspectiveCamera,this.renderer.domElement),this.orthographicControls=new bt(this.orthographicCamera,this.renderer.domElement));for(let e of[this.orthographicControls,this.perspectiveControls])e&&(e.listenToKeyEvents(window),e.rotateSpeed=.5,e.maxPolarAngle=Math.PI*.75,e.minPolarAngle=.1,e.enableDamping=!0,e.dampingFactor=.05,e.target.copy(this.initialCameraLookAt),e.update());this.controls=this.camera.isOrthographicCamera?this.orthographicControls:this.perspectiveControls,this.controls.update()}}setupEventHandlers(){this.useBuiltInControls&&this.webXRMode===tt.None&&(this.mouseMoveListener=this.onMouseMove.bind(this),this.renderer.domElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.renderer.domElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.renderer.domElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1))}removeEventHandlers(){this.useBuiltInControls&&(this.renderer.domElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.renderer.domElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.renderer.domElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}setRenderMode(e){this.renderMode=e}setActiveSphericalHarmonicsDegrees(e){this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value=e,this.splatMesh.material.uniformsNeedUpdate=!0}onSplatMeshChanged(e){this.onSplatMeshChangedCallback=e}onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=$e()}onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setOrthographicMode(e){if(e===this.camera.isOrthographicCamera)return;const s=this.camera,t=e?this.orthographicCamera:this.perspectiveCamera;if(t.position.copy(s.position),t.up.copy(s.up),t.rotation.copy(s.rotation),t.quaternion.copy(s.quaternion),t.matrix.copy(s.matrix),this.camera=t,this.controls){const r=i=>{i.saveState(),i.reset()},n=this.controls,o=e?this.orthographicControls:this.perspectiveControls;r(o),r(n),o.target.copy(n.target),e?qe.setCameraZoomFromPosition(t,s,n):qe.setCameraPositionFromZoom(t,s,o),this.controls=o,this.camera.lookAt(this.controls.target)}}adjustForWebXRStereo(e){if(this.camera&&this.webXRActive){const t=this.renderer.xr.getCamera().projectionMatrix.elements[0],r=this.camera.projectionMatrix.elements[0];e.x*=r/t}}isLoadingOrUnloading(){return Object.keys(this.splatSceneDownloadPromises).length>0||this.splatSceneDownloadAndBuildPromise!==null||this.splatSceneRemovalPromise!==null}isDisposingOrDisposed(){return this.disposing||this.disposed}addSplatSceneDownloadPromise(e){this.splatSceneDownloadPromises[e.id]=e}removeSplatSceneDownloadPromise(e){delete this.splatSceneDownloadPromises[e.id]}setSplatSceneDownloadAndBuildPromise(e){this.splatSceneDownloadAndBuildPromise=e}clearSplatSceneDownloadAndBuildPromise(){this.splatSceneDownloadAndBuildPromise=null}addSplatScene(e,s={}){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");s.progressiveLoad&&this.splatMesh.scenes&&this.splatMesh.scenes.length>0&&(console.log('addSplatScene(): "progressiveLoad" option ignore because there are multiple splat scenes'),s.progressiveLoad=!1);const t=s.format!==void 0&&s.format!==null?s.format:en(e),r=qe.isProgressivelyLoadable(t)&&s.progressiveLoad,n=s.showLoadingUI!==void 0&&s.showLoadingUI!==null?s.showLoadingUI:!0;let o=null;n&&(this.loadingSpinner.removeAllTasks(),o=this.loadingSpinner.addTask("Downloading..."));const i=()=>{this.loadingProgressBar.hide(),this.loadingSpinner.removeAllTasks()},a=(f,m,S)=>{if(n)if(S===fe.Downloading)if(f==100)this.loadingSpinner.setMessageForTask(o,"Download complete!");else if(r)this.loadingSpinner.setMessageForTask(o,"Downloading splats...");else{const g=m?`: ${m}`:"...";this.loadingSpinner.setMessageForTask(o,`Downloading${g}`)}else S===fe.Processing&&this.loadingSpinner.setMessageForTask(o,"Processing splats...")};let l=!1,c=0;const d=(f,m)=>{n&&((f&&r||m&&!r)&&(this.loadingSpinner.removeTask(o),!m&&!l&&this.loadingProgressBar.show()),r&&(m?(l=!0,this.loadingProgressBar.hide()):this.loadingProgressBar.setProgress(c)))},h=(f,m,S)=>{c=f,a(f,m,S),s.onProgress&&s.onProgress(f,m,S)},u=(f,m,S)=>{!r&&s.onProgress&&s.onProgress(0,"0%",fe.Processing);const g={rotation:s.rotation||s.orientation,position:s.position,scale:s.scale,splatAlphaRemovalThreshold:s.splatAlphaRemovalThreshold};return this.addSplatBuffers([f],[g],S,m&&n,n,r,r).then(()=>{!r&&s.onProgress&&s.onProgress(100,"100%",fe.Processing),d(m,S)})};return(r?this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this):this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this))(e,t,s.splatAlphaRemovalThreshold,u.bind(this),h,i.bind(this),s.headers)}downloadAndBuildSingleSplatSceneStandardLoad(e,s,t,r,n,o,i){const a=this.downloadSplatSceneToSplatBuffer(e,t,n,!1,void 0,s,i),l=Gt(a.abortHandler);return a.then(c=>(this.removeSplatSceneDownloadPromise(a),r(c,!0,!0).then(()=>{l.resolve(),this.clearSplatSceneDownloadAndBuildPromise()}))).catch(c=>{o&&o(),this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(a),l.reject(this.updateError(c,`Viewer::addSplatScene -> Could not load file ${e}`))}),this.addSplatSceneDownloadPromise(a),this.setSplatSceneDownloadAndBuildPromise(l.promise),l.promise}downloadAndBuildSingleSplatSceneProgressiveLoad(e,s,t,r,n,o,i){let a=0,l=!1;const c=[],d=()=>{if(c.length>0&&!l&&!this.isDisposingOrDisposed()){l=!0;const m=c.shift();r(m.splatBuffer,m.firstBuild,m.finalBuild).then(()=>{l=!1,m.firstBuild?p.resolve():m.finalBuild&&(f.resolve(),this.clearSplatSceneDownloadAndBuildPromise()),c.length>0&&be(()=>d())})}},h=(m,S)=>{this.isDisposingOrDisposed()||(S||c.length===0||m.getSplatCount()>c[0].splatBuffer.getSplatCount())&&(c.push({splatBuffer:m,firstBuild:a===0,finalBuild:S}),a++,d())},u=this.downloadSplatSceneToSplatBuffer(e,t,n,!0,h,s,i),p=Gt(u.abortHandler),f=Gt();return this.addSplatSceneDownloadPromise(u),this.setSplatSceneDownloadAndBuildPromise(f.promise),u.then(()=>{this.removeSplatSceneDownloadPromise(u)}).catch(m=>{this.clearSplatSceneDownloadAndBuildPromise(),this.removeSplatSceneDownloadPromise(u);const S=this.updateError(m,"Viewer::addSplatScene -> Could not load one or more scenes");p.reject(S),o&&o(S)}),p.promise}addSplatScenes(e,s=!0,t=void 0){if(this.isLoadingOrUnloading())throw new Error("Cannot add splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot add splat scene after dispose() is called.");const r=e.length,n=[];let o;s&&(this.loadingSpinner.removeAllTasks(),o=this.loadingSpinner.addTask("Downloading..."));const i=(d,h,u,p)=>{n[d]=h;let f=0;for(let m=0;m<r;m++)f+=n[m]||0;f=f/r,u=`${f.toFixed(2)}%`,s&&p===fe.Downloading&&this.loadingSpinner.setMessageForTask(o,f==100?"Download complete!":`Downloading: ${u}`),t&&t(f,u,p)},a=[],l=[];for(let d=0;d<e.length;d++){const h=e[d],u=h.format!==void 0&&h.format!==null?h.format:en(h.path),p=this.downloadSplatSceneToSplatBuffer(h.path,h.splatAlphaRemovalThreshold,i.bind(this,d),!1,void 0,u,h.headers);a.push(p),l.push(p.promise)}const c=new xt((d,h)=>{Promise.all(l).then(u=>{s&&this.loadingSpinner.removeTask(o),t&&t(0,"0%",fe.Processing),this.addSplatBuffers(u,e,!0,s,s,!1,!1).then(()=>{t&&t(100,"100%",fe.Processing),this.clearSplatSceneDownloadAndBuildPromise(),d()})}).catch(u=>{s&&this.loadingSpinner.removeTask(o),this.clearSplatSceneDownloadAndBuildPromise(),h(this.updateError(u,"Viewer::addSplatScenes -> Could not load one or more splat scenes."))}).finally(()=>{this.removeSplatSceneDownloadPromise(c)})},d=>{for(let h of a)h.abort(d)});return this.addSplatSceneDownloadPromise(c),this.setSplatSceneDownloadAndBuildPromise(c),c}downloadSplatSceneToSplatBuffer(e,s=1,t=void 0,r=!1,n=void 0,o,i){try{if(o===Ee.Splat||o===Ee.KSplat||o===Ee.Ply){const a=r?!1:this.optimizeSplatData;if(o===Ee.Splat)return Ts.loadFromURL(e,t,r,n,s,this.inMemoryCompressionLevel,a,i);if(o===Ee.KSplat)return ns.loadFromURL(e,t,r,n,i);if(o===Ee.Ply)return xs.loadFromURL(e,t,r,n,s,this.inMemoryCompressionLevel,a,this.sphericalHarmonicsDegree,i)}else if(o===Ee.Spz)return Is.loadFromURL(e,t,s,this.inMemoryCompressionLevel,this.optimizeSplatData,this.sphericalHarmonicsDegree,i)}catch(a){throw this.updateError(a,null)}throw new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${e}`)}static isProgressivelyLoadable(e){return e===Ee.Splat||e===Ee.KSplat||e===Ee.Ply}setupSortWorker(e){if(!this.isDisposingOrDisposed())return new Promise(s=>{const t=this.integerBasedSort?Int32Array:Float32Array,r=e.getSplatCount(),n=e.getMaxSplatCount();this.sortWorker=Do(n,this.sharedMemoryForWorkers,this.enableSIMDInSort,this.integerBasedSort,this.splatMesh.dynamicMode,this.splatSortDistanceMapPrecision),this.sortWorker.onmessage=o=>{if(o.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,o.data.splatRenderCount);else{const i=new Uint32Array(o.data.sortedIndexes.buffer,0,o.data.splatRenderCount);this.splatMesh.updateRenderIndexes(i,o.data.splatRenderCount)}this.lastSplatSortCount=this.splatSortCount,this.lastSortTime=o.data.sortTime,this.sortPromiseResolver(),this.sortPromiseResolver=null,this.forceRenderNextFrame(),this.runAfterNextSort.length>0&&(this.runAfterNextSort.forEach(i=>{i()}),this.runAfterNextSort.length=0)}else if(o.data.sortCanceled)this.sortRunning=!1;else if(o.data.sortSetupPhase1Complete){this.logLevel>=at.Info&&console.log("Sorting web worker WASM setup complete."),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(o.data.sortedIndexesBuffer,o.data.sortedIndexesOffset,n),this.sortWorkerIndexesToSort=new Uint32Array(o.data.indexesToSortBuffer,o.data.indexesToSortOffset,n),this.sortWorkerPrecomputedDistances=new t(o.data.precomputedDistancesBuffer,o.data.precomputedDistancesOffset,n),this.sortWorkerTransforms=new Float32Array(o.data.transformsBuffer,o.data.transformsOffset,G.MaxScenes*16)):(this.sortWorkerIndexesToSort=new Uint32Array(n),this.sortWorkerPrecomputedDistances=new t(n),this.sortWorkerTransforms=new Float32Array(G.MaxScenes*16));for(let i=0;i<r;i++)this.sortWorkerIndexesToSort[i]=i;if(this.sortWorker.maxSplatCount=n,this.logLevel>=at.Info){console.log("Sorting web worker ready.");const i=this.splatMesh.getSplatDataTextures(),a=i.covariances.size,l=i.centerColors.size;console.log("Covariances texture size: "+a.x+" x "+a.y),console.log("Centers/colors texture size: "+l.x+" x "+l.y)}s()}}})}updateError(e,s){return e instanceof mn?e:e instanceof Ot?new Error("File type or server does not support progressive loading."):s?new Error(s):e}disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortPromise=null,this.sortPromiseResolver&&(this.sortPromiseResolver(),this.sortPromiseResolver=null),this.preSortMessages=[],this.sortRunning=!1}removeSplatScene(e,s=!0){return this.removeSplatScenes([e],s)}removeSplatScenes(e,s=!0){if(this.isLoadingOrUnloading())throw new Error("Cannot remove splat scene while another load or unload is already in progress.");if(this.isDisposingOrDisposed())throw new Error("Cannot remove splat scene after dispose() is called.");let t;return this.splatSceneRemovalPromise=new Promise((r,n)=>{let o;s&&(this.loadingSpinner.removeAllTasks(),this.loadingSpinner.show(),o=this.loadingSpinner.addTask("Removing splat scene..."));const i=()=>{s&&(this.loadingSpinner.hide(),this.loadingSpinner.removeTask(o))},a=c=>{i(),this.splatSceneRemovalPromise=null,c?n(c):r()},l=()=>this.isDisposingOrDisposed()?(a(),!0):!1;t=this.sortPromise||Promise.resolve(),t.then(()=>{if(l())return;const c=[],d=[],h=[];for(let u=0;u<this.splatMesh.scenes.length;u++){let p=!1;for(let f of e)if(f===u){p=!0;break}if(!p){const f=this.splatMesh.scenes[u];c.push(f.splatBuffer),d.push(this.splatMesh.sceneOptions[u]),h.push({position:f.position.clone(),quaternion:f.quaternion.clone(),scale:f.scale.clone()})}}this.disposeSortWorker(),this.splatMesh.dispose(),this.sceneRevealMode=St.Instant,this.createSplatMesh(),this.addSplatBuffers(c,d,!0,!1,!0).then(()=>{l()||(i(),this.splatMesh.scenes.forEach((u,p)=>{u.position.copy(h[p].position),u.quaternion.copy(h[p].quaternion),u.scale.copy(h[p].scale)}),this.splatMesh.updateTransforms(),this.splatRenderReady=!1,this.runSplatSort(!0).then(()=>{if(l()){this.splatRenderReady=!0;return}t=this.sortPromise||Promise.resolve(),t.then(()=>{this.splatRenderReady=!0,a()})}))}).catch(u=>{a(u)})})}),this.splatSceneRemovalPromise}start(){if(this.selfDrivenMode)this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0;else throw new Error("Cannot start viewer unless it is in self driven mode.")}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode?this.renderer.setAnimationLoop(null):cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){if(this.isDisposingOrDisposed())return this.disposePromise;let e=[],s=[];for(let t in this.splatSceneDownloadPromises)if(this.splatSceneDownloadPromises.hasOwnProperty(t)){const r=this.splatSceneDownloadPromises[t];s.push(r),e.push(r.promise)}return this.sortPromise&&e.push(this.sortPromise),this.disposing=!0,this.disposePromise=Promise.all(e).finally(()=>{this.stop(),this.orthographicControls&&(this.orthographicControls.dispose(),this.orthographicControls=null),this.perspectiveControls&&(this.perspectiveControls.dispose(),this.perspectiveControls=null),this.controls=null,this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.disposeSortWorker(),this.removeEventHandlers(),this.loadingSpinner.removeAllTasks(),this.loadingSpinner.setContainer(null),this.loadingProgressBar.hide(),this.loadingProgressBar.setContainer(null),this.infoPanel.setContainer(null),this.camera=null,this.threeScene=null,this.splatRenderReady=!1,this.initialized=!1,this.renderer&&(this.usingExternalRenderer||(this.rootElement.removeChild(this.renderer.domElement),this.renderer.dispose()),this.renderer=null),this.usingExternalRenderer||document.body.removeChild(this.rootElement),this.sortWorkerSortedIndexes=null,this.sortWorkerIndexesToSort=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.disposed=!0,this.disposing=!1,this.disposePromise=null}),s.forEach(t=>{t.abort("Scene disposed")}),this.disposePromise}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.shouldRender()?(this.render(),this.consecutiveRenderFrames++):this.consecutiveRenderFrames=0,this.renderNextFrame=!1}forceRenderNextFrame(){this.renderNextFrame=!0}update(e,s){this.dropInMode&&this.updateForDropInMode(e,s),!(!this.initialized||!this.splatRenderReady||this.isDisposingOrDisposed())&&(this.controls&&(this.controls.update(),this.camera.isOrthographicCamera&&!this.usingExternalCamera&&qe.setCameraPositionFromZoom(this.camera,this.camera,this.controls)),this.runSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,s){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=s,this.controls&&(this.controls.object=s),this.init()}updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}getSceneCount(){return this.splatMesh.getSceneCount()}isMobile(){return navigator.userAgent.includes("Mobi")}};P(qe,"setCameraPositionFromZoom",(function(){const e=new D;return function(s,t,r){const n=1/(t.zoom*.001);e.copy(r.target).sub(s.position).normalize().multiplyScalar(n).negate(),s.position.copy(r.target).add(e)}})()),P(qe,"setCameraZoomFromPosition",(function(){const e=new D;return function(s,t,r){const n=e.copy(r.target).sub(t.position).length();s.zoom=1/(n*.001)}})());let is=qe;class as extends Zn{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.dropInMode=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new is(e),this.splatMesh=null,this.updateSplatMesh(),this.callbackMesh=as.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=as.onBeforeRender.bind(this,this.viewer),this.viewer.onSplatMeshChanged(()=>{this.updateSplatMesh()})}updateSplatMesh(){this.splatMesh!==this.viewer.splatMesh&&(this.splatMesh&&this.remove(this.splatMesh),this.splatMesh=this.viewer.splatMesh,this.add(this.viewer.splatMesh))}addSplatScene(e,s={}){return s.showLoadingUI!==!1&&(s.showLoadingUI=!0),this.viewer.addSplatScene(e,s)}addSplatScenes(e,s){return s!==!1&&(s=!0),this.viewer.addSplatScenes(e,s)}getSplatScene(e){return this.viewer.getSplatScene(e)}removeSplatScene(e,s=!0){return this.viewer.removeSplatScene(e,s)}removeSplatScenes(e,s=!0){return this.viewer.removeSplatScenes(e,s)}getSceneCount(){return this.viewer.getSceneCount()}setActiveSphericalHarmonicsDegrees(e){this.viewer.setActiveSphericalHarmonicsDegrees(e)}async dispose(){return await this.viewer.dispose()}static onBeforeRender(e,s,t,r){e.update(s,r)}static createCallbackMesh(){const e=new $t(1,8,8),s=new lt;s.colorWrite=!1,s.depthWrite=!1;const t=new Fe(e,s);return t.frustumCulled=!1,t}}export{as as D};
//# sourceMappingURL=gaussian-splats-3d-vendor-CwjmzPDi.js.map
