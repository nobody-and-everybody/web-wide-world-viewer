{"version":3,"file":"gaussian-splats-3d-vendor-CIwpavXY.js","sources":["../../../node_modules/@mkkellogg/gaussian-splats-3d/build/gaussian-splats-3d.module.js"],"sourcesContent":["import * as THREE from 'three';\nimport { Ray as Ray$1, Plane, MathUtils, EventDispatcher, Vector3, MOUSE, TOUCH, Quaternion, Spherical, Vector2 } from 'three';\n\n/**\n * AbortablePromise: A quick & dirty wrapper for JavaScript's Promise class that allows the underlying\n * asynchronous operation to be cancelled. It is only meant for simple situations where no complex promise\n * chaining or merging occurs. It needs a significant amount of work to truly replicate the full\n * functionality of JavaScript's Promise class. Look at Util.fetchWithProgress() for example usage.\n *\n * This class was primarily added to allow splat scene downloads to be cancelled. It has not been tested\n * very thoroughly and the implementation is kinda janky. If you can at all help it, please avoid using it :)\n */\nclass AbortablePromise {\n\n    static idGen = 0;\n\n    constructor(promiseFunc, abortHandler) {\n\n        let resolver;\n        let rejecter;\n        this.promise = new Promise((resolve, reject) => {\n            resolver = resolve;\n            rejecter = reject;\n        });\n\n        const promiseResolve = resolver.bind(this);\n        const promiseReject = rejecter.bind(this);\n\n        const resolve = (...args) => {\n            promiseResolve(...args);\n        };\n\n        const reject = (error) => {\n            promiseReject(error);\n        };\n\n        promiseFunc(resolve.bind(this), reject.bind(this));\n        this.abortHandler = abortHandler;\n        this.id = AbortablePromise.idGen++;\n    }\n\n    then(onResolve) {\n        return new AbortablePromise((resolve, reject) => {\n            this.promise = this.promise\n            .then((...args) => {\n                const onResolveResult = onResolve(...args);\n                if (onResolveResult instanceof Promise || onResolveResult instanceof AbortablePromise) {\n                    onResolveResult.then((...args2) => {\n                        resolve(...args2);\n                    });\n                } else {\n                    resolve(onResolveResult);\n                }\n            })\n            .catch((error) => {\n                reject(error);\n            });\n        }, this.abortHandler);\n    }\n\n    catch(onFail) {\n        return new AbortablePromise((resolve) => {\n            this.promise = this.promise.then((...args) => {\n                resolve(...args);\n            })\n            .catch(onFail);\n        }, this.abortHandler);\n    }\n\n    abort(reason) {\n        if (this.abortHandler) this.abortHandler(reason);\n    }\n\n}\n\nclass AbortedPromiseError extends Error {\n\n    constructor(msg) {\n        super(msg);\n    }\n\n}\n\nconst floatToHalf = function() {\n\n    const floatView = new Float32Array(1);\n    const int32View = new Int32Array(floatView.buffer);\n\n    return function(val) {\n        floatView[0] = val;\n        const x = int32View[0];\n\n        let bits = (x >> 16) & 0x8000;\n        let m = (x >> 12) & 0x07ff;\n        const e = (x >> 23) & 0xff;\n\n        if (e < 103) return bits;\n\n        if (e > 142) {\n            bits |= 0x7c00;\n            bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\n            return bits;\n        }\n\n        if (e < 113) {\n            m |= 0x0800;\n            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n            return bits;\n        }\n\n        bits |= (( e - 112) << 10) | (m >> 1);\n        bits += m & 1;\n        return bits;\n    };\n\n}();\n\nconst uintEncodedFloat = function() {\n\n    const floatView = new Float32Array(1);\n    const int32View = new Int32Array(floatView.buffer);\n\n    return function(f) {\n        floatView[0] = f;\n        return int32View[0];\n    };\n\n}();\n\nconst rgbaToInteger = function(r, g, b, a) {\n    return r + (g << 8) + (b << 16) + (a << 24);\n};\n\nconst rgbaArrayToInteger = function(arr, offset) {\n    return arr[offset] + (arr[offset + 1] << 8) + (arr[offset + 2] << 16) + (arr[offset + 3] << 24);\n};\n\nconst fetchWithProgress = function(path, onProgress, saveChunks = true, headers) {\n\n    const abortController = new AbortController();\n    const signal = abortController.signal;\n    let aborted = false;\n    const abortHandler = (reason) => {\n        abortController.abort(reason);\n        aborted = true;\n    };\n\n    let onProgressCalledAtComplete = false;\n    const localOnProgress = (percent, percentLabel, chunk, fileSize) => {\n        if (onProgress && !onProgressCalledAtComplete) {\n            onProgress(percent, percentLabel, chunk, fileSize);\n            if (percent === 100) {\n                onProgressCalledAtComplete = true;\n            }\n        }\n    };\n\n    return new AbortablePromise((resolve, reject) => {\n        const fetchOptions = { signal };\n        if (headers) fetchOptions.headers = headers;\n         fetch(path, fetchOptions)\n        .then(async (data) => {\n            // Handle error conditions where data is still returned\n            if (!data.ok) {\n                const errorText = await data.text();\n                reject(new Error(`Fetch failed: ${data.status} ${data.statusText} ${errorText}`));\n                return;\n            }\n\n            const reader = data.body.getReader();\n            let bytesDownloaded = 0;\n            let _fileSize = data.headers.get('Content-Length');\n            let fileSize = _fileSize ? parseInt(_fileSize) : undefined;\n\n            const chunks = [];\n\n            while (!aborted) {\n                try {\n                    const { value: chunk, done } = await reader.read();\n                    if (done) {\n                        localOnProgress(100, '100%', chunk, fileSize);\n                        if (saveChunks) {\n                            const buffer = new Blob(chunks).arrayBuffer();\n                            resolve(buffer);\n                        } else {\n                            resolve();\n                        }\n                        break;\n                    }\n                    bytesDownloaded += chunk.length;\n                    let percent;\n                    let percentLabel;\n                    if (fileSize !== undefined) {\n                        percent = bytesDownloaded / fileSize * 100;\n                        percentLabel = `${percent.toFixed(2)}%`;\n                    }\n                    if (saveChunks) {\n                        chunks.push(chunk);\n                    }\n                    localOnProgress(percent, percentLabel, chunk, fileSize);\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n            }\n        })\n        .catch((error) => {\n            reject(new AbortedPromiseError(error));\n        });\n    }, abortHandler);\n\n};\n\nconst clamp = function(val, min, max) {\n    return Math.max(Math.min(val, max), min);\n};\n\nconst getCurrentTime = function() {\n    return performance.now() / 1000;\n};\n\nconst disposeAllMeshes = (object3D) => {\n    if (object3D.geometry) {\n        object3D.geometry.dispose();\n        object3D.geometry = null;\n    }\n    if (object3D.material) {\n        object3D.material.dispose();\n        object3D.material = null;\n    }\n    if (object3D.children) {\n        for (let child of object3D.children) {\n            disposeAllMeshes(child);\n        }\n    }\n};\n\nconst delayedExecute = (func, fast) => {\n    return new Promise((resolve) => {\n        window.setTimeout(() => {\n            resolve(func ? func() : undefined);\n        }, fast ? 1 : 50);\n    });\n};\n\n\nconst getSphericalHarmonicsComponentCountForDegree = (sphericalHarmonicsDegree = 0) => {\n    let shCoeffPerSplat = 0;\n    if (sphericalHarmonicsDegree === 1) {\n        shCoeffPerSplat = 9;\n    } else if (sphericalHarmonicsDegree === 2) {\n        shCoeffPerSplat = 24;\n    } else if (sphericalHarmonicsDegree === 3) {\n        shCoeffPerSplat = 45;\n    } else if (sphericalHarmonicsDegree > 3) {\n        throw new Error('getSphericalHarmonicsComponentCountForDegree() -> Invalid spherical harmonics degree');\n    }\n    return shCoeffPerSplat;\n};\n\nconst nativePromiseWithExtractedComponents = () => {\n    let resolver;\n    let rejecter;\n    const promise = new Promise((resolve, reject) => {\n        resolver = resolve;\n        rejecter = reject;\n    });\n    return {\n        'promise': promise,\n        'resolve': resolver,\n        'reject': rejecter\n    };\n};\n\nconst abortablePromiseWithExtractedComponents = (abortHandler) => {\n    let resolver;\n    let rejecter;\n    if (!abortHandler) {\n        abortHandler = () => {};\n    }\n    const promise = new AbortablePromise((resolve, reject) => {\n        resolver = resolve;\n        rejecter = reject;\n    }, abortHandler);\n    return {\n        'promise': promise,\n        'resolve': resolver,\n        'reject': rejecter\n    };\n};\n\nclass Semver {\n    constructor(major, minor, patch) {\n        this.major = major;\n        this.minor = minor;\n        this.patch = patch;\n    }\n\n    toString() {\n        return `${this.major}_${this.minor}_${this.patch}`;\n    }\n}\n\nfunction isIOS() {\n    const ua = navigator.userAgent;\n    return ua.indexOf('iPhone') > 0 || ua.indexOf('iPad') > 0;\n}\n\nfunction getIOSSemever() {\n    if (isIOS()) {\n        const extract = navigator.userAgent.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n        return new Semver(\n            parseInt(extract[1] || 0, 10),\n            parseInt(extract[2] || 0, 10),\n            parseInt(extract[3] || 0, 10)\n        );\n    } else {\n        return null; // or [0,0,0]\n    }\n}\n\nconst BASE_COMPONENT_COUNT = 14;\n\nclass UncompressedSplatArray {\n\n    static OFFSET = {\n        X: 0,\n        Y: 1,\n        Z: 2,\n        SCALE0: 3,\n        SCALE1: 4,\n        SCALE2: 5,\n        ROTATION0: 6,\n        ROTATION1: 7,\n        ROTATION2: 8,\n        ROTATION3: 9,\n        FDC0: 10,\n        FDC1: 11,\n        FDC2: 12,\n        OPACITY: 13,\n        FRC0: 14,\n        FRC1: 15,\n        FRC2: 16,\n        FRC3: 17,\n        FRC4: 18,\n        FRC5: 19,\n        FRC6: 20,\n        FRC7: 21,\n        FRC8: 22,\n        FRC9: 23,\n        FRC10: 24,\n        FRC11: 25,\n        FRC12: 26,\n        FRC13: 27,\n        FRC14: 28,\n        FRC15: 29,\n        FRC16: 30,\n        FRC17: 31,\n        FRC18: 32,\n        FRC19: 33,\n        FRC20: 34,\n        FRC21: 35,\n        FRC22: 36,\n        FRC23: 37\n    };\n\n    constructor(sphericalHarmonicsDegree = 0) {\n        this.sphericalHarmonicsDegree = sphericalHarmonicsDegree;\n        this.sphericalHarmonicsCount = getSphericalHarmonicsComponentCountForDegree(this.sphericalHarmonicsDegree);\n        this.componentCount = this.sphericalHarmonicsCount + BASE_COMPONENT_COUNT;\n        this.defaultSphericalHarmonics = new Array(this.sphericalHarmonicsCount).fill(0);\n        this.splats = [];\n        this.splatCount = 0;\n    }\n\n    static createSplat(sphericalHarmonicsDegree = 0) {\n        const baseSplat = [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];\n        let shEntries = getSphericalHarmonicsComponentCountForDegree(sphericalHarmonicsDegree);\n        for (let i = 0; i < shEntries; i++) baseSplat.push(0);\n        return baseSplat;\n    }\n\n    addSplat(splat) {\n        this.splats.push(splat);\n        this.splatCount++;\n    }\n\n    getSplat(index) {\n        return this.splats[index];\n    }\n\n    addDefaultSplat() {\n        const newSplat = UncompressedSplatArray.createSplat(this.sphericalHarmonicsDegree);\n        this.addSplat(newSplat);\n        return newSplat;\n    }\n\n    addSplatFromComonents(x, y, z, scale0, scale1, scale2, rot0, rot1, rot2, rot3, r, g, b, opacity, ...rest) {\n        const newSplat = [x, y, z, scale0, scale1, scale2, rot0, rot1, rot2, rot3, r, g, b, opacity, ...this.defaultSphericalHarmonics];\n        for (let i = 0; i < rest.length && i < this.sphericalHarmonicsCount; i++) {\n            newSplat[i] = rest[i];\n        }\n        this.addSplat(newSplat);\n        return newSplat;\n    }\n\n    addSplatFromArray(src, srcIndex) {\n        const srcSplat = src.splats[srcIndex];\n        const newSplat = UncompressedSplatArray.createSplat(this.sphericalHarmonicsDegree);\n        for (let i = 0; i < this.componentCount && i < srcSplat.length; i++) {\n            newSplat[i] = srcSplat[i];\n        }\n        this.addSplat(newSplat);\n    }\n}\n\nclass Constants {\n\n    static DefaultSplatSortDistanceMapPrecision = 16;\n    static MemoryPageSize = 65536;\n    static BytesPerFloat = 4;\n    static BytesPerInt = 4;\n    static MaxScenes = 32;\n    static ProgressiveLoadSectionSize = 262144;\n    static ProgressiveLoadSectionDelayDuration = 15;\n    static SphericalHarmonics8BitCompressionRange = 3;\n}\n\nconst DefaultSphericalHarmonics8BitCompressionRange = Constants.SphericalHarmonics8BitCompressionRange;\nconst DefaultSphericalHarmonics8BitCompressionHalfRange = DefaultSphericalHarmonics8BitCompressionRange / 2.0;\n\nconst toHalfFloat = THREE.DataUtils.toHalfFloat.bind(THREE.DataUtils);\nconst fromHalfFloat$1 = THREE.DataUtils.fromHalfFloat.bind(THREE.DataUtils);\n\nconst toUncompressedFloat = (f, compressionLevel, isSH = false, range8BitMin, range8BitMax) => {\n    if (compressionLevel === 0) {\n        return f;\n    } else if (compressionLevel === 1 || compressionLevel === 2 && !isSH) {\n        return THREE.DataUtils.fromHalfFloat(f);\n    } else if (compressionLevel === 2) {\n        return fromUint8(f, range8BitMin, range8BitMax);\n    }\n};\n\nconst toUint8 = (v, rangeMin, rangeMax) => {\n    v = clamp(v, rangeMin, rangeMax);\n    const range = (rangeMax - rangeMin);\n    return clamp(Math.floor((v - rangeMin) / range * 255), 0, 255);\n};\n\nconst fromUint8 = (v, rangeMin, rangeMax) => {\n    const range = (rangeMax - rangeMin);\n    return (v / 255 * range + rangeMin);\n};\n\nconst fromHalfFloatToUint8 = (v, rangeMin, rangeMax) => {\n    return toUint8(fromHalfFloat$1(v, rangeMin, rangeMax));\n};\n\nconst fromUint8ToHalfFloat = (v, rangeMin, rangeMax) => {\n    return toHalfFloat(fromUint8(v, rangeMin, rangeMax));\n};\n\nconst dataViewFloatForCompressionLevel = (dataView, floatIndex, compressionLevel, isSH = false) => {\n    if (compressionLevel === 0) {\n        return dataView.getFloat32(floatIndex * 4, true);\n    } else if (compressionLevel === 1 || compressionLevel === 2 && !isSH) {\n        return dataView.getUint16(floatIndex * 2, true);\n    } else {\n        return dataView.getUint8(floatIndex, true);\n    }\n};\n\nconst convertBetweenCompressionLevels = function() {\n\n    const noop = (v) => v;\n\n    return function(val, fromLevel, toLevel, isSH = false) {\n        if (fromLevel === toLevel) return val;\n        let outputConversionFunc = noop;\n\n        if (fromLevel === 2 && isSH) {\n            if (toLevel === 1) outputConversionFunc = fromUint8ToHalfFloat;\n            else if (toLevel == 0) {\n                outputConversionFunc = fromUint8;\n            }\n        } else if (fromLevel === 2 || fromLevel === 1) {\n            if (toLevel === 0) outputConversionFunc = fromHalfFloat$1;\n            else if (toLevel == 2) {\n                if (!isSH) outputConversionFunc = noop;\n                else outputConversionFunc = fromHalfFloatToUint8;\n            }\n        } else if (fromLevel === 0) {\n            if (toLevel === 1) outputConversionFunc = toHalfFloat;\n            else if (toLevel == 2) {\n                if (!isSH) outputConversionFunc = toHalfFloat;\n                else outputConversionFunc = toUint8;\n            }\n        }\n\n        return outputConversionFunc(val);\n    };\n\n}();\n\nconst copyBetweenBuffers = (srcBuffer, srcOffset, destBuffer, destOffset, byteCount = 0) => {\n    const src = new Uint8Array(srcBuffer, srcOffset);\n    const dest = new Uint8Array(destBuffer, destOffset);\n    for (let i = 0; i < byteCount; i++) {\n        dest[i] = src[i];\n    }\n};\n\n/**\n * SplatBuffer: Container for splat data from a single scene/file and capable of (mediocre) compression.\n */\nclass SplatBuffer {\n\n    static CurrentMajorVersion = 0;\n    static CurrentMinorVersion = 1;\n\n    static CenterComponentCount = 3;\n    static ScaleComponentCount = 3;\n    static RotationComponentCount = 4;\n    static ColorComponentCount = 4;\n    static CovarianceComponentCount = 6;\n\n    static SplatScaleOffsetFloat = 3;\n    static SplatRotationOffsetFloat = 6;\n\n    static CompressionLevels = {\n        0: {\n            BytesPerCenter: 12,\n            BytesPerScale: 12,\n            BytesPerRotation: 16,\n            BytesPerColor: 4,\n            ScaleOffsetBytes: 12,\n            RotationffsetBytes: 24,\n            ColorOffsetBytes: 40,\n            SphericalHarmonicsOffsetBytes: 44,\n            ScaleRange: 1,\n            BytesPerSphericalHarmonicsComponent: 4,\n            SphericalHarmonicsOffsetFloat: 11,\n            SphericalHarmonicsDegrees: {\n                0: { BytesPerSplat: 44 },\n                1: { BytesPerSplat: 80 },\n                2: { BytesPerSplat: 140 }\n            },\n        },\n        1: {\n            BytesPerCenter: 6,\n            BytesPerScale: 6,\n            BytesPerRotation: 8,\n            BytesPerColor: 4,\n            ScaleOffsetBytes: 6,\n            RotationffsetBytes: 12,\n            ColorOffsetBytes: 20,\n            SphericalHarmonicsOffsetBytes: 24,\n            ScaleRange: 32767,\n            BytesPerSphericalHarmonicsComponent: 2,\n            SphericalHarmonicsOffsetFloat: 12,\n            SphericalHarmonicsDegrees: {\n                0: { BytesPerSplat: 24 },\n                1: { BytesPerSplat: 42 },\n                2: { BytesPerSplat: 72 }\n            },\n        },\n        2: {\n            BytesPerCenter: 6,\n            BytesPerScale: 6,\n            BytesPerRotation: 8,\n            BytesPerColor: 4,\n            ScaleOffsetBytes: 6,\n            RotationffsetBytes: 12,\n            ColorOffsetBytes: 20,\n            SphericalHarmonicsOffsetBytes: 24,\n            ScaleRange: 32767,\n            BytesPerSphericalHarmonicsComponent: 1,\n            SphericalHarmonicsOffsetFloat: 12,\n            SphericalHarmonicsDegrees: {\n                0: { BytesPerSplat: 24 },\n                1: { BytesPerSplat: 33 },\n                2: { BytesPerSplat: 48 }\n            },\n        }\n    };\n\n    static CovarianceSizeFloats = 6;\n\n    static HeaderSizeBytes = 4096;\n    static SectionHeaderSizeBytes = 1024;\n\n    static BucketStorageSizeBytes = 12;\n    static BucketStorageSizeFloats = 3;\n\n    static BucketBlockSize = 5.0;\n    static BucketSize = 256;\n\n    constructor(bufferData, secLoadedCountsToMax = true) {\n        this.constructFromBuffer(bufferData, secLoadedCountsToMax);\n    }\n\n    getSplatCount() {\n        return this.splatCount;\n    }\n\n    getMaxSplatCount() {\n        return this.maxSplatCount;\n    }\n\n    getMinSphericalHarmonicsDegree() {\n        let minSphericalHarmonicsDegree = 0;\n        for (let i = 0; i < this.sections.length; i++) {\n            const section = this.sections[i];\n            if (i === 0 || section.sphericalHarmonicsDegree < minSphericalHarmonicsDegree) {\n                minSphericalHarmonicsDegree = section.sphericalHarmonicsDegree;\n            }\n        }\n        return minSphericalHarmonicsDegree;\n    }\n\n    getBucketIndex(section, localSplatIndex) {\n        let bucketIndex;\n        const maxSplatIndexInFullBuckets = section.fullBucketCount * section.bucketSize;\n        if (localSplatIndex < maxSplatIndexInFullBuckets) {\n            bucketIndex = Math.floor(localSplatIndex / section.bucketSize);\n        } else {\n            let bucketSplatIndex = maxSplatIndexInFullBuckets;\n            bucketIndex = section.fullBucketCount;\n            let partiallyFullBucketIndex = 0;\n            while (bucketSplatIndex < section.splatCount) {\n                let currentPartiallyFilledBucketSize = section.partiallyFilledBucketLengths[partiallyFullBucketIndex];\n                if (localSplatIndex >= bucketSplatIndex && localSplatIndex < bucketSplatIndex + currentPartiallyFilledBucketSize) {\n                    break;\n                }\n                bucketSplatIndex += currentPartiallyFilledBucketSize;\n                bucketIndex++;\n                partiallyFullBucketIndex++;\n            }\n        }\n        return bucketIndex;\n    }\n\n    getSplatCenter(globalSplatIndex, outCenter, transform) {\n        const sectionIndex = this.globalSplatIndexToSectionMap[globalSplatIndex];\n        const section = this.sections[sectionIndex];\n        const localSplatIndex = globalSplatIndex - section.splatCountOffset;\n\n        const srcSplatCentersBase = section.bytesPerSplat * localSplatIndex;\n        const dataView = new DataView(this.bufferData, section.dataBase + srcSplatCentersBase);\n\n        const x = dataViewFloatForCompressionLevel(dataView, 0, this.compressionLevel);\n        const y = dataViewFloatForCompressionLevel(dataView, 1, this.compressionLevel);\n        const z = dataViewFloatForCompressionLevel(dataView, 2, this.compressionLevel);\n        if (this.compressionLevel >= 1) {\n            const bucketIndex = this.getBucketIndex(section, localSplatIndex);\n            const bucketBase = bucketIndex * SplatBuffer.BucketStorageSizeFloats;\n            const sf = section.compressionScaleFactor;\n            const sr = section.compressionScaleRange;\n            outCenter.x = (x - sr) * sf + section.bucketArray[bucketBase];\n            outCenter.y = (y - sr) * sf + section.bucketArray[bucketBase + 1];\n            outCenter.z = (z - sr) * sf + section.bucketArray[bucketBase + 2];\n        } else {\n            outCenter.x = x;\n            outCenter.y = y;\n            outCenter.z = z;\n        }\n        if (transform) outCenter.applyMatrix4(transform);\n    }\n\n    getSplatScaleAndRotation = function() {\n\n        const scaleMatrix = new THREE.Matrix4();\n        const rotationMatrix = new THREE.Matrix4();\n        const tempMatrix = new THREE.Matrix4();\n        const tempPosition = new THREE.Vector3();\n        const scale = new THREE.Vector3();\n        const rotation = new THREE.Quaternion();\n\n        return function(index, outScale, outRotation, transform, scaleOverride) {\n            const sectionIndex = this.globalSplatIndexToSectionMap[index];\n            const section = this.sections[sectionIndex];\n            const localSplatIndex = index - section.splatCountOffset;\n\n            const srcSplatScalesBase = section.bytesPerSplat * localSplatIndex +\n                                       SplatBuffer.CompressionLevels[this.compressionLevel].ScaleOffsetBytes;\n\n            const dataView = new DataView(this.bufferData, section.dataBase + srcSplatScalesBase);\n\n            scale.set(toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 0, this.compressionLevel), this.compressionLevel),\n                      toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 1, this.compressionLevel), this.compressionLevel),\n                      toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 2, this.compressionLevel), this.compressionLevel));\n            if (scaleOverride) {\n                if (scaleOverride.x !== undefined) scale.x = scaleOverride.x;\n                if (scaleOverride.y !== undefined) scale.y = scaleOverride.y;\n                if (scaleOverride.z !== undefined) scale.z = scaleOverride.z;\n            }\n\n            rotation.set(toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 4, this.compressionLevel), this.compressionLevel),\n                         toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 5, this.compressionLevel), this.compressionLevel),\n                         toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 6, this.compressionLevel), this.compressionLevel),\n                         toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 3, this.compressionLevel), this.compressionLevel));\n\n            if (transform) {\n                scaleMatrix.makeScale(scale.x, scale.y, scale.z);\n                rotationMatrix.makeRotationFromQuaternion(rotation);\n                tempMatrix.copy(scaleMatrix).multiply(rotationMatrix).multiply(transform);\n                tempMatrix.decompose(tempPosition, outRotation, outScale);\n            } else {\n                outScale.copy(scale);\n                outRotation.copy(rotation);\n            }\n        };\n\n    }();\n\n    getSplatColor(globalSplatIndex, outColor) {\n        const sectionIndex = this.globalSplatIndexToSectionMap[globalSplatIndex];\n        const section = this.sections[sectionIndex];\n        const localSplatIndex = globalSplatIndex - section.splatCountOffset;\n\n        const srcSplatColorsBase = section.bytesPerSplat * localSplatIndex +\n                                   SplatBuffer.CompressionLevels[this.compressionLevel].ColorOffsetBytes;\n        const splatColorsArray = new Uint8Array(this.bufferData, section.dataBase + srcSplatColorsBase, 4);\n\n        outColor.set(splatColorsArray[0], splatColorsArray[1],\n                     splatColorsArray[2], splatColorsArray[3]);\n    }\n\n    fillSplatCenterArray(outCenterArray, transform, srcFrom, srcTo, destFrom) {\n        const splatCount = this.splatCount;\n\n        srcFrom = srcFrom || 0;\n        srcTo = srcTo || splatCount - 1;\n        if (destFrom === undefined) destFrom = srcFrom;\n\n        const center = new THREE.Vector3();\n        for (let i = srcFrom; i <= srcTo; i++) {\n            const sectionIndex = this.globalSplatIndexToSectionMap[i];\n            const section = this.sections[sectionIndex];\n            const localSplatIndex = i - section.splatCountOffset;\n            const centerDestBase = (i - srcFrom + destFrom) * SplatBuffer.CenterComponentCount;\n\n            const srcSplatCentersBase = section.bytesPerSplat * localSplatIndex;\n            const dataView = new DataView(this.bufferData, section.dataBase + srcSplatCentersBase);\n\n            const x = dataViewFloatForCompressionLevel(dataView, 0, this.compressionLevel);\n            const y = dataViewFloatForCompressionLevel(dataView, 1, this.compressionLevel);\n            const z = dataViewFloatForCompressionLevel(dataView, 2, this.compressionLevel);\n            if (this.compressionLevel >= 1) {\n                const bucketIndex = this.getBucketIndex(section, localSplatIndex);\n                const bucketBase = bucketIndex * SplatBuffer.BucketStorageSizeFloats;\n                const sf = section.compressionScaleFactor;\n                const sr = section.compressionScaleRange;\n                center.x = (x - sr) * sf + section.bucketArray[bucketBase];\n                center.y = (y - sr) * sf + section.bucketArray[bucketBase + 1];\n                center.z = (z - sr) * sf + section.bucketArray[bucketBase + 2];\n            } else {\n                center.x = x;\n                center.y = y;\n                center.z = z;\n            }\n            if (transform) {\n                center.applyMatrix4(transform);\n            }\n            outCenterArray[centerDestBase] = center.x;\n            outCenterArray[centerDestBase + 1] = center.y;\n            outCenterArray[centerDestBase + 2] = center.z;\n        }\n    }\n\n    fillSplatScaleRotationArray = function() {\n\n        const scaleMatrix = new THREE.Matrix4();\n        const rotationMatrix = new THREE.Matrix4();\n        const tempMatrix = new THREE.Matrix4();\n        const scale = new THREE.Vector3();\n        const rotation = new THREE.Quaternion();\n        const tempPosition = new THREE.Vector3();\n\n        const ensurePositiveW = (quaternion) => {\n            const flip = quaternion.w < 0 ? -1 : 1;\n            quaternion.x *= flip;\n            quaternion.y *= flip;\n            quaternion.z *= flip;\n            quaternion.w *= flip;\n        };\n\n        return function(outScaleArray, outRotationArray, transform, srcFrom, srcTo, destFrom,\n                        desiredOutputCompressionLevel, scaleOverride) {\n            const splatCount = this.splatCount;\n\n            srcFrom = srcFrom || 0;\n            srcTo = srcTo || splatCount - 1;\n            if (destFrom === undefined) destFrom = srcFrom;\n\n            const outputConversion = (value, srcCompressionLevel) => {\n                if (srcCompressionLevel === undefined) srcCompressionLevel = this.compressionLevel;\n                return convertBetweenCompressionLevels(value, srcCompressionLevel, desiredOutputCompressionLevel);\n            };\n\n            for (let i = srcFrom; i <= srcTo; i++) {\n                const sectionIndex = this.globalSplatIndexToSectionMap[i];\n                const section = this.sections[sectionIndex];\n                const localSplatIndex = i - section.splatCountOffset;\n\n                const srcSplatScalesBase = section.bytesPerSplat * localSplatIndex +\n                                        SplatBuffer.CompressionLevels[this.compressionLevel].ScaleOffsetBytes;\n\n                const scaleDestBase = (i - srcFrom + destFrom) * SplatBuffer.ScaleComponentCount;\n                const rotationDestBase = (i - srcFrom + destFrom) * SplatBuffer.RotationComponentCount;\n                const dataView = new DataView(this.bufferData, section.dataBase + srcSplatScalesBase);\n\n                const srcScaleX = (scaleOverride && scaleOverride.x !== undefined) ? scaleOverride.x :\n                                   dataViewFloatForCompressionLevel(dataView, 0, this.compressionLevel);\n                const srcScaleY = (scaleOverride && scaleOverride.y !== undefined) ? scaleOverride.y :\n                                   dataViewFloatForCompressionLevel(dataView, 1, this.compressionLevel);\n                const srcScaleZ = (scaleOverride && scaleOverride.z !== undefined) ? scaleOverride.z :\n                                   dataViewFloatForCompressionLevel(dataView, 2, this.compressionLevel);\n\n                const srcRotationW = dataViewFloatForCompressionLevel(dataView, 3, this.compressionLevel);\n                const srcRotationX = dataViewFloatForCompressionLevel(dataView, 4, this.compressionLevel);\n                const srcRotationY = dataViewFloatForCompressionLevel(dataView, 5, this.compressionLevel);\n                const srcRotationZ = dataViewFloatForCompressionLevel(dataView, 6, this.compressionLevel);\n\n                scale.set(toUncompressedFloat(srcScaleX, this.compressionLevel),\n                          toUncompressedFloat(srcScaleY, this.compressionLevel),\n                          toUncompressedFloat(srcScaleZ, this.compressionLevel));\n\n                rotation.set(toUncompressedFloat(srcRotationX, this.compressionLevel),\n                             toUncompressedFloat(srcRotationY, this.compressionLevel),\n                             toUncompressedFloat(srcRotationZ, this.compressionLevel),\n                             toUncompressedFloat(srcRotationW, this.compressionLevel)).normalize();\n\n                if (transform) {\n                    tempPosition.set(0, 0, 0);\n                    scaleMatrix.makeScale(scale.x, scale.y, scale.z);\n                    rotationMatrix.makeRotationFromQuaternion(rotation);\n                    tempMatrix.identity().premultiply(scaleMatrix).premultiply(rotationMatrix);\n                    tempMatrix.premultiply(transform);\n                    tempMatrix.decompose(tempPosition, rotation, scale);\n                    rotation.normalize();\n                }\n\n                ensurePositiveW(rotation);\n\n                if (outScaleArray) {\n                    outScaleArray[scaleDestBase] = outputConversion(scale.x, 0);\n                    outScaleArray[scaleDestBase + 1] = outputConversion(scale.y, 0);\n                    outScaleArray[scaleDestBase + 2] = outputConversion(scale.z, 0);\n                }\n\n                if (outRotationArray) {\n                    outRotationArray[rotationDestBase] = outputConversion(rotation.x, 0);\n                    outRotationArray[rotationDestBase + 1] = outputConversion(rotation.y, 0);\n                    outRotationArray[rotationDestBase + 2] = outputConversion(rotation.z, 0);\n                    outRotationArray[rotationDestBase + 3] = outputConversion(rotation.w, 0);\n                }\n            }\n        };\n    }();\n\n    static computeCovariance = function() {\n\n        const tempMatrix4 = new THREE.Matrix4();\n        const scaleMatrix = new THREE.Matrix3();\n        const rotationMatrix = new THREE.Matrix3();\n        const covarianceMatrix = new THREE.Matrix3();\n        const transformedCovariance = new THREE.Matrix3();\n        const transform3x3 = new THREE.Matrix3();\n        const transform3x3Transpose = new THREE.Matrix3();\n\n        return function(scale, rotation, transform, outCovariance, outOffset = 0, desiredOutputCompressionLevel) {\n\n            tempMatrix4.makeScale(scale.x, scale.y, scale.z);\n            scaleMatrix.setFromMatrix4(tempMatrix4);\n\n            tempMatrix4.makeRotationFromQuaternion(rotation);\n            rotationMatrix.setFromMatrix4(tempMatrix4);\n\n            covarianceMatrix.copy(rotationMatrix).multiply(scaleMatrix);\n            transformedCovariance.copy(covarianceMatrix).transpose().premultiply(covarianceMatrix);\n\n            if (transform) {\n                transform3x3.setFromMatrix4(transform);\n                transform3x3Transpose.copy(transform3x3).transpose();\n                transformedCovariance.multiply(transform3x3Transpose);\n                transformedCovariance.premultiply(transform3x3);\n            }\n\n            if (desiredOutputCompressionLevel >= 1) {\n                outCovariance[outOffset] = toHalfFloat(transformedCovariance.elements[0]);\n                outCovariance[outOffset + 1] = toHalfFloat(transformedCovariance.elements[3]);\n                outCovariance[outOffset + 2] = toHalfFloat(transformedCovariance.elements[6]);\n                outCovariance[outOffset + 3] = toHalfFloat(transformedCovariance.elements[4]);\n                outCovariance[outOffset + 4] = toHalfFloat(transformedCovariance.elements[7]);\n                outCovariance[outOffset + 5] = toHalfFloat(transformedCovariance.elements[8]);\n            } else {\n                outCovariance[outOffset] = transformedCovariance.elements[0];\n                outCovariance[outOffset + 1] = transformedCovariance.elements[3];\n                outCovariance[outOffset + 2] = transformedCovariance.elements[6];\n                outCovariance[outOffset + 3] = transformedCovariance.elements[4];\n                outCovariance[outOffset + 4] = transformedCovariance.elements[7];\n                outCovariance[outOffset + 5] = transformedCovariance.elements[8];\n            }\n\n        };\n\n    }();\n\n    fillSplatCovarianceArray(covarianceArray, transform, srcFrom, srcTo, destFrom, desiredOutputCompressionLevel) {\n        const splatCount = this.splatCount;\n\n        const scale = new THREE.Vector3();\n        const rotation = new THREE.Quaternion();\n\n        srcFrom = srcFrom || 0;\n        srcTo = srcTo || splatCount - 1;\n        if (destFrom === undefined) destFrom = srcFrom;\n\n        for (let i = srcFrom; i <= srcTo; i++) {\n            const sectionIndex = this.globalSplatIndexToSectionMap[i];\n            const section = this.sections[sectionIndex];\n            const localSplatIndex = i - section.splatCountOffset;\n\n            const covarianceDestBase = (i - srcFrom + destFrom) * SplatBuffer.CovarianceComponentCount;\n            const srcSplatScalesBase = section.bytesPerSplat * localSplatIndex +\n                                       SplatBuffer.CompressionLevels[this.compressionLevel].ScaleOffsetBytes;\n\n            const dataView = new DataView(this.bufferData, section.dataBase + srcSplatScalesBase);\n\n            scale.set(toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 0, this.compressionLevel), this.compressionLevel),\n                      toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 1, this.compressionLevel), this.compressionLevel),\n                      toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 2, this.compressionLevel), this.compressionLevel));\n\n            rotation.set(toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 4, this.compressionLevel), this.compressionLevel),\n                         toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 5, this.compressionLevel), this.compressionLevel),\n                         toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 6, this.compressionLevel), this.compressionLevel),\n                         toUncompressedFloat(dataViewFloatForCompressionLevel(dataView, 3, this.compressionLevel), this.compressionLevel));\n\n            SplatBuffer.computeCovariance(scale, rotation, transform, covarianceArray, covarianceDestBase, desiredOutputCompressionLevel);\n        }\n    }\n\n    fillSplatColorArray(outColorArray, minimumAlpha, srcFrom, srcTo, destFrom) {\n        const splatCount = this.splatCount;\n\n        srcFrom = srcFrom || 0;\n        srcTo = srcTo || splatCount - 1;\n        if (destFrom === undefined) destFrom = srcFrom;\n\n        for (let i = srcFrom; i <= srcTo; i++) {\n\n            const sectionIndex = this.globalSplatIndexToSectionMap[i];\n            const section = this.sections[sectionIndex];\n            const localSplatIndex = i - section.splatCountOffset;\n\n            const colorDestBase = (i - srcFrom + destFrom) * SplatBuffer.ColorComponentCount;\n            const srcSplatColorsBase = section.bytesPerSplat * localSplatIndex +\n                                       SplatBuffer.CompressionLevels[this.compressionLevel].ColorOffsetBytes;\n\n            const dataView = new Uint8Array(this.bufferData, section.dataBase + srcSplatColorsBase);\n\n            let alpha = dataView[3];\n            alpha = (alpha >= minimumAlpha) ? alpha : 0;\n\n            outColorArray[colorDestBase] = dataView[0];\n            outColorArray[colorDestBase + 1] = dataView[1];\n            outColorArray[colorDestBase + 2] = dataView[2];\n            outColorArray[colorDestBase + 3] = alpha;\n        }\n    }\n\n    fillSphericalHarmonicsArray = function() {\n\n        const sphericalHarmonicVectors = [];\n        for (let i = 0; i < 15; i++) {\n            sphericalHarmonicVectors[i] = new THREE.Vector3();\n        }\n\n        const tempMatrix3 = new THREE.Matrix3();\n        const tempMatrix4 = new THREE.Matrix4();\n\n        const tempTranslation = new THREE.Vector3();\n        const tempScale = new THREE.Vector3();\n        const tempRotation = new THREE.Quaternion();\n\n        const sh11 = [];\n        const sh12 = [];\n        const sh13 = [];\n\n        const sh21 = [];\n        const sh22 = [];\n        const sh23 = [];\n        const sh24 = [];\n        const sh25 = [];\n\n        const shIn1 = [];\n        const shIn2 = [];\n        const shIn3 = [];\n        const shIn4 = [];\n        const shIn5 = [];\n\n        const shOut1 = [];\n        const shOut2 = [];\n        const shOut3 = [];\n        const shOut4 = [];\n        const shOut5 = [];\n\n        const noop = (v) => v;\n\n        const set3 = (array, val1, val2, val3) => {\n            array[0] = val1;\n            array[1] = val2;\n            array[2] = val3;\n        };\n\n        const set3FromArray = (array, srcDestView, stride, srcBase, compressionLevel) => {\n            array[0] = dataViewFloatForCompressionLevel(srcDestView, srcBase, compressionLevel, true);\n            array[1] = dataViewFloatForCompressionLevel(srcDestView, srcBase + stride, compressionLevel, true);\n            array[2] = dataViewFloatForCompressionLevel(srcDestView, srcBase + stride + stride, compressionLevel, true);\n        };\n\n        const copy3 = (srcArray, destArray) => {\n            destArray[0] = srcArray[0];\n            destArray[1] = srcArray[1];\n            destArray[2] = srcArray[2];\n        };\n\n        const setOutput3 = (srcArray, destArray, destBase, conversionFunc) => {\n            destArray[destBase] = conversionFunc(srcArray[0]);\n            destArray[destBase + 1] = conversionFunc(srcArray[1]);\n            destArray[destBase + 2] = conversionFunc(srcArray[2]);\n        };\n\n        const toUncompressedFloatArray3 = (src, dest, compressionLevel, range8BitMin, range8BitMax) => {\n            dest[0] = toUncompressedFloat(src[0], compressionLevel, true, range8BitMin, range8BitMax);\n            dest[1] = toUncompressedFloat(src[1], compressionLevel, true, range8BitMin, range8BitMax);\n            dest[2] = toUncompressedFloat(src[2], compressionLevel, true, range8BitMin, range8BitMax);\n            return dest;\n        };\n\n        return function(outSphericalHarmonicsArray, outSphericalHarmonicsDegree, transform,\n                        srcFrom, srcTo, destFrom, desiredOutputCompressionLevel) {\n            const splatCount = this.splatCount;\n\n            srcFrom = srcFrom || 0;\n            srcTo = srcTo || splatCount - 1;\n            if (destFrom === undefined) destFrom = srcFrom;\n\n            if (transform && outSphericalHarmonicsDegree >= 1) {\n                tempMatrix4.copy(transform);\n                tempMatrix4.decompose(tempTranslation, tempRotation, tempScale);\n                tempRotation.normalize();\n                tempMatrix4.makeRotationFromQuaternion(tempRotation);\n                tempMatrix3.setFromMatrix4(tempMatrix4);\n                set3(sh11, tempMatrix3.elements[4], -tempMatrix3.elements[7], tempMatrix3.elements[1]);\n                set3(sh12, -tempMatrix3.elements[5], tempMatrix3.elements[8], -tempMatrix3.elements[2]);\n                set3(sh13, tempMatrix3.elements[3], -tempMatrix3.elements[6], tempMatrix3.elements[0]);\n            }\n\n            const localFromHalfFloatToUint8 = (v) => {\n                return fromHalfFloatToUint8(v, this.minSphericalHarmonicsCoeff, this.maxSphericalHarmonicsCoeff);\n            };\n\n            const localToUint8 = (v) => {\n                return toUint8(v, this.minSphericalHarmonicsCoeff, this.maxSphericalHarmonicsCoeff);\n            };\n\n            for (let i = srcFrom; i <= srcTo; i++) {\n\n                const sectionIndex = this.globalSplatIndexToSectionMap[i];\n                const section = this.sections[sectionIndex];\n                outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, section.sphericalHarmonicsDegree);\n                const outSphericalHarmonicsComponentsCount = getSphericalHarmonicsComponentCountForDegree(outSphericalHarmonicsDegree);\n\n                const localSplatIndex = i - section.splatCountOffset;\n\n                const srcSplatSHBase = section.bytesPerSplat * localSplatIndex +\n                                       SplatBuffer.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes;\n\n                const dataView = new DataView(this.bufferData, section.dataBase + srcSplatSHBase);\n\n                const shDestBase = (i - srcFrom + destFrom) * outSphericalHarmonicsComponentsCount;\n\n                let compressionLevelForOutputConversion = transform ? 0 : this.compressionLevel;\n                let outputConversionFunc = noop;\n                if (compressionLevelForOutputConversion !== desiredOutputCompressionLevel) {\n                    if (compressionLevelForOutputConversion === 1) {\n                        if (desiredOutputCompressionLevel === 0) outputConversionFunc = fromHalfFloat$1;\n                        else if (desiredOutputCompressionLevel == 2) outputConversionFunc = localFromHalfFloatToUint8;\n                    } else if (compressionLevelForOutputConversion === 0) {\n                        if (desiredOutputCompressionLevel === 1) outputConversionFunc = toHalfFloat;\n                        else if (desiredOutputCompressionLevel == 2) outputConversionFunc = localToUint8;\n                    }\n                }\n\n                const minShCoeff = this.minSphericalHarmonicsCoeff;\n                const maxShCoeff = this.maxSphericalHarmonicsCoeff;\n\n                if (outSphericalHarmonicsDegree >= 1) {\n\n                    set3FromArray(shIn1, dataView, 3, 0, this.compressionLevel);\n                    set3FromArray(shIn2, dataView, 3, 1, this.compressionLevel);\n                    set3FromArray(shIn3, dataView, 3, 2, this.compressionLevel);\n\n                    if (transform) {\n                        toUncompressedFloatArray3(shIn1, shIn1, this.compressionLevel, minShCoeff, maxShCoeff);\n                        toUncompressedFloatArray3(shIn2, shIn2, this.compressionLevel, minShCoeff, maxShCoeff);\n                        toUncompressedFloatArray3(shIn3, shIn3, this.compressionLevel, minShCoeff, maxShCoeff);\n                        SplatBuffer.rotateSphericalHarmonics3(shIn1, shIn2, shIn3, sh11, sh12, sh13, shOut1, shOut2, shOut3);\n                    } else {\n                        copy3(shIn1, shOut1);\n                        copy3(shIn2, shOut2);\n                        copy3(shIn3, shOut3);\n                    }\n\n                    setOutput3(shOut1, outSphericalHarmonicsArray, shDestBase, outputConversionFunc);\n                    setOutput3(shOut2, outSphericalHarmonicsArray, shDestBase + 3, outputConversionFunc);\n                    setOutput3(shOut3, outSphericalHarmonicsArray, shDestBase + 6, outputConversionFunc);\n\n                    if (outSphericalHarmonicsDegree >= 2) {\n\n                        set3FromArray(shIn1, dataView, 5, 9, this.compressionLevel);\n                        set3FromArray(shIn2, dataView, 5, 10, this.compressionLevel);\n                        set3FromArray(shIn3, dataView, 5, 11, this.compressionLevel);\n                        set3FromArray(shIn4, dataView, 5, 12, this.compressionLevel);\n                        set3FromArray(shIn5, dataView, 5, 13, this.compressionLevel);\n\n                        if (transform) {\n                            toUncompressedFloatArray3(shIn1, shIn1, this.compressionLevel, minShCoeff, maxShCoeff);\n                            toUncompressedFloatArray3(shIn2, shIn2, this.compressionLevel, minShCoeff, maxShCoeff);\n                            toUncompressedFloatArray3(shIn3, shIn3, this.compressionLevel, minShCoeff, maxShCoeff);\n                            toUncompressedFloatArray3(shIn4, shIn4, this.compressionLevel, minShCoeff, maxShCoeff);\n                            toUncompressedFloatArray3(shIn5, shIn5, this.compressionLevel, minShCoeff, maxShCoeff);\n                            SplatBuffer.rotateSphericalHarmonics5(shIn1, shIn2, shIn3, shIn4, shIn5,\n                                                                  sh11, sh12, sh13, sh21, sh22, sh23, sh24, sh25,\n                                                                  shOut1, shOut2, shOut3, shOut4, shOut5);\n                        } else {\n                            copy3(shIn1, shOut1);\n                            copy3(shIn2, shOut2);\n                            copy3(shIn3, shOut3);\n                            copy3(shIn4, shOut4);\n                            copy3(shIn5, shOut5);\n                        }\n\n                        setOutput3(shOut1, outSphericalHarmonicsArray, shDestBase + 9, outputConversionFunc);\n                        setOutput3(shOut2, outSphericalHarmonicsArray, shDestBase + 12, outputConversionFunc);\n                        setOutput3(shOut3, outSphericalHarmonicsArray, shDestBase + 15, outputConversionFunc);\n                        setOutput3(shOut4, outSphericalHarmonicsArray, shDestBase + 18, outputConversionFunc);\n                        setOutput3(shOut5, outSphericalHarmonicsArray, shDestBase + 21, outputConversionFunc);\n                    }\n                }\n            }\n        };\n\n    }();\n\n    static dot3 = (v1, v2, v3, transformRow, outArray) => {\n        outArray[0] = outArray[1] = outArray[2] = 0;\n        const t0 = transformRow[0];\n        const t1 = transformRow[1];\n        const t2 = transformRow[2];\n        SplatBuffer.addInto3(v1[0] * t0, v1[1] * t0, v1[2] * t0, outArray);\n        SplatBuffer.addInto3(v2[0] * t1, v2[1] * t1, v2[2] * t1, outArray);\n        SplatBuffer.addInto3(v3[0] * t2, v3[1] * t2, v3[2] * t2, outArray);\n    };\n\n    static addInto3 = (val1, val2, val3, destArray) => {\n        destArray[0] = destArray[0] + val1;\n        destArray[1] = destArray[1] + val2;\n        destArray[2] = destArray[2] + val3;\n    };\n\n    static dot5 = (v1, v2, v3, v4, v5, transformRow, outArray) => {\n        outArray[0] = outArray[1] = outArray[2] = 0;\n        const t0 = transformRow[0];\n        const t1 = transformRow[1];\n        const t2 = transformRow[2];\n        const t3 = transformRow[3];\n        const t4 = transformRow[4];\n        SplatBuffer.addInto3(v1[0] * t0, v1[1] * t0, v1[2] * t0, outArray);\n        SplatBuffer.addInto3(v2[0] * t1, v2[1] * t1, v2[2] * t1, outArray);\n        SplatBuffer.addInto3(v3[0] * t2, v3[1] * t2, v3[2] * t2, outArray);\n        SplatBuffer.addInto3(v4[0] * t3, v4[1] * t3, v4[2] * t3, outArray);\n        SplatBuffer.addInto3(v5[0] * t4, v5[1] * t4, v5[2] * t4, outArray);\n    };\n\n    static rotateSphericalHarmonics3 = (in1, in2, in3, tsh11, tsh12, tsh13, out1, out2, out3) => {\n        SplatBuffer.dot3(in1, in2, in3, tsh11, out1);\n        SplatBuffer.dot3(in1, in2, in3, tsh12, out2);\n        SplatBuffer.dot3(in1, in2, in3, tsh13, out3);\n    };\n\n    static rotateSphericalHarmonics5 = (in1, in2, in3, in4, in5, tsh11, tsh12, tsh13,\n                                        tsh21, tsh22, tsh23, tsh24, tsh25, out1, out2, out3, out4, out5) => {\n\n        const kSqrt0104 = Math.sqrt(1.0 / 4.0);\n        const kSqrt0304 = Math.sqrt(3.0 / 4.0);\n        const kSqrt0103 = Math.sqrt(1.0 / 3.0);\n        const kSqrt0403 = Math.sqrt(4.0 / 3.0);\n        const kSqrt0112 = Math.sqrt(1.0 / 12.0);\n\n        tsh21[0] = kSqrt0104 * ((tsh13[2] * tsh11[0] + tsh13[0] * tsh11[2]) + (tsh11[2] * tsh13[0] + tsh11[0] * tsh13[2]));\n        tsh21[1] = (tsh13[1] * tsh11[0] + tsh11[1] * tsh13[0]);\n        tsh21[2] = kSqrt0304 * (tsh13[1] * tsh11[1] + tsh11[1] * tsh13[1]);\n        tsh21[3] = (tsh13[1] * tsh11[2] + tsh11[1] * tsh13[2]);\n        tsh21[4] = kSqrt0104 * ((tsh13[2] * tsh11[2] - tsh13[0] * tsh11[0]) + (tsh11[2] * tsh13[2] - tsh11[0] * tsh13[0]));\n        SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh21, out1);\n\n        tsh22[0] = kSqrt0104 * ((tsh12[2] * tsh11[0] + tsh12[0] * tsh11[2]) + (tsh11[2] * tsh12[0] + tsh11[0] * tsh12[2]));\n        tsh22[1] = tsh12[1] * tsh11[0] + tsh11[1] * tsh12[0];\n        tsh22[2] = kSqrt0304 * (tsh12[1] * tsh11[1] + tsh11[1] * tsh12[1]);\n        tsh22[3] = tsh12[1] * tsh11[2] + tsh11[1] * tsh12[2];\n        tsh22[4] = kSqrt0104 * ((tsh12[2] * tsh11[2] - tsh12[0] * tsh11[0]) + (tsh11[2] * tsh12[2] - tsh11[0] * tsh12[0]));\n        SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh22, out2);\n\n        tsh23[0] = kSqrt0103 * (tsh12[2] * tsh12[0] + tsh12[0] * tsh12[2]) + -kSqrt0112 *\n                   ((tsh13[2] * tsh13[0] + tsh13[0] * tsh13[2]) + (tsh11[2] * tsh11[0] + tsh11[0] * tsh11[2]));\n        tsh23[1] = kSqrt0403 * tsh12[1] * tsh12[0] + -kSqrt0103 * (tsh13[1] * tsh13[0] + tsh11[1] * tsh11[0]);\n        tsh23[2] = tsh12[1] * tsh12[1] + -kSqrt0104 * (tsh13[1] * tsh13[1] + tsh11[1] * tsh11[1]);\n        tsh23[3] = kSqrt0403 * tsh12[1] * tsh12[2] + -kSqrt0103 * (tsh13[1] * tsh13[2] + tsh11[1] * tsh11[2]);\n        tsh23[4] = kSqrt0103 * (tsh12[2] * tsh12[2] - tsh12[0] * tsh12[0]) + -kSqrt0112 *\n                   ((tsh13[2] * tsh13[2] - tsh13[0] * tsh13[0]) + (tsh11[2] * tsh11[2] - tsh11[0] * tsh11[0]));\n        SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh23, out3);\n\n        tsh24[0] = kSqrt0104 * ((tsh12[2] * tsh13[0] + tsh12[0] * tsh13[2]) + (tsh13[2] * tsh12[0] + tsh13[0] * tsh12[2]));\n        tsh24[1] = tsh12[1] * tsh13[0] + tsh13[1] * tsh12[0];\n        tsh24[2] = kSqrt0304 * (tsh12[1] * tsh13[1] + tsh13[1] * tsh12[1]);\n        tsh24[3] = tsh12[1] * tsh13[2] + tsh13[1] * tsh12[2];\n        tsh24[4] = kSqrt0104 * ((tsh12[2] * tsh13[2] - tsh12[0] * tsh13[0]) + (tsh13[2] * tsh12[2] - tsh13[0] * tsh12[0]));\n        SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh24, out4);\n\n        tsh25[0] = kSqrt0104 * ((tsh13[2] * tsh13[0] + tsh13[0] * tsh13[2]) - (tsh11[2] * tsh11[0] + tsh11[0] * tsh11[2]));\n        tsh25[1] = (tsh13[1] * tsh13[0] - tsh11[1] * tsh11[0]);\n        tsh25[2] = kSqrt0304 * (tsh13[1] * tsh13[1] - tsh11[1] * tsh11[1]);\n        tsh25[3] = (tsh13[1] * tsh13[2] - tsh11[1] * tsh11[2]);\n        tsh25[4] = kSqrt0104 * ((tsh13[2] * tsh13[2] - tsh13[0] * tsh13[0]) - (tsh11[2] * tsh11[2] - tsh11[0] * tsh11[0]));\n        SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh25, out5);\n    };\n\n    static parseHeader(buffer) {\n        const headerArrayUint8 = new Uint8Array(buffer, 0, SplatBuffer.HeaderSizeBytes);\n        const headerArrayUint16 = new Uint16Array(buffer, 0, SplatBuffer.HeaderSizeBytes / 2);\n        const headerArrayUint32 = new Uint32Array(buffer, 0, SplatBuffer.HeaderSizeBytes / 4);\n        const headerArrayFloat32 = new Float32Array(buffer, 0, SplatBuffer.HeaderSizeBytes / 4);\n        const versionMajor = headerArrayUint8[0];\n        const versionMinor = headerArrayUint8[1];\n        const maxSectionCount = headerArrayUint32[1];\n        const sectionCount = headerArrayUint32[2];\n        const maxSplatCount = headerArrayUint32[3];\n        const splatCount = headerArrayUint32[4];\n        const compressionLevel = headerArrayUint16[10];\n        const sceneCenter = new THREE.Vector3(headerArrayFloat32[6], headerArrayFloat32[7], headerArrayFloat32[8]);\n\n        const minSphericalHarmonicsCoeff = headerArrayFloat32[9] || -DefaultSphericalHarmonics8BitCompressionHalfRange;\n        const maxSphericalHarmonicsCoeff = headerArrayFloat32[10] || DefaultSphericalHarmonics8BitCompressionHalfRange;\n\n        return {\n            versionMajor,\n            versionMinor,\n            maxSectionCount,\n            sectionCount,\n            maxSplatCount,\n            splatCount,\n            compressionLevel,\n            sceneCenter,\n            minSphericalHarmonicsCoeff,\n            maxSphericalHarmonicsCoeff\n        };\n    }\n\n    static writeHeaderCountsToBuffer(sectionCount, splatCount, buffer) {\n        const headerArrayUint32 = new Uint32Array(buffer, 0, SplatBuffer.HeaderSizeBytes / 4);\n        headerArrayUint32[2] = sectionCount;\n        headerArrayUint32[4] = splatCount;\n    }\n\n    static writeHeaderToBuffer(header, buffer) {\n        const headerArrayUint8 = new Uint8Array(buffer, 0, SplatBuffer.HeaderSizeBytes);\n        const headerArrayUint16 = new Uint16Array(buffer, 0, SplatBuffer.HeaderSizeBytes / 2);\n        const headerArrayUint32 = new Uint32Array(buffer, 0, SplatBuffer.HeaderSizeBytes / 4);\n        const headerArrayFloat32 = new Float32Array(buffer, 0, SplatBuffer.HeaderSizeBytes / 4);\n        headerArrayUint8[0] = header.versionMajor;\n        headerArrayUint8[1] = header.versionMinor;\n        headerArrayUint8[2] = 0; // unused for now\n        headerArrayUint8[3] = 0; // unused for now\n        headerArrayUint32[1] = header.maxSectionCount;\n        headerArrayUint32[2] = header.sectionCount;\n        headerArrayUint32[3] = header.maxSplatCount;\n        headerArrayUint32[4] = header.splatCount;\n        headerArrayUint16[10] = header.compressionLevel;\n        headerArrayFloat32[6] = header.sceneCenter.x;\n        headerArrayFloat32[7] = header.sceneCenter.y;\n        headerArrayFloat32[8] = header.sceneCenter.z;\n        headerArrayFloat32[9] = header.minSphericalHarmonicsCoeff || -DefaultSphericalHarmonics8BitCompressionHalfRange;\n        headerArrayFloat32[10] = header.maxSphericalHarmonicsCoeff || DefaultSphericalHarmonics8BitCompressionHalfRange;\n    }\n\n    static parseSectionHeaders(header, buffer, offset = 0, secLoadedCountsToMax) {\n        const compressionLevel = header.compressionLevel;\n\n        const maxSectionCount = header.maxSectionCount;\n        const sectionHeaderArrayUint16 = new Uint16Array(buffer, offset, maxSectionCount * SplatBuffer.SectionHeaderSizeBytes / 2);\n        const sectionHeaderArrayUint32 = new Uint32Array(buffer, offset, maxSectionCount * SplatBuffer.SectionHeaderSizeBytes / 4);\n        const sectionHeaderArrayFloat32 = new Float32Array(buffer, offset, maxSectionCount * SplatBuffer.SectionHeaderSizeBytes / 4);\n\n        const sectionHeaders = [];\n        let sectionHeaderBase = 0;\n        let sectionHeaderBaseUint16 = sectionHeaderBase / 2;\n        let sectionHeaderBaseUint32 = sectionHeaderBase / 4;\n        let sectionBase = SplatBuffer.HeaderSizeBytes + header.maxSectionCount * SplatBuffer.SectionHeaderSizeBytes;\n        let splatCountOffset = 0;\n        for (let i = 0; i < maxSectionCount; i++) {\n            const maxSplatCount = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 1];\n            const bucketSize = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 2];\n            const bucketCount = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 3];\n            const bucketBlockSize = sectionHeaderArrayFloat32[sectionHeaderBaseUint32 + 4];\n            const halfBucketBlockSize = bucketBlockSize / 2.0;\n            const bucketStorageSizeBytes = sectionHeaderArrayUint16[sectionHeaderBaseUint16 + 10];\n            const compressionScaleRange = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 6] ||\n                                          SplatBuffer.CompressionLevels[compressionLevel].ScaleRange;\n            const fullBucketCount = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 8];\n            const partiallyFilledBucketCount = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 9];\n            const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n            const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n\n            const sphericalHarmonicsDegree = sectionHeaderArrayUint16[sectionHeaderBaseUint16 + 20];\n            const { bytesPerSplat } = SplatBuffer.calculateComponentStorage(compressionLevel, sphericalHarmonicsDegree);\n\n            const splatDataStorageSizeBytes = bytesPerSplat * maxSplatCount;\n            const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n            const sectionHeader = {\n                bytesPerSplat: bytesPerSplat,\n                splatCountOffset: splatCountOffset,\n                splatCount: secLoadedCountsToMax ? maxSplatCount : 0,\n                maxSplatCount: maxSplatCount,\n                bucketSize: bucketSize,\n                bucketCount: bucketCount,\n                bucketBlockSize: bucketBlockSize,\n                halfBucketBlockSize: halfBucketBlockSize,\n                bucketStorageSizeBytes: bucketStorageSizeBytes,\n                bucketsStorageSizeBytes: bucketsStorageSizeBytes,\n                splatDataStorageSizeBytes: splatDataStorageSizeBytes,\n                storageSizeBytes: storageSizeBytes,\n                compressionScaleRange: compressionScaleRange,\n                compressionScaleFactor: halfBucketBlockSize / compressionScaleRange,\n                base: sectionBase,\n                bucketsBase: sectionBase + bucketsMetaDataSizeBytes,\n                dataBase: sectionBase + bucketsStorageSizeBytes,\n                fullBucketCount: fullBucketCount,\n                partiallyFilledBucketCount: partiallyFilledBucketCount,\n                sphericalHarmonicsDegree: sphericalHarmonicsDegree\n            };\n            sectionHeaders[i] = sectionHeader;\n            sectionBase += storageSizeBytes;\n            sectionHeaderBase += SplatBuffer.SectionHeaderSizeBytes;\n            sectionHeaderBaseUint16 = sectionHeaderBase / 2;\n            sectionHeaderBaseUint32 = sectionHeaderBase / 4;\n            splatCountOffset += maxSplatCount;\n        }\n\n        return sectionHeaders;\n    }\n\n\n    static writeSectionHeaderToBuffer(sectionHeader, compressionLevel, buffer, offset = 0) {\n        const sectionHeadeArrayUint16 = new Uint16Array(buffer, offset, SplatBuffer.SectionHeaderSizeBytes / 2);\n        const sectionHeadeArrayUint32 = new Uint32Array(buffer, offset, SplatBuffer.SectionHeaderSizeBytes / 4);\n        const sectionHeadeArrayFloat32 = new Float32Array(buffer, offset, SplatBuffer.SectionHeaderSizeBytes / 4);\n\n        sectionHeadeArrayUint32[0] = sectionHeader.splatCount;\n        sectionHeadeArrayUint32[1] = sectionHeader.maxSplatCount;\n        sectionHeadeArrayUint32[2] = compressionLevel >= 1 ? sectionHeader.bucketSize : 0;\n        sectionHeadeArrayUint32[3] = compressionLevel >= 1 ? sectionHeader.bucketCount : 0;\n        sectionHeadeArrayFloat32[4] = compressionLevel >= 1 ? sectionHeader.bucketBlockSize : 0.0;\n        sectionHeadeArrayUint16[10] = compressionLevel >= 1 ? SplatBuffer.BucketStorageSizeBytes : 0;\n        sectionHeadeArrayUint32[6] = compressionLevel >= 1 ? sectionHeader.compressionScaleRange : 0;\n        sectionHeadeArrayUint32[7] = sectionHeader.storageSizeBytes;\n        sectionHeadeArrayUint32[8] = compressionLevel >= 1 ? sectionHeader.fullBucketCount : 0;\n        sectionHeadeArrayUint32[9] = compressionLevel >= 1 ? sectionHeader.partiallyFilledBucketCount : 0;\n        sectionHeadeArrayUint16[20] = sectionHeader.sphericalHarmonicsDegree;\n\n    }\n\n    static writeSectionHeaderSplatCountToBuffer(splatCount, buffer, offset = 0) {\n        const sectionHeadeArrayUint32 = new Uint32Array(buffer, offset, SplatBuffer.SectionHeaderSizeBytes / 4);\n        sectionHeadeArrayUint32[0] = splatCount;\n    }\n\n    constructFromBuffer(bufferData, secLoadedCountsToMax) {\n        this.bufferData = bufferData;\n\n        this.globalSplatIndexToLocalSplatIndexMap = [];\n        this.globalSplatIndexToSectionMap = [];\n\n        const header = SplatBuffer.parseHeader(this.bufferData);\n        this.versionMajor = header.versionMajor;\n        this.versionMinor = header.versionMinor;\n        this.maxSectionCount = header.maxSectionCount;\n        this.sectionCount = secLoadedCountsToMax ? header.maxSectionCount : 0;\n        this.maxSplatCount = header.maxSplatCount;\n        this.splatCount = secLoadedCountsToMax ? header.maxSplatCount : 0;\n        this.compressionLevel = header.compressionLevel;\n        this.sceneCenter = new THREE.Vector3().copy(header.sceneCenter);\n        this.minSphericalHarmonicsCoeff = header.minSphericalHarmonicsCoeff;\n        this.maxSphericalHarmonicsCoeff = header.maxSphericalHarmonicsCoeff;\n\n        this.sections = SplatBuffer.parseSectionHeaders(header, this.bufferData, SplatBuffer.HeaderSizeBytes, secLoadedCountsToMax);\n\n        this.linkBufferArrays();\n        this.buildMaps();\n    }\n\n    static calculateComponentStorage(compressionLevel, sphericalHarmonicsDegree) {\n        const bytesPerCenter = SplatBuffer.CompressionLevels[compressionLevel].BytesPerCenter;\n        const bytesPerScale = SplatBuffer.CompressionLevels[compressionLevel].BytesPerScale;\n        const bytesPerRotation = SplatBuffer.CompressionLevels[compressionLevel].BytesPerRotation;\n        const bytesPerColor = SplatBuffer.CompressionLevels[compressionLevel].BytesPerColor;\n        const sphericalHarmonicsComponentsPerSplat = getSphericalHarmonicsComponentCountForDegree(sphericalHarmonicsDegree);\n        const sphericalHarmonicsBytesPerSplat = SplatBuffer.CompressionLevels[compressionLevel].BytesPerSphericalHarmonicsComponent *\n                                                sphericalHarmonicsComponentsPerSplat;\n        const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation +\n                              bytesPerColor + sphericalHarmonicsBytesPerSplat;\n        return {\n            bytesPerCenter,\n            bytesPerScale,\n            bytesPerRotation,\n            bytesPerColor,\n            sphericalHarmonicsComponentsPerSplat,\n            sphericalHarmonicsBytesPerSplat,\n            bytesPerSplat\n        };\n    }\n\n    linkBufferArrays() {\n        for (let i = 0; i < this.maxSectionCount; i++) {\n            const section = this.sections[i];\n            section.bucketArray = new Float32Array(this.bufferData, section.bucketsBase,\n                                                   section.bucketCount * SplatBuffer.BucketStorageSizeFloats);\n            if (section.partiallyFilledBucketCount > 0) {\n                section.partiallyFilledBucketLengths = new Uint32Array(this.bufferData, section.base,\n                                                                       section.partiallyFilledBucketCount);\n            }\n        }\n    }\n\n    buildMaps() {\n        let cumulativeSplatCount = 0;\n        for (let i = 0; i < this.maxSectionCount; i++) {\n            const section = this.sections[i];\n            for (let j = 0; j < section.maxSplatCount; j++) {\n                const globalSplatIndex = cumulativeSplatCount + j;\n                this.globalSplatIndexToLocalSplatIndexMap[globalSplatIndex] = j;\n                this.globalSplatIndexToSectionMap[globalSplatIndex] = i;\n            }\n            cumulativeSplatCount += section.maxSplatCount;\n        }\n    }\n\n    updateLoadedCounts(newSectionCount, newSplatCount) {\n        SplatBuffer.writeHeaderCountsToBuffer(newSectionCount, newSplatCount, this.bufferData);\n        this.sectionCount = newSectionCount;\n        this.splatCount = newSplatCount;\n    }\n\n    updateSectionLoadedCounts(sectionIndex, newSplatCount) {\n        const sectionHeaderOffset = SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes * sectionIndex;\n        SplatBuffer.writeSectionHeaderSplatCountToBuffer(newSplatCount, this.bufferData, sectionHeaderOffset);\n        this.sections[sectionIndex].splatCount = newSplatCount;\n    }\n\n    static writeSplatDataToSectionBuffer = function() {\n\n        const tempCenterBuffer = new ArrayBuffer(12);\n        const tempScaleBuffer = new ArrayBuffer(12);\n        const tempRotationBuffer = new ArrayBuffer(16);\n        const tempColorBuffer = new ArrayBuffer(4);\n        const tempSHBuffer = new ArrayBuffer(256);\n        const tempRot = new THREE.Quaternion();\n        const tempScale = new THREE.Vector3();\n        const bucketCenterDelta = new THREE.Vector3();\n\n        const {\n            X: OFFSET_X, Y: OFFSET_Y, Z: OFFSET_Z,\n            SCALE0: OFFSET_SCALE0, SCALE1: OFFSET_SCALE1, SCALE2: OFFSET_SCALE2,\n            ROTATION0: OFFSET_ROT0, ROTATION1: OFFSET_ROT1, ROTATION2: OFFSET_ROT2, ROTATION3: OFFSET_ROT3,\n            FDC0: OFFSET_FDC0, FDC1: OFFSET_FDC1, FDC2: OFFSET_FDC2, OPACITY: OFFSET_OPACITY,\n            FRC0: OFFSET_FRC0, FRC9: OFFSET_FRC9,\n        } = UncompressedSplatArray.OFFSET;\n\n        const compressPositionOffset = (v, compressionScaleFactor, compressionScaleRange) => {\n            const doubleCompressionScaleRange = compressionScaleRange * 2 + 1;\n            v = Math.round(v * compressionScaleFactor) + compressionScaleRange;\n            return clamp(v, 0, doubleCompressionScaleRange);\n        };\n\n        return function(targetSplat, sectionBuffer, bufferOffset, compressionLevel, sphericalHarmonicsDegree,\n                        bucketCenter, compressionScaleFactor, compressionScaleRange,\n                        minSphericalHarmonicsCoeff = -DefaultSphericalHarmonics8BitCompressionHalfRange,\n                        maxSphericalHarmonicsCoeff = DefaultSphericalHarmonics8BitCompressionHalfRange) {\n\n            const sphericalHarmonicsComponentsPerSplat = getSphericalHarmonicsComponentCountForDegree(sphericalHarmonicsDegree);\n            const bytesPerCenter = SplatBuffer.CompressionLevels[compressionLevel].BytesPerCenter;\n            const bytesPerScale = SplatBuffer.CompressionLevels[compressionLevel].BytesPerScale;\n            const bytesPerRotation = SplatBuffer.CompressionLevels[compressionLevel].BytesPerRotation;\n            const bytesPerColor = SplatBuffer.CompressionLevels[compressionLevel].BytesPerColor;\n\n            const centerBase = bufferOffset;\n            const scaleBase = centerBase + bytesPerCenter;\n            const rotationBase = scaleBase + bytesPerScale;\n            const colorBase = rotationBase + bytesPerRotation;\n            const sphericalHarmonicsBase = colorBase + bytesPerColor;\n\n            if (targetSplat[OFFSET_ROT0] !== undefined) {\n                tempRot.set(targetSplat[OFFSET_ROT0], targetSplat[OFFSET_ROT1], targetSplat[OFFSET_ROT2], targetSplat[OFFSET_ROT3]);\n                tempRot.normalize();\n            } else {\n                tempRot.set(1.0, 0.0, 0.0, 0.0);\n            }\n\n            if (targetSplat[OFFSET_SCALE0] !== undefined) {\n                tempScale.set(targetSplat[OFFSET_SCALE0] || 0,\n                              targetSplat[OFFSET_SCALE1] || 0,\n                              targetSplat[OFFSET_SCALE2] || 0);\n            } else {\n                tempScale.set(0, 0, 0);\n            }\n\n            if (compressionLevel === 0) {\n                const center = new Float32Array(sectionBuffer, centerBase, SplatBuffer.CenterComponentCount);\n                const rot = new Float32Array(sectionBuffer, rotationBase, SplatBuffer.RotationComponentCount);\n                const scale = new Float32Array(sectionBuffer, scaleBase, SplatBuffer.ScaleComponentCount);\n\n                rot.set([tempRot.x, tempRot.y, tempRot.z, tempRot.w]);\n                scale.set([tempScale.x, tempScale.y, tempScale.z]);\n                center.set([targetSplat[OFFSET_X], targetSplat[OFFSET_Y], targetSplat[OFFSET_Z]]);\n\n                if (sphericalHarmonicsDegree > 0) {\n                    const shOut = new Float32Array(sectionBuffer, sphericalHarmonicsBase, sphericalHarmonicsComponentsPerSplat);\n                    if (sphericalHarmonicsDegree >= 1) {\n                            for (let s = 0; s < 9; s++) shOut[s] = targetSplat[OFFSET_FRC0 + s] || 0;\n                            if (sphericalHarmonicsDegree >= 2) {\n                                for (let s = 0; s < 15; s++) shOut[s + 9] = targetSplat[OFFSET_FRC9 + s] || 0;\n                            }\n                    }\n                }\n            } else {\n                const center = new Uint16Array(tempCenterBuffer, 0, SplatBuffer.CenterComponentCount);\n                const rot = new Uint16Array(tempRotationBuffer, 0, SplatBuffer.RotationComponentCount);\n                const scale = new Uint16Array(tempScaleBuffer, 0, SplatBuffer.ScaleComponentCount);\n\n                rot.set([toHalfFloat(tempRot.x), toHalfFloat(tempRot.y), toHalfFloat(tempRot.z), toHalfFloat(tempRot.w)]);\n                scale.set([toHalfFloat(tempScale.x), toHalfFloat(tempScale.y), toHalfFloat(tempScale.z)]);\n\n                bucketCenterDelta.set(targetSplat[OFFSET_X], targetSplat[OFFSET_Y], targetSplat[OFFSET_Z]).sub(bucketCenter);\n                bucketCenterDelta.x = compressPositionOffset(bucketCenterDelta.x, compressionScaleFactor, compressionScaleRange);\n                bucketCenterDelta.y = compressPositionOffset(bucketCenterDelta.y, compressionScaleFactor, compressionScaleRange);\n                bucketCenterDelta.z = compressPositionOffset(bucketCenterDelta.z, compressionScaleFactor, compressionScaleRange);\n                center.set([bucketCenterDelta.x, bucketCenterDelta.y, bucketCenterDelta.z]);\n\n                if (sphericalHarmonicsDegree > 0) {\n                    const SHArrayType = compressionLevel === 1 ? Uint16Array : Uint8Array;\n                    const bytesPerSHComponent = compressionLevel === 1 ? 2 : 1;\n                    const shOut = new SHArrayType(tempSHBuffer, 0, sphericalHarmonicsComponentsPerSplat);\n                    if (sphericalHarmonicsDegree >= 1) {\n                        for (let s = 0; s < 9; s++) {\n                            const srcVal = targetSplat[OFFSET_FRC0 + s] || 0;\n                            shOut[s] = compressionLevel === 1 ? toHalfFloat(srcVal) :\n                                       toUint8(srcVal, minSphericalHarmonicsCoeff, maxSphericalHarmonicsCoeff);\n                        }\n                        const degree1ByteCount = 9 * bytesPerSHComponent;\n                        copyBetweenBuffers(shOut.buffer, 0, sectionBuffer, sphericalHarmonicsBase, degree1ByteCount);\n                        if (sphericalHarmonicsDegree >= 2) {\n                            for (let s = 0; s < 15; s++) {\n                                const srcVal = targetSplat[OFFSET_FRC9 + s] || 0;\n                                shOut[s + 9] = compressionLevel === 1 ? toHalfFloat(srcVal) :\n                                               toUint8(srcVal, minSphericalHarmonicsCoeff, maxSphericalHarmonicsCoeff);\n                            }\n                            copyBetweenBuffers(shOut.buffer, degree1ByteCount, sectionBuffer,\n                                               sphericalHarmonicsBase + degree1ByteCount, 15 * bytesPerSHComponent);\n                        }\n                    }\n                }\n\n                copyBetweenBuffers(center.buffer, 0, sectionBuffer, centerBase, 6);\n                copyBetweenBuffers(scale.buffer, 0, sectionBuffer, scaleBase, 6);\n                copyBetweenBuffers(rot.buffer, 0, sectionBuffer, rotationBase, 8);\n            }\n\n            const rgba = new Uint8ClampedArray(tempColorBuffer, 0, 4);\n            rgba.set([targetSplat[OFFSET_FDC0] || 0, targetSplat[OFFSET_FDC1] || 0, targetSplat[OFFSET_FDC2] || 0]);\n            rgba[3] = targetSplat[OFFSET_OPACITY] || 0;\n\n            copyBetweenBuffers(rgba.buffer, 0, sectionBuffer, colorBase, 4);\n        };\n\n    }();\n\n    static generateFromUncompressedSplatArrays(splatArrays, minimumAlpha, compressionLevel,\n                                               sceneCenter, blockSize, bucketSize, options = []) {\n\n        let shDegree = 0;\n        for (let sa = 0; sa < splatArrays.length; sa ++) {\n            const splatArray = splatArrays[sa];\n            shDegree = Math.max(splatArray.sphericalHarmonicsDegree, shDegree);\n        }\n\n        let minSphericalHarmonicsCoeff;\n        let maxSphericalHarmonicsCoeff;\n\n        for (let sa = 0; sa < splatArrays.length; sa ++) {\n            const splatArray = splatArrays[sa];\n            for (let i = 0; i < splatArray.splats.length; i++) {\n                const splat = splatArray.splats[i];\n                for (let sc = UncompressedSplatArray.OFFSET.FRC0; sc < UncompressedSplatArray.OFFSET.FRC23 && sc < splat.length; sc++) {\n                    if (!minSphericalHarmonicsCoeff || splat[sc] < minSphericalHarmonicsCoeff) {\n                        minSphericalHarmonicsCoeff = splat[sc];\n                    }\n                    if (!maxSphericalHarmonicsCoeff || splat[sc] > maxSphericalHarmonicsCoeff) {\n                        maxSphericalHarmonicsCoeff = splat[sc];\n                    }\n                }\n            }\n        }\n\n        minSphericalHarmonicsCoeff = minSphericalHarmonicsCoeff || -DefaultSphericalHarmonics8BitCompressionHalfRange;\n        maxSphericalHarmonicsCoeff = maxSphericalHarmonicsCoeff || DefaultSphericalHarmonics8BitCompressionHalfRange;\n\n        const { bytesPerSplat } = SplatBuffer.calculateComponentStorage(compressionLevel, shDegree);\n        const compressionScaleRange = SplatBuffer.CompressionLevels[compressionLevel].ScaleRange;\n\n        const sectionBuffers = [];\n        const sectionHeaderBuffers = [];\n        let totalSplatCount = 0;\n\n        for (let sa = 0; sa < splatArrays.length; sa ++) {\n            const splatArray = splatArrays[sa];\n            const validSplats = new UncompressedSplatArray(shDegree);\n            for (let i = 0; i < splatArray.splatCount; i++) {\n                const targetSplat = splatArray.splats[i];\n                if ((targetSplat[UncompressedSplatArray.OFFSET.OPACITY] || 0) >= minimumAlpha) {\n                    validSplats.addSplat(targetSplat);\n                }\n            }\n\n            const sectionOptions = options[sa] || {};\n            const sectionBlockSize = (sectionOptions.blockSizeFactor || 1) * (blockSize || SplatBuffer.BucketBlockSize);\n            const sectionBucketSize = Math.ceil((sectionOptions.bucketSizeFactor || 1) * (bucketSize || SplatBuffer.BucketSize));\n\n            const bucketInfo = SplatBuffer.computeBucketsForUncompressedSplatArray(validSplats, sectionBlockSize, sectionBucketSize);\n            const fullBucketCount = bucketInfo.fullBuckets.length;\n            const partiallyFullBucketLengths = bucketInfo.partiallyFullBuckets.map((bucket) => bucket.splats.length);\n            const partiallyFilledBucketCount = partiallyFullBucketLengths.length;\n            const buckets = [...bucketInfo.fullBuckets, ...bucketInfo.partiallyFullBuckets];\n\n            const sectionDataSizeBytes = validSplats.splats.length * bytesPerSplat;\n            const bucketMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n            const bucketDataBytes = compressionLevel >= 1 ? buckets.length *\n                                                            SplatBuffer.BucketStorageSizeBytes + bucketMetaDataSizeBytes : 0;\n            const sectionSizeBytes = sectionDataSizeBytes + bucketDataBytes;\n            const sectionBuffer = new ArrayBuffer(sectionSizeBytes);\n\n            const compressionScaleFactor = compressionScaleRange / (sectionBlockSize * 0.5);\n            const bucketCenter = new THREE.Vector3();\n\n            let outSplatCount = 0;\n            for (let b = 0; b < buckets.length; b++) {\n                const bucket = buckets[b];\n                bucketCenter.fromArray(bucket.center);\n                for (let i = 0; i < bucket.splats.length; i++) {\n                    let row = bucket.splats[i];\n                    const targetSplat = validSplats.splats[row];\n                    const bufferOffset = bucketDataBytes + outSplatCount * bytesPerSplat;\n                    SplatBuffer.writeSplatDataToSectionBuffer(targetSplat, sectionBuffer, bufferOffset, compressionLevel, shDegree,\n                                                              bucketCenter, compressionScaleFactor, compressionScaleRange,\n                                                              minSphericalHarmonicsCoeff, maxSphericalHarmonicsCoeff);\n                    outSplatCount++;\n                }\n            }\n            totalSplatCount += outSplatCount;\n\n            if (compressionLevel >= 1) {\n                const bucketMetaDataArray = new Uint32Array(sectionBuffer, 0, partiallyFullBucketLengths.length * 4);\n                for (let pfb = 0; pfb < partiallyFullBucketLengths.length; pfb ++) {\n                    bucketMetaDataArray[pfb] = partiallyFullBucketLengths[pfb];\n                }\n                const bucketArray = new Float32Array(sectionBuffer, bucketMetaDataSizeBytes,\n                                                     buckets.length * SplatBuffer.BucketStorageSizeFloats);\n                for (let b = 0; b < buckets.length; b++) {\n                    const bucket = buckets[b];\n                    const base = b * 3;\n                    bucketArray[base] = bucket.center[0];\n                    bucketArray[base + 1] = bucket.center[1];\n                    bucketArray[base + 2] = bucket.center[2];\n                }\n            }\n            sectionBuffers.push(sectionBuffer);\n\n            const sectionHeaderBuffer = new ArrayBuffer(SplatBuffer.SectionHeaderSizeBytes);\n            SplatBuffer.writeSectionHeaderToBuffer({\n                maxSplatCount: outSplatCount,\n                splatCount: outSplatCount,\n                bucketSize: sectionBucketSize,\n                bucketCount: buckets.length,\n                bucketBlockSize: sectionBlockSize,\n                compressionScaleRange: compressionScaleRange,\n                storageSizeBytes: sectionSizeBytes,\n                fullBucketCount: fullBucketCount,\n                partiallyFilledBucketCount: partiallyFilledBucketCount,\n                sphericalHarmonicsDegree: shDegree\n            }, compressionLevel, sectionHeaderBuffer, 0);\n            sectionHeaderBuffers.push(sectionHeaderBuffer);\n\n        }\n\n        let sectionsCumulativeSizeBytes = 0;\n        for (let sectionBuffer of sectionBuffers) sectionsCumulativeSizeBytes += sectionBuffer.byteLength;\n        const unifiedBufferSize = SplatBuffer.HeaderSizeBytes +\n                                  SplatBuffer.SectionHeaderSizeBytes * sectionBuffers.length + sectionsCumulativeSizeBytes;\n        const unifiedBuffer = new ArrayBuffer(unifiedBufferSize);\n\n        SplatBuffer.writeHeaderToBuffer({\n            versionMajor: 0,\n            versionMinor: 1,\n            maxSectionCount: sectionBuffers.length,\n            sectionCount: sectionBuffers.length,\n            maxSplatCount: totalSplatCount,\n            splatCount: totalSplatCount,\n            compressionLevel: compressionLevel,\n            sceneCenter: sceneCenter,\n            minSphericalHarmonicsCoeff: minSphericalHarmonicsCoeff,\n            maxSphericalHarmonicsCoeff: maxSphericalHarmonicsCoeff\n        }, unifiedBuffer);\n\n        let currentUnifiedBase = SplatBuffer.HeaderSizeBytes;\n        for (let sectionHeaderBuffer of sectionHeaderBuffers) {\n            new Uint8Array(unifiedBuffer, currentUnifiedBase, SplatBuffer.SectionHeaderSizeBytes).set(new Uint8Array(sectionHeaderBuffer));\n            currentUnifiedBase += SplatBuffer.SectionHeaderSizeBytes;\n        }\n\n        for (let sectionBuffer of sectionBuffers) {\n            new Uint8Array(unifiedBuffer, currentUnifiedBase, sectionBuffer.byteLength).set(new Uint8Array(sectionBuffer));\n            currentUnifiedBase += sectionBuffer.byteLength;\n        }\n\n        const splatBuffer = new SplatBuffer(unifiedBuffer);\n        return splatBuffer;\n    }\n\n    static computeBucketsForUncompressedSplatArray(splatArray, blockSize, bucketSize) {\n        let splatCount = splatArray.splatCount;\n        const halfBlockSize = blockSize / 2.0;\n\n        const min = new THREE.Vector3();\n        const max = new THREE.Vector3();\n\n        for (let i = 0; i < splatCount; i++) {\n            const targetSplat = splatArray.splats[i];\n            const center = [targetSplat[UncompressedSplatArray.OFFSET.X],\n                            targetSplat[UncompressedSplatArray.OFFSET.Y],\n                            targetSplat[UncompressedSplatArray.OFFSET.Z]];\n            if (i === 0 || center[0] < min.x) min.x = center[0];\n            if (i === 0 || center[0] > max.x) max.x = center[0];\n            if (i === 0 || center[1] < min.y) min.y = center[1];\n            if (i === 0 || center[1] > max.y) max.y = center[1];\n            if (i === 0 || center[2] < min.z) min.z = center[2];\n            if (i === 0 || center[2] > max.z) max.z = center[2];\n        }\n\n        const dimensions = new THREE.Vector3().copy(max).sub(min);\n        const yBlocks = Math.ceil(dimensions.y / blockSize);\n        const zBlocks = Math.ceil(dimensions.z / blockSize);\n\n        const blockCenter = new THREE.Vector3();\n        const fullBuckets = [];\n        const partiallyFullBuckets = {};\n\n        for (let i = 0; i < splatCount; i++) {\n            const targetSplat = splatArray.splats[i];\n            const center = [targetSplat[UncompressedSplatArray.OFFSET.X],\n                            targetSplat[UncompressedSplatArray.OFFSET.Y],\n                            targetSplat[UncompressedSplatArray.OFFSET.Z]];\n            const xBlock = Math.floor((center[0] - min.x) / blockSize);\n            const yBlock = Math.floor((center[1] - min.y) / blockSize);\n            const zBlock = Math.floor((center[2] - min.z) / blockSize);\n\n            blockCenter.x = xBlock * blockSize + min.x + halfBlockSize;\n            blockCenter.y = yBlock * blockSize + min.y + halfBlockSize;\n            blockCenter.z = zBlock * blockSize + min.z + halfBlockSize;\n\n            const bucketId = xBlock * (yBlocks * zBlocks) + yBlock * zBlocks + zBlock;\n            let bucket = partiallyFullBuckets[bucketId];\n            if (!bucket) {\n                partiallyFullBuckets[bucketId] = bucket = {\n                    'splats': [],\n                    'center': blockCenter.toArray()\n                };\n            }\n\n            bucket.splats.push(i);\n            if (bucket.splats.length >= bucketSize) {\n                fullBuckets.push(bucket);\n                partiallyFullBuckets[bucketId] = null;\n            }\n        }\n\n        const partiallyFullBucketArray = [];\n        for (let bucketId in partiallyFullBuckets) {\n            if (partiallyFullBuckets.hasOwnProperty(bucketId)) {\n                const bucket = partiallyFullBuckets[bucketId];\n                if (bucket) {\n                    partiallyFullBucketArray.push(bucket);\n                }\n            }\n        }\n\n        return {\n            'fullBuckets': fullBuckets,\n            'partiallyFullBuckets': partiallyFullBucketArray,\n        };\n    }\n\n    static preallocateUncompressed(splatCount, sphericalHarmonicsDegrees) {\n        const shDescriptor = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[sphericalHarmonicsDegrees];\n        const splatBufferDataOffsetBytes = SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes;\n        const splatBufferSizeBytes = splatBufferDataOffsetBytes + shDescriptor.BytesPerSplat * splatCount;\n        const outBuffer = new ArrayBuffer(splatBufferSizeBytes);\n        SplatBuffer.writeHeaderToBuffer({\n            versionMajor: SplatBuffer.CurrentMajorVersion,\n            versionMinor: SplatBuffer.CurrentMinorVersion,\n            maxSectionCount: 1,\n            sectionCount: 1,\n            maxSplatCount: splatCount,\n            splatCount: splatCount,\n            compressionLevel: 0,\n            sceneCenter: new THREE.Vector3()\n        }, outBuffer);\n\n        SplatBuffer.writeSectionHeaderToBuffer({\n            maxSplatCount: splatCount,\n            splatCount: splatCount,\n            bucketSize: 0,\n            bucketCount: 0,\n            bucketBlockSize: 0,\n            compressionScaleRange: 0,\n            storageSizeBytes: 0,\n            fullBucketCount: 0,\n            partiallyFilledBucketCount: 0,\n            sphericalHarmonicsDegree: sphericalHarmonicsDegrees\n        }, 0, outBuffer, SplatBuffer.HeaderSizeBytes);\n\n        return {\n            splatBuffer: new SplatBuffer(outBuffer, true),\n            splatBufferDataOffsetBytes\n        };\n    }\n}\n\nconst HeaderMagicBytes = new Uint8Array([112, 108, 121, 10]);\nconst HeaderEndTokenBytes = new Uint8Array([10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10]);\nconst HeaderEndToken = 'end_header';\n\nconst DataTypeMap = new Map([\n  ['char', Int8Array],\n  ['uchar', Uint8Array],\n  ['short', Int16Array],\n  ['ushort', Uint16Array],\n  ['int', Int32Array],\n  ['uint', Uint32Array],\n  ['float', Float32Array],\n  ['double', Float64Array],\n]);\n\nconst unpackUnorm = (value, bits) => {\n  const t = (1 << bits) - 1;\n  return (value & t) / t;\n};\n\nconst unpack111011 = (result, value) => {\n  result.x = unpackUnorm(value >>> 21, 11);\n  result.y = unpackUnorm(value >>> 11, 10);\n  result.z = unpackUnorm(value, 11);\n};\n\nconst unpack8888 = (result, value) => {\n  result.x = unpackUnorm(value >>> 24, 8);\n  result.y = unpackUnorm(value >>> 16, 8);\n  result.z = unpackUnorm(value >>> 8, 8);\n  result.w = unpackUnorm(value, 8);\n};\n\n// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)\nconst unpackRot = (result, value) => {\n  const norm = 1.0 / (Math.sqrt(2) * 0.5);\n  const a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;\n  const b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;\n  const c = (unpackUnorm(value, 10) - 0.5) * norm;\n  const m = Math.sqrt(1.0 - (a * a + b * b + c * c));\n\n  switch (value >>> 30) {\n    case 0:\n      result.set(m, a, b, c);\n      break;\n    case 1:\n      result.set(a, m, b, c);\n      break;\n    case 2:\n      result.set(a, b, m, c);\n      break;\n    case 3:\n      result.set(a, b, c, m);\n      break;\n  }\n};\n\nconst lerp = (a, b, t) => {\n  return a * (1 - t) + b * t;\n};\n\nconst getElementPropStorage = (element, name) => {\n  return element.properties.find((p) => p.name === name && p.storage)\n    ?.storage;\n};\n\nclass PlayCanvasCompressedPlyParser {\n\n  static decodeHeaderText(headerText) {\n\n    let element;\n    let chunkElement;\n    let vertexElement;\n    let shElement;\n\n    const headerLines = headerText.split('\\n').filter((line) => !line.startsWith('comment '));\n\n    let bytesPerSplat = 0;\n    let done = false;\n    for (let i = 1; i < headerLines.length; ++i) {\n      const words = headerLines[i].split(' ');\n\n      switch (words[0]) {\n        case 'format':\n          if (words[1] !== 'binary_little_endian') {\n            throw new Error('Unsupported ply format');\n          }\n          break;\n        case 'element':\n          element = {\n            name: words[1],\n            count: parseInt(words[2], 10),\n            properties: [],\n            storageSizeBytes: 0\n          };\n          if (element.name === 'chunk') chunkElement = element;\n          else if (element.name === 'vertex') vertexElement = element;\n          else if (element.name === 'sh') shElement = element;\n          break;\n        case 'property': {\n          if (!DataTypeMap.has(words[1])) {\n            throw new Error(\n              `Unrecognized property data type '${words[1]}' in ply header`\n            );\n          }\n          const StorageType = DataTypeMap.get(words[1]);\n          const storageSizeByes = StorageType.BYTES_PER_ELEMENT * element.count;\n          if (element.name === 'vertex') bytesPerSplat += StorageType.BYTES_PER_ELEMENT;\n          element.properties.push({\n            type: words[1],\n            name: words[2],\n            storage: null,\n            byteSize: StorageType.BYTES_PER_ELEMENT,\n            storageSizeByes: storageSizeByes\n          });\n          element.storageSizeBytes += storageSizeByes;\n          break;\n        }\n        case HeaderEndToken:\n          done = true;\n        break;\n        default:\n          throw new Error(\n            `Unrecognized header value '${words[0]}' in ply header`\n          );\n      }\n      if (done) break;\n    }\n\n    let sphericalHarmonicsDegree = 0;\n    let sphericalHarmonicsPerSplat = 0;\n    if (shElement) {\n      sphericalHarmonicsPerSplat = shElement.properties.length;\n      if (shElement.properties.length >= 45) {\n        sphericalHarmonicsDegree = 3;\n      } else if (shElement.properties.length >= 24) {\n        sphericalHarmonicsDegree = 2;\n      } else if (shElement.properties.length >= 9) {\n        sphericalHarmonicsDegree = 1;\n      }\n    }\n\n    return {\n      'chunkElement': chunkElement,\n      'vertexElement': vertexElement,\n      'shElement': shElement,\n      'bytesPerSplat': bytesPerSplat,\n      'headerSizeBytes': headerText.indexOf(HeaderEndToken) + HeaderEndToken.length + 1,\n      'sphericalHarmonicsDegree': sphericalHarmonicsDegree,\n      'sphericalHarmonicsPerSplat': sphericalHarmonicsPerSplat\n    };\n  }\n\n  static decodeHeader(plyBuffer) {\n\n    /**\n     * Searches for the first occurrence of a sequence within a buffer.\n     * @example\n     * find(new Uint8Array([1, 2, 3, 4]), new Uint8Array([3, 4])); // 2\n     * @param {Uint8Array} buf - The buffer in which to search.\n     * @param {Uint8Array} search - The sequence to search for.\n     * @return {number} The index of the first occurrence of the search sequence in the buffer, or -1 if not found.\n     */\n    const find = (buf, search) => {\n      const endIndex = buf.length - search.length;\n      let i;\n      let j;\n      for (i = 0; i <= endIndex; ++i) {\n        for (j = 0; j < search.length; ++j) {\n          if (buf[i + j] !== search[j]) {\n            break;\n          }\n        }\n        if (j === search.length) {\n          return i;\n        }\n      }\n      return -1;\n    };\n\n    /**\n     * Checks if array 'a' starts with the same elements as array 'b'.\n     * @example\n     * startsWith(new Uint8Array([1, 2, 3, 4]), new Uint8Array([1, 2])); // true\n     * @param {Uint8Array} a - The array to check against.\n     * @param {Uint8Array} b - The array of elements to look for at the start of 'a'.\n     * @return {boolean} - True if 'a' starts with all elements of 'b', otherwise false.\n     */\n    const startsWith = (a, b) => {\n      if (a.length < b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < b.length; ++i) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    let buf = new Uint8Array(plyBuffer);\n    let endHeaderTokenOffset;\n\n    if (buf.length >= HeaderMagicBytes.length && !startsWith(buf, HeaderMagicBytes)) {\n      throw new Error('Invalid PLY header');\n    }\n\n    endHeaderTokenOffset = find(buf, HeaderEndTokenBytes);\n    if (endHeaderTokenOffset === -1) {\n      throw new Error('End of PLY header not found');\n    }\n\n    const headerText = new TextDecoder('ascii').decode(\n      buf.slice(0, endHeaderTokenOffset)\n    );\n\n    const {\n      chunkElement,\n      vertexElement,\n      shElement,\n      sphericalHarmonicsDegree,\n      sphericalHarmonicsPerSplat,\n      bytesPerSplat\n    } = PlayCanvasCompressedPlyParser.decodeHeaderText(headerText);\n\n    return {\n      'headerSizeBytes': endHeaderTokenOffset + HeaderEndTokenBytes.length,\n      'bytesPerSplat': bytesPerSplat,\n      'chunkElement': chunkElement,\n      'vertexElement': vertexElement,\n      'shElement': shElement,\n      'sphericalHarmonicsDegree': sphericalHarmonicsDegree,\n      'sphericalHarmonicsPerSplat': sphericalHarmonicsPerSplat\n    };\n  }\n\n  static readElementData(element, readBuffer, readOffset, fromIndex, toIndex, propertyFilter = null) {\n\n    let dataView = readBuffer instanceof DataView ? readBuffer : new DataView(readBuffer);\n\n    fromIndex = fromIndex || 0;\n    toIndex = toIndex || element.count - 1;\n    for (let e = fromIndex; e <= toIndex; ++e) {\n      for (let j = 0; j < element.properties.length; ++j) {\n        const property = element.properties[j];\n\n        const StorageType = DataTypeMap.get(property.type);\n        const requiredStorageSizeBytes = StorageType.BYTES_PER_ELEMENT * element.count;\n        if ((!property.storage || property.storage.byteLength < requiredStorageSizeBytes) &&\n            (!propertyFilter || propertyFilter(property.name))) {\n          property.storage = new StorageType(element.count);\n        }\n\n        if (property.storage) {\n          switch (property.type) {\n            case 'char':\n              property.storage[e] = dataView.getInt8(readOffset);\n              break;\n            case 'uchar':\n              property.storage[e] = dataView.getUint8(readOffset);\n              break;\n            case 'short':\n              property.storage[e] = dataView.getInt16(readOffset, true);\n              break;\n            case 'ushort':\n              property.storage[e] = dataView.getUint16(readOffset, true);\n              break;\n            case 'int':\n              property.storage[e] = dataView.getInt32(readOffset, true);\n              break;\n            case 'uint':\n              property.storage[e] = dataView.getUint32(readOffset, true);\n              break;\n            case 'float':\n              property.storage[e] = dataView.getFloat32(readOffset, true);\n              break;\n            case 'double':\n              property.storage[e] = dataView.getFloat64(readOffset, true);\n              break;\n          }\n        }\n\n        readOffset += property.byteSize;\n      }\n    }\n\n    return readOffset;\n  }\n\n  static readPly(plyBuffer, propertyFilter = null) {\n\n    const header = PlayCanvasCompressedPlyParser.decodeHeader(plyBuffer);\n\n    let readIndex = PlayCanvasCompressedPlyParser.readElementData(header.chunkElement, plyBuffer,\n                                                                  header.headerSizeBytes, null, null, propertyFilter);\n    readIndex = PlayCanvasCompressedPlyParser.readElementData(header.vertexElement, plyBuffer, readIndex, null, null, propertyFilter);\n    PlayCanvasCompressedPlyParser.readElementData(header.shElement, plyBuffer, readIndex, null, null, propertyFilter);\n\n    return {\n      'chunkElement': header.chunkElement,\n      'vertexElement': header.vertexElement,\n      'shElement': header.shElement,\n      'sphericalHarmonicsDegree': header.sphericalHarmonicsDegree,\n      'sphericalHarmonicsPerSplat': header.sphericalHarmonicsPerSplat\n    };\n  }\n\n  static getElementStorageArrays(chunkElement, vertexElement, shElement) {\n    const storageArrays = {};\n\n    if (vertexElement) {\n      const minR = getElementPropStorage(chunkElement, 'min_r');\n      const minG = getElementPropStorage(chunkElement, 'min_g');\n      const minB = getElementPropStorage(chunkElement, 'min_b');\n      const maxR = getElementPropStorage(chunkElement, 'max_r');\n      const maxG = getElementPropStorage(chunkElement, 'max_g');\n      const maxB = getElementPropStorage(chunkElement, 'max_b');\n      const minX = getElementPropStorage(chunkElement, 'min_x');\n      const minY = getElementPropStorage(chunkElement, 'min_y');\n      const minZ = getElementPropStorage(chunkElement, 'min_z');\n      const maxX = getElementPropStorage(chunkElement, 'max_x');\n      const maxY = getElementPropStorage(chunkElement, 'max_y');\n      const maxZ = getElementPropStorage(chunkElement, 'max_z');\n      const minScaleX = getElementPropStorage(chunkElement, 'min_scale_x');\n      const minScaleY = getElementPropStorage(chunkElement, 'min_scale_y');\n      const minScaleZ = getElementPropStorage(chunkElement, 'min_scale_z');\n      const maxScaleX = getElementPropStorage(chunkElement, 'max_scale_x');\n      const maxScaleY = getElementPropStorage(chunkElement, 'max_scale_y');\n      const maxScaleZ = getElementPropStorage(chunkElement, 'max_scale_z');\n      const position = getElementPropStorage(vertexElement, 'packed_position');\n      const rotation = getElementPropStorage(vertexElement, 'packed_rotation');\n      const scale = getElementPropStorage(vertexElement, 'packed_scale');\n      const color = getElementPropStorage(vertexElement, 'packed_color');\n\n      storageArrays['colorExtremes'] = {\n        minR, maxR,\n        minG, maxG,\n        minB, maxB\n      };\n      storageArrays['positionExtremes'] = {\n        minX, maxX,\n        minY, maxY,\n        minZ, maxZ\n      };\n      storageArrays['scaleExtremes'] = {\n        minScaleX, maxScaleX, minScaleY,\n        maxScaleY, minScaleZ, maxScaleZ\n      };\n      storageArrays['position'] = position;\n      storageArrays['rotation'] = rotation;\n      storageArrays['scale'] = scale;\n      storageArrays['color'] = color;\n    }\n\n    if (shElement) {\n      const shStorageArrays = {};\n      for (let i = 0; i < 45; i++) {\n        const fRestKey = `f_rest_${i}`;\n        const fRest = getElementPropStorage(shElement, fRestKey);\n        if (fRest) {\n          shStorageArrays[fRestKey] = fRest;\n        } else {\n          break;\n        }\n      }\n      storageArrays['sh'] = shStorageArrays;\n    }\n\n    return storageArrays;\n  }\n\n  static decompressBaseSplat = function() {\n\n    const p = new THREE.Vector3();\n    const r = new THREE.Quaternion();\n    const s = new THREE.Vector3();\n    const c = new THREE.Vector4();\n\n    const OFFSET = UncompressedSplatArray.OFFSET;\n\n    return function(index, chunkSplatIndexOffset, positionArray, positionExtremes, scaleArray, scaleExtremes,\n                    rotationArray, colorExtremes, colorArray, outSplat) {\n      outSplat = outSplat || UncompressedSplatArray.createSplat();\n\n      const chunkIndex = Math.floor((chunkSplatIndexOffset + index) / 256);\n\n      unpack111011(p, positionArray[index]);\n      unpackRot(r, rotationArray[index]);\n      unpack111011(s, scaleArray[index]);\n      unpack8888(c, colorArray[index]);\n\n      outSplat[OFFSET.X] = lerp(positionExtremes.minX[chunkIndex], positionExtremes.maxX[chunkIndex], p.x);\n      outSplat[OFFSET.Y] = lerp(positionExtremes.minY[chunkIndex], positionExtremes.maxY[chunkIndex], p.y);\n      outSplat[OFFSET.Z] = lerp(positionExtremes.minZ[chunkIndex], positionExtremes.maxZ[chunkIndex], p.z);\n\n      outSplat[OFFSET.ROTATION0] = r.x;\n      outSplat[OFFSET.ROTATION1] = r.y;\n      outSplat[OFFSET.ROTATION2] = r.z;\n      outSplat[OFFSET.ROTATION3] = r.w;\n\n      outSplat[OFFSET.SCALE0] = Math.exp(lerp(scaleExtremes.minScaleX[chunkIndex], scaleExtremes.maxScaleX[chunkIndex], s.x));\n      outSplat[OFFSET.SCALE1] = Math.exp(lerp(scaleExtremes.minScaleY[chunkIndex], scaleExtremes.maxScaleY[chunkIndex], s.y));\n      outSplat[OFFSET.SCALE2] = Math.exp(lerp(scaleExtremes.minScaleZ[chunkIndex], scaleExtremes.maxScaleZ[chunkIndex], s.z));\n\n      if (colorExtremes.minR && colorExtremes.maxR) {\n        outSplat[OFFSET.FDC0] = clamp(Math.round(lerp(colorExtremes.minR[chunkIndex], colorExtremes.maxR[chunkIndex], c.x) * 255), 0, 255);\n      } else {\n        outSplat[OFFSET.FDC0] = clamp(Math.floor(c.x * 255), 0, 255);\n      }\n      if (colorExtremes.minG && colorExtremes.maxG) {\n        outSplat[OFFSET.FDC1] = clamp(Math.round(lerp(colorExtremes.minG[chunkIndex], colorExtremes.maxG[chunkIndex], c.y) * 255), 0, 255);\n      } else {\n        outSplat[OFFSET.FDC1] = clamp(Math.floor(c.y * 255), 0, 255);\n      }\n      if (colorExtremes.minB && colorExtremes.maxB) {\n        outSplat[OFFSET.FDC2] = clamp(Math.round(lerp(colorExtremes.minB[chunkIndex], colorExtremes.maxB[chunkIndex], c.z) * 255), 0, 255);\n      } else {\n        outSplat[OFFSET.FDC2] = clamp(Math.floor(c.z * 255), 0, 255);\n      }\n      outSplat[OFFSET.OPACITY] = clamp(Math.floor(c.w * 255), 0, 255);\n\n      return outSplat;\n    };\n\n  }();\n\n  static decompressSphericalHarmonics = function() {\n\n    const shCoeffMap = [0, 3, 8, 15];\n\n    const shIndexMap = [\n      0, 1, 2, 9, 10, 11, 12, 13, 24, 25, 26, 27, 28, 29, 30,\n      3, 4, 5, 14, 15, 16, 17, 18, 31, 32, 33, 34, 35, 36, 37,\n      6, 7, 8, 19, 20, 21, 22, 23, 38, 39, 40, 41, 42, 43, 44\n    ];\n\n    return function(index, shArray, outSphericalHarmonicsDegree, readSphericalHarmonicsDegree, outSplat) {\n      outSplat = outSplat || UncompressedSplatArray.createSplat();\n      let outSHCoeff = shCoeffMap[outSphericalHarmonicsDegree];\n      let readSHCoeff = shCoeffMap[readSphericalHarmonicsDegree];\n      for (let j = 0; j < 3; ++j) {\n        for (let k = 0; k < 15; ++k) {\n          const outIndex = shIndexMap[j * 15 + k];\n          if (k < outSHCoeff && k < readSHCoeff) {\n            outSplat[UncompressedSplatArray.OFFSET.FRC0 + outIndex] = (shArray[j * readSHCoeff + k][index] * (8 / 255) - 4);\n          }\n        }\n      }\n\n      return outSplat;\n    };\n\n  }();\n\n  static parseToUncompressedSplatBufferSection(chunkElement, vertexElement, fromIndex, toIndex, chunkSplatIndexOffset,\n                                               vertexDataBuffer, outBuffer, outOffset, propertyFilter = null) {\n\n    PlayCanvasCompressedPlyParser.readElementData(vertexElement, vertexDataBuffer, 0, fromIndex, toIndex, propertyFilter);\n\n    const outBytesPerSplat = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;\n\n    const { positionExtremes, scaleExtremes, colorExtremes, position, rotation, scale, color } =\n      PlayCanvasCompressedPlyParser.getElementStorageArrays(chunkElement, vertexElement);\n\n    const tempSplat = UncompressedSplatArray.createSplat();\n\n    for (let i = fromIndex; i <= toIndex; ++i) {\n      PlayCanvasCompressedPlyParser.decompressBaseSplat(i, chunkSplatIndexOffset, position, positionExtremes,\n                                                        scale, scaleExtremes, rotation, colorExtremes, color, tempSplat);\n      const outBase = i * outBytesPerSplat + outOffset;\n      SplatBuffer.writeSplatDataToSectionBuffer(tempSplat, outBuffer, outBase, 0, 0);\n    }\n  }\n\n  static parseToUncompressedSplatArraySection(chunkElement, vertexElement, fromIndex, toIndex, chunkSplatIndexOffset,\n                                              vertexDataBuffer, splatArray, propertyFilter = null) {\n\n    PlayCanvasCompressedPlyParser.readElementData(vertexElement, vertexDataBuffer, 0, fromIndex, toIndex, propertyFilter);\n\n    const { positionExtremes, scaleExtremes, colorExtremes, position, rotation, scale, color } =\n      PlayCanvasCompressedPlyParser.getElementStorageArrays(chunkElement, vertexElement);\n\n    for (let i = fromIndex; i <= toIndex; ++i) {\n      const tempSplat = UncompressedSplatArray.createSplat();\n      PlayCanvasCompressedPlyParser.decompressBaseSplat(i, chunkSplatIndexOffset, position, positionExtremes,\n                                                        scale, scaleExtremes, rotation, colorExtremes, color, tempSplat);\n      splatArray.addSplat(tempSplat);\n    }\n  }\n\n  static parseSphericalHarmonicsToUncompressedSplatArraySection(chunkElement, shElement, fromIndex, toIndex,\n    vertexDataBuffer, vertexReadOffset, outSphericalHarmonicsDegree, readSphericalHarmonicsDegree, splatArray, propertyFilter = null) {\n\n    PlayCanvasCompressedPlyParser.readElementData(shElement, vertexDataBuffer, vertexReadOffset, fromIndex, toIndex, propertyFilter);\n\n    const { sh } = PlayCanvasCompressedPlyParser.getElementStorageArrays(chunkElement, undefined, shElement);\n    const shArrays = Object.values(sh);\n\n    for (let i = fromIndex; i <= toIndex; ++i) {\n      PlayCanvasCompressedPlyParser.decompressSphericalHarmonics(\n        i, shArrays, outSphericalHarmonicsDegree, readSphericalHarmonicsDegree, splatArray.splats[i]\n      );\n    }\n  }\n\n  static parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree) {\n    const { chunkElement, vertexElement, shElement, sphericalHarmonicsDegree } = PlayCanvasCompressedPlyParser.readPly(plyBuffer);\n\n    outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, sphericalHarmonicsDegree);\n\n    const splatArray = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n\n    const { positionExtremes, scaleExtremes, colorExtremes, position, rotation, scale, color } =\n      PlayCanvasCompressedPlyParser.getElementStorageArrays(chunkElement, vertexElement);\n\n    let shArrays;\n    if (outSphericalHarmonicsDegree > 0) {\n      const { sh } = PlayCanvasCompressedPlyParser.getElementStorageArrays(chunkElement, undefined, shElement);\n      shArrays = Object.values(sh);\n    }\n\n    for (let i = 0; i < vertexElement.count; ++i) {\n\n      splatArray.addDefaultSplat();\n      const newSplat = splatArray.getSplat(splatArray.splatCount - 1);\n\n      PlayCanvasCompressedPlyParser.decompressBaseSplat(i, 0, position, positionExtremes, scale,\n                                                        scaleExtremes, rotation, colorExtremes, color, newSplat);\n\n      if (outSphericalHarmonicsDegree > 0) {\n        PlayCanvasCompressedPlyParser.decompressSphericalHarmonics(\n          i, shArrays, outSphericalHarmonicsDegree, sphericalHarmonicsDegree, newSplat\n        );\n      }\n    }\n\n    return splatArray;\n  }\n\n  static parseToUncompressedSplatBuffer(plyBuffer, outSphericalHarmonicsDegree) {\n    const { chunkElement, vertexElement, shElement, sphericalHarmonicsDegree } = PlayCanvasCompressedPlyParser.readPly(plyBuffer);\n\n    outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, sphericalHarmonicsDegree);\n\n    const {\n      splatBuffer,\n      splatBufferDataOffsetBytes\n    } = SplatBuffer.preallocateUncompressed(vertexElement.count, outSphericalHarmonicsDegree);\n\n    const { positionExtremes, scaleExtremes, colorExtremes, position, rotation, scale, color } =\n    PlayCanvasCompressedPlyParser.getElementStorageArrays(chunkElement, vertexElement);\n\n    let shArrays;\n    if (outSphericalHarmonicsDegree > 0) {\n      const { sh } = PlayCanvasCompressedPlyParser.getElementStorageArrays(chunkElement, undefined, shElement);\n      shArrays = Object.values(sh);\n    }\n\n    const outBytesPerSplat = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[outSphericalHarmonicsDegree].BytesPerSplat;\n\n    const newSplat = UncompressedSplatArray.createSplat(outSphericalHarmonicsDegree);\n\n    for (let i = 0; i < vertexElement.count; ++i) {\n      PlayCanvasCompressedPlyParser.decompressBaseSplat(\n        i, 0, position, positionExtremes, scale, scaleExtremes, rotation, colorExtremes, color, newSplat\n      );\n      if (outSphericalHarmonicsDegree > 0) {\n        PlayCanvasCompressedPlyParser.decompressSphericalHarmonics(\n          i, shArrays, outSphericalHarmonicsDegree, sphericalHarmonicsDegree, newSplat\n        );\n      }\n\n      const outBase = i * outBytesPerSplat + splatBufferDataOffsetBytes;\n      SplatBuffer.writeSplatDataToSectionBuffer(newSplat, splatBuffer.bufferData, outBase, 0, outSphericalHarmonicsDegree);\n    }\n\n    return splatBuffer;\n  }\n\n}\n\nconst PlyFormat = {\n    'INRIAV1': 0,\n    'INRIAV2': 1,\n    'PlayCanvasCompressed': 2\n};\n\nconst [\n        FieldSizeIdDouble, FieldSizeIdInt, FieldSizeIdUInt, FieldSizeIdFloat, FieldSizeIdShort, FieldSizeIdUShort, FieldSizeIdUChar\n      ] = [0, 1, 2, 3, 4, 5, 6];\n\nconst FieldSizeStringMap = {\n    'double': FieldSizeIdDouble,\n    'int': FieldSizeIdInt,\n    'uint': FieldSizeIdUInt,\n    'float': FieldSizeIdFloat,\n    'short': FieldSizeIdShort,\n    'ushort': FieldSizeIdUShort,\n    'uchar': FieldSizeIdUChar,\n};\n\nconst FieldSize = {\n    [FieldSizeIdDouble]: 8,\n    [FieldSizeIdInt]: 4,\n    [FieldSizeIdUInt]: 4,\n    [FieldSizeIdFloat]: 4,\n    [FieldSizeIdShort]: 2,\n    [FieldSizeIdUShort]: 2,\n    [FieldSizeIdUChar]: 1,\n};\n\nclass PlyParserUtils {\n\n    static HeaderEndToken = 'end_header';\n\n    static decodeSectionHeader(headerLines, fieldNameIdMap, headerStartLine = 0) {\n\n        const extractedLines = [];\n\n        let processingSection = false;\n        let headerEndLine = -1;\n        let vertexCount = 0;\n        let endOfHeader = false;\n        let sectionName = null;\n\n        const fieldIds = [];\n        const fieldTypes = [];\n        const allFieldNames = [];\n        const usedFieldNames = [];\n        const fieldTypesByName = {};\n\n        for (let i = headerStartLine; i < headerLines.length; i++) {\n            const line = headerLines[i].trim();\n            if (line.startsWith('element')) {\n                if (processingSection) {\n                    headerEndLine--;\n                    break;\n                } else {\n                    processingSection = true;\n                    headerStartLine = i;\n                    headerEndLine = i;\n                    const lineComponents = line.split(' ');\n                    let validComponents = 0;\n                    for (let lineComponent of lineComponents) {\n                        const trimmedComponent = lineComponent.trim();\n                        if (trimmedComponent.length > 0) {\n                            validComponents++;\n                            if (validComponents === 2) {\n                                sectionName = trimmedComponent;\n                            } else if (validComponents === 3) {\n                                vertexCount = parseInt(trimmedComponent);\n                            }\n                        }\n                    }\n                }\n            } else if (line.startsWith('property')) {\n                const fieldMatch = line.match(/(\\w+)\\s+(\\w+)\\s+(\\w+)/);\n                if (fieldMatch) {\n                    const fieldTypeStr = fieldMatch[2];\n                    const fieldName = fieldMatch[3];\n                    allFieldNames.push(fieldName);\n                    const fieldId = fieldNameIdMap[fieldName];\n                    fieldTypesByName[fieldName] = fieldTypeStr;\n                    const fieldType = FieldSizeStringMap[fieldTypeStr];\n                    if (fieldId !== undefined) {\n                        usedFieldNames.push(fieldName);\n                        fieldIds.push(fieldId);\n                        fieldTypes[fieldId] = fieldType;\n                    }\n                }\n            }\n            if (line === PlyParserUtils.HeaderEndToken) {\n                endOfHeader = true;\n                break;\n            }\n            if (processingSection) {\n                extractedLines.push(line);\n                headerEndLine++;\n            }\n        }\n\n        const fieldOffsets = [];\n        let bytesPerVertex = 0;\n        for (let fieldName of allFieldNames) {\n            const fieldType = fieldTypesByName[fieldName];\n            if (fieldTypesByName.hasOwnProperty(fieldName)) {\n                const fieldId = fieldNameIdMap[fieldName];\n                if (fieldId !== undefined) {\n                    fieldOffsets[fieldId] = bytesPerVertex;\n                }\n            }\n            bytesPerVertex += FieldSize[FieldSizeStringMap[fieldType]];\n        }\n\n        const sphericalHarmonics = PlyParserUtils.decodeSphericalHarmonicsFromSectionHeader(allFieldNames, fieldNameIdMap);\n\n        return {\n            'headerLines': extractedLines,\n            'headerStartLine': headerStartLine,\n            'headerEndLine': headerEndLine,\n            'fieldTypes': fieldTypes,\n            'fieldIds': fieldIds,\n            'fieldOffsets': fieldOffsets,\n            'bytesPerVertex': bytesPerVertex,\n            'vertexCount': vertexCount,\n            'dataSizeBytes': bytesPerVertex * vertexCount,\n            'endOfHeader': endOfHeader,\n            'sectionName': sectionName,\n            'sphericalHarmonicsDegree': sphericalHarmonics.degree,\n            'sphericalHarmonicsCoefficientsPerChannel': sphericalHarmonics.coefficientsPerChannel,\n            'sphericalHarmonicsDegree1Fields': sphericalHarmonics.degree1Fields,\n            'sphericalHarmonicsDegree2Fields': sphericalHarmonics.degree2Fields\n        };\n\n    }\n\n    static decodeSphericalHarmonicsFromSectionHeader(fieldNames, fieldNameIdMap) {\n        let sphericalHarmonicsFieldCount = 0;\n        let coefficientsPerChannel = 0;\n        for (let fieldName of fieldNames) {\n            if (fieldName.startsWith('f_rest')) sphericalHarmonicsFieldCount++;\n        }\n        coefficientsPerChannel = sphericalHarmonicsFieldCount / 3;\n        let degree = 0;\n        if (coefficientsPerChannel >= 3) degree = 1;\n        if (coefficientsPerChannel >= 8) degree = 2;\n\n        let degree1Fields = [];\n        let degree2Fields = [];\n\n        for (let rgb = 0; rgb < 3; rgb++) {\n            if (degree >= 1) {\n                for (let i = 0; i < 3; i++) {\n                    degree1Fields.push(fieldNameIdMap['f_rest_' + (i + coefficientsPerChannel * rgb)]);\n                }\n            }\n            if (degree >= 2) {\n                for (let i = 0; i < 5; i++) {\n                    degree2Fields.push(fieldNameIdMap['f_rest_' + (i + coefficientsPerChannel * rgb + 3)]);\n                }\n            }\n        }\n\n        return {\n            'degree': degree,\n            'coefficientsPerChannel': coefficientsPerChannel,\n            'degree1Fields': degree1Fields,\n            'degree2Fields': degree2Fields\n        };\n    }\n\n    static getHeaderSectionNames(headerLines) {\n        const sectionNames = [];\n        for (let headerLine of headerLines) {\n            if (headerLine.startsWith('element')) {\n                const lineComponents = headerLine.split(' ');\n                let validComponents = 0;\n                for (let lineComponent of lineComponents) {\n                    const trimmedComponent = lineComponent.trim();\n                    if (trimmedComponent.length > 0) {\n                        validComponents++;\n                        if (validComponents === 2) {\n                            sectionNames.push(trimmedComponent);\n                        }\n                    }\n                }\n            }\n        }\n        return sectionNames;\n    }\n\n    static checkTextForEndHeader(endHeaderTestText) {\n        if (endHeaderTestText.includes(PlyParserUtils.HeaderEndToken)) {\n            return true;\n        }\n        return false;\n    }\n\n    static checkBufferForEndHeader(buffer, searchOfset, chunkSize, decoder) {\n        const endHeaderTestChunk = new Uint8Array(buffer, Math.max(0, searchOfset - chunkSize), chunkSize);\n        const endHeaderTestText = decoder.decode(endHeaderTestChunk);\n        return PlyParserUtils.checkTextForEndHeader(endHeaderTestText);\n    }\n\n    static extractHeaderFromBufferToText(plyBuffer) {\n        const decoder = new TextDecoder();\n        let headerOffset = 0;\n        let headerText = '';\n        const readChunkSize = 100;\n\n        while (true) {\n            if (headerOffset + readChunkSize >= plyBuffer.byteLength) {\n                throw new Error('End of file reached while searching for end of header');\n            }\n            const headerChunk = new Uint8Array(plyBuffer, headerOffset, readChunkSize);\n            headerText += decoder.decode(headerChunk);\n            headerOffset += readChunkSize;\n\n            if (PlyParserUtils.checkBufferForEndHeader(plyBuffer, headerOffset, readChunkSize * 2, decoder)) {\n                break;\n            }\n        }\n\n        return headerText;\n    }\n\n    static readHeaderFromBuffer(plyBuffer) {\n        const decoder = new TextDecoder();\n        let headerOffset = 0;\n        let headerText = '';\n        const readChunkSize = 100;\n\n        while (true) {\n            if (headerOffset + readChunkSize >= plyBuffer.byteLength) {\n                throw new Error('End of file reached while searching for end of header');\n            }\n            const headerChunk = new Uint8Array(plyBuffer, headerOffset, readChunkSize);\n            headerText += decoder.decode(headerChunk);\n            headerOffset += readChunkSize;\n\n            if (PlyParserUtils.checkBufferForEndHeader(plyBuffer, headerOffset, readChunkSize * 2, decoder)) {\n                break;\n            }\n        }\n\n        return headerText;\n    }\n\n    static convertHeaderTextToLines(headerText) {\n        const headerLines = headerText.split('\\n');\n        const prunedLines = [];\n        for (let i = 0; i < headerLines.length; i++) {\n            const line = headerLines[i].trim();\n            prunedLines.push(line);\n            if (line === PlyParserUtils.HeaderEndToken) {\n                break;\n            }\n        }\n        return prunedLines;\n    }\n\n    static determineHeaderFormatFromHeaderText(headertText) {\n        const headerLines = PlyParserUtils.convertHeaderTextToLines(headertText);\n        let format = PlyFormat.INRIAV1;\n        for (let i = 0; i < headerLines.length; i++) {\n            const line = headerLines[i].trim();\n            if (line.startsWith('element chunk') || line.match(/[A-Za-z]*packed_[A-Za-z]*/)) {\n                format = PlyFormat.PlayCanvasCompressed;\n            } else if (line.startsWith('element codebook_centers')) {\n                format = PlyFormat.INRIAV2;\n            } else if (line === PlyParserUtils.HeaderEndToken) {\n                break;\n            }\n        }\n        return format;\n    }\n\n    static determineHeaderFormatFromPlyBuffer(plyBuffer) {\n        const headertText = PlyParserUtils.extractHeaderFromBufferToText(plyBuffer);\n        return PlyParserUtils.determineHeaderFormatFromHeaderText(headertText);\n    }\n\n    static readVertex(vertexData, header, row, dataOffset, fieldsToRead, rawVertex, normalize = true) {\n        const offset = row * header.bytesPerVertex + dataOffset;\n        const fieldOffsets = header.fieldOffsets;\n        const fieldTypes = header.fieldTypes;\n        for (let fieldId of fieldsToRead) {\n            const fieldType = fieldTypes[fieldId];\n            if (fieldType === FieldSizeIdFloat) {\n                rawVertex[fieldId] = vertexData.getFloat32(offset + fieldOffsets[fieldId], true);\n            } else if (fieldType === FieldSizeIdShort) {\n                rawVertex[fieldId] = vertexData.getInt16(offset + fieldOffsets[fieldId], true);\n            } else if (fieldType === FieldSizeIdUShort) {\n                rawVertex[fieldId] = vertexData.getUint16(offset + fieldOffsets[fieldId], true);\n            } else if (fieldType === FieldSizeIdInt) {\n                rawVertex[fieldId] = vertexData.getInt32(offset + fieldOffsets[fieldId], true);\n            } else if (fieldType === FieldSizeIdUInt) {\n                rawVertex[fieldId] = vertexData.getUint32(offset + fieldOffsets[fieldId], true);\n            } else if (fieldType === FieldSizeIdUChar) {\n                if (normalize) {\n                    rawVertex[fieldId] = vertexData.getUint8(offset + fieldOffsets[fieldId]) / 255.0;\n                } else {\n                    rawVertex[fieldId] = vertexData.getUint8(offset + fieldOffsets[fieldId]);\n                }\n            }\n        }\n    }\n}\n\nconst BaseFieldNamesToRead = ['scale_0', 'scale_1', 'scale_2', 'rot_0', 'rot_1', 'rot_2', 'rot_3', 'x', 'y', 'z',\n                              'f_dc_0', 'f_dc_1', 'f_dc_2', 'opacity', 'red', 'green', 'blue', 'f_rest_0'];\n\nconst BaseFieldsToReadIndexes = BaseFieldNamesToRead.map((e, i) => i);\n\nconst [\n        SCALE_0, SCALE_1, SCALE_2, ROT_0, ROT_1, ROT_2, ROT_3, X, Y, Z, F_DC_0, F_DC_1, F_DC_2, OPACITY, RED$1, GREEN$1, BLUE$1, F_REST_0\n      ] = BaseFieldsToReadIndexes;\n\nclass INRIAV1PlyParser {\n\n    static decodeHeaderLines(headerLines) {\n\n        let shLineCount = 0;\n        headerLines.forEach((line) => {\n            if (line.includes('f_rest_')) shLineCount++;\n        });\n\n        let shFieldsToReadCount = 0;\n        if (shLineCount >= 45) {\n            shFieldsToReadCount = 45;\n        } else if (shLineCount >= 24) {\n            shFieldsToReadCount = 24;\n        } else if (shLineCount >= 9) {\n            shFieldsToReadCount = 9;\n        }\n\n        const shFieldIndexesToMap = Array.from(Array(Math.max(shFieldsToReadCount - 1, 0)));\n        let shRemainingFieldNamesToRead = shFieldIndexesToMap.map((element, index) => `f_rest_${index + 1}`);\n\n        const fieldNamesToRead = [...BaseFieldNamesToRead, ...shRemainingFieldNamesToRead];\n        const fieldsToReadIndexes = fieldNamesToRead.map((e, i) => i);\n\n        const fieldNameIdMap = fieldsToReadIndexes.reduce((acc, element) => {\n            acc[fieldNamesToRead[element]] = element;\n            return acc;\n        }, {});\n        const header = PlyParserUtils.decodeSectionHeader(headerLines, fieldNameIdMap, 0);\n        header.splatCount = header.vertexCount;\n        header.bytesPerSplat = header.bytesPerVertex;\n        header.fieldsToReadIndexes = fieldsToReadIndexes;\n        return header;\n    }\n\n    static decodeHeaderText(headerText) {\n        const headerLines = PlyParserUtils.convertHeaderTextToLines(headerText);\n        const header = INRIAV1PlyParser.decodeHeaderLines(headerLines);\n        header.headerText = headerText;\n        header.headerSizeBytes = headerText.indexOf(PlyParserUtils.HeaderEndToken) + PlyParserUtils.HeaderEndToken.length + 1;\n        return header;\n    }\n\n    static decodeHeaderFromBuffer(plyBuffer) {\n        const headerText = PlyParserUtils.readHeaderFromBuffer(plyBuffer);\n        return INRIAV1PlyParser.decodeHeaderText(headerText);\n    }\n\n    static findSplatData(plyBuffer, header) {\n        return new DataView(plyBuffer, header.headerSizeBytes);\n    }\n\n    static parseToUncompressedSplatBufferSection(header, fromSplat, toSplat, splatData, splatDataOffset,\n                                                 toBuffer, toOffset, outSphericalHarmonicsDegree = 0) {\n        outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, header.sphericalHarmonicsDegree);\n        const outBytesPerSplat = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[outSphericalHarmonicsDegree].BytesPerSplat;\n\n        for (let i = fromSplat; i <= toSplat; i++) {\n            const parsedSplat = INRIAV1PlyParser.parseToUncompressedSplat(splatData, i, header,\n                                                                          splatDataOffset, outSphericalHarmonicsDegree);\n            const outBase = i * outBytesPerSplat + toOffset;\n            SplatBuffer.writeSplatDataToSectionBuffer(parsedSplat, toBuffer, outBase, 0, outSphericalHarmonicsDegree);\n        }\n    }\n\n    static parseToUncompressedSplatArraySection(header, fromSplat, toSplat, splatData, splatDataOffset,\n                                         splatArray, outSphericalHarmonicsDegree = 0) {\n        outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, header.sphericalHarmonicsDegree);\n        for (let i = fromSplat; i <= toSplat; i++) {\n            const parsedSplat = INRIAV1PlyParser.parseToUncompressedSplat(splatData, i, header,\n                                                                          splatDataOffset, outSphericalHarmonicsDegree);\n            splatArray.addSplat(parsedSplat);\n        }\n    }\n\n    static decodeSectionSplatData(sectionSplatData, splatCount, sectionHeader, outSphericalHarmonicsDegree, toSplatArray = true) {\n        outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, sectionHeader.sphericalHarmonicsDegree);\n        if (toSplatArray) {\n            const splatArray = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n            for (let row = 0; row < splatCount; row++) {\n                const newSplat = INRIAV1PlyParser.parseToUncompressedSplat(sectionSplatData, row, sectionHeader,\n                                                                           0, outSphericalHarmonicsDegree);\n                splatArray.addSplat(newSplat);\n            }\n            return splatArray;\n        } else {\n            const {\n                splatBuffer,\n                splatBufferDataOffsetBytes\n              } = SplatBuffer.preallocateUncompressed(splatCount, outSphericalHarmonicsDegree);\n            INRIAV1PlyParser.parseToUncompressedSplatBufferSection(\n                sectionHeader, 0, splatCount - 1, sectionSplatData, 0,\n                splatBuffer.bufferData, splatBufferDataOffsetBytes, outSphericalHarmonicsDegree\n            );\n            return splatBuffer;\n        }\n    }\n\n    static parseToUncompressedSplat = function() {\n\n        let rawSplat = [];\n        const tempRotation = new THREE.Quaternion();\n\n        const OFFSET_X = UncompressedSplatArray.OFFSET.X;\n        const OFFSET_Y = UncompressedSplatArray.OFFSET.Y;\n        const OFFSET_Z = UncompressedSplatArray.OFFSET.Z;\n\n        const OFFSET_SCALE0 = UncompressedSplatArray.OFFSET.SCALE0;\n        const OFFSET_SCALE1 = UncompressedSplatArray.OFFSET.SCALE1;\n        const OFFSET_SCALE2 = UncompressedSplatArray.OFFSET.SCALE2;\n\n        const OFFSET_ROTATION0 = UncompressedSplatArray.OFFSET.ROTATION0;\n        const OFFSET_ROTATION1 = UncompressedSplatArray.OFFSET.ROTATION1;\n        const OFFSET_ROTATION2 = UncompressedSplatArray.OFFSET.ROTATION2;\n        const OFFSET_ROTATION3 = UncompressedSplatArray.OFFSET.ROTATION3;\n\n        const OFFSET_FDC0 = UncompressedSplatArray.OFFSET.FDC0;\n        const OFFSET_FDC1 = UncompressedSplatArray.OFFSET.FDC1;\n        const OFFSET_FDC2 = UncompressedSplatArray.OFFSET.FDC2;\n        const OFFSET_OPACITY = UncompressedSplatArray.OFFSET.OPACITY;\n\n        const OFFSET_FRC = [];\n\n        for (let i = 0; i < 45; i++) {\n            OFFSET_FRC[i] = UncompressedSplatArray.OFFSET.FRC0 + i;\n        }\n\n        return function(splatData, row, header, splatDataOffset = 0, outSphericalHarmonicsDegree = 0) {\n            outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, header.sphericalHarmonicsDegree);\n            INRIAV1PlyParser.readSplat(splatData, header, row, splatDataOffset, rawSplat);\n            const newSplat = UncompressedSplatArray.createSplat(outSphericalHarmonicsDegree);\n            if (rawSplat[SCALE_0] !== undefined) {\n                newSplat[OFFSET_SCALE0] = Math.exp(rawSplat[SCALE_0]);\n                newSplat[OFFSET_SCALE1] = Math.exp(rawSplat[SCALE_1]);\n                newSplat[OFFSET_SCALE2] = Math.exp(rawSplat[SCALE_2]);\n            } else {\n                newSplat[OFFSET_SCALE0] = 0.01;\n                newSplat[OFFSET_SCALE1] = 0.01;\n                newSplat[OFFSET_SCALE2] = 0.01;\n            }\n\n            if (rawSplat[F_DC_0] !== undefined) {\n                const SH_C0 = 0.28209479177387814;\n                newSplat[OFFSET_FDC0] = (0.5 + SH_C0 * rawSplat[F_DC_0]) * 255;\n                newSplat[OFFSET_FDC1] = (0.5 + SH_C0 * rawSplat[F_DC_1]) * 255;\n                newSplat[OFFSET_FDC2] = (0.5 + SH_C0 * rawSplat[F_DC_2]) * 255;\n            } else if (rawSplat[RED$1] !== undefined) {\n                newSplat[OFFSET_FDC0] = rawSplat[RED$1] * 255;\n                newSplat[OFFSET_FDC1] = rawSplat[GREEN$1] * 255;\n                newSplat[OFFSET_FDC2] = rawSplat[BLUE$1] * 255;\n            } else {\n                newSplat[OFFSET_FDC0] = 0;\n                newSplat[OFFSET_FDC1] = 0;\n                newSplat[OFFSET_FDC2] = 0;\n            }\n\n            if (rawSplat[OPACITY] !== undefined) {\n                newSplat[OFFSET_OPACITY] = (1 / (1 + Math.exp(-rawSplat[OPACITY]))) * 255;\n            }\n\n            newSplat[OFFSET_FDC0] = clamp(Math.floor(newSplat[OFFSET_FDC0]), 0, 255);\n            newSplat[OFFSET_FDC1] = clamp(Math.floor(newSplat[OFFSET_FDC1]), 0, 255);\n            newSplat[OFFSET_FDC2] = clamp(Math.floor(newSplat[OFFSET_FDC2]), 0, 255);\n            newSplat[OFFSET_OPACITY] = clamp(Math.floor(newSplat[OFFSET_OPACITY]), 0, 255);\n\n            if (outSphericalHarmonicsDegree >= 1) {\n                if (rawSplat[F_REST_0] !== undefined) {\n                    for (let i = 0; i < 9; i++) {\n                        newSplat[OFFSET_FRC[i]] = rawSplat[header.sphericalHarmonicsDegree1Fields[i]];\n                    }\n                    if (outSphericalHarmonicsDegree >= 2) {\n                        for (let i = 0; i < 15; i++) {\n                            newSplat[OFFSET_FRC[9 + i]] = rawSplat[header.sphericalHarmonicsDegree2Fields[i]];\n                        }\n                    }\n                }\n            }\n\n            tempRotation.set(rawSplat[ROT_0], rawSplat[ROT_1], rawSplat[ROT_2], rawSplat[ROT_3]);\n            tempRotation.normalize();\n\n            newSplat[OFFSET_ROTATION0] = tempRotation.x;\n            newSplat[OFFSET_ROTATION1] = tempRotation.y;\n            newSplat[OFFSET_ROTATION2] = tempRotation.z;\n            newSplat[OFFSET_ROTATION3] = tempRotation.w;\n\n            newSplat[OFFSET_X] = rawSplat[X];\n            newSplat[OFFSET_Y] = rawSplat[Y];\n            newSplat[OFFSET_Z] = rawSplat[Z];\n\n            return newSplat;\n        };\n\n    }();\n\n    static readSplat(splatData, header, row, dataOffset, rawSplat) {\n        return PlyParserUtils.readVertex(splatData, header, row, dataOffset, header.fieldsToReadIndexes, rawSplat, true);\n    }\n\n    static parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree = 0) {\n        const { header, splatCount, splatData } = separatePlyHeaderAndData(plyBuffer);\n        return INRIAV1PlyParser.decodeSectionSplatData(splatData, splatCount, header, outSphericalHarmonicsDegree, true);\n    }\n\n    static parseToUncompressedSplatBuffer(plyBuffer, outSphericalHarmonicsDegree = 0) {\n        const { header, splatCount, splatData } = separatePlyHeaderAndData(plyBuffer);\n        return INRIAV1PlyParser.decodeSectionSplatData(splatData, splatCount, header, outSphericalHarmonicsDegree, false);\n    }\n}\n\nfunction separatePlyHeaderAndData(plyBuffer) {\n    const header = INRIAV1PlyParser.decodeHeaderFromBuffer(plyBuffer);\n    const splatCount = header.splatCount;\n    const splatData = INRIAV1PlyParser.findSplatData(plyBuffer, header);\n    return {\n        header,\n        splatCount,\n        splatData\n    };\n}\n\nconst CodeBookEntryNamesToRead = [\n    'features_dc', 'features_rest_0', 'features_rest_1', 'features_rest_2', 'features_rest_3', 'features_rest_4', 'features_rest_5',\n    'features_rest_6', 'features_rest_7', 'features_rest_8', 'features_rest_9', 'features_rest_10', 'features_rest_11', 'features_rest_12',\n    'features_rest_13', 'features_rest_14', 'opacity', 'scaling', 'rotation_re', 'rotation_im'\n];\nconst CodeBookEntriesToReadIndexes = CodeBookEntryNamesToRead.map((e, i) => i);\n\nconst [\n        CB_FEATURES_DC, CB_FEATURES_REST_0, CB_FEATURES_REST_3, CB_OPACITY, CB_SCALING, CB_ROTATION_RE, CB_ROTATION_IM\n      ] = [0, 1, 4, 16, 17, 18, 19];\n\nconst FieldNamesToRead = ['scale_0', 'scale_1', 'scale_2', 'rot_0', 'rot_1', 'rot_2', 'rot_3',\n                          'x', 'y', 'z', 'f_dc_0', 'f_dc_1', 'f_dc_2', 'opacity', 'red', 'green', 'blue',\n                          'f_rest_0', 'f_rest_1', 'f_rest_2', 'f_rest_3', 'f_rest_4', 'f_rest_5', 'f_rest_6', 'f_rest_7', 'f_rest_8',\n                          'f_rest_9', 'f_rest_10', 'f_rest_11', 'f_rest_12', 'f_rest_13', 'f_rest_14', 'f_rest_15', 'f_rest_16',\n                          'f_rest_17', 'f_rest_18', 'f_rest_19', 'f_rest_20', 'f_rest_21', 'f_rest_22', 'f_rest_23', 'f_rest_24',\n                          'f_rest_25', 'f_rest_26', 'f_rest_27', 'f_rest_28', 'f_rest_29', 'f_rest_30', 'f_rest_31', 'f_rest_32',\n                          'f_rest_33', 'f_rest_34', 'f_rest_35', 'f_rest_36', 'f_rest_37', 'f_rest_38', 'f_rest_39', 'f_rest_40',\n                          'f_rest_41', 'f_rest_42', 'f_rest_43', 'f_rest_44', 'f_rest_45'\n                         ];\nconst FieldsToReadIndexes = FieldNamesToRead.map((e, i) => i);\n\nconst [\n        PLY_SCALE_0, PLY_SCALE_1, PLY_SCALE_2, PLY_ROT_0, PLY_ROT_1, PLY_ROT_2, PLY_ROT_3, PLY_X, PLY_Y, PLY_Z,\n        PLY_F_DC_0, PLY_F_DC_1, PLY_F_DC_2, PLY_OPACITY,\n      ] = FieldsToReadIndexes;\n\nconst PLY_RED = PLY_F_DC_0;\nconst PLY_GREEN = PLY_F_DC_1;\nconst PLY_BLUE = PLY_F_DC_2;\n\nconst fromHalfFloat = (hf) =>{\n    const t = (31744 & hf) >> 10;\n    const a = 1023 & hf;\n    return (hf >> 15 ? -1 : 1)*(t ? t === 31 ? a ? NaN : 1/0 : Math.pow(2, t - 15) *( 1 + a / 1024) : a / 1024*6103515625e-14);\n};\n\nclass INRIAV2PlyParser {\n\n    static decodeSectionHeadersFromHeaderLines(headerLines) {\n        const fieldNameIdMap = FieldsToReadIndexes.reduce((acc, element) => {\n            acc[FieldNamesToRead[element]] = element;\n            return acc;\n        }, {});\n\n        const codeBookEntriesToReadIdMap = CodeBookEntriesToReadIndexes.reduce((acc, element) => {\n            acc[CodeBookEntryNamesToRead[element]] = element;\n            return acc;\n        }, {});\n\n        const sectionNames = PlyParserUtils.getHeaderSectionNames(headerLines);\n        let codeBookSectionIndex;\n        for (let s = 0; s < sectionNames.length; s++) {\n            const sectionName = sectionNames[s];\n            if (sectionName === 'codebook_centers') {\n                codeBookSectionIndex = s;\n            }\n        }\n\n        let currentStartLine = 0;\n        let lastSectionFound = false;\n        const sectionHeaders = [];\n        let sectionIndex = 0;\n        while (!lastSectionFound) {\n            let sectionHeader;\n            if (sectionIndex === codeBookSectionIndex) {\n                sectionHeader = PlyParserUtils.decodeSectionHeader(headerLines, codeBookEntriesToReadIdMap, currentStartLine);\n            } else {\n                sectionHeader = PlyParserUtils.decodeSectionHeader(headerLines, fieldNameIdMap, currentStartLine);\n            }\n            lastSectionFound = sectionHeader.endOfHeader;\n            currentStartLine = sectionHeader.headerEndLine + 1;\n            if (!lastSectionFound) {\n                sectionHeader.splatCount = sectionHeader.vertexCount;\n                sectionHeader.bytesPerSplat = sectionHeader.bytesPerVertex;\n            }\n            sectionHeaders.push(sectionHeader);\n            sectionIndex++;\n        }\n        return sectionHeaders;\n    }\n\n    static decodeSectionHeadersFromHeaderText(headerText) {\n        const headerLines = PlyParserUtils.convertHeaderTextToLines(headerText);\n        return INRIAV2PlyParser.decodeSectionHeadersFromHeaderLines(headerLines);\n    }\n\n    static getSplatCountFromSectionHeaders(sectionHeaders) {\n        let splatCount = 0;\n        for (let sectionHeader of sectionHeaders) {\n            if (sectionHeader.sectionName !== 'codebook_centers') {\n                splatCount += sectionHeader.vertexCount;\n            }\n        }\n        return splatCount;\n    }\n\n    static decodeHeaderFromHeaderText(headerText) {\n        const headerSizeBytes = headerText.indexOf(PlyParserUtils.HeaderEndToken) + PlyParserUtils.HeaderEndToken.length + 1;\n        const sectionHeaders = INRIAV2PlyParser.decodeSectionHeadersFromHeaderText(headerText);\n        const splatCount = INRIAV2PlyParser.getSplatCountFromSectionHeaders(sectionHeaders);\n        return {\n            'headerSizeBytes': headerSizeBytes,\n            'sectionHeaders': sectionHeaders,\n            'splatCount': splatCount\n        };\n    }\n\n    static decodeHeaderFromBuffer(plyBuffer) {\n        const headerText = PlyParserUtils.readHeaderFromBuffer(plyBuffer);\n        return INRIAV2PlyParser.decodeHeaderFromHeaderText(headerText);\n    }\n\n    static findVertexData(plyBuffer, header, targetSection) {\n        let byteOffset = header.headerSizeBytes;\n        for (let s = 0; s < targetSection && s < header.sectionHeaders.length; s++) {\n            const sectionHeader = header.sectionHeaders[s];\n            byteOffset += sectionHeader.dataSizeBytes;\n        }\n        return new DataView(plyBuffer, byteOffset, header.sectionHeaders[targetSection].dataSizeBytes);\n    }\n\n    static decodeCodeBook(codeBookData, sectionHeader) {\n\n        const rawVertex = [];\n        const codeBook = [];\n        for (let row = 0; row < sectionHeader.vertexCount; row++) {\n            PlyParserUtils.readVertex(codeBookData, sectionHeader, row, 0, CodeBookEntriesToReadIndexes, rawVertex);\n            for (let index of CodeBookEntriesToReadIndexes) {\n                const codeBookElementOffset = CodeBookEntriesToReadIndexes[index];\n                let codeBookPage = codeBook[codeBookElementOffset];\n                if (!codeBookPage) {\n                    codeBook[codeBookElementOffset] = codeBookPage = [];\n                }\n                codeBookPage.push(rawVertex[index]);\n            }\n        }\n        for (let page = 0; page < codeBook.length; page++) {\n            const codeBookPage = codeBook[page];\n            const SH_C0 = 0.28209479177387814;\n            for (let i = 0; i < codeBookPage.length; i++) {\n               const baseValue = fromHalfFloat(codeBookPage[i]);\n                if (page === CB_OPACITY) {\n                    codeBookPage[i] = Math.round((1 / (1 + Math.exp(-baseValue))) * 255);\n                } else if (page === CB_FEATURES_DC) {\n                    codeBookPage[i] = Math.round((0.5 + SH_C0 * baseValue) * 255);\n                } else if (page === CB_SCALING) {\n                    codeBookPage[i] = Math.exp(baseValue);\n                } else {\n                    codeBookPage[i] = baseValue;\n                }\n            }\n        }\n        return codeBook;\n    }\n\n    static decodeSectionSplatData(sectionSplatData, splatCount, sectionHeader, codeBook, outSphericalHarmonicsDegree) {\n        outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, sectionHeader.sphericalHarmonicsDegree);\n        const splatArray = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n        for (let row = 0; row < splatCount; row++) {\n            const newSplat = INRIAV2PlyParser.parseToUncompressedSplat(sectionSplatData, row, sectionHeader, codeBook,\n                                                                       0, outSphericalHarmonicsDegree);\n            splatArray.addSplat(newSplat);\n        }\n        return splatArray;\n    }\n\n    static parseToUncompressedSplat = function() {\n\n        let rawSplat = [];\n        const tempRotation = new THREE.Quaternion();\n\n        const OFFSET_X = UncompressedSplatArray.OFFSET.X;\n        const OFFSET_Y = UncompressedSplatArray.OFFSET.Y;\n        const OFFSET_Z = UncompressedSplatArray.OFFSET.Z;\n\n        const OFFSET_SCALE0 = UncompressedSplatArray.OFFSET.SCALE0;\n        const OFFSET_SCALE1 = UncompressedSplatArray.OFFSET.SCALE1;\n        const OFFSET_SCALE2 = UncompressedSplatArray.OFFSET.SCALE2;\n\n        const OFFSET_ROTATION0 = UncompressedSplatArray.OFFSET.ROTATION0;\n        const OFFSET_ROTATION1 = UncompressedSplatArray.OFFSET.ROTATION1;\n        const OFFSET_ROTATION2 = UncompressedSplatArray.OFFSET.ROTATION2;\n        const OFFSET_ROTATION3 = UncompressedSplatArray.OFFSET.ROTATION3;\n\n        const OFFSET_FDC0 = UncompressedSplatArray.OFFSET.FDC0;\n        const OFFSET_FDC1 = UncompressedSplatArray.OFFSET.FDC1;\n        const OFFSET_FDC2 = UncompressedSplatArray.OFFSET.FDC2;\n        const OFFSET_OPACITY = UncompressedSplatArray.OFFSET.OPACITY;\n\n        const OFFSET_FRC = [];\n\n        for (let i = 0; i < 45; i++) {\n            OFFSET_FRC[i] = UncompressedSplatArray.OFFSET.FRC0 + i;\n        }\n\n        return function(splatData, row, header, codeBook, splatDataOffset = 0, outSphericalHarmonicsDegree = 0) {\n            outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, header.sphericalHarmonicsDegree);\n            INRIAV2PlyParser.readSplat(splatData, header, row, splatDataOffset, rawSplat);\n            const newSplat = UncompressedSplatArray.createSplat(outSphericalHarmonicsDegree);\n            if (rawSplat[PLY_SCALE_0] !== undefined) {\n                newSplat[OFFSET_SCALE0] = codeBook[CB_SCALING][rawSplat[PLY_SCALE_0]];\n                newSplat[OFFSET_SCALE1] = codeBook[CB_SCALING][rawSplat[PLY_SCALE_1]];\n                newSplat[OFFSET_SCALE2] = codeBook[CB_SCALING][rawSplat[PLY_SCALE_2]];\n            } else {\n                newSplat[OFFSET_SCALE0] = 0.01;\n                newSplat[OFFSET_SCALE1] = 0.01;\n                newSplat[OFFSET_SCALE2] = 0.01;\n            }\n\n            if (rawSplat[PLY_F_DC_0] !== undefined) {\n                newSplat[OFFSET_FDC0] = codeBook[CB_FEATURES_DC][rawSplat[PLY_F_DC_0]];\n                newSplat[OFFSET_FDC1] = codeBook[CB_FEATURES_DC][rawSplat[PLY_F_DC_1]];\n                newSplat[OFFSET_FDC2] = codeBook[CB_FEATURES_DC][rawSplat[PLY_F_DC_2]];\n            } else if (rawSplat[PLY_RED] !== undefined) {\n                newSplat[OFFSET_FDC0] = rawSplat[PLY_RED] * 255;\n                newSplat[OFFSET_FDC1] = rawSplat[PLY_GREEN] * 255;\n                newSplat[OFFSET_FDC2] = rawSplat[PLY_BLUE] * 255;\n            } else {\n                newSplat[OFFSET_FDC0] = 0;\n                newSplat[OFFSET_FDC1] = 0;\n                newSplat[OFFSET_FDC2] = 0;\n            }\n\n            if (rawSplat[PLY_OPACITY] !== undefined) {\n                newSplat[OFFSET_OPACITY] = codeBook[CB_OPACITY][rawSplat[PLY_OPACITY]];\n            }\n\n            newSplat[OFFSET_FDC0] = clamp(Math.floor(newSplat[OFFSET_FDC0]), 0, 255);\n            newSplat[OFFSET_FDC1] = clamp(Math.floor(newSplat[OFFSET_FDC1]), 0, 255);\n            newSplat[OFFSET_FDC2] = clamp(Math.floor(newSplat[OFFSET_FDC2]), 0, 255);\n            newSplat[OFFSET_OPACITY] = clamp(Math.floor(newSplat[OFFSET_OPACITY]), 0, 255);\n\n            if (outSphericalHarmonicsDegree >= 1 && header.sphericalHarmonicsDegree >= 1) {\n                for (let i = 0; i < 9; i++) {\n                    const codeBookPage = codeBook[CB_FEATURES_REST_0 + i % 3];\n                    newSplat[OFFSET_FRC[i]] = codeBookPage[rawSplat[header.sphericalHarmonicsDegree1Fields[i]]];\n                }\n                if (outSphericalHarmonicsDegree >= 2 && header.sphericalHarmonicsDegree >= 2) {\n                    for (let i = 0; i < 15; i++) {\n                        const codeBookPage = codeBook[CB_FEATURES_REST_3 + i % 5];\n                        newSplat[OFFSET_FRC[9 + i]] = codeBookPage[rawSplat[header.sphericalHarmonicsDegree2Fields[i]]];\n                    }\n                }\n            }\n\n            const rot0 = codeBook[CB_ROTATION_RE][rawSplat[PLY_ROT_0]];\n            const rot1 = codeBook[CB_ROTATION_IM][rawSplat[PLY_ROT_1]];\n            const rot2 = codeBook[CB_ROTATION_IM][rawSplat[PLY_ROT_2]];\n            const rot3 = codeBook[CB_ROTATION_IM][rawSplat[PLY_ROT_3]];\n            tempRotation.set(rot0, rot1, rot2, rot3);\n            tempRotation.normalize();\n\n            newSplat[OFFSET_ROTATION0] = tempRotation.x;\n            newSplat[OFFSET_ROTATION1] = tempRotation.y;\n            newSplat[OFFSET_ROTATION2] = tempRotation.z;\n            newSplat[OFFSET_ROTATION3] = tempRotation.w;\n\n            newSplat[OFFSET_X] = fromHalfFloat(rawSplat[PLY_X]);\n            newSplat[OFFSET_Y] = fromHalfFloat(rawSplat[PLY_Y]);\n            newSplat[OFFSET_Z] = fromHalfFloat(rawSplat[PLY_Z]);\n\n            return newSplat;\n        };\n\n    }();\n\n    static readSplat(splatData, header, row, dataOffset, rawSplat) {\n        return PlyParserUtils.readVertex(splatData, header, row, dataOffset, FieldsToReadIndexes, rawSplat, false);\n    }\n\n    static parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree = 0) {\n        const splatArrays = [];\n        const header = INRIAV2PlyParser.decodeHeaderFromBuffer(plyBuffer, outSphericalHarmonicsDegree);\n        let codeBook;\n\n        for (let s = 0; s < header.sectionHeaders.length; s++) {\n            const sectionHeader = header.sectionHeaders[s];\n            if (sectionHeader.sectionName === 'codebook_centers') {\n                const codeBookData = INRIAV2PlyParser.findVertexData(plyBuffer, header, s);\n                codeBook = INRIAV2PlyParser.decodeCodeBook(codeBookData, sectionHeader);\n            }\n        }\n        for (let s = 0; s < header.sectionHeaders.length; s++) {\n            const sectionHeader = header.sectionHeaders[s];\n            if (sectionHeader.sectionName !== 'codebook_centers') {\n                const splatCount = sectionHeader.vertexCount;\n                const vertexData = INRIAV2PlyParser.findVertexData(plyBuffer, header, s);\n                const splatArray = INRIAV2PlyParser.decodeSectionSplatData(vertexData, splatCount, sectionHeader,\n                                                               codeBook, outSphericalHarmonicsDegree);\n                splatArrays.push(splatArray);\n            }\n        }\n\n        const unified = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n        for (let splatArray of splatArrays) {\n            for (let splat of splatArray.splats) {\n                unified.addSplat(splat);\n            }\n        }\n\n        return unified;\n    }\n}\n\nclass PlyParser {\n\n    static parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree = 0) {\n        const plyFormat = PlyParserUtils.determineHeaderFormatFromPlyBuffer(plyBuffer);\n        if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n            return PlayCanvasCompressedPlyParser.parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree);\n        } else if (plyFormat === PlyFormat.INRIAV1) {\n            return INRIAV1PlyParser.parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree);\n        } else if (plyFormat === PlyFormat.INRIAV2) {\n            return INRIAV2PlyParser.parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree);\n        }\n    }\n\n    static parseToUncompressedSplatBuffer(plyBuffer, outSphericalHarmonicsDegree = 0) {\n        const plyFormat = PlyParserUtils.determineHeaderFormatFromPlyBuffer(plyBuffer);\n        if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n            return PlayCanvasCompressedPlyParser.parseToUncompressedSplatBuffer(plyBuffer, outSphericalHarmonicsDegree);\n        } else if (plyFormat === PlyFormat.INRIAV1) {\n            return INRIAV1PlyParser.parseToUncompressedSplatBuffer(plyBuffer, outSphericalHarmonicsDegree);\n        } else if (plyFormat === PlyFormat.INRIAV2) {\n             // TODO: Implement!\n            throw new Error('parseToUncompressedSplatBuffer() is not implemented for INRIA V2 PLY files');\n        }\n    }\n\n}\n\nclass SplatPartitioner {\n\n    constructor(sectionCount, sectionFilters, groupingParameters, partitionGenerator) {\n        this.sectionCount = sectionCount;\n        this.sectionFilters = sectionFilters;\n        this.groupingParameters = groupingParameters;\n        this.partitionGenerator = partitionGenerator;\n    }\n\n    partitionUncompressedSplatArray(splatArray) {\n        let groupingParameters;\n        let sectionCount;\n        let sectionFilters;\n        if (this.partitionGenerator) {\n            const results = this.partitionGenerator(splatArray);\n            groupingParameters = results.groupingParameters;\n            sectionCount = results.sectionCount;\n            sectionFilters = results.sectionFilters;\n        } else {\n            groupingParameters = this.groupingParameters;\n            sectionCount = this.sectionCount;\n            sectionFilters = this.sectionFilters;\n        }\n\n        const newArrays = [];\n        for (let s = 0; s < sectionCount; s++) {\n            const sectionSplats = new UncompressedSplatArray(splatArray.sphericalHarmonicsDegree);\n            const sectionFilter = sectionFilters[s];\n            for (let i = 0; i < splatArray.splatCount; i++) {\n                if (sectionFilter(i)) {\n                    sectionSplats.addSplat(splatArray.splats[i]);\n                }\n            }\n            newArrays.push(sectionSplats);\n        }\n        return {\n            splatArrays: newArrays,\n            parameters: groupingParameters\n        };\n    }\n\n    static getStandardPartitioner(partitionSize = 0, sceneCenter = new THREE.Vector3(),\n                                  blockSize = SplatBuffer.BucketBlockSize, bucketSize = SplatBuffer.BucketSize) {\n\n        const partitionGenerator = (splatArray) => {\n\n            const OFFSET_X = UncompressedSplatArray.OFFSET.X;\n            const OFFSET_Y = UncompressedSplatArray.OFFSET.Y;\n            const OFFSET_Z = UncompressedSplatArray.OFFSET.Z;\n\n            if (partitionSize <= 0) partitionSize = splatArray.splatCount;\n\n            const center = new THREE.Vector3();\n            const clampDistance = 0.5;\n            const clampPoint = (point) => {\n                point.x = Math.floor(point.x / clampDistance) * clampDistance;\n                point.y = Math.floor(point.y / clampDistance) * clampDistance;\n                point.z = Math.floor(point.z / clampDistance) * clampDistance;\n            };\n            splatArray.splats.forEach((splat) => {\n                center.set(splat[OFFSET_X], splat[OFFSET_Y], splat[OFFSET_Z]).sub(sceneCenter);\n                clampPoint(center);\n                splat.centerDist = center.lengthSq();\n            });\n            splatArray.splats.sort((a, b) => {\n                let centerADist = a.centerDist;\n                let centerBDist = b.centerDist;\n                if (centerADist > centerBDist) return 1;\n                else return -1;\n            });\n\n            const sectionFilters = [];\n            const groupingParameters = [];\n            partitionSize = Math.min(splatArray.splatCount, partitionSize);\n            const patitionCount = Math.ceil(splatArray.splatCount / partitionSize);\n            let currentStartSplat = 0;\n            for (let i = 0; i < patitionCount; i ++) {\n                let startSplat = currentStartSplat;\n                sectionFilters.push((splatIndex) => {\n                    return splatIndex >= startSplat && splatIndex < startSplat + partitionSize;\n                });\n                groupingParameters.push({\n                    'blocksSize': blockSize,\n                    'bucketSize': bucketSize,\n                });\n                currentStartSplat += partitionSize;\n            }\n            return {\n                'sectionCount': sectionFilters.length,\n                sectionFilters,\n                groupingParameters\n            };\n        };\n        return new SplatPartitioner(undefined, undefined, undefined, partitionGenerator);\n    }\n}\n\nclass SplatBufferGenerator {\n\n    constructor(splatPartitioner, alphaRemovalThreshold, compressionLevel, sectionSize, sceneCenter, blockSize, bucketSize) {\n        this.splatPartitioner = splatPartitioner;\n        this.alphaRemovalThreshold = alphaRemovalThreshold;\n        this.compressionLevel = compressionLevel;\n        this.sectionSize = sectionSize;\n        this.sceneCenter = sceneCenter ? new THREE.Vector3().copy(sceneCenter) : undefined;\n        this.blockSize = blockSize;\n        this.bucketSize = bucketSize;\n    }\n\n    generateFromUncompressedSplatArray(splatArray) {\n        const partitionResults = this.splatPartitioner.partitionUncompressedSplatArray(splatArray);\n        return SplatBuffer.generateFromUncompressedSplatArrays(partitionResults.splatArrays,\n                                                               this.alphaRemovalThreshold, this.compressionLevel,\n                                                               this.sceneCenter, this.blockSize, this.bucketSize,\n                                                               partitionResults.parameters);\n    }\n\n    static getStandardGenerator(alphaRemovalThreshold = 1, compressionLevel = 1, sectionSize = 0, sceneCenter = new THREE.Vector3(),\n                                blockSize = SplatBuffer.BucketBlockSize, bucketSize = SplatBuffer.BucketSize) {\n        const splatPartitioner = SplatPartitioner.getStandardPartitioner(sectionSize, sceneCenter, blockSize, bucketSize);\n        return new SplatBufferGenerator(splatPartitioner, alphaRemovalThreshold, compressionLevel,\n                                        sectionSize, sceneCenter, blockSize, bucketSize);\n    }\n}\n\nconst LoaderStatus = {\n    'Downloading': 0,\n    'Processing': 1,\n    'Done': 2\n};\n\nclass DirectLoadError extends Error {\n\n    constructor(msg) {\n        super(msg);\n    }\n\n}\n\nconst InternalLoadType = {\n    ProgressiveToSplatBuffer: 0,\n    ProgressiveToSplatArray: 1,\n    DownloadBeforeProcessing: 2\n};\n\nfunction storeChunksInBuffer(chunks, buffer) {\n    let inBytes = 0;\n    for (let chunk of chunks) inBytes += chunk.sizeBytes;\n\n    if (!buffer || buffer.byteLength < inBytes) {\n        buffer = new ArrayBuffer(inBytes);\n    }\n\n    let offset = 0;\n    for (let chunk of chunks) {\n        new Uint8Array(buffer, offset, chunk.sizeBytes).set(chunk.data);\n        offset += chunk.sizeBytes;\n    }\n\n    return buffer;\n}\n\nfunction finalize$1(splatData, optimizeSplatData, minimumAlpha, compressionLevel, sectionSize, sceneCenter, blockSize, bucketSize) {\n    if (optimizeSplatData) {\n        const splatBufferGenerator = SplatBufferGenerator.getStandardGenerator(minimumAlpha, compressionLevel,\n                                                                               sectionSize, sceneCenter,\n                                                                               blockSize, bucketSize);\n        return splatBufferGenerator.generateFromUncompressedSplatArray(splatData);\n    } else {\n        return SplatBuffer.generateFromUncompressedSplatArrays([splatData], minimumAlpha, 0, new THREE.Vector3());\n    }\n}\n\nclass PlyLoader {\n\n    static loadFromURL(fileName, onProgress, progressiveLoadToSplatBuffer, onProgressiveLoadSectionProgress,\n                       minimumAlpha, compressionLevel, optimizeSplatData = true, outSphericalHarmonicsDegree = 0,\n                       headers, sectionSize, sceneCenter, blockSize, bucketSize) {\n\n        let internalLoadType;\n        if (!progressiveLoadToSplatBuffer && !optimizeSplatData) {\n            internalLoadType = InternalLoadType.DownloadBeforeProcessing;\n        } else {\n            if (optimizeSplatData) internalLoadType = InternalLoadType.ProgressiveToSplatArray;\n            else internalLoadType = InternalLoadType.ProgressiveToSplatBuffer;\n        }\n\n        const directLoadSectionSizeBytes = Constants.ProgressiveLoadSectionSize;\n        const splatBufferDataOffsetBytes = SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes;\n        const sectionCount = 1;\n\n        let plyFormat;\n        let directLoadBufferIn;\n        let directLoadBufferOut;\n        let directLoadSplatBuffer;\n        let compressedPlyHeaderChunksBuffer;\n        let maxSplatCount = 0;\n        let processedBaseSplatCount = 0;\n        let processedSphericalHarmonicsSplatCount = 0;\n\n        let headerLoaded = false;\n        let readyToLoadSplatData = false;\n        let baseSplatDataLoaded = false;\n\n        const loadPromise = nativePromiseWithExtractedComponents();\n\n        let numBytesStreamed = 0;\n        let numBytesParsed = 0;\n        let numBytesDownloaded = 0;\n        let endOfBaseSplatDataBytes = 0;\n        let headerText = '';\n        let header = null;\n        let chunks = [];\n\n        let standardLoadUncompressedSplatArray;\n\n        const textDecoder = new TextDecoder();\n\n        const localOnProgress = (percent, percentLabel, chunkData) => {\n            const loadComplete = percent >= 100;\n\n            if (chunkData) {\n                chunks.push({\n                    'data': chunkData,\n                    'sizeBytes': chunkData.byteLength,\n                    'startBytes': numBytesDownloaded,\n                    'endBytes': numBytesDownloaded + chunkData.byteLength\n                });\n                numBytesDownloaded += chunkData.byteLength;\n            }\n\n            if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n                if (loadComplete) {\n                    loadPromise.resolve(chunks);\n                }\n            } else {\n                if (!headerLoaded) {\n                    headerText += textDecoder.decode(chunkData);\n                    if (PlyParserUtils.checkTextForEndHeader(headerText)) {\n                        plyFormat = PlyParserUtils.determineHeaderFormatFromHeaderText(headerText);\n                        if (plyFormat === PlyFormat.INRIAV1) {\n                            header = INRIAV1PlyParser.decodeHeaderText(headerText);\n                            outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, header.sphericalHarmonicsDegree);\n                            maxSplatCount = header.splatCount;\n                            readyToLoadSplatData = true;\n                            endOfBaseSplatDataBytes = header.headerSizeBytes + header.bytesPerSplat * maxSplatCount;\n                        } else if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n                            header = PlayCanvasCompressedPlyParser.decodeHeaderText(headerText);\n                            outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, header.sphericalHarmonicsDegree);\n                            if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer && outSphericalHarmonicsDegree > 0) {\n                                throw new DirectLoadError(\n                                    'PlyLoader.loadFromURL() -> Selected PLY format has spherical ' +\n                                    'harmonics data that cannot be progressively loaded.'\n                                );\n                            }\n                            maxSplatCount = header.vertexElement.count;\n                            endOfBaseSplatDataBytes = header.headerSizeBytes + header.bytesPerSplat * maxSplatCount +\n                                                      header.chunkElement.storageSizeBytes;\n                        } else {\n                            if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                                throw new DirectLoadError(\n                                    'PlyLoader.loadFromURL() -> Selected PLY format cannot be progressively loaded.'\n                                );\n                            } else {\n                                internalLoadType = InternalLoadType.DownloadBeforeProcessing;\n                                return;\n                            }\n                        }\n\n                        if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                            const shDescriptor = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[outSphericalHarmonicsDegree];\n                            const splatBufferSizeBytes = splatBufferDataOffsetBytes + shDescriptor.BytesPerSplat * maxSplatCount;\n                            directLoadBufferOut = new ArrayBuffer(splatBufferSizeBytes);\n                            SplatBuffer.writeHeaderToBuffer({\n                                versionMajor: SplatBuffer.CurrentMajorVersion,\n                                versionMinor: SplatBuffer.CurrentMinorVersion,\n                                maxSectionCount: sectionCount,\n                                sectionCount: sectionCount,\n                                maxSplatCount: maxSplatCount,\n                                splatCount: 0,\n                                compressionLevel: 0,\n                                sceneCenter: new THREE.Vector3()\n                            }, directLoadBufferOut);\n                        } else {\n                            standardLoadUncompressedSplatArray = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n                        }\n\n                        numBytesStreamed = header.headerSizeBytes;\n                        numBytesParsed = header.headerSizeBytes;\n                        headerLoaded = true;\n                    }\n                } else if (plyFormat === PlyFormat.PlayCanvasCompressed && !readyToLoadSplatData) {\n                    const sizeRequiredForHeaderAndChunks = header.headerSizeBytes + header.chunkElement.storageSizeBytes;\n                    compressedPlyHeaderChunksBuffer = storeChunksInBuffer(chunks, compressedPlyHeaderChunksBuffer);\n                    if (compressedPlyHeaderChunksBuffer.byteLength >= sizeRequiredForHeaderAndChunks) {\n                        PlayCanvasCompressedPlyParser.readElementData(header.chunkElement, compressedPlyHeaderChunksBuffer,\n                                                                      header.headerSizeBytes);\n                        numBytesStreamed = sizeRequiredForHeaderAndChunks;\n                        numBytesParsed = sizeRequiredForHeaderAndChunks;\n                        readyToLoadSplatData = true;\n                    }\n                }\n\n                if (headerLoaded && readyToLoadSplatData && chunks.length > 0) {\n\n                    directLoadBufferIn = storeChunksInBuffer(chunks, directLoadBufferIn);\n\n                    const bytesLoadedSinceLastStreamedSection = numBytesDownloaded - numBytesStreamed;\n                    if (bytesLoadedSinceLastStreamedSection > directLoadSectionSizeBytes ||\n                        (numBytesDownloaded >= endOfBaseSplatDataBytes && !baseSplatDataLoaded) ||\n                        loadComplete) {\n                        const bytesPerSplat = baseSplatDataLoaded ? header.sphericalHarmonicsPerSplat : header.bytesPerSplat;\n                        const endOfBytesToProcess = baseSplatDataLoaded ? numBytesDownloaded :\n                                                    Math.min(endOfBaseSplatDataBytes, numBytesDownloaded);\n                        const numBytesToProcess = endOfBytesToProcess - numBytesParsed;\n                        const addedSplatCount = Math.floor(numBytesToProcess / bytesPerSplat);\n                        const numBytesToParse = addedSplatCount * bytesPerSplat;\n                        const numBytesLeftOver = numBytesDownloaded - numBytesParsed - numBytesToParse;\n                        const parsedDataViewOffset = numBytesParsed - chunks[0].startBytes;\n                        const dataToParse = new DataView(directLoadBufferIn, parsedDataViewOffset, numBytesToParse);\n\n                        if (!baseSplatDataLoaded) {\n                            if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                                const shDesc = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[outSphericalHarmonicsDegree];\n                                const outOffset = processedBaseSplatCount * shDesc.BytesPerSplat + splatBufferDataOffsetBytes;\n                                if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n                                    PlayCanvasCompressedPlyParser.parseToUncompressedSplatBufferSection(\n                                        header.chunkElement, header.vertexElement, 0, addedSplatCount - 1,\n                                        processedBaseSplatCount, dataToParse, directLoadBufferOut, outOffset\n                                    );\n                                } else {\n                                    INRIAV1PlyParser.parseToUncompressedSplatBufferSection(\n                                        header, 0, addedSplatCount - 1, dataToParse, 0,\n                                        directLoadBufferOut, outOffset, outSphericalHarmonicsDegree\n                                    );\n                                }\n                            } else {\n                                if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n                                    PlayCanvasCompressedPlyParser.parseToUncompressedSplatArraySection(\n                                        header.chunkElement, header.vertexElement, 0, addedSplatCount - 1,\n                                        processedBaseSplatCount, dataToParse, standardLoadUncompressedSplatArray\n                                    );\n                                } else {\n                                    INRIAV1PlyParser.parseToUncompressedSplatArraySection(\n                                        header, 0, addedSplatCount - 1, dataToParse, 0,\n                                        standardLoadUncompressedSplatArray, outSphericalHarmonicsDegree\n                                    );\n                                }\n                            }\n\n                            processedBaseSplatCount += addedSplatCount;\n\n                            if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                                if (!directLoadSplatBuffer) {\n                                    SplatBuffer.writeSectionHeaderToBuffer({\n                                        maxSplatCount: maxSplatCount,\n                                        splatCount: processedBaseSplatCount,\n                                        bucketSize: 0,\n                                        bucketCount: 0,\n                                        bucketBlockSize: 0,\n                                        compressionScaleRange: 0,\n                                        storageSizeBytes: 0,\n                                        fullBucketCount: 0,\n                                        partiallyFilledBucketCount: 0,\n                                        sphericalHarmonicsDegree: outSphericalHarmonicsDegree\n                                    }, 0, directLoadBufferOut, SplatBuffer.HeaderSizeBytes);\n                                    directLoadSplatBuffer = new SplatBuffer(directLoadBufferOut, false);\n                                }\n                                directLoadSplatBuffer.updateLoadedCounts(1, processedBaseSplatCount);\n                            }\n                            if (numBytesDownloaded >= endOfBaseSplatDataBytes) {\n                                baseSplatDataLoaded = true;\n                            }\n                        } else {\n                            if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n                                if (internalLoadType === InternalLoadType.ProgressiveToSplatArray) {\n                                    PlayCanvasCompressedPlyParser.parseSphericalHarmonicsToUncompressedSplatArraySection(\n                                        header.chunkElement, header.shElement, processedSphericalHarmonicsSplatCount,\n                                        processedSphericalHarmonicsSplatCount + addedSplatCount - 1,\n                                        dataToParse, 0, outSphericalHarmonicsDegree, header.sphericalHarmonicsDegree,\n                                        standardLoadUncompressedSplatArray\n                                    );\n                                    processedSphericalHarmonicsSplatCount += addedSplatCount;\n                                }\n                            }\n                        }\n\n                        if (numBytesLeftOver === 0) {\n                            chunks = [];\n                        } else {\n                            let keepChunks = [];\n                            let keepSize = 0;\n                            for (let i = chunks.length - 1; i >= 0; i--) {\n                                const chunk = chunks[i];\n                                keepSize += chunk.sizeBytes;\n                                keepChunks.unshift(chunk);\n                                if (keepSize >= numBytesLeftOver) break;\n                            }\n                            chunks = keepChunks;\n                        }\n\n                        numBytesStreamed += directLoadSectionSizeBytes;\n                        numBytesParsed += numBytesToParse;\n                    }\n                }\n\n                if (onProgressiveLoadSectionProgress && directLoadSplatBuffer) {\n                    onProgressiveLoadSectionProgress(directLoadSplatBuffer, loadComplete);\n                }\n\n                if (loadComplete) {\n                    if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                        loadPromise.resolve(directLoadSplatBuffer);\n                    } else {\n                        loadPromise.resolve(standardLoadUncompressedSplatArray);\n                    }\n                }\n            }\n\n            if (onProgress) onProgress(percent, percentLabel, LoaderStatus.Downloading);\n        };\n\n        if (onProgress) onProgress(0, '0%', LoaderStatus.Downloading);\n        return fetchWithProgress(fileName, localOnProgress, false, headers).then(() => {\n            if (onProgress) onProgress(0, '0%', LoaderStatus.Processing);\n            return loadPromise.promise.then((splatData) => {\n                if (onProgress) onProgress(100, '100%', LoaderStatus.Done);\n                if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n                    const chunkDatas = chunks.map((chunk) => chunk.data);\n                    return new Blob(chunkDatas).arrayBuffer().then((plyFileData) => {\n                        return PlyLoader.loadFromFileData(plyFileData, minimumAlpha, compressionLevel, optimizeSplatData,\n                                                          outSphericalHarmonicsDegree, sectionSize, sceneCenter, blockSize, bucketSize);\n                    });\n                } else if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                    return splatData;\n                } else {\n                    return delayedExecute(() => {\n                        return finalize$1(splatData, optimizeSplatData, minimumAlpha, compressionLevel,\n                                        sectionSize, sceneCenter, blockSize, bucketSize);\n                    });\n                }\n            });\n        });\n    }\n\n    static loadFromFileData(plyFileData, minimumAlpha, compressionLevel, optimizeSplatData, outSphericalHarmonicsDegree = 0,\n                            sectionSize, sceneCenter, blockSize, bucketSize) {\n        if (optimizeSplatData) {\n            return delayedExecute(() => {\n                return PlyParser.parseToUncompressedSplatArray(plyFileData, outSphericalHarmonicsDegree);\n            })\n            .then((splatArray) => {\n                return finalize$1(splatArray, optimizeSplatData, minimumAlpha, compressionLevel,\n                                sectionSize, sceneCenter, blockSize, bucketSize);\n            });\n        } else {\n            return delayedExecute(() => {\n                return PlyParser.parseToUncompressedSplatBuffer(plyFileData, outSphericalHarmonicsDegree);\n            });\n        }\n    }\n}\n\nconst createStream = (data)=> {\n    return new ReadableStream({\n        async start(controller) {\n            controller.enqueue(data);\n            controller.close();\n        },\n    });\n};\n\nasync function decompressGzipped(data) {\n    try {\n        const stream = createStream(data);\n        if (!stream) throw new Error('Failed to create stream from data');\n\n        return await decompressGzipStream(stream);\n    } catch (error) {\n        console.error('Error decompressing gzipped data:', error);\n        throw error;\n    }\n}\n\nasync function decompressGzipStream(stream) {\n    const decompressedStream = stream.pipeThrough(new DecompressionStream('gzip'));\n    const response = new Response(decompressedStream);\n    const buffer = await response.arrayBuffer();\n\n    return new Uint8Array(buffer);\n}\n\nasync function compressGzipped(data) {\n    try {\n        const stream = createStream(data);\n        const compressedStream = stream.pipeThrough(new CompressionStream('gzip'));\n        const response = new Response(compressedStream);\n        const buffer = await response.arrayBuffer();\n\n        return new Uint8Array(buffer);\n    } catch (error) {\n        console.error('Error compressing gzipped data:', error);\n        throw error;\n    }\n}\n\nconst SPZ_MAGIC = 1347635022;\nconst FLAG_ANTIALIASED = 1;\nconst COLOR_SCALE = 0.15;\n\nfunction halfToFloat(h) {\n    const sgn = (h >> 15) & 0x1;\n    const exponent = (h >> 10) & 0x1f;\n    const mantissa = h & 0x3ff;\n\n    const signMul = sgn === 1 ? -1.0 : 1.0;\n    if (exponent === 0) {\n        return signMul * Math.pow(2, -14) * mantissa / 1024;\n    }\n\n    if (exponent === 31) {\n        return mantissa !== 0 ? NaN : signMul * Infinity;\n    }\n\n    return signMul * Math.pow(2, exponent - 15) * (1 + mantissa / 1024);\n}\n\nfunction unquantizeSH(x) {\n    return (x - 128.0) / 128.0;\n}\n\nfunction dimForDegree(degree) {\n    switch (degree) {\n        case 0: return 0;\n        case 1: return 3;\n        case 2: return 8;\n        case 3: return 15;\n        default:\n            console.error(`[SPZ: ERROR] Unsupported SH degree: ${degree}`);\n            return 0;\n    }\n}\n\nconst unpackedSplatToUncompressedSplat = function() {\n\n    let rawSplat = [];\n    const tempRotation = new THREE.Quaternion();\n\n    const OFFSET_X = UncompressedSplatArray.OFFSET.X;\n    const OFFSET_Y = UncompressedSplatArray.OFFSET.Y;\n    const OFFSET_Z = UncompressedSplatArray.OFFSET.Z;\n\n    const OFFSET_SCALE0 = UncompressedSplatArray.OFFSET.SCALE0;\n    const OFFSET_SCALE1 = UncompressedSplatArray.OFFSET.SCALE1;\n    const OFFSET_SCALE2 = UncompressedSplatArray.OFFSET.SCALE2;\n\n    const OFFSET_ROTATION0 = UncompressedSplatArray.OFFSET.ROTATION0;\n    const OFFSET_ROTATION1 = UncompressedSplatArray.OFFSET.ROTATION1;\n    const OFFSET_ROTATION2 = UncompressedSplatArray.OFFSET.ROTATION2;\n    const OFFSET_ROTATION3 = UncompressedSplatArray.OFFSET.ROTATION3;\n\n    const OFFSET_FDC0 = UncompressedSplatArray.OFFSET.FDC0;\n    const OFFSET_FDC1 = UncompressedSplatArray.OFFSET.FDC1;\n    const OFFSET_FDC2 = UncompressedSplatArray.OFFSET.FDC2;\n    const OFFSET_OPACITY = UncompressedSplatArray.OFFSET.OPACITY;\n\n    const OFFSET_FRC = [];\n\n    for (let i = 0; i < 45; i++) {\n        OFFSET_FRC[i] = UncompressedSplatArray.OFFSET.FRC0 + i;\n    }\n\n    const shCoeffMap = [dimForDegree(0), dimForDegree(1), dimForDegree(2), dimForDegree(3)];\n\n    const shIndexMap = [\n        0, 1, 2, 9, 10, 11, 12, 13, 24, 25, 26, 27, 28, 29, 30,\n        3, 4, 5, 14, 15, 16, 17, 18, 31, 32, 33, 34, 35, 36, 37,\n        6, 7, 8, 19, 20, 21, 22, 23, 38, 39, 40, 41, 42, 43, 44\n    ];\n\n    return function(unpackedSplat, unpackedSphericalHarmonicsDegree, outSphericalHarmonicsDegree) {\n                    outSphericalHarmonicsDegree = Math.min(unpackedSphericalHarmonicsDegree, outSphericalHarmonicsDegree);\n\n        const newSplat = UncompressedSplatArray.createSplat(outSphericalHarmonicsDegree);\n        if (unpackedSplat.scale[0] !== undefined) {\n            newSplat[OFFSET_SCALE0] = unpackedSplat.scale[0];\n            newSplat[OFFSET_SCALE1] = unpackedSplat.scale[1];\n            newSplat[OFFSET_SCALE2] = unpackedSplat.scale[2];\n        } else {\n            newSplat[OFFSET_SCALE0] = 0.01;\n            newSplat[OFFSET_SCALE1] = 0.01;\n            newSplat[OFFSET_SCALE2] = 0.01;\n        }\n\n        if (unpackedSplat.color[0] !== undefined) {\n            newSplat[OFFSET_FDC0] = unpackedSplat.color[0];\n            newSplat[OFFSET_FDC1] = unpackedSplat.color[1];\n            newSplat[OFFSET_FDC2] = unpackedSplat.color[2];\n        } else if (rawSplat[RED] !== undefined) {\n            newSplat[OFFSET_FDC0] = rawSplat[RED] * 255;\n            newSplat[OFFSET_FDC1] = rawSplat[GREEN] * 255;\n            newSplat[OFFSET_FDC2] = rawSplat[BLUE] * 255;\n        } else {\n            newSplat[OFFSET_FDC0] = 0;\n            newSplat[OFFSET_FDC1] = 0;\n            newSplat[OFFSET_FDC2] = 0;\n        }\n\n        if (unpackedSplat.alpha !== undefined) {\n            newSplat[OFFSET_OPACITY] = unpackedSplat.alpha;\n        }\n\n        newSplat[OFFSET_FDC0] = clamp(Math.floor(newSplat[OFFSET_FDC0]), 0, 255);\n        newSplat[OFFSET_FDC1] = clamp(Math.floor(newSplat[OFFSET_FDC1]), 0, 255);\n        newSplat[OFFSET_FDC2] = clamp(Math.floor(newSplat[OFFSET_FDC2]), 0, 255);\n        newSplat[OFFSET_OPACITY] = clamp(Math.floor(newSplat[OFFSET_OPACITY]), 0, 255);\n\n        let outSHCoeff = shCoeffMap[outSphericalHarmonicsDegree];\n        let readSHCoeff = shCoeffMap[unpackedSphericalHarmonicsDegree];\n        for (let j = 0; j < 3; ++j) {\n            for (let k = 0; k < 15; ++k) {\n                const outIndex = shIndexMap[j * 15 + k];\n                if (k < outSHCoeff && k < readSHCoeff) {\n                    newSplat[UncompressedSplatArray.OFFSET.FRC0 + outIndex] = unpackedSplat.sh[j * readSHCoeff + k];\n                }\n            }\n        }\n\n        tempRotation.set(unpackedSplat.rotation[3], unpackedSplat.rotation[0], unpackedSplat.rotation[1], unpackedSplat.rotation[2]);\n        tempRotation.normalize();\n\n        newSplat[OFFSET_ROTATION0] = tempRotation.x;\n        newSplat[OFFSET_ROTATION1] = tempRotation.y;\n        newSplat[OFFSET_ROTATION2] = tempRotation.z;\n        newSplat[OFFSET_ROTATION3] = tempRotation.w;\n\n        newSplat[OFFSET_X] = unpackedSplat.position[0];\n        newSplat[OFFSET_Y] = unpackedSplat.position[1];\n        newSplat[OFFSET_Z] = unpackedSplat.position[2];\n\n        return newSplat;\n    };\n\n}();\n\n// Helper function to check sizes (matching C++ checkSizes function)\nfunction checkSizes2(packed, numPoints, shDim, usesFloat16) {\n    if (packed.positions.length !== numPoints * 3 * (usesFloat16 ? 2 : 3)) return false;\n    if (packed.scales.length !== numPoints * 3) return false;\n    if (packed.rotations.length !== numPoints * 3) return false;\n    if (packed.alphas.length !== numPoints) return false;\n    if (packed.colors.length !== numPoints * 3) return false;\n    if (packed.sh.length !== numPoints * shDim * 3) return false;\n    return true;\n}\n\nfunction unpackGaussians(packed, outSphericalHarmonicsDegree, directToSplatBuffer, outTarget, outTargetOffset) {\n    outSphericalHarmonicsDegree = Math.min(outSphericalHarmonicsDegree, packed.shDegree);\n    const numPoints = packed.numPoints;\n    const shDim = dimForDegree(packed.shDegree);\n    const usesFloat16 = packed.positions.length === numPoints * 3 * 2;\n\n    // Validate sizes\n    if (!checkSizes2(packed, numPoints, shDim, usesFloat16)) {\n        return null;\n    }\n\n    const splat = {\n        position: [],\n        scale: [],\n        rotation: [],\n        alpha: undefined,\n        color: [],\n        sh: []\n    };\n\n    let halfData;\n    if (usesFloat16) {\n       halfData = new Uint16Array(packed.positions.buffer, packed.positions.byteOffset, numPoints * 3);\n    }\n    const fullPrecisionPositionScale = 1.0 / (1 << packed.fractionalBits);\n    const shCoeffPerChannelPerSplat = dimForDegree(packed.shDegree);\n    const SH_C0 = 0.28209479177387814;\n\n    for (let i = 0; i < numPoints; i++) {\n        // Splat position\n        if (usesFloat16) {\n            // Decode legacy float16 format\n            for (let j = 0; j < 3; j++) {\n                splat.position[j] = halfToFloat(halfData[i * 3 + j]);\n            }\n        } else {\n            // Decode 24-bit fixed point coordinates\n            for (let j = 0; j < 3; j++) {\n                const base = i * 9 + j * 3;\n                let fixed32 = packed.positions[base];\n                fixed32 |= packed.positions[base + 1] << 8;\n                fixed32 |= packed.positions[base + 2] << 16;\n                fixed32 |= (fixed32 & 0x800000) ? 0xff000000 : 0;\n                splat.position[j] = fixed32 * fullPrecisionPositionScale;\n            }\n        }\n\n        // Splat scale\n        for (let j = 0; j < 3; j++) {\n            splat.scale[j] = Math.exp(packed.scales[i * 3 + j] / 16.0 - 10.0);\n        }\n\n        // Splat rotation\n        const r = packed.rotations.subarray(i * 3, i * 3 + 3);\n        const xyz = [\n            r[0] / 127.5 - 1.0,\n            r[1] / 127.5 - 1.0,\n            r[2] / 127.5 - 1.0\n        ];\n        splat.rotation[0] = xyz[0];\n        splat.rotation[1] = xyz[1];\n        splat.rotation[2] = xyz[2];\n        const squaredNorm = xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2];\n        splat.rotation[3] = Math.sqrt(Math.max(0.0, 1.0 - squaredNorm));\n\n        // Splat alpha\n        // splat.alpha = invSigmoid(packed.alphas[i] / 255.0);\n        splat.alpha = Math.floor(packed.alphas[i]);\n\n        // Splat color\n        for (let j = 0; j < 3; j++) {\n            splat.color[j] = Math.floor(((((packed.colors[i * 3 + j] / 255.0) - 0.5) / COLOR_SCALE) * SH_C0 + 0.5) * 255);\n        }\n\n        // Splat spherical harmonics\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < shCoeffPerChannelPerSplat; k++) {\n                splat.sh[j * shCoeffPerChannelPerSplat + k] = unquantizeSH(packed.sh[shCoeffPerChannelPerSplat * 3 * i + k * 3 + j]);\n            }\n        }\n\n        const uncompressedSplat = unpackedSplatToUncompressedSplat(splat, packed.shDegree, outSphericalHarmonicsDegree);\n        if (directToSplatBuffer) {\n            const outBytesPerSplat = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[outSphericalHarmonicsDegree].BytesPerSplat;\n            const outBase = i * outBytesPerSplat + outTargetOffset;\n            SplatBuffer.writeSplatDataToSectionBuffer(uncompressedSplat, outTarget, outBase, 0, outSphericalHarmonicsDegree);\n        } else {\n            outTarget.addSplat(uncompressedSplat);\n        }\n    }\n}\n\nconst HEADER_SIZE = 16; // 4 + 4 + 4 + 1 + 1 + 1 + 1 bytes\nconst MAX_POINTS_TO_READ = 10000000;\n\nfunction deserializePackedGaussians(buffer) {\n    const view = new DataView(buffer);\n    let offset = 0;\n\n    // Read and validate header\n    const header = {\n        magic: view.getUint32(offset, true),\n        version: view.getUint32(offset + 4, true),\n        numPoints: view.getUint32(offset + 8, true),\n        shDegree: view.getUint8(offset + 12),\n        fractionalBits: view.getUint8(offset + 13),\n        flags: view.getUint8(offset + 14),\n        reserved: view.getUint8(offset + 15)\n    };\n\n    offset += HEADER_SIZE;\n\n    // Validate header\n    if (header.magic !== SPZ_MAGIC) {\n        console.error('[SPZ ERROR] deserializePackedGaussians: header not found');\n        return null;\n    }\n    if (header.version < 1 || header.version > 2) {\n        console.error(`[SPZ ERROR] deserializePackedGaussians: version not supported: ${header.version}`);\n        return null;\n    }\n    if (header.numPoints > MAX_POINTS_TO_READ) {\n        console.error(`[SPZ ERROR] deserializePackedGaussians: Too many points: ${header.numPoints}`);\n        return null;\n    }\n    if (header.shDegree > 3) {\n        console.error(`[SPZ ERROR] deserializePackedGaussians: Unsupported SH degree: ${header.shDegree}`);\n        return null;\n    }\n\n    const numPoints = header.numPoints;\n    const shDim = dimForDegree(header.shDegree);\n    const usesFloat16 = header.version === 1;\n\n    // Initialize result object\n    const result = {\n        numPoints,\n        shDegree: header.shDegree,\n        fractionalBits: header.fractionalBits,\n        antialiased: (header.flags & FLAG_ANTIALIASED) !== 0,\n        positions: new Uint8Array(numPoints * 3 * (usesFloat16 ? 2 : 3)),\n        scales: new Uint8Array(numPoints * 3),\n        rotations: new Uint8Array(numPoints * 3),\n        alphas: new Uint8Array(numPoints),\n        colors: new Uint8Array(numPoints * 3),\n        sh: new Uint8Array(numPoints * shDim * 3)\n    };\n\n    // Read data sections\n    try {\n        const uint8View = new Uint8Array(buffer);\n        let positionsSize = result.positions.length;\n        let currentOffset = offset;\n\n        result.positions.set(uint8View.slice(currentOffset, currentOffset + positionsSize));\n        currentOffset += positionsSize;\n\n        result.alphas.set(uint8View.slice(currentOffset, currentOffset + result.alphas.length));\n        currentOffset += result.alphas.length;\n\n        result.colors.set(uint8View.slice(currentOffset, currentOffset + result.colors.length));\n        currentOffset += result.colors.length;\n\n        result.scales.set(uint8View.slice(currentOffset, currentOffset + result.scales.length));\n        currentOffset += result.scales.length;\n\n        result.rotations.set(uint8View.slice(currentOffset, currentOffset + result.rotations.length));\n        currentOffset += result.rotations.length;\n\n        result.sh.set(uint8View.slice(currentOffset, currentOffset + result.sh.length));\n\n        // Verify we read the expected amount of data\n        if (currentOffset + result.sh.length !== buffer.byteLength) {\n            console.error('[SPZ ERROR] deserializePackedGaussians: incorrect buffer size');\n            return null;\n        }\n    } catch (error) {\n        console.error('[SPZ ERROR] deserializePackedGaussians: read error', error);\n        return null;\n    }\n\n    return result;\n}\n\nasync function loadSpzPacked(compressedData) {\n    try {\n        const decompressed = await decompressGzipped(compressedData);\n        return deserializePackedGaussians(decompressed.buffer);\n    } catch (error) {\n        console.error('[SPZ ERROR] loadSpzPacked: decompression error', error);\n        return null;\n    }\n}\n\nclass SpzLoader {\n\n    static loadFromURL(fileName, onProgress, minimumAlpha, compressionLevel, optimizeSplatData = true,\n                       outSphericalHarmonicsDegree = 0, headers, sectionSize, sceneCenter, blockSize, bucketSize) {\n        if (onProgress) onProgress(0, '0%', LoaderStatus.Downloading);\n        return fetchWithProgress(fileName, onProgress, true, headers).then((fileData) => {\n            if (onProgress) onProgress(0, '0%', LoaderStatus.Processing);\n            return SpzLoader.loadFromFileData(fileData, minimumAlpha, compressionLevel, optimizeSplatData,\n                                              outSphericalHarmonicsDegree, sectionSize, sceneCenter, blockSize, bucketSize);\n        });\n    }\n\n    static async loadFromFileData(spzFileData, minimumAlpha, compressionLevel, optimizeSplatData,\n                                  outSphericalHarmonicsDegree = 0, sectionSize, sceneCenter, blockSize, bucketSize) {\n        await delayedExecute();\n        const packed = await loadSpzPacked(spzFileData);\n        outSphericalHarmonicsDegree = Math.min(packed.shDegree, outSphericalHarmonicsDegree);\n\n        const splatArray = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n\n        if (optimizeSplatData) {\n            unpackGaussians(packed, outSphericalHarmonicsDegree, false, splatArray, 0);\n            const splatBufferGenerator = SplatBufferGenerator.getStandardGenerator(minimumAlpha, compressionLevel,\n                                                                                   sectionSize, sceneCenter,\n                                                                                   blockSize, bucketSize);\n            return splatBufferGenerator.generateFromUncompressedSplatArray(splatArray);\n        } else {\n            const {\n                splatBuffer,\n                splatBufferDataOffsetBytes\n              } = SplatBuffer.preallocateUncompressed(packed.numPoints, outSphericalHarmonicsDegree);\n            unpackGaussians(packed, outSphericalHarmonicsDegree, true, splatBuffer.bufferData, splatBufferDataOffsetBytes);\n            return splatBuffer;\n        }\n    }\n\n}\n\nclass SplatParser {\n\n    static RowSizeBytes = 32;\n    static CenterSizeBytes = 12;\n    static ScaleSizeBytes = 12;\n    static RotationSizeBytes = 4;\n    static ColorSizeBytes = 4;\n\n    static parseToUncompressedSplatBufferSection(fromSplat, toSplat, fromBuffer, fromOffset, toBuffer, toOffset) {\n\n        const outBytesPerCenter = SplatBuffer.CompressionLevels[0].BytesPerCenter;\n        const outBytesPerScale = SplatBuffer.CompressionLevels[0].BytesPerScale;\n        const outBytesPerRotation = SplatBuffer.CompressionLevels[0].BytesPerRotation;\n        const outBytesPerSplat = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;\n\n        for (let i = fromSplat; i <= toSplat; i++) {\n            const inBase = i * SplatParser.RowSizeBytes + fromOffset;\n            const inCenter = new Float32Array(fromBuffer, inBase, 3);\n            const inScale = new Float32Array(fromBuffer, inBase + SplatParser.CenterSizeBytes, 3);\n            const inColor = new Uint8Array(fromBuffer, inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes, 4);\n            const inRotation = new Uint8Array(fromBuffer, inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes +\n                                              SplatParser.RotationSizeBytes, 4);\n\n            const quat = new THREE.Quaternion((inRotation[1] - 128) / 128, (inRotation[2] - 128) / 128,\n                                              (inRotation[3] - 128) / 128, (inRotation[0] - 128) / 128);\n            quat.normalize();\n\n            const outBase = i * outBytesPerSplat + toOffset;\n            const outCenter = new Float32Array(toBuffer, outBase, 3);\n            const outScale = new Float32Array(toBuffer, outBase + outBytesPerCenter, 3);\n            const outRotation = new Float32Array(toBuffer, outBase + outBytesPerCenter + outBytesPerScale, 4);\n            const outColor = new Uint8Array(toBuffer, outBase + outBytesPerCenter + outBytesPerScale + outBytesPerRotation, 4);\n\n            outCenter[0] = inCenter[0];\n            outCenter[1] = inCenter[1];\n            outCenter[2] = inCenter[2];\n\n            outScale[0] = inScale[0];\n            outScale[1] = inScale[1];\n            outScale[2] = inScale[2];\n\n            outRotation[0] = quat.w;\n            outRotation[1] = quat.x;\n            outRotation[2] = quat.y;\n            outRotation[3] = quat.z;\n\n            outColor[0] = inColor[0];\n            outColor[1] = inColor[1];\n            outColor[2] = inColor[2];\n            outColor[3] = inColor[3];\n        }\n    }\n\n    static parseToUncompressedSplatArraySection(fromSplat, toSplat, fromBuffer, fromOffset, splatArray) {\n\n        for (let i = fromSplat; i <= toSplat; i++) {\n            const inBase = i * SplatParser.RowSizeBytes + fromOffset;\n            const inCenter = new Float32Array(fromBuffer, inBase, 3);\n            const inScale = new Float32Array(fromBuffer, inBase + SplatParser.CenterSizeBytes, 3);\n            const inColor = new Uint8Array(fromBuffer, inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes, 4);\n            const inRotation = new Uint8Array(fromBuffer, inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes +\n                                              SplatParser.RotationSizeBytes, 4);\n\n            const quat = new THREE.Quaternion((inRotation[1] - 128) / 128, (inRotation[2] - 128) / 128,\n                                              (inRotation[3] - 128) / 128, (inRotation[0] - 128) / 128);\n            quat.normalize();\n\n            splatArray.addSplatFromComonents(inCenter[0], inCenter[1], inCenter[2], inScale[0], inScale[1], inScale[2],\n                                             quat.w, quat.x, quat.y, quat.z, inColor[0], inColor[1], inColor[2], inColor[3]);\n        }\n    }\n\n    static parseStandardSplatToUncompressedSplatArray(inBuffer) {\n        // Standard .splat row layout:\n        // XYZ - Position (Float32)\n        // XYZ - Scale (Float32)\n        // RGBA - colors (uint8)\n        // IJKL - quaternion/rot (uint8)\n\n        const splatCount = inBuffer.byteLength / SplatParser.RowSizeBytes;\n\n        const splatArray = new UncompressedSplatArray();\n\n        for (let i = 0; i < splatCount; i++) {\n            const inBase = i * SplatParser.RowSizeBytes;\n            const inCenter = new Float32Array(inBuffer, inBase, 3);\n            const inScale = new Float32Array(inBuffer, inBase + SplatParser.CenterSizeBytes, 3);\n            const inColor = new Uint8Array(inBuffer, inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes, 4);\n            const inRotation = new Uint8Array(inBuffer, inBase + SplatParser.CenterSizeBytes +\n                                              SplatParser.ScaleSizeBytes + SplatParser.ColorSizeBytes, 4);\n\n            const quat = new THREE.Quaternion((inRotation[1] - 128) / 128, (inRotation[2] - 128) / 128,\n                                              (inRotation[3] - 128) / 128, (inRotation[0] - 128) / 128);\n            quat.normalize();\n\n            splatArray.addSplatFromComonents(inCenter[0], inCenter[1], inCenter[2], inScale[0], inScale[1], inScale[2],\n                                             quat.w, quat.x, quat.y, quat.z, inColor[0], inColor[1], inColor[2], inColor[3]);\n        }\n\n        return splatArray;\n    }\n\n}\n\nfunction finalize(splatData, optimizeSplatData, minimumAlpha, compressionLevel, sectionSize, sceneCenter, blockSize, bucketSize) {\n    if (optimizeSplatData) {\n        const splatBufferGenerator = SplatBufferGenerator.getStandardGenerator(minimumAlpha, compressionLevel,\n                                                                               sectionSize, sceneCenter,\n                                                                               blockSize, bucketSize);\n        return splatBufferGenerator.generateFromUncompressedSplatArray(splatData);\n    } else {\n        // TODO: Implement direct-to-SplatBuffer when not optimizing splat data\n        return SplatBuffer.generateFromUncompressedSplatArrays([splatData], minimumAlpha, 0, new THREE.Vector3());\n    }\n}\n\nclass SplatLoader {\n\n    static loadFromURL(fileName, onProgress, progressiveLoadToSplatBuffer, onProgressiveLoadSectionProgress, minimumAlpha, compressionLevel,\n                       optimizeSplatData = true, headers, sectionSize, sceneCenter, blockSize, bucketSize) {\n\n        let internalLoadType = progressiveLoadToSplatBuffer ? InternalLoadType.ProgressiveToSplatBuffer :\n                                                          InternalLoadType.ProgressiveToSplatArray;\n        if (optimizeSplatData) internalLoadType = InternalLoadType.ProgressiveToSplatArray;\n\n        const splatDataOffsetBytes = SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes;\n        const directLoadSectionSizeBytes = Constants.ProgressiveLoadSectionSize;\n        const sectionCount = 1;\n\n        let directLoadBufferIn;\n        let directLoadBufferOut;\n        let directLoadSplatBuffer;\n        let maxSplatCount = 0;\n        let splatCount = 0;\n\n        let standardLoadUncompressedSplatArray;\n\n        const loadPromise = nativePromiseWithExtractedComponents();\n\n        let numBytesStreamed = 0;\n        let numBytesLoaded = 0;\n        let chunks = [];\n\n        const localOnProgress = (percent, percentStr, chunk, fileSize) => {\n            const loadComplete = percent >= 100;\n\n            if (chunk) {\n                chunks.push(chunk);\n            }\n\n            if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n                if (loadComplete) {\n                    loadPromise.resolve(chunks);\n                }\n                return;\n            }\n\n            if (!fileSize) {\n                if (progressiveLoadToSplatBuffer) {\n                    throw new DirectLoadError('Cannon directly load .splat because no file size info is available.');\n                } else {\n                    internalLoadType = InternalLoadType.DownloadBeforeProcessing;\n                    return;\n                }\n            }\n\n            if (!directLoadBufferIn) {\n                maxSplatCount = fileSize / SplatParser.RowSizeBytes;\n                directLoadBufferIn = new ArrayBuffer(fileSize);\n                const bytesPerSplat = SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;\n                const splatBufferSizeBytes = splatDataOffsetBytes + bytesPerSplat * maxSplatCount;\n\n                if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                    directLoadBufferOut = new ArrayBuffer(splatBufferSizeBytes);\n                    SplatBuffer.writeHeaderToBuffer({\n                        versionMajor: SplatBuffer.CurrentMajorVersion,\n                        versionMinor: SplatBuffer.CurrentMinorVersion,\n                        maxSectionCount: sectionCount,\n                        sectionCount: sectionCount,\n                        maxSplatCount: maxSplatCount,\n                        splatCount: splatCount,\n                        compressionLevel: 0,\n                        sceneCenter: new THREE.Vector3()\n                    }, directLoadBufferOut);\n                } else {\n                    standardLoadUncompressedSplatArray = new UncompressedSplatArray(0);\n                }\n            }\n\n            if (chunk) {\n                new Uint8Array(directLoadBufferIn, numBytesLoaded, chunk.byteLength).set(new Uint8Array(chunk));\n                numBytesLoaded += chunk.byteLength;\n\n                const bytesLoadedSinceLastSection = numBytesLoaded - numBytesStreamed;\n                if (bytesLoadedSinceLastSection > directLoadSectionSizeBytes || loadComplete) {\n                    const bytesToUpdate = loadComplete ? bytesLoadedSinceLastSection : directLoadSectionSizeBytes;\n                    const addedSplatCount = bytesToUpdate / SplatParser.RowSizeBytes;\n                    const newSplatCount = splatCount + addedSplatCount;\n\n                    if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                        SplatParser.parseToUncompressedSplatBufferSection(splatCount, newSplatCount - 1, directLoadBufferIn, 0,\n                                                                            directLoadBufferOut, splatDataOffsetBytes);\n                    } else {\n                        SplatParser.parseToUncompressedSplatArraySection(splatCount, newSplatCount - 1, directLoadBufferIn, 0,\n                                                                            standardLoadUncompressedSplatArray);\n                    }\n\n                    splatCount = newSplatCount;\n\n                    if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                        if (!directLoadSplatBuffer) {\n                            SplatBuffer.writeSectionHeaderToBuffer({\n                                maxSplatCount: maxSplatCount,\n                                splatCount: splatCount,\n                                bucketSize: 0,\n                                bucketCount: 0,\n                                bucketBlockSize: 0,\n                                compressionScaleRange: 0,\n                                storageSizeBytes: 0,\n                                fullBucketCount: 0,\n                                partiallyFilledBucketCount: 0\n                            }, 0, directLoadBufferOut, SplatBuffer.HeaderSizeBytes);\n                            directLoadSplatBuffer = new SplatBuffer(directLoadBufferOut, false);\n                        }\n                        directLoadSplatBuffer.updateLoadedCounts(1, splatCount);\n                        if (onProgressiveLoadSectionProgress) {\n                            onProgressiveLoadSectionProgress(directLoadSplatBuffer, loadComplete);\n                        }\n                    }\n\n                    numBytesStreamed += directLoadSectionSizeBytes;\n                }\n            }\n\n            if (loadComplete) {\n                if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                    loadPromise.resolve(directLoadSplatBuffer);\n                } else {\n                    loadPromise.resolve(standardLoadUncompressedSplatArray);\n                }\n            }\n\n            if (onProgress) onProgress(percent, percentStr, LoaderStatus.Downloading);\n        };\n\n        if (onProgress) onProgress(0, '0%', LoaderStatus.Downloading);\n        return fetchWithProgress(fileName, localOnProgress, false, headers).then(() => {\n            if (onProgress) onProgress(0, '0%', LoaderStatus.Processing);\n            return loadPromise.promise.then((splatData) => {\n                if (onProgress) onProgress(100, '100%', LoaderStatus.Done);\n                if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n                    return new Blob(chunks).arrayBuffer().then((splatData) => {\n                        return SplatLoader.loadFromFileData(splatData, minimumAlpha, compressionLevel, optimizeSplatData,\n                                                            sectionSize, sceneCenter, blockSize, bucketSize);\n                    });\n                } else if (internalLoadType === InternalLoadType.ProgressiveToSplatBuffer) {\n                    return splatData;\n                } else {\n                    return delayedExecute(() => {\n                        return finalize(splatData, optimizeSplatData, minimumAlpha, compressionLevel,\n                                        sectionSize, sceneCenter, blockSize, bucketSize);\n                    });\n                }\n            });\n        });\n    }\n\n    static loadFromFileData(splatFileData, minimumAlpha, compressionLevel, optimizeSplatData,\n                            sectionSize, sceneCenter, blockSize, bucketSize) {\n        return delayedExecute(() => {\n            const splatArray = SplatParser.parseStandardSplatToUncompressedSplatArray(splatFileData);\n            return finalize(splatArray, optimizeSplatData, minimumAlpha, compressionLevel,\n                            sectionSize, sceneCenter, blockSize, bucketSize);\n        });\n    }\n\n}\n\nclass KSplatLoader {\n\n   static checkVersion(buffer) {\n        const minVersionMajor = SplatBuffer.CurrentMajorVersion;\n        const minVersionMinor = SplatBuffer.CurrentMinorVersion;\n        const header = SplatBuffer.parseHeader(buffer);\n        if (header.versionMajor === minVersionMajor &&\n            header.versionMinor >= minVersionMinor ||\n            header.versionMajor > minVersionMajor) {\n           return true;\n        } else {\n            throw new Error(`KSplat version not supported: v${header.versionMajor}.${header.versionMinor}. ` +\n                            `Minimum required: v${minVersionMajor}.${minVersionMinor}`);\n        }\n    };\n\n    static loadFromURL(fileName, externalOnProgress, progressiveLoadToSplatBuffer, onSectionBuilt, headers) {\n        let directLoadBuffer;\n        let directLoadSplatBuffer;\n\n        let headerBuffer;\n        let header;\n        let headerLoaded = false;\n        let headerLoading = false;\n\n        let sectionHeadersBuffer;\n        let sectionHeaders = [];\n        let sectionHeadersLoaded = false;\n        let sectionHeadersLoading = false;\n\n        let numBytesLoaded = 0;\n        let numBytesProgressivelyLoaded = 0;\n        let totalBytesToDownload = 0;\n\n        let downloadComplete = false;\n        let loadComplete = false;\n        let loadSectionQueued = false;\n\n        let chunks = [];\n\n        const directLoadPromise = nativePromiseWithExtractedComponents();\n\n        const checkAndLoadHeader = () => {\n            if (!headerLoaded && !headerLoading && numBytesLoaded >= SplatBuffer.HeaderSizeBytes) {\n                headerLoading = true;\n                const headerAssemblyPromise = new Blob(chunks).arrayBuffer();\n                headerAssemblyPromise.then((bufferData) => {\n                    headerBuffer = new ArrayBuffer(SplatBuffer.HeaderSizeBytes);\n                    new Uint8Array(headerBuffer).set(new Uint8Array(bufferData, 0, SplatBuffer.HeaderSizeBytes));\n                    KSplatLoader.checkVersion(headerBuffer);\n                    headerLoading = false;\n                    headerLoaded = true;\n                    header = SplatBuffer.parseHeader(headerBuffer);\n                    window.setTimeout(() => {\n                        checkAndLoadSectionHeaders();\n                    }, 1);\n                });\n            }\n        };\n\n        let queuedCheckAndLoadSectionsCount = 0;\n        const queueCheckAndLoadSections = () => {\n            if (queuedCheckAndLoadSectionsCount === 0) {\n                queuedCheckAndLoadSectionsCount++;\n                window.setTimeout(() => {\n                    queuedCheckAndLoadSectionsCount--;\n                    checkAndLoadSections();\n                }, 1);\n            }\n        };\n\n        const checkAndLoadSectionHeaders = () => {\n            const performLoad = () => {\n                sectionHeadersLoading = true;\n                const sectionHeadersAssemblyPromise = new Blob(chunks).arrayBuffer();\n                sectionHeadersAssemblyPromise.then((bufferData) => {\n                    sectionHeadersLoading = false;\n                    sectionHeadersLoaded = true;\n                    sectionHeadersBuffer = new ArrayBuffer(header.maxSectionCount * SplatBuffer.SectionHeaderSizeBytes);\n                    new Uint8Array(sectionHeadersBuffer).set(new Uint8Array(bufferData, SplatBuffer.HeaderSizeBytes,\n                                                                            header.maxSectionCount * SplatBuffer.SectionHeaderSizeBytes));\n                    sectionHeaders = SplatBuffer.parseSectionHeaders(header, sectionHeadersBuffer, 0, false);\n                    let totalSectionStorageStorageByes = 0;\n                    for (let i = 0; i < header.maxSectionCount; i++) {\n                        totalSectionStorageStorageByes += sectionHeaders[i].storageSizeBytes;\n                    }\n                    const totalStorageSizeBytes = SplatBuffer.HeaderSizeBytes + header.maxSectionCount *\n                                                  SplatBuffer.SectionHeaderSizeBytes + totalSectionStorageStorageByes;\n                    if (!directLoadBuffer) {\n                        directLoadBuffer = new ArrayBuffer(totalStorageSizeBytes);\n                        let offset = 0;\n                        for (let i = 0; i < chunks.length; i++) {\n                            const chunk = chunks[i];\n                            new Uint8Array(directLoadBuffer, offset, chunk.byteLength).set(new Uint8Array(chunk));\n                            offset += chunk.byteLength;\n                        }\n                    }\n\n                    totalBytesToDownload = SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes * header.maxSectionCount;\n                    for (let i = 0; i <= sectionHeaders.length && i < header.maxSectionCount; i++) {\n                        totalBytesToDownload += sectionHeaders[i].storageSizeBytes;\n                    }\n\n                    queueCheckAndLoadSections();\n                });\n            };\n\n            if (!sectionHeadersLoading && !sectionHeadersLoaded && headerLoaded &&\n                numBytesLoaded >= SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes * header.maxSectionCount) {\n                performLoad();\n            }\n        };\n\n        const checkAndLoadSections = () => {\n            if (loadSectionQueued) return;\n            loadSectionQueued = true;\n            const checkAndLoadFunc = () => {\n                loadSectionQueued = false;\n                if (sectionHeadersLoaded) {\n\n                    if (loadComplete) return;\n\n                    downloadComplete = numBytesLoaded >= totalBytesToDownload;\n\n                    let bytesLoadedSinceLastSection = numBytesLoaded - numBytesProgressivelyLoaded;\n                    if (bytesLoadedSinceLastSection > Constants.ProgressiveLoadSectionSize || downloadComplete) {\n\n                        numBytesProgressivelyLoaded += Constants.ProgressiveLoadSectionSize;\n                        loadComplete = numBytesProgressivelyLoaded >= totalBytesToDownload;\n\n                        if (!directLoadSplatBuffer) directLoadSplatBuffer = new SplatBuffer(directLoadBuffer, false);\n\n                        const baseDataOffset = SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes * header.maxSectionCount;\n                        let sectionBase = 0;\n                        let reachedSections = 0;\n                        let loadedSplatCount = 0;\n                        for (let i = 0; i < header.maxSectionCount; i++) {\n                            const sectionHeader = sectionHeaders[i];\n                            const bucketsDataOffset = sectionBase + sectionHeader.partiallyFilledBucketCount * 4 +\n                                                    sectionHeader.bucketStorageSizeBytes * sectionHeader.bucketCount;\n                            const bytesRequiredToReachSectionSplatData = baseDataOffset + bucketsDataOffset;\n                            if (numBytesProgressivelyLoaded >= bytesRequiredToReachSectionSplatData) {\n                                reachedSections++;\n                                const bytesPastSSectionSplatDataStart = numBytesProgressivelyLoaded - bytesRequiredToReachSectionSplatData;\n                                const baseDescriptor = SplatBuffer.CompressionLevels[header.compressionLevel];\n                                const shDesc = baseDescriptor.SphericalHarmonicsDegrees[sectionHeader.sphericalHarmonicsDegree];\n                                const bytesPerSplat = shDesc.BytesPerSplat;\n                                let loadedSplatsForSection = Math.floor(bytesPastSSectionSplatDataStart / bytesPerSplat);\n                                loadedSplatsForSection = Math.min(loadedSplatsForSection, sectionHeader.maxSplatCount);\n                                loadedSplatCount += loadedSplatsForSection;\n                                directLoadSplatBuffer.updateLoadedCounts(reachedSections, loadedSplatCount);\n                                directLoadSplatBuffer.updateSectionLoadedCounts(i, loadedSplatsForSection);\n                            } else {\n                                break;\n                            }\n                            sectionBase += sectionHeader.storageSizeBytes;\n                        }\n\n                        onSectionBuilt(directLoadSplatBuffer, loadComplete);\n\n                        const percentComplete = numBytesProgressivelyLoaded / totalBytesToDownload * 100;\n                        const percentLabel = (percentComplete).toFixed(2) + '%';\n\n                        if (externalOnProgress) externalOnProgress(percentComplete, percentLabel, LoaderStatus.Downloading);\n\n                        if (loadComplete) {\n                            directLoadPromise.resolve(directLoadSplatBuffer);\n                        } else {\n                            checkAndLoadSections();\n                        }\n                    }\n                }\n            };\n            window.setTimeout(checkAndLoadFunc, Constants.ProgressiveLoadSectionDelayDuration);\n        };\n\n        const localOnProgress = (percent, percentStr, chunk) => {\n            if (chunk) {\n                chunks.push(chunk);\n                if (directLoadBuffer) {\n                    new Uint8Array(directLoadBuffer, numBytesLoaded, chunk.byteLength).set(new Uint8Array(chunk));\n                }\n                numBytesLoaded += chunk.byteLength;\n            }\n            if (progressiveLoadToSplatBuffer) {\n                checkAndLoadHeader();\n                checkAndLoadSectionHeaders();\n                checkAndLoadSections();\n            } else {\n                if (externalOnProgress) externalOnProgress(percent, percentStr, LoaderStatus.Downloading);\n            }\n        };\n\n        return fetchWithProgress(fileName, localOnProgress, !progressiveLoadToSplatBuffer, headers).then((fullBuffer) => {\n            if (externalOnProgress) externalOnProgress(0, '0%', LoaderStatus.Processing);\n            const loadPromise = progressiveLoadToSplatBuffer ? directLoadPromise.promise : KSplatLoader.loadFromFileData(fullBuffer);\n            return loadPromise.then((splatBuffer) => {\n                if (externalOnProgress) externalOnProgress(100, '100%', LoaderStatus.Done);\n                return splatBuffer;\n            });\n        });\n    }\n\n    static loadFromFileData(fileData) {\n        return delayedExecute(() => {\n            KSplatLoader.checkVersion(fileData);\n            return new SplatBuffer(fileData);\n        });\n    }\n\n    static downloadFile = function() {\n\n        let downLoadLink;\n\n        return function(splatBuffer, fileName) {\n            const blob = new Blob([splatBuffer.bufferData], {\n                type: 'application/octet-stream',\n            });\n\n            if (!downLoadLink) {\n                downLoadLink = document.createElement('a');\n                document.body.appendChild(downLoadLink);\n            }\n            downLoadLink.download = fileName;\n            downLoadLink.href = URL.createObjectURL(blob);\n            downLoadLink.click();\n        };\n\n    }();\n\n}\n\nconst SceneFormat = {\n    'Splat': 0,\n    'KSplat': 1,\n    'Ply': 2,\n    'Spz': 3\n};\n\nconst sceneFormatFromPath = (path) => {\n    if (path.endsWith('.ply')) return SceneFormat.Ply;\n    else if (path.endsWith('.splat')) return SceneFormat.Splat;\n    else if (path.endsWith('.ksplat')) return SceneFormat.KSplat;\n    else if (path.endsWith('.spz')) return SceneFormat.Spz;\n    return null;\n};\n\nvar Utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    sceneFormatFromPath: sceneFormatFromPath\n});\n\n/*\nCopyright  2010-2024 three.js authors & Mark Kellogg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n*/\n\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\nconst _ray = new Ray$1();\nconst _plane = new Plane();\nconst TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );\n\nclass OrbitControls extends EventDispatcher {\n\n    constructor( object, domElement ) {\n\n        super();\n\n        this.object = object;\n        this.domElement = domElement;\n        this.domElement.style.touchAction = 'none'; // disable touch scroll\n\n        // Set to false to disable this control\n        this.enabled = true;\n\n        // \"target\" sets the location of focus, where the object orbits around\n        this.target = new Vector3();\n\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n\n        // How far you can zoom in and out ( OrthographicCamera only )\n        this.minZoom = 0;\n        this.maxZoom = Infinity;\n\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        this.minPolarAngle = 0; // radians\n        this.maxPolarAngle = Math.PI; // radians\n\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [min, max] must be a sub-interval of [- 2 PI, 2 PI], with ( max - min < 2 PI )\n        this.minAzimuthAngle = - Infinity; // radians\n        this.maxAzimuthAngle = Infinity; // radians\n\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        this.enableDamping = false;\n        this.dampingFactor = 0.05;\n\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        this.enableZoom = true;\n        this.zoomSpeed = 1.0;\n\n        // Set to false to disable rotating\n        this.enableRotate = true;\n        this.rotateSpeed = 1.0;\n\n        // Set to false to disable panning\n        this.enablePan = true;\n        this.panSpeed = 1.0;\n        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n        this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n        this.zoomToCursor = false;\n\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        this.autoRotate = false;\n        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n        // The four arrow keys\n        this.keys = { LEFT: 'KeyA', UP: 'KeyW', RIGHT: 'KeyD', BOTTOM: 'KeyS' };\n\n        // Mouse buttons\n        this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n        // Touch fingers\n        this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n        // for reset\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n\n        // the target DOM element for key events\n        this._domElementKeyEvents = null;\n\n        //\n        // public methods\n        //\n\n        this.getPolarAngle = function() {\n\n            return spherical.phi;\n\n        };\n\n        this.getAzimuthalAngle = function() {\n\n            return spherical.theta;\n\n        };\n\n        this.getDistance = function() {\n\n            return this.object.position.distanceTo( this.target );\n\n        };\n\n        this.listenToKeyEvents = function( domElement ) {\n\n            domElement.addEventListener( 'keydown', onKeyDown );\n            this._domElementKeyEvents = domElement;\n\n        };\n\n        this.stopListenToKeyEvents = function() {\n\n            this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n            this._domElementKeyEvents = null;\n\n        };\n\n        this.saveState = function() {\n\n            scope.target0.copy( scope.target );\n            scope.position0.copy( scope.object.position );\n            scope.zoom0 = scope.object.zoom;\n\n        };\n\n        this.reset = function() {\n\n            scope.target.copy( scope.target0 );\n            scope.object.position.copy( scope.position0 );\n            scope.object.zoom = scope.zoom0;\n            this.clearDampedRotation();\n            this.clearDampedPan();\n\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent( _changeEvent );\n\n            scope.update();\n\n            state = STATE.NONE;\n\n        };\n\n        this.clearDampedRotation = function() {\n            sphericalDelta.theta = 0.0;\n            sphericalDelta.phi = 0.0;\n        };\n\n        this.clearDampedPan = function() {\n            panOffset.set(0, 0, 0);\n        };\n\n        // this method is exposed, but perhaps it would be better if we can make it private...\n        this.update = function() {\n\n            const offset = new Vector3();\n\n            // so camera.up is the orbit axis\n            const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n            const quatInverse = quat.clone().invert();\n\n            const lastPosition = new Vector3();\n            const lastQuaternion = new Quaternion();\n            const lastTargetPosition = new Vector3();\n\n            const twoPI = 2 * Math.PI;\n\n            return function update() {\n\n                quat.setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n                quatInverse.copy(quat).invert();\n\n                const position = scope.object.position;\n\n                offset.copy( position ).sub( scope.target );\n\n                // rotate offset to \"y-axis-is-up\" space\n                offset.applyQuaternion( quat );\n\n                // angle from z-axis around y-axis\n                spherical.setFromVector3( offset );\n\n                if ( scope.autoRotate && state === STATE.NONE ) {\n\n                    rotateLeft( getAutoRotationAngle() );\n\n                }\n\n                if ( scope.enableDamping ) {\n\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n                } else {\n\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n\n                }\n\n                // restrict theta to be between desired limits\n\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n\n                if ( isFinite( min ) && isFinite( max ) ) {\n\n                    if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n                    if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n                    if ( min <= max ) {\n\n                        spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n                    } else {\n\n                        spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n                            Math.max( min, spherical.theta ) :\n                            Math.min( max, spherical.theta );\n\n                    }\n\n                }\n\n                // restrict phi to be between desired limits\n                spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n                spherical.makeSafe();\n\n\n                // move target to panned location\n\n                if ( scope.enableDamping === true ) {\n\n                    scope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n                } else {\n\n                    scope.target.add( panOffset );\n\n                }\n\n                // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n                // we adjust zoom later in these cases\n                if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {\n\n                    spherical.radius = clampDistance( spherical.radius );\n\n                } else {\n\n                    spherical.radius = clampDistance( spherical.radius * scale );\n\n                }\n\n\n                offset.setFromSpherical( spherical );\n\n                // rotate offset back to \"camera-up-vector-is-up\" space\n                offset.applyQuaternion( quatInverse );\n\n                position.copy( scope.target ).add( offset );\n\n                scope.object.lookAt( scope.target );\n\n                if ( scope.enableDamping === true ) {\n\n                    sphericalDelta.theta *= ( 1 - scope.dampingFactor );\n                    sphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n                    panOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n                } else {\n\n                    sphericalDelta.set( 0, 0, 0 );\n\n                    panOffset.set( 0, 0, 0 );\n\n                }\n\n                // adjust camera position\n                let zoomChanged = false;\n                if ( scope.zoomToCursor && performCursorZoom ) {\n\n                    let newRadius = null;\n                    if ( scope.object.isPerspectiveCamera ) {\n\n                        // move the camera down the pointer ray\n                        // this method avoids floating point error\n                        const prevRadius = offset.length();\n                        newRadius = clampDistance( prevRadius * scale );\n\n                        const radiusDelta = prevRadius - newRadius;\n                        scope.object.position.addScaledVector( dollyDirection, radiusDelta );\n                        scope.object.updateMatrixWorld();\n\n                    } else if ( scope.object.isOrthographicCamera ) {\n\n                        // adjust the ortho camera position based on zoom changes\n                        const mouseBefore = new Vector3( mouse.x, mouse.y, 0 );\n                        mouseBefore.unproject( scope.object );\n\n                        scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n                        scope.object.updateProjectionMatrix();\n                        zoomChanged = true;\n\n                        const mouseAfter = new Vector3( mouse.x, mouse.y, 0 );\n                        mouseAfter.unproject( scope.object );\n\n                        scope.object.position.sub( mouseAfter ).add( mouseBefore );\n                        scope.object.updateMatrixWorld();\n\n                        newRadius = offset.length();\n\n                    } else {\n\n                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );\n                        scope.zoomToCursor = false;\n\n                    }\n\n                    // handle the placement of the target\n                    if ( newRadius !== null ) {\n\n                        if ( this.screenSpacePanning ) {\n\n                            // position the orbit target in front of the new camera position\n                            scope.target.set( 0, 0, - 1 )\n                                .transformDirection( scope.object.matrix )\n                                .multiplyScalar( newRadius )\n                                .add( scope.object.position );\n\n                        } else {\n\n                            // get the ray and translation plane to compute target\n                            _ray.origin.copy( scope.object.position );\n                            _ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );\n\n                            // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n                            // extremely large values\n                            if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {\n\n                                object.lookAt( scope.target );\n\n                            } else {\n\n                                _plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );\n                                _ray.intersectPlane( _plane, scope.target );\n\n                            }\n\n                        }\n\n                    }\n\n                } else if ( scope.object.isOrthographicCamera ) {\n\n                    scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n                    scope.object.updateProjectionMatrix();\n                    zoomChanged = true;\n\n                }\n\n                scale = 1;\n                performCursorZoom = false;\n\n                // update condition is:\n                // min(camera displacement, camera rotation in radians)^2 > EPS\n                // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n                if ( zoomChanged ||\n                    lastPosition.distanceToSquared( scope.object.position ) > EPS ||\n                    8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||\n                    lastTargetPosition.distanceToSquared( scope.target ) > 0 ) {\n\n                    scope.dispatchEvent( _changeEvent );\n\n                    lastPosition.copy( scope.object.position );\n                    lastQuaternion.copy( scope.object.quaternion );\n                    lastTargetPosition.copy( scope.target );\n\n                    zoomChanged = false;\n\n                    return true;\n\n                }\n\n                return false;\n\n            };\n\n        }();\n\n        this.dispose = function() {\n\n            scope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n            scope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n            scope.domElement.removeEventListener( 'pointercancel', onPointerUp );\n            scope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n            scope.domElement.removeEventListener( 'pointermove', onPointerMove );\n            scope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\n            if ( scope._domElementKeyEvents !== null ) {\n\n                scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n                scope._domElementKeyEvents = null;\n\n            }\n\n        };\n\n        //\n        // internals\n        //\n\n        const scope = this;\n\n        const STATE = {\n            NONE: - 1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n\n        let state = STATE.NONE;\n\n        const EPS = 0.000001;\n\n        // current position in spherical coordinates\n        const spherical = new Spherical();\n        const sphericalDelta = new Spherical();\n\n        let scale = 1;\n        const panOffset = new Vector3();\n\n        const rotateStart = new Vector2();\n        const rotateEnd = new Vector2();\n        const rotateDelta = new Vector2();\n\n        const panStart = new Vector2();\n        const panEnd = new Vector2();\n        const panDelta = new Vector2();\n\n        const dollyStart = new Vector2();\n        const dollyEnd = new Vector2();\n        const dollyDelta = new Vector2();\n\n        const dollyDirection = new Vector3();\n        const mouse = new Vector2();\n        let performCursorZoom = false;\n\n        const pointers = [];\n        const pointerPositions = {};\n\n        function getAutoRotationAngle() {\n\n            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n        }\n\n        function getZoomScale() {\n\n            return Math.pow( 0.95, scope.zoomSpeed );\n\n        }\n\n        function rotateLeft( angle ) {\n\n            sphericalDelta.theta -= angle;\n\n        }\n\n        function rotateUp( angle ) {\n\n            sphericalDelta.phi -= angle;\n\n        }\n\n        const panLeft = function() {\n\n            const v = new Vector3();\n\n            return function panLeft( distance, objectMatrix ) {\n\n                v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n                v.multiplyScalar( - distance );\n\n                panOffset.add( v );\n\n            };\n\n        }();\n\n        const panUp = function() {\n\n            const v = new Vector3();\n\n            return function panUp( distance, objectMatrix ) {\n\n                if ( scope.screenSpacePanning === true ) {\n\n                    v.setFromMatrixColumn( objectMatrix, 1 );\n\n                } else {\n\n                    v.setFromMatrixColumn( objectMatrix, 0 );\n                    v.crossVectors( scope.object.up, v );\n\n                }\n\n                v.multiplyScalar( distance );\n\n                panOffset.add( v );\n\n            };\n\n        }();\n\n        // deltaX and deltaY are in pixels; right and down are positive\n        const pan = function() {\n\n            const offset = new Vector3();\n\n            return function pan( deltaX, deltaY ) {\n\n                const element = scope.domElement;\n\n                if ( scope.object.isPerspectiveCamera ) {\n\n                    // perspective\n                    const position = scope.object.position;\n                    offset.copy( position ).sub( scope.target );\n                    let targetDistance = offset.length();\n\n                    // half of the fov is center to top of screen\n                    targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n                    // we use only clientHeight here so aspect ratio does not distort speed\n                    panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n                    panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n                } else if ( scope.object.isOrthographicCamera ) {\n\n                    // orthographic\n                    panLeft( deltaX * ( scope.object.right - scope.object.left ) /\n                                        scope.object.zoom / element.clientWidth, scope.object.matrix );\n                    panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom /\n                                      element.clientHeight, scope.object.matrix );\n\n                } else {\n\n                    // camera neither orthographic nor perspective\n                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n                    scope.enablePan = false;\n\n                }\n\n            };\n\n        }();\n\n        function dollyOut( dollyScale ) {\n\n            if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n                scale /= dollyScale;\n\n            } else {\n\n                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n                scope.enableZoom = false;\n\n            }\n\n        }\n\n        function dollyIn( dollyScale ) {\n\n            if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n                scale *= dollyScale;\n\n            } else {\n\n                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n                scope.enableZoom = false;\n\n            }\n\n        }\n\n        function updateMouseParameters( event ) {\n\n            if ( ! scope.zoomToCursor ) {\n\n                return;\n\n            }\n\n            performCursorZoom = true;\n\n            const rect = scope.domElement.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            const w = rect.width;\n            const h = rect.height;\n\n            mouse.x = ( x / w ) * 2 - 1;\n            mouse.y = - ( y / h ) * 2 + 1;\n\n            dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( object ).sub( object.position ).normalize();\n\n        }\n\n        function clampDistance( dist ) {\n\n            return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );\n\n        }\n\n        //\n        // event callbacks - update the object state\n        //\n\n        function handleMouseDownRotate( event ) {\n\n            rotateStart.set( event.clientX, event.clientY );\n\n        }\n\n        function handleMouseDownDolly( event ) {\n\n            updateMouseParameters( event );\n            dollyStart.set( event.clientX, event.clientY );\n\n        }\n\n        function handleMouseDownPan( event ) {\n\n            panStart.set( event.clientX, event.clientY );\n\n        }\n\n        function handleMouseMoveRotate( event ) {\n\n            rotateEnd.set( event.clientX, event.clientY );\n\n            rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n            const element = scope.domElement;\n\n            rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n            rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n            rotateStart.copy( rotateEnd );\n\n            scope.update();\n\n        }\n\n        function handleMouseMoveDolly( event ) {\n\n            dollyEnd.set( event.clientX, event.clientY );\n\n            dollyDelta.subVectors( dollyEnd, dollyStart );\n\n            if ( dollyDelta.y > 0 ) {\n\n                dollyOut( getZoomScale() );\n\n            } else if ( dollyDelta.y < 0 ) {\n\n                dollyIn( getZoomScale() );\n\n            }\n\n            dollyStart.copy( dollyEnd );\n\n            scope.update();\n\n        }\n\n        function handleMouseMovePan( event ) {\n\n            panEnd.set( event.clientX, event.clientY );\n\n            panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n            pan( panDelta.x, panDelta.y );\n\n            panStart.copy( panEnd );\n\n            scope.update();\n\n        }\n\n        function handleMouseWheel( event ) {\n\n            updateMouseParameters( event );\n\n            if ( event.deltaY < 0 ) {\n\n                dollyIn( getZoomScale() );\n\n            } else if ( event.deltaY > 0 ) {\n\n                dollyOut( getZoomScale() );\n\n            }\n\n            scope.update();\n\n        }\n\n        function handleKeyDown( event ) {\n\n            let needsUpdate = false;\n\n            switch ( event.code ) {\n\n                case scope.keys.UP:\n\n                    if ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n                        rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n                    } else {\n\n                        pan( 0, scope.keyPanSpeed );\n\n                    }\n\n                    needsUpdate = true;\n                    break;\n\n                case scope.keys.BOTTOM:\n\n                    if ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n                        rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n                    } else {\n\n                        pan( 0, - scope.keyPanSpeed );\n\n                    }\n\n                    needsUpdate = true;\n                    break;\n\n                case scope.keys.LEFT:\n\n                    if ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n                        rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n                    } else {\n\n                        pan( scope.keyPanSpeed, 0 );\n\n                    }\n\n                    needsUpdate = true;\n                    break;\n\n                case scope.keys.RIGHT:\n\n                    if ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n                        rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n                    } else {\n\n                        pan( - scope.keyPanSpeed, 0 );\n\n                    }\n\n                    needsUpdate = true;\n                    break;\n\n            }\n\n            if ( needsUpdate ) {\n\n                // prevent the browser from scrolling on cursor keys\n                event.preventDefault();\n\n                scope.update();\n\n            }\n\n\n        }\n\n        function handleTouchStartRotate() {\n\n            if ( pointers.length === 1 ) {\n\n                rotateStart.set( pointers[0].pageX, pointers[0].pageY );\n\n            } else {\n\n                const x = 0.5 * ( pointers[0].pageX + pointers[1].pageX );\n                const y = 0.5 * ( pointers[0].pageY + pointers[1].pageY );\n\n                rotateStart.set( x, y );\n\n            }\n\n        }\n\n        function handleTouchStartPan() {\n\n            if ( pointers.length === 1 ) {\n\n                panStart.set( pointers[0].pageX, pointers[0].pageY );\n\n            } else {\n\n                const x = 0.5 * ( pointers[0].pageX + pointers[1].pageX );\n                const y = 0.5 * ( pointers[0].pageY + pointers[1].pageY );\n\n                panStart.set( x, y );\n\n            }\n\n        }\n\n        function handleTouchStartDolly() {\n\n            const dx = pointers[0].pageX - pointers[1].pageX;\n            const dy = pointers[0].pageY - pointers[1].pageY;\n\n            const distance = Math.sqrt( dx * dx + dy * dy );\n\n            dollyStart.set( 0, distance );\n\n        }\n\n        function handleTouchStartDollyPan() {\n\n            if ( scope.enableZoom ) handleTouchStartDolly();\n\n            if ( scope.enablePan ) handleTouchStartPan();\n\n        }\n\n        function handleTouchStartDollyRotate() {\n\n            if ( scope.enableZoom ) handleTouchStartDolly();\n\n            if ( scope.enableRotate ) handleTouchStartRotate();\n\n        }\n\n        function handleTouchMoveRotate( event ) {\n\n            if ( pointers.length == 1 ) {\n\n                rotateEnd.set( event.pageX, event.pageY );\n\n            } else {\n\n                const position = getSecondPointerPosition( event );\n\n                const x = 0.5 * ( event.pageX + position.x );\n                const y = 0.5 * ( event.pageY + position.y );\n\n                rotateEnd.set( x, y );\n\n            }\n\n            rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n            const element = scope.domElement;\n\n            rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n            rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n            rotateStart.copy( rotateEnd );\n\n        }\n\n        function handleTouchMovePan( event ) {\n\n            if ( pointers.length === 1 ) {\n\n                panEnd.set( event.pageX, event.pageY );\n\n            } else {\n\n                const position = getSecondPointerPosition( event );\n\n                const x = 0.5 * ( event.pageX + position.x );\n                const y = 0.5 * ( event.pageY + position.y );\n\n                panEnd.set( x, y );\n\n            }\n\n            panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n            pan( panDelta.x, panDelta.y );\n\n            panStart.copy( panEnd );\n\n        }\n\n        function handleTouchMoveDolly( event ) {\n\n            const position = getSecondPointerPosition( event );\n\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n\n            const distance = Math.sqrt( dx * dx + dy * dy );\n\n            dollyEnd.set( 0, distance );\n\n            dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n            dollyOut( dollyDelta.y );\n\n            dollyStart.copy( dollyEnd );\n\n        }\n\n        function handleTouchMoveDollyPan( event ) {\n\n            if ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n            if ( scope.enablePan ) handleTouchMovePan( event );\n\n        }\n\n        function handleTouchMoveDollyRotate( event ) {\n\n            if ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n            if ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n        }\n\n        //\n        // event handlers - FSM: listen for events and reset state\n        //\n\n        function onPointerDown( event ) {\n\n            if ( scope.enabled === false ) return;\n\n            if ( pointers.length === 0 ) {\n\n                scope.domElement.setPointerCapture( event.pointerId );\n\n                scope.domElement.addEventListener( 'pointermove', onPointerMove );\n                scope.domElement.addEventListener( 'pointerup', onPointerUp );\n\n            }\n\n            //\n\n            addPointer( event );\n\n            if ( event.pointerType === 'touch' ) {\n\n                onTouchStart( event );\n\n            } else {\n\n                onMouseDown( event );\n\n            }\n\n        }\n\n        function onPointerMove( event ) {\n\n            if ( scope.enabled === false ) return;\n\n            if ( event.pointerType === 'touch' ) {\n\n                onTouchMove( event );\n\n            } else {\n\n                onMouseMove( event );\n\n            }\n\n        }\n\n        function onPointerUp( event ) {\n\n            removePointer( event );\n\n            if ( pointers.length === 0 ) {\n\n                scope.domElement.releasePointerCapture( event.pointerId );\n\n                scope.domElement.removeEventListener( 'pointermove', onPointerMove );\n                scope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n            }\n\n            scope.dispatchEvent( _endEvent );\n\n            state = STATE.NONE;\n\n        }\n\n        function onMouseDown( event ) {\n\n            let mouseAction;\n\n            switch ( event.button ) {\n\n                case 0:\n\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n\n                case 1:\n\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n\n                case 2:\n\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n\n                default:\n\n                    mouseAction = - 1;\n\n            }\n\n            switch ( mouseAction ) {\n\n                case MOUSE.DOLLY:\n\n                    if ( scope.enableZoom === false ) return;\n\n                    handleMouseDownDolly( event );\n\n                    state = STATE.DOLLY;\n\n                    break;\n\n                case MOUSE.ROTATE:\n\n                    if ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n                        if ( scope.enablePan === false ) return;\n\n                        handleMouseDownPan( event );\n\n                        state = STATE.PAN;\n\n                    } else {\n\n                        if ( scope.enableRotate === false ) return;\n\n                        handleMouseDownRotate( event );\n\n                        state = STATE.ROTATE;\n\n                    }\n\n                    break;\n\n                case MOUSE.PAN:\n\n                    if ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n                        if ( scope.enableRotate === false ) return;\n\n                        handleMouseDownRotate( event );\n\n                        state = STATE.ROTATE;\n\n                    } else {\n\n                        if ( scope.enablePan === false ) return;\n\n                        handleMouseDownPan( event );\n\n                        state = STATE.PAN;\n\n                    }\n\n                    break;\n\n                default:\n\n                    state = STATE.NONE;\n\n            }\n\n            if ( state !== STATE.NONE ) {\n\n                scope.dispatchEvent( _startEvent );\n\n            }\n\n        }\n\n        function onMouseMove( event ) {\n\n            switch ( state ) {\n\n                case STATE.ROTATE:\n\n                    if ( scope.enableRotate === false ) return;\n\n                    handleMouseMoveRotate( event );\n\n                    break;\n\n                case STATE.DOLLY:\n\n                    if ( scope.enableZoom === false ) return;\n\n                    handleMouseMoveDolly( event );\n\n                    break;\n\n                case STATE.PAN:\n\n                    if ( scope.enablePan === false ) return;\n\n                    handleMouseMovePan( event );\n\n                    break;\n\n            }\n\n        }\n\n        function onMouseWheel( event ) {\n\n            if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n            event.preventDefault();\n\n            scope.dispatchEvent( _startEvent );\n\n            handleMouseWheel( event );\n\n            scope.dispatchEvent( _endEvent );\n\n        }\n\n        function onKeyDown( event ) {\n\n            if ( scope.enabled === false || scope.enablePan === false ) return;\n\n            handleKeyDown( event );\n\n        }\n\n        function onTouchStart( event ) {\n\n            trackPointer( event );\n\n            switch ( pointers.length ) {\n\n                case 1:\n\n                    switch ( scope.touches.ONE ) {\n\n                        case TOUCH.ROTATE:\n\n                            if ( scope.enableRotate === false ) return;\n\n                            handleTouchStartRotate();\n\n                            state = STATE.TOUCH_ROTATE;\n\n                            break;\n\n                        case TOUCH.PAN:\n\n                            if ( scope.enablePan === false ) return;\n\n                            handleTouchStartPan();\n\n                            state = STATE.TOUCH_PAN;\n\n                            break;\n\n                        default:\n\n                            state = STATE.NONE;\n\n                    }\n\n                    break;\n\n                case 2:\n\n                    switch ( scope.touches.TWO ) {\n\n                        case TOUCH.DOLLY_PAN:\n\n                            if ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n                            handleTouchStartDollyPan();\n\n                            state = STATE.TOUCH_DOLLY_PAN;\n\n                            break;\n\n                        case TOUCH.DOLLY_ROTATE:\n\n                            if ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n                            handleTouchStartDollyRotate();\n\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n\n                            break;\n\n                        default:\n\n                            state = STATE.NONE;\n\n                    }\n\n                    break;\n\n                default:\n\n                    state = STATE.NONE;\n\n            }\n\n            if ( state !== STATE.NONE ) {\n\n                scope.dispatchEvent( _startEvent );\n\n            }\n\n        }\n\n        function onTouchMove( event ) {\n\n            trackPointer( event );\n\n            switch ( state ) {\n\n                case STATE.TOUCH_ROTATE:\n\n                    if ( scope.enableRotate === false ) return;\n\n                    handleTouchMoveRotate( event );\n\n                    scope.update();\n\n                    break;\n\n                case STATE.TOUCH_PAN:\n\n                    if ( scope.enablePan === false ) return;\n\n                    handleTouchMovePan( event );\n\n                    scope.update();\n\n                    break;\n\n                case STATE.TOUCH_DOLLY_PAN:\n\n                    if ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n                    handleTouchMoveDollyPan( event );\n\n                    scope.update();\n\n                    break;\n\n                case STATE.TOUCH_DOLLY_ROTATE:\n\n                    if ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n                    handleTouchMoveDollyRotate( event );\n\n                    scope.update();\n\n                    break;\n\n                default:\n\n                    state = STATE.NONE;\n\n            }\n\n        }\n\n        function onContextMenu( event ) {\n\n            if ( scope.enabled === false ) return;\n\n            event.preventDefault();\n\n        }\n\n        function addPointer( event ) {\n\n            pointers.push( event );\n\n        }\n\n        function removePointer( event ) {\n\n            delete pointerPositions[event.pointerId];\n\n            for ( let i = 0; i < pointers.length; i ++ ) {\n\n                if ( pointers[i].pointerId == event.pointerId ) {\n\n                    pointers.splice( i, 1 );\n                    return;\n\n                }\n\n            }\n\n        }\n\n        function trackPointer( event ) {\n\n            let position = pointerPositions[event.pointerId];\n\n            if ( position === undefined ) {\n\n                position = new Vector2();\n                pointerPositions[event.pointerId] = position;\n\n            }\n\n            position.set( event.pageX, event.pageY );\n\n        }\n\n        function getSecondPointerPosition( event ) {\n\n            const pointer = ( event.pointerId === pointers[0].pointerId ) ? pointers[1] : pointers[0];\n\n            return pointerPositions[pointer.pointerId];\n\n        }\n\n        //\n\n        scope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n        scope.domElement.addEventListener( 'pointerdown', onPointerDown );\n        scope.domElement.addEventListener( 'pointercancel', onPointerUp );\n        scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n        // force an update at start\n\n        this.update();\n\n    }\n\n}\n\nconst fadeElement = (element, out, displayStyle, duration, onComplete) => {\n    const startTime = performance.now();\n\n    let startOpacity = element.style.display === 'none' ? 0 : parseFloat(element.style.opacity);\n    if (isNaN(startOpacity)) startOpacity = 1;\n\n    const interval = window.setInterval(() => {\n        const currentTime = performance.now();\n        const elapsed = currentTime - startTime;\n\n        let t = Math.min(elapsed / duration, 1.0);\n        if (t > 0.999) t = 1;\n\n        let opacity;\n        if (out) {\n            opacity = (1.0 - t) * startOpacity;\n            if (opacity < 0.0001) opacity = 0;\n        } else {\n            opacity = (1.0 - startOpacity) * t + startOpacity;\n        }\n\n        if (opacity > 0) {\n            element.style.display = displayStyle;\n            element.style.opacity = opacity;\n        } else {\n            element.style.display = 'none';\n        }\n\n        if (t >= 1) {\n            if (onComplete) onComplete();\n            window.clearInterval(interval);\n        }\n    }, 16);\n    return interval;\n};\n\nconst cancelFade = (interval) => {\n    window.clearInterval(interval);\n};\n\nconst STANDARD_FADE_DURATION = 500;\n\nclass LoadingSpinner {\n\n    static elementIDGen = 0;\n\n    constructor(message, container) {\n\n        this.taskIDGen = 0;\n        this.elementID = LoadingSpinner.elementIDGen++;\n\n        this.tasks = [];\n\n        this.message = message || 'Loading...';\n        this.container = container || document.body;\n\n        this.spinnerContainerOuter = document.createElement('div');\n        this.spinnerContainerOuter.className = `spinnerOuterContainer${this.elementID}`;\n        this.spinnerContainerOuter.style.display = 'none';\n\n        this.spinnerContainerPrimary = document.createElement('div');\n        this.spinnerContainerPrimary.className = `spinnerContainerPrimary${this.elementID}`;\n        this.spinnerPrimary = document.createElement('div');\n        this.spinnerPrimary.classList.add(`spinner${this.elementID}`, `spinnerPrimary${this.elementID}`);\n        this.messageContainerPrimary = document.createElement('div');\n        this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`, `messageContainerPrimary${this.elementID}`);\n        this.messageContainerPrimary.innerHTML = this.message;\n\n        this.spinnerContainerMin = document.createElement('div');\n        this.spinnerContainerMin.className = `spinnerContainerMin${this.elementID}`;\n        this.spinnerMin = document.createElement('div');\n        this.spinnerMin.classList.add(`spinner${this.elementID}`, `spinnerMin${this.elementID}`);\n        this.messageContainerMin = document.createElement('div');\n        this.messageContainerMin.classList.add(`messageContainer${this.elementID}`, `messageContainerMin${this.elementID}`);\n        this.messageContainerMin.innerHTML = this.message;\n\n        this.spinnerContainerPrimary.appendChild(this.spinnerPrimary);\n        this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary);\n        this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary);\n\n        this.spinnerContainerMin.appendChild(this.spinnerMin);\n        this.spinnerContainerMin.appendChild(this.messageContainerMin);\n        this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);\n\n        const style = document.createElement('style');\n        style.innerHTML = `\n\n            .spinnerOuterContainer${this.elementID} {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .messageContainer${this.elementID} {\n                height: 20px;\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                vertical-align: middle;\n            }\n\n            .spinner${this.elementID} {\n                padding: 15px;\n                background: #07e8d6;\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n            }\n\n            .spinnerContainerPrimary${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 10px;\n                margin: 0;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n                pointer-events: auto;\n            }\n\n            .spinnerPrimary${this.elementID} {\n                width: 120px;\n                margin-left: 30px;\n            }\n\n            .messageContainerPrimary${this.elementID} {\n                padding-top: 15px;\n            }\n\n            .spinnerContainerMin${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                display: flex;\n                flex-direction: left;\n                pointer-events: auto;\n                min-width: 250px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                margin-right: 15px;\n            }\n\n            .spinnerMin${this.elementID} {\n                width: 50px;\n                height: 50px;\n                margin-left: 15px;\n                margin-right: 25px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                padding-top: 15px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        `;\n        this.spinnerContainerOuter.appendChild(style);\n        this.container.appendChild(this.spinnerContainerOuter);\n\n        this.setMinimized(false, true);\n\n        this.fadeTransitions = [];\n    }\n\n    addTask(message) {\n        const newTask = {\n            'message': message,\n            'id': this.taskIDGen++\n        };\n        this.tasks.push(newTask);\n        this.update();\n        return newTask.id;\n    }\n\n    removeTask(id) {\n        let index = 0;\n        for (let task of this.tasks) {\n            if (task.id === id) {\n                this.tasks.splice(index, 1);\n                break;\n            }\n            index++;\n        }\n        this.update();\n    }\n\n    removeAllTasks() {\n        this.tasks = [];\n        this.update();\n    }\n\n    setMessageForTask(id, message) {\n        for (let task of this.tasks) {\n            if (task.id === id) {\n                task.message = message;\n                break;\n            }\n        }\n        this.update();\n    }\n\n    update() {\n        if (this.tasks.length > 0) {\n            this.show();\n            this.setMessage(this.tasks[this.tasks.length - 1].message);\n        } else {\n            this.hide();\n        }\n    }\n\n    show() {\n        this.spinnerContainerOuter.style.display = 'block';\n        this.visible = true;\n    }\n\n    hide() {\n        this.spinnerContainerOuter.style.display = 'none';\n        this.visible = false;\n    }\n\n    setContainer(container) {\n        if (this.container && this.spinnerContainerOuter.parentElement === this.container) {\n            this.container.removeChild(this.spinnerContainerOuter);\n        }\n        if (container) {\n            this.container = container;\n            this.container.appendChild(this.spinnerContainerOuter);\n            this.spinnerContainerOuter.style.zIndex = this.container.style.zIndex + 1;\n        }\n    }\n\n    setMinimized(minimized, instant) {\n        const showHideSpinner = (element, show, instant, displayStyle, fadeTransitionsIndex) => {\n            if (instant) {\n                element.style.display = show ? displayStyle : 'none';\n            } else {\n                this.fadeTransitions[fadeTransitionsIndex] = fadeElement(element, !show, displayStyle, STANDARD_FADE_DURATION, () => {\n                    this.fadeTransitions[fadeTransitionsIndex] = null;\n                });\n            }\n        };\n        showHideSpinner(this.spinnerContainerPrimary, !minimized, instant, 'block', 0);\n        showHideSpinner(this.spinnerContainerMin, minimized, instant, 'flex', 1);\n        this.minimized = minimized;\n    }\n\n    setMessage(msg) {\n        this.messageContainerPrimary.innerHTML = msg;\n        this.messageContainerMin.innerHTML = msg;\n    }\n}\n\nclass LoadingProgressBar {\n\n    constructor(container) {\n\n        this.idGen = 0;\n\n        this.tasks = [];\n\n        this.container = container || document.body;\n\n        this.progressBarContainerOuter = document.createElement('div');\n        this.progressBarContainerOuter.className = 'progressBarOuterContainer';\n        this.progressBarContainerOuter.style.display = 'none';\n\n        this.progressBarBox = document.createElement('div');\n        this.progressBarBox.className = 'progressBarBox';\n\n        this.progressBarBackground = document.createElement('div');\n        this.progressBarBackground.className = 'progressBarBackground';\n\n        this.progressBar = document.createElement('div');\n        this.progressBar.className = 'progressBar';\n\n        this.progressBarBackground.appendChild(this.progressBar);\n        this.progressBarBox.appendChild(this.progressBarBackground);\n        this.progressBarContainerOuter.appendChild(this.progressBarBox);\n\n        const style = document.createElement('style');\n        style.innerHTML = `\n\n            .progressBarOuterContainer {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .progressBarBox {\n                z-index:99999;\n                padding: 7px 9px 5px 7px;\n                background-color: rgba(190, 190, 190, 0.75);\n                border: #555555 1px solid;\n                border-radius: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                width: 180px;\n                height: 30px;\n                pointer-events: auto;\n            }\n\n            .progressBarBackground {\n                width: 100%;\n                height: 25px;\n                border-radius:10px;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #444444 1px solid;\n                box-shadow: inset 0 0 10px #333333;\n            }\n\n            .progressBar {\n                height: 25px;\n                width: 0px;\n                border-radius:10px;\n                background-color: rgba(0, 200, 0, 0.75);\n                box-shadow: inset 0 0 10px #003300;\n            }\n\n        `;\n        this.progressBarContainerOuter.appendChild(style);\n        this.container.appendChild(this.progressBarContainerOuter);\n    }\n\n    show() {\n        this.progressBarContainerOuter.style.display = 'block';\n    }\n\n    hide() {\n        this.progressBarContainerOuter.style.display = 'none';\n    }\n\n    setProgress(progress) {\n        this.progressBar.style.width = progress + '%';\n    }\n\n    setContainer(container) {\n        if (this.container && this.progressBarContainerOuter.parentElement === this.container) {\n            this.container.removeChild(this.progressBarContainerOuter);\n        }\n        if (container) {\n            this.container = container;\n            this.container.appendChild(this.progressBarContainerOuter);\n            this.progressBarContainerOuter.style.zIndex = this.container.style.zIndex + 1;\n        }\n    }\n\n}\n\nclass InfoPanel {\n\n    constructor(container) {\n\n        this.container = container || document.body;\n\n        this.infoCells = {};\n\n        const layout = [\n            ['Camera position', 'cameraPosition'],\n            ['Camera look-at', 'cameraLookAt'],\n            ['Camera up', 'cameraUp'],\n            ['Camera mode', 'orthographicCamera'],\n            ['Cursor position', 'cursorPosition'],\n            ['FPS', 'fps'],\n            ['Rendering:', 'renderSplatCount'],\n            ['Sort time', 'sortTime'],\n            ['Render window', 'renderWindow'],\n            ['Focal adjustment', 'focalAdjustment'],\n            ['Splat scale', 'splatScale'],\n            ['Point cloud mode', 'pointCloudMode']\n        ];\n\n        this.infoPanelContainer = document.createElement('div');\n        const style = document.createElement('style');\n        style.innerHTML = `\n\n            .infoPanel {\n                width: 430px;\n                padding: 10px;\n                background-color: rgba(50, 50, 50, 0.85);\n                border: #555555 2px solid;\n                color: #dddddd;\n                border-radius: 10px;\n                z-index: 9999;\n                font-family: arial;\n                font-size: 11pt;\n                text-align: left;\n                margin: 0;\n                top: 10px;\n                left:10px;\n                position: absolute;\n                pointer-events: auto;\n            }\n\n            .info-panel-cell {\n                margin-bottom: 5px;\n                padding-bottom: 2px;\n            }\n\n            .label-cell {\n                font-weight: bold;\n                font-size: 12pt;\n                width: 140px;\n            }\n\n        `;\n        this.infoPanelContainer.append(style);\n\n        this.infoPanel = document.createElement('div');\n        this.infoPanel.className = 'infoPanel';\n\n        const infoTable = document.createElement('div');\n        infoTable.style.display = 'table';\n\n        for (let layoutEntry of layout) {\n            const row = document.createElement('div');\n            row.style.display = 'table-row';\n            row.className = 'info-panel-row';\n\n            const labelCell = document.createElement('div');\n            labelCell.style.display = 'table-cell';\n            labelCell.innerHTML = `${layoutEntry[0]}: `;\n            labelCell.classList.add('info-panel-cell', 'label-cell');\n\n            const spacerCell = document.createElement('div');\n            spacerCell.style.display = 'table-cell';\n            spacerCell.style.width = '10px';\n            spacerCell.innerHTML = ' ';\n            spacerCell.className = 'info-panel-cell';\n\n            const infoCell = document.createElement('div');\n            infoCell.style.display = 'table-cell';\n            infoCell.innerHTML = '';\n            infoCell.className = 'info-panel-cell';\n\n            this.infoCells[layoutEntry[1]] = infoCell;\n\n            row.appendChild(labelCell);\n            row.appendChild(spacerCell);\n            row.appendChild(infoCell);\n\n            infoTable.appendChild(row);\n        }\n\n        this.infoPanel.appendChild(infoTable);\n        this.infoPanelContainer.append(this.infoPanel);\n        this.infoPanelContainer.style.display = 'none';\n        this.container.appendChild(this.infoPanelContainer);\n\n        this.visible = false;\n    }\n\n    update = function(renderDimensions, cameraPosition, cameraLookAtPosition, cameraUp, orthographicCamera,\n                      meshCursorPosition, currentFPS, splatCount, splatRenderCount,\n                      splatRenderCountPct, lastSortTime, focalAdjustment, splatScale, pointCloudMode) {\n\n        const cameraPosString = `${cameraPosition.x.toFixed(5)}, ${cameraPosition.y.toFixed(5)}, ${cameraPosition.z.toFixed(5)}`;\n        if (this.infoCells.cameraPosition.innerHTML !== cameraPosString) {\n            this.infoCells.cameraPosition.innerHTML = cameraPosString;\n        }\n\n        if (cameraLookAtPosition) {\n            const cla = cameraLookAtPosition;\n            const cameraLookAtString = `${cla.x.toFixed(5)}, ${cla.y.toFixed(5)}, ${cla.z.toFixed(5)}`;\n            if (this.infoCells.cameraLookAt.innerHTML !== cameraLookAtString) {\n                this.infoCells.cameraLookAt.innerHTML = cameraLookAtString;\n            }\n        }\n\n        const cameraUpString = `${cameraUp.x.toFixed(5)}, ${cameraUp.y.toFixed(5)}, ${cameraUp.z.toFixed(5)}`;\n        if (this.infoCells.cameraUp.innerHTML !== cameraUpString) {\n            this.infoCells.cameraUp.innerHTML = cameraUpString;\n        }\n\n        this.infoCells.orthographicCamera.innerHTML = orthographicCamera ? 'Orthographic' : 'Perspective';\n\n        if (meshCursorPosition) {\n            const cursPos = meshCursorPosition;\n            const cursorPosString = `${cursPos.x.toFixed(5)}, ${cursPos.y.toFixed(5)}, ${cursPos.z.toFixed(5)}`;\n            this.infoCells.cursorPosition.innerHTML = cursorPosString;\n        } else {\n            this.infoCells.cursorPosition.innerHTML = 'N/A';\n        }\n\n        this.infoCells.fps.innerHTML = currentFPS;\n        this.infoCells.renderWindow.innerHTML = `${renderDimensions.x} x ${renderDimensions.y}`;\n\n        this.infoCells.renderSplatCount.innerHTML =\n            `${splatRenderCount} splats out of ${splatCount} (${splatRenderCountPct.toFixed(2)}%)`;\n\n        this.infoCells.sortTime.innerHTML = `${lastSortTime.toFixed(3)} ms`;\n        this.infoCells.focalAdjustment.innerHTML = `${focalAdjustment.toFixed(3)}`;\n        this.infoCells.splatScale.innerHTML = `${splatScale.toFixed(3)}`;\n        this.infoCells.pointCloudMode.innerHTML = `${pointCloudMode}`;\n    };\n\n    setContainer(container) {\n        if (this.container && this.infoPanelContainer.parentElement === this.container) {\n            this.container.removeChild(this.infoPanelContainer);\n        }\n        if (container) {\n            this.container = container;\n            this.container.appendChild(this.infoPanelContainer);\n            this.infoPanelContainer.style.zIndex = this.container.style.zIndex + 1;\n        }\n    }\n\n    show() {\n        this.infoPanelContainer.style.display = 'block';\n        this.visible = true;\n    }\n\n    hide() {\n        this.infoPanelContainer.style.display = 'none';\n        this.visible = false;\n    }\n\n}\n\nconst _axis = new THREE.Vector3();\n\nclass ArrowHelper extends THREE.Object3D {\n\n    constructor(dir = new THREE.Vector3(0, 0, 1), origin = new THREE.Vector3(0, 0, 0), length = 1,\n                radius = 0.1, color = 0xffff00, headLength = length * 0.2, headRadius = headLength * 0.2) {\n        super();\n\n        this.type = 'ArrowHelper';\n\n        const lineGeometry = new THREE.CylinderGeometry(radius, radius, length, 32);\n        lineGeometry.translate(0, length / 2.0, 0);\n        const coneGeometry = new THREE.CylinderGeometry( 0, headRadius, headLength, 32);\n        coneGeometry.translate(0, length, 0);\n\n        this.position.copy( origin );\n\n        this.line = new THREE.Mesh(lineGeometry, new THREE.MeshBasicMaterial({color: color, toneMapped: false}));\n        this.line.matrixAutoUpdate = false;\n        this.add(this.line);\n\n        this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color: color, toneMapped: false}));\n        this.cone.matrixAutoUpdate = false;\n        this.add(this.cone);\n\n        this.setDirection(dir);\n    }\n\n    setDirection( dir ) {\n        if (dir.y > 0.99999) {\n            this.quaternion.set(0, 0, 0, 1);\n        } else if (dir.y < - 0.99999) {\n            this.quaternion.set(1, 0, 0, 0);\n        } else {\n            _axis.set(dir.z, 0, -dir.x).normalize();\n            const radians = Math.acos(dir.y);\n            this.quaternion.setFromAxisAngle(_axis, radians);\n        }\n    }\n\n    setColor( color ) {\n        this.line.material.color.set(color);\n        this.cone.material.color.set(color);\n    }\n\n    copy(source) {\n        super.copy(source, false);\n        this.line.copy(source.line);\n        this.cone.copy(source.cone);\n        return this;\n    }\n\n    dispose() {\n        this.line.geometry.dispose();\n        this.line.material.dispose();\n        this.cone.geometry.dispose();\n        this.cone.material.dispose();\n    }\n\n}\n\nclass SceneHelper {\n\n    constructor(threeScene) {\n        this.threeScene = threeScene;\n        this.splatRenderTarget = null;\n        this.renderTargetCopyQuad = null;\n        this.renderTargetCopyCamera = null;\n        this.meshCursor = null;\n        this.focusMarker = null;\n        this.controlPlane = null;\n        this.debugRoot = null;\n        this.secondaryDebugRoot = null;\n    }\n\n    updateSplatRenderTargetForRenderDimensions(width, height) {\n        this.destroySplatRendertarget();\n        this.splatRenderTarget = new THREE.WebGLRenderTarget(width, height, {\n            format: THREE.RGBAFormat,\n            stencilBuffer: false,\n            depthBuffer: true,\n\n        });\n        this.splatRenderTarget.depthTexture = new THREE.DepthTexture(width, height);\n        this.splatRenderTarget.depthTexture.format = THREE.DepthFormat;\n        this.splatRenderTarget.depthTexture.type = THREE.UnsignedIntType;\n    }\n\n    destroySplatRendertarget() {\n        if (this.splatRenderTarget) {\n            this.splatRenderTarget = null;\n        }\n    }\n\n    setupRenderTargetCopyObjects() {\n        const uniforms = {\n            'sourceColorTexture': {\n                'type': 't',\n                'value': null\n            },\n            'sourceDepthTexture': {\n                'type': 't',\n                'value': null\n            },\n        };\n        const renderTargetCopyMaterial = new THREE.ShaderMaterial({\n            vertexShader: `\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            `,\n            fragmentShader: `\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            `,\n            uniforms: uniforms,\n            depthWrite: false,\n            depthTest: false,\n            transparent: true,\n            blending: THREE.CustomBlending,\n            blendSrc: THREE.SrcAlphaFactor,\n            blendSrcAlpha: THREE.SrcAlphaFactor,\n            blendDst: THREE.OneMinusSrcAlphaFactor,\n            blendDstAlpha: THREE.OneMinusSrcAlphaFactor\n        });\n        renderTargetCopyMaterial.extensions.fragDepth = true;\n        this.renderTargetCopyQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), renderTargetCopyMaterial);\n        this.renderTargetCopyCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    }\n\n    destroyRenderTargetCopyObjects() {\n        if (this.renderTargetCopyQuad) {\n            disposeAllMeshes(this.renderTargetCopyQuad);\n            this.renderTargetCopyQuad = null;\n        }\n    }\n\n    setupMeshCursor() {\n        if (!this.meshCursor) {\n            const coneGeometry = new THREE.ConeGeometry(0.5, 1.5, 32);\n            const coneMaterial = new THREE.MeshBasicMaterial({color: 0xFFFFFF});\n\n            const downArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n            downArrow.rotation.set(0, 0, Math.PI);\n            downArrow.position.set(0, 1, 0);\n            const upArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n            upArrow.position.set(0, -1, 0);\n            const leftArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n            leftArrow.rotation.set(0, 0, Math.PI / 2.0);\n            leftArrow.position.set(1, 0, 0);\n            const rightArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n            rightArrow.rotation.set(0, 0, -Math.PI / 2.0);\n            rightArrow.position.set(-1, 0, 0);\n\n            this.meshCursor = new THREE.Object3D();\n            this.meshCursor.add(downArrow);\n            this.meshCursor.add(upArrow);\n            this.meshCursor.add(leftArrow);\n            this.meshCursor.add(rightArrow);\n            this.meshCursor.scale.set(0.1, 0.1, 0.1);\n            this.threeScene.add(this.meshCursor);\n            this.meshCursor.visible = false;\n        }\n    }\n\n    destroyMeshCursor() {\n        if (this.meshCursor) {\n            disposeAllMeshes(this.meshCursor);\n            this.threeScene.remove(this.meshCursor);\n            this.meshCursor = null;\n        }\n    }\n\n    setMeshCursorVisibility(visible) {\n        this.meshCursor.visible = visible;\n    }\n\n    getMeschCursorVisibility() {\n        return this.meshCursor.visible;\n    }\n\n    setMeshCursorPosition(position) {\n        this.meshCursor.position.copy(position);\n    }\n\n    positionAndOrientMeshCursor(position, camera) {\n        this.meshCursor.position.copy(position);\n        this.meshCursor.up.copy(camera.up);\n        this.meshCursor.lookAt(camera.position);\n    }\n\n    setupFocusMarker() {\n        if (!this.focusMarker) {\n            const sphereGeometry = new THREE.SphereGeometry(.5, 32, 32);\n            const focusMarkerMaterial = SceneHelper.buildFocusMarkerMaterial();\n            focusMarkerMaterial.depthTest = false;\n            focusMarkerMaterial.depthWrite = false;\n            focusMarkerMaterial.transparent = true;\n            this.focusMarker = new THREE.Mesh(sphereGeometry, focusMarkerMaterial);\n        }\n    }\n\n    destroyFocusMarker() {\n        if (this.focusMarker) {\n            disposeAllMeshes(this.focusMarker);\n            this.focusMarker = null;\n        }\n    }\n\n    updateFocusMarker = function() {\n\n        const tempPosition = new THREE.Vector3();\n        const tempMatrix = new THREE.Matrix4();\n        const toCamera = new THREE.Vector3();\n\n        return function(position, camera, viewport) {\n            tempMatrix.copy(camera.matrixWorld).invert();\n            tempPosition.copy(position).applyMatrix4(tempMatrix);\n            tempPosition.normalize().multiplyScalar(10);\n            tempPosition.applyMatrix4(camera.matrixWorld);\n            toCamera.copy(camera.position).sub(position);\n            const toCameraDistance = toCamera.length();\n            this.focusMarker.position.copy(position);\n            this.focusMarker.scale.set(toCameraDistance, toCameraDistance, toCameraDistance);\n            this.focusMarker.material.uniforms.realFocusPosition.value.copy(position);\n            this.focusMarker.material.uniforms.viewport.value.copy(viewport);\n            this.focusMarker.material.uniformsNeedUpdate = true;\n        };\n\n    }();\n\n    setFocusMarkerVisibility(visible) {\n        this.focusMarker.visible = visible;\n    }\n\n    setFocusMarkerOpacity(opacity) {\n        this.focusMarker.material.uniforms.opacity.value = opacity;\n        this.focusMarker.material.uniformsNeedUpdate = true;\n    }\n\n    getFocusMarkerOpacity() {\n        return this.focusMarker.material.uniforms.opacity.value;\n    }\n\n    setupControlPlane() {\n        if (!this.controlPlane) {\n            const planeGeometry = new THREE.PlaneGeometry(1, 1);\n            planeGeometry.rotateX(-Math.PI / 2);\n            const planeMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});\n            planeMaterial.transparent = true;\n            planeMaterial.opacity = 0.6;\n            planeMaterial.depthTest = false;\n            planeMaterial.depthWrite = false;\n            planeMaterial.side = THREE.DoubleSide;\n            const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);\n\n            const arrowDir = new THREE.Vector3(0, 1, 0);\n            arrowDir.normalize();\n            const arrowOrigin = new THREE.Vector3(0, 0, 0);\n            const arrowLength = 0.5;\n            const arrowRadius = 0.01;\n            const arrowColor = 0x00dd00;\n            const arrowHelper = new ArrowHelper(arrowDir, arrowOrigin, arrowLength, arrowRadius, arrowColor, 0.1, 0.03);\n\n            this.controlPlane = new THREE.Object3D();\n            this.controlPlane.add(planeMesh);\n            this.controlPlane.add(arrowHelper);\n        }\n    }\n\n    destroyControlPlane() {\n        if (this.controlPlane) {\n            disposeAllMeshes(this.controlPlane);\n            this.controlPlane = null;\n        }\n    }\n\n    setControlPlaneVisibility(visible) {\n        this.controlPlane.visible = visible;\n    }\n\n    positionAndOrientControlPlane = function() {\n\n        const tempQuaternion = new THREE.Quaternion();\n        const defaultUp = new THREE.Vector3(0, 1, 0);\n\n        return function(position, up) {\n            tempQuaternion.setFromUnitVectors(defaultUp, up);\n            this.controlPlane.position.copy(position);\n            this.controlPlane.quaternion.copy(tempQuaternion);\n        };\n\n    }();\n\n    addDebugMeshes() {\n        this.debugRoot = this.createDebugMeshes();\n        this.secondaryDebugRoot = this.createSecondaryDebugMeshes();\n        this.threeScene.add(this.debugRoot);\n        this.threeScene.add(this.secondaryDebugRoot);\n    }\n\n    destroyDebugMeshes() {\n        for (let debugRoot of [this.debugRoot, this.secondaryDebugRoot]) {\n            if (debugRoot) {\n                disposeAllMeshes(debugRoot);\n                this.threeScene.remove(debugRoot);\n            }\n        }\n        this.debugRoot = null;\n        this.secondaryDebugRoot = null;\n    }\n\n    createDebugMeshes(renderOrder) {\n        const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);\n        const debugMeshRoot = new THREE.Object3D();\n\n        const createMesh = (color, position) => {\n            let sphereMesh = new THREE.Mesh(sphereGeometry, SceneHelper.buildDebugMaterial(color));\n            sphereMesh.renderOrder = renderOrder;\n            debugMeshRoot.add(sphereMesh);\n            sphereMesh.position.fromArray(position);\n        };\n\n        createMesh(0xff0000, [-50, 0, 0]);\n        createMesh(0xff0000, [50, 0, 0]);\n        createMesh(0x00ff00, [0, 0, -50]);\n        createMesh(0x00ff00, [0, 0, 50]);\n        createMesh(0xffaa00, [5, 0, 5]);\n\n        return debugMeshRoot;\n    }\n\n    createSecondaryDebugMeshes(renderOrder) {\n        const boxGeometry = new THREE.BoxGeometry(3, 3, 3);\n        const debugMeshRoot = new THREE.Object3D();\n\n        let boxColor = 0xBBBBBB;\n        const createMesh = (position) => {\n            let boxMesh = new THREE.Mesh(boxGeometry, SceneHelper.buildDebugMaterial(boxColor));\n            boxMesh.renderOrder = renderOrder;\n            debugMeshRoot.add(boxMesh);\n            boxMesh.position.fromArray(position);\n        };\n\n        let separation = 10;\n        createMesh([-separation, 0, -separation]);\n        createMesh([-separation, 0, separation]);\n        createMesh([separation, 0, -separation]);\n        createMesh([separation, 0, separation]);\n\n        return debugMeshRoot;\n    }\n\n    static buildDebugMaterial(color) {\n        const vertexShaderSource = `\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        `;\n\n        const fragmentShaderSource = `\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        `;\n\n        const uniforms = {\n            'color': {\n                'type': 'v3',\n                'value': new THREE.Color(color)\n            },\n        };\n\n        const material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: vertexShaderSource,\n            fragmentShader: fragmentShaderSource,\n            transparent: false,\n            depthTest: true,\n            depthWrite: true,\n            side: THREE.FrontSide\n        });\n        material.extensions.fragDepth = true;\n\n        return material;\n    }\n\n    static buildFocusMarkerMaterial(color) {\n        const vertexShaderSource = `\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        `;\n\n        const fragmentShaderSource = `\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        `;\n\n        const uniforms = {\n            'color': {\n                'type': 'v3',\n                'value': new THREE.Color(color)\n            },\n            'realFocusPosition': {\n                'type': 'v3',\n                'value': new THREE.Vector3()\n            },\n            'viewport': {\n                'type': 'v2',\n                'value': new THREE.Vector2()\n            },\n            'opacity': {\n                'value': 0.0\n            }\n        };\n\n        const material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: vertexShaderSource,\n            fragmentShader: fragmentShaderSource,\n            transparent: true,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.FrontSide\n        });\n\n        return material;\n    }\n\n    dispose() {\n        this.destroyMeshCursor();\n        this.destroyFocusMarker();\n        this.destroyDebugMeshes();\n        this.destroyControlPlane();\n        this.destroyRenderTargetCopyObjects();\n        this.destroySplatRendertarget();\n    }\n}\n\nconst VectorRight = new THREE.Vector3(1, 0, 0);\nconst VectorUp = new THREE.Vector3(0, 1, 0);\nconst VectorBackward = new THREE.Vector3(0, 0, 1);\n\nclass Ray {\n\n    constructor(origin = new THREE.Vector3(), direction = new THREE.Vector3()) {\n        this.origin = new THREE.Vector3();\n        this.direction = new THREE.Vector3();\n        this.setParameters(origin, direction);\n    }\n\n    setParameters(origin, direction) {\n        this.origin.copy(origin);\n        this.direction.copy(direction).normalize();\n    }\n\n    boxContainsPoint(box, point, epsilon) {\n        return point.x < box.min.x - epsilon || point.x > box.max.x + epsilon ||\n               point.y < box.min.y - epsilon || point.y > box.max.y + epsilon ||\n               point.z < box.min.z - epsilon || point.z > box.max.z + epsilon ? false : true;\n    }\n\n    intersectBox = function() {\n\n        const planeIntersectionPoint = new THREE.Vector3();\n        const planeIntersectionPointArray = [];\n        const originArray = [];\n        const directionArray = [];\n\n        return function(box, outHit) {\n\n            originArray[0] = this.origin.x;\n            originArray[1] = this.origin.y;\n            originArray[2] = this.origin.z;\n            directionArray[0] = this.direction.x;\n            directionArray[1] = this.direction.y;\n            directionArray[2] = this.direction.z;\n\n            if (this.boxContainsPoint(box, this.origin, 0.0001)) {\n                if (outHit) {\n                    outHit.origin.copy(this.origin);\n                    outHit.normal.set(0, 0, 0);\n                    outHit.distance = -1;\n                }\n                return true;\n            }\n\n            for (let i = 0; i < 3; i++) {\n                if (directionArray[i] == 0.0) continue;\n\n                const hitNormal = i == 0 ? VectorRight : i == 1 ? VectorUp : VectorBackward;\n                const extremeVec = directionArray[i] < 0 ? box.max : box.min;\n                let multiplier = -Math.sign(directionArray[i]);\n                planeIntersectionPointArray[0] = i == 0 ? extremeVec.x : i == 1 ? extremeVec.y : extremeVec.z;\n                let toSide = planeIntersectionPointArray[0] - originArray[i];\n\n                if (toSide * multiplier < 0) {\n                    const idx1 = (i + 1) % 3;\n                    const idx2 = (i + 2) % 3;\n                    planeIntersectionPointArray[2] = directionArray[idx1] / directionArray[i] * toSide + originArray[idx1];\n                    planeIntersectionPointArray[1] = directionArray[idx2] / directionArray[i] * toSide + originArray[idx2];\n                    planeIntersectionPoint.set(planeIntersectionPointArray[i],\n                                               planeIntersectionPointArray[idx2],\n                                               planeIntersectionPointArray[idx1]);\n                    if (this.boxContainsPoint(box, planeIntersectionPoint, 0.0001)) {\n                        if (outHit) {\n                            outHit.origin.copy(planeIntersectionPoint);\n                            outHit.normal.copy(hitNormal).multiplyScalar(multiplier);\n                            outHit.distance = planeIntersectionPoint.sub(this.origin).length();\n                        }\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n    }();\n\n    intersectSphere = function() {\n\n        const toSphereCenterVec = new THREE.Vector3();\n\n        return function(center, radius, outHit) {\n            toSphereCenterVec.copy(center).sub(this.origin);\n            const toClosestApproach = toSphereCenterVec.dot(this.direction);\n            const toClosestApproachSq = toClosestApproach * toClosestApproach;\n            const toSphereCenterSq = toSphereCenterVec.dot(toSphereCenterVec);\n            const diffSq = toSphereCenterSq - toClosestApproachSq;\n            const radiusSq = radius * radius;\n\n            if (diffSq > radiusSq) return false;\n\n            const thc = Math.sqrt(radiusSq - diffSq);\n            const t0 = toClosestApproach - thc;\n            const t1 = toClosestApproach + thc;\n\n            if (t1 < 0) return false;\n            let t = t0 < 0 ? t1 : t0;\n\n            if (outHit) {\n                outHit.origin.copy(this.origin).addScaledVector(this.direction, t);\n                outHit.normal.copy(outHit.origin).sub(center).normalize();\n                outHit.distance = t;\n            }\n            return true;\n        };\n\n    }();\n}\n\nclass Hit {\n\n    constructor() {\n        this.origin = new THREE.Vector3();\n        this.normal = new THREE.Vector3();\n        this.distance = 0;\n        this.splatIndex = 0;\n    }\n\n    set(origin, normal, distance, splatIndex) {\n        this.origin.copy(origin);\n        this.normal.copy(normal);\n        this.distance = distance;\n        this.splatIndex = splatIndex;\n    }\n\n    clone() {\n        const hitClone = new Hit();\n        hitClone.origin.copy(this.origin);\n        hitClone.normal.copy(this.normal);\n        hitClone.distance = this.distance;\n        hitClone.splatIndex = this.splatIndex;\n        return hitClone;\n    }\n\n}\n\nconst SplatRenderMode = {\n    ThreeD: 0,\n    TwoD: 1\n};\n\nclass Raycaster {\n\n    constructor(origin, direction, raycastAgainstTrueSplatEllipsoid = false) {\n        this.ray = new Ray(origin, direction);\n        this.raycastAgainstTrueSplatEllipsoid = raycastAgainstTrueSplatEllipsoid;\n    }\n\n    setFromCameraAndScreenPosition = function() {\n\n        const ndcCoords = new THREE.Vector2();\n\n        return function(camera, screenPosition, screenDimensions) {\n            ndcCoords.x = screenPosition.x / screenDimensions.x * 2.0 - 1.0;\n            ndcCoords.y = (screenDimensions.y - screenPosition.y) / screenDimensions.y * 2.0 - 1.0;\n            if (camera.isPerspectiveCamera) {\n                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n                this.ray.direction.set(ndcCoords.x, ndcCoords.y, 0.5 ).unproject(camera).sub(this.ray.origin).normalize();\n                this.camera = camera;\n            } else if (camera.isOrthographicCamera) {\n                this.ray.origin.set(ndcCoords.x, ndcCoords.y,\n                                   (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);\n                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n                this.camera = camera;\n            } else {\n                throw new Error('Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type');\n            }\n        };\n\n    }();\n\n    intersectSplatMesh = function() {\n\n        const toLocal = new THREE.Matrix4();\n        const fromLocal = new THREE.Matrix4();\n        const sceneTransform = new THREE.Matrix4();\n        const localRay = new Ray();\n        const tempPoint = new THREE.Vector3();\n\n        return function(splatMesh, outHits = []) {\n            const splatTree = splatMesh.getSplatTree();\n\n            if (!splatTree) return;\n\n            for (let s = 0; s < splatTree.subTrees.length; s++) {\n                const subTree = splatTree.subTrees[s];\n\n                fromLocal.copy(splatMesh.matrixWorld);\n                if (splatMesh.dynamicMode) {\n                    splatMesh.getSceneTransform(s, sceneTransform);\n                    fromLocal.multiply(sceneTransform);\n                }\n                toLocal.copy(fromLocal).invert();\n\n                localRay.origin.copy(this.ray.origin).applyMatrix4(toLocal);\n                localRay.direction.copy(this.ray.origin).add(this.ray.direction);\n                localRay.direction.applyMatrix4(toLocal).sub(localRay.origin).normalize();\n\n                const outHitsForSubTree = [];\n                if (subTree.rootNode) {\n                    this.castRayAtSplatTreeNode(localRay, splatTree, subTree.rootNode, outHitsForSubTree);\n                }\n\n                outHitsForSubTree.forEach((hit) => {\n                    hit.origin.applyMatrix4(fromLocal);\n                    hit.normal.applyMatrix4(fromLocal).normalize();\n                    hit.distance = tempPoint.copy(hit.origin).sub(this.ray.origin).length();\n                });\n\n                outHits.push(...outHitsForSubTree);\n            }\n\n            outHits.sort((a, b) => {\n                if (a.distance > b.distance) return 1;\n                else return -1;\n            });\n\n            return outHits;\n        };\n\n    }();\n\n    castRayAtSplatTreeNode = function() {\n\n        const tempColor = new THREE.Vector4();\n        const tempCenter = new THREE.Vector3();\n        const tempScale = new THREE.Vector3();\n        const tempRotation = new THREE.Quaternion();\n        const tempHit = new Hit();\n        const scaleEpsilon = 0.0000001;\n\n        const origin = new THREE.Vector3(0, 0, 0);\n        const uniformScaleMatrix = new THREE.Matrix4();\n        const scaleMatrix = new THREE.Matrix4();\n        const rotationMatrix = new THREE.Matrix4();\n        const toSphereSpace = new THREE.Matrix4();\n        const fromSphereSpace = new THREE.Matrix4();\n        const tempRay = new Ray();\n\n        return function(ray, splatTree, node, outHits = []) {\n            if (!ray.intersectBox(node.boundingBox)) {\n                return;\n            }\n            if (node.data && node.data.indexes && node.data.indexes.length > 0) {\n                for (let i = 0; i < node.data.indexes.length; i++) {\n\n                    const splatGlobalIndex = node.data.indexes[i];\n                    const splatSceneIndex = splatTree.splatMesh.getSceneIndexForSplat(splatGlobalIndex);\n                    const splatScene = splatTree.splatMesh.getScene(splatSceneIndex);\n                    if (!splatScene.visible) continue;\n\n                    splatTree.splatMesh.getSplatColor(splatGlobalIndex, tempColor);\n                    splatTree.splatMesh.getSplatCenter(splatGlobalIndex, tempCenter);\n                    splatTree.splatMesh.getSplatScaleAndRotation(splatGlobalIndex, tempScale, tempRotation);\n\n                    if (tempScale.x <= scaleEpsilon || tempScale.y <= scaleEpsilon ||\n                        splatTree.splatMesh.splatRenderMode === SplatRenderMode.ThreeD && tempScale.z <= scaleEpsilon) {\n                        continue;\n                    }\n\n                    if (!this.raycastAgainstTrueSplatEllipsoid) {\n                        let radius = (tempScale.x + tempScale.y);\n                        let componentCount = 2;\n                        if (splatTree.splatMesh.splatRenderMode === SplatRenderMode.ThreeD) {\n                            radius += tempScale.z;\n                            componentCount = 3;\n                        }\n                        radius = radius / componentCount;\n                        if (ray.intersectSphere(tempCenter, radius, tempHit)) {\n                            const hitClone = tempHit.clone();\n                            hitClone.splatIndex = splatGlobalIndex;\n                            outHits.push(hitClone);\n                        }\n                    } else {\n                        scaleMatrix.makeScale(tempScale.x, tempScale.y, tempScale.z);\n                        rotationMatrix.makeRotationFromQuaternion(tempRotation);\n                        const uniformScale = Math.log10(tempColor.w) * 2.0;\n                        uniformScaleMatrix.makeScale(uniformScale, uniformScale, uniformScale);\n                        fromSphereSpace.copy(uniformScaleMatrix).multiply(rotationMatrix).multiply(scaleMatrix);\n                        toSphereSpace.copy(fromSphereSpace).invert();\n                        tempRay.origin.copy(ray.origin).sub(tempCenter).applyMatrix4(toSphereSpace);\n                        tempRay.direction.copy(ray.origin).add(ray.direction).sub(tempCenter);\n                        tempRay.direction.applyMatrix4(toSphereSpace).sub(tempRay.origin).normalize();\n                        if (tempRay.intersectSphere(origin, 1.0, tempHit)) {\n                            const hitClone = tempHit.clone();\n                            hitClone.splatIndex = splatGlobalIndex;\n                            hitClone.origin.applyMatrix4(fromSphereSpace).add(tempCenter);\n                            outHits.push(hitClone);\n                        }\n                    }\n                }\n             }\n            if (node.children && node.children.length > 0) {\n                for (let child of node.children) {\n                    this.castRayAtSplatTreeNode(ray, splatTree, child, outHits);\n                }\n            }\n            return outHits;\n        };\n\n    }();\n}\n\nclass SplatMaterial {\n\n    static buildVertexShaderBase(dynamicMode = false, enableOptionalEffects = false, maxSphericalHarmonicsDegree = 0, customVars = '') {\n        let vertexShaderSource = `\n        precision highp float;\n        #include <common>\n\n        attribute uint splatIndex;\n        uniform highp usampler2D centersColorsTexture;\n        uniform highp sampler2D sphericalHarmonicsTexture;\n        uniform highp sampler2D sphericalHarmonicsTextureR;\n        uniform highp sampler2D sphericalHarmonicsTextureG;\n        uniform highp sampler2D sphericalHarmonicsTextureB;\n\n        uniform highp usampler2D sceneIndexesTexture;\n        uniform vec2 sceneIndexesTextureSize;\n        uniform int sceneCount;\n    `;\n\n    if (enableOptionalEffects) {\n        vertexShaderSource += `\n            uniform float sceneOpacity[${Constants.MaxScenes}];\n            uniform int sceneVisibility[${Constants.MaxScenes}];\n        `;\n    }\n\n    if (dynamicMode) {\n        vertexShaderSource += `\n            uniform highp mat4 transforms[${Constants.MaxScenes}];\n        `;\n    }\n\n    vertexShaderSource += `\n        ${customVars}\n        uniform vec2 focal;\n        uniform float orthoZoom;\n        uniform int orthographicMode;\n        uniform int pointCloudModeEnabled;\n        uniform float inverseFocalAdjustment;\n        uniform vec2 viewport;\n        uniform vec2 basisViewport;\n        uniform vec2 centersColorsTextureSize;\n        uniform int sphericalHarmonicsDegree;\n        uniform vec2 sphericalHarmonicsTextureSize;\n        uniform int sphericalHarmonics8BitMode;\n        uniform int sphericalHarmonicsMultiTextureMode;\n        uniform float visibleRegionRadius;\n        uniform float visibleRegionFadeStartRadius;\n        uniform float firstRenderTime;\n        uniform float currentTime;\n        uniform int fadeInComplete;\n        uniform vec3 sceneCenter;\n        uniform float splatScale;\n        uniform float sphericalHarmonics8BitCompressionRangeMin[${Constants.MaxScenes}];\n        uniform float sphericalHarmonics8BitCompressionRangeMax[${Constants.MaxScenes}];\n\n        varying vec4 vColor;\n        varying vec2 vUv;\n        varying vec2 vPosition;\n\n        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {\n            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);\n        \n            return mat3(\n                1. - 2. * (y * y + z * z),\n                2. * (x * y + w * z),\n                2. * (x * z - w * y),\n                2. * (x * y - w * z),\n                1. - 2. * (x * x + z * z),\n                2. * (y * z + w * x),\n                2. * (x * z + w * y),\n                2. * (y * z - w * x),\n                1. - 2. * (x * x + y * y)\n            );\n        }\n\n        const float sqrt8 = sqrt(8.0);\n        const float minAlpha = 1.0 / 255.0;\n\n        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n        const uvec4 shift4 = uvec4(0, 8, 16, 24);\n        vec4 uintToRGBAVec (uint u) {\n           uvec4 urgba = mask4 & u;\n           urgba = urgba >> shift4;\n           vec4 rgba = vec4(urgba) * encodeNorm4;\n           return rgba;\n        }\n\n        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        const float SH_C1 = 0.4886025119029199f;\n        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);\n\n        void main () {\n\n            uint oddOffset = splatIndex & uint(0x00000001);\n            uint doubleOddOffset = oddOffset * uint(2);\n            bool isEven = oddOffset == uint(0);\n            uint nearestEvenIndex = splatIndex - oddOffset;\n            float fOddOffset = float(oddOffset);\n\n            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n\n            uint sceneIndex = uint(0);\n            if (sceneCount > 1) {\n                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;\n            }\n            `;\n\n        if (enableOptionalEffects) {\n            vertexShaderSource += `\n                float splatOpacityFromScene = sceneOpacity[sceneIndex];\n                int sceneVisible = sceneVisibility[sceneIndex];\n                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n            `;\n        }\n\n        if (dynamicMode) {\n            vertexShaderSource += `\n                mat4 transform = transforms[sceneIndex];\n                mat4 transformModelViewMatrix = viewMatrix * transform;\n            `;\n        } else {\n            vertexShaderSource += `mat4 transformModelViewMatrix = modelViewMatrix;`;\n        }\n\n        vertexShaderSource += `\n            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];\n            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];\n            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;\n            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;\n            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);\n\n            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);\n\n            vec4 clipCenter = projectionMatrix * viewCenter;\n\n            float clip = 1.2 * clipCenter.w;\n            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                return;\n            }\n\n            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n            vPosition = position.xy;\n            vColor = uintToRGBAVec(sampledCenterColor.r);\n        `;\n\n        // Proceed to sampling and rendering 1st degree spherical harmonics\n        if (maxSphericalHarmonicsDegree >= 1) {\n\n            vertexShaderSource += `   \n            if (sphericalHarmonicsDegree >= 1) {\n            `;\n\n            if (dynamicMode) {\n                vertexShaderSource += `\n                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));\n                `;\n            } else {\n                vertexShaderSource += `\n                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);\n                `;\n            }\n\n            vertexShaderSource += `\n                vec3 sh1;\n                vec3 sh2;\n                vec3 sh3;\n            `;\n\n            if (maxSphericalHarmonicsDegree >= 2) {\n                vertexShaderSource += `\n                    vec3 sh4;\n                    vec3 sh5;\n                    vec3 sh6;\n                    vec3 sh7;\n                    vec3 sh8;\n                `;\n            }\n\n            // Determining how to sample spherical harmonics textures to get the coefficients for calculations for a given degree\n            // depends on how many total degrees (maxSphericalHarmonicsDegree) are present in the textures. This is because that\n            // number affects how they are packed in the textures, and therefore the offset & stride required to access them.\n\n            // Sample spherical harmonics textures with 1 degree worth of data for 1st degree calculations, and store in sh1, sh2, and sh3\n            if (maxSphericalHarmonicsDegree === 1) {\n                vertexShaderSource += `\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);\n                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);\n                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;\n                    } else {\n                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);\n                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);\n                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);\n                    }\n                `;\n            // Sample spherical harmonics textures with 2 degrees worth of data for 1st degree calculations, and store in sh1, sh2, and sh3\n            } else if (maxSphericalHarmonicsDegree === 2) {\n                vertexShaderSource += `\n                    vec4 sampledSH0123;\n                    vec4 sampledSH4567;\n                    vec4 sampledSH891011;\n\n                    vec4 sampledSH0123R;\n                    vec4 sampledSH0123G;\n                    vec4 sampledSH0123B;\n\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));\n                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));\n                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));\n                        sh1 = sampledSH0123.rgb;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);\n                    } else {\n                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sh1 = vec3(sampledSH0123R.rgb);\n                        sh2 = vec3(sampledSH0123G.rgb);\n                        sh3 = vec3(sampledSH0123B.rgb);\n                    }\n                `;\n            }\n\n            // Perform 1st degree spherical harmonics calculations\n            vertexShaderSource += `\n                    if (sphericalHarmonics8BitMode == 1) {\n                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                    }\n                    float x = worldViewDir.x;\n                    float y = worldViewDir.y;\n                    float z = worldViewDir.z;\n                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);\n            `;\n\n            // Proceed to sampling and rendering 2nd degree spherical harmonics\n            if (maxSphericalHarmonicsDegree >= 2) {\n\n                vertexShaderSource += `\n                    if (sphericalHarmonicsDegree >= 2) {\n                        float xx = x * x;\n                        float yy = y * y;\n                        float zz = z * z;\n                        float xy = x * y;\n                        float yz = y * z;\n                        float xz = x * z;\n                `;\n\n                // Sample spherical harmonics textures with 2 degrees worth of data for 2nd degree calculations,\n                // and store in sh4, sh5, sh6, sh7, and sh8\n                if (maxSphericalHarmonicsDegree === 2) {\n                    vertexShaderSource += `\n                        if (sphericalHarmonicsMultiTextureMode == 0) {\n                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));\n                            sh4 = sampledSH891011.gba;\n                            sh5 = sampledSH12131415.rgb;\n                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);\n                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);\n                            sh8 = sampledSH20212223.gba;\n                        } else {\n                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);\n                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);\n                            sh6 = vec3(sampledSH4567G.rgb);\n                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);\n                            sh8 = vec3(sampledSH4567B.gba);\n                        }\n                    `;\n                }\n\n                // Perform 2nd degree spherical harmonics calculations\n                vertexShaderSource += `\n                        if (sphericalHarmonics8BitMode == 1) {\n                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        }\n\n                        vColor.rgb +=\n                            (SH_C2[0] * xy) * sh4 +\n                            (SH_C2[1] * yz) * sh5 +\n                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +\n                            (SH_C2[3] * xz) * sh7 +\n                            (SH_C2[4] * (xx - yy)) * sh8;\n                    }\n                `;\n            }\n\n            vertexShaderSource += `\n\n                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));\n\n            }\n\n            `;\n        }\n\n        return vertexShaderSource;\n    }\n\n    static getVertexShaderFadeIn() {\n        return `\n            if (fadeInComplete == 0) {\n                float opacityAdjust = 1.0;\n                float centerDist = length(splatCenter - sceneCenter);\n                float renderTime = max(currentTime - firstRenderTime, 0.0);\n\n                float fadeDistance = 0.75;\n                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);\n                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +\n                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *\n                                        distanceLoadFadeInFactor;\n                opacityAdjust *= distanceLoadFadeInFactor;\n                vColor.a *= opacityAdjust;\n            }\n        `;\n    }\n\n    static getUniforms(dynamicMode = false, enableOptionalEffects = false, maxSphericalHarmonicsDegree = 0,\n                       splatScale = 1.0, pointCloudModeEnabled = false) {\n\n        const uniforms = {\n            'sceneCenter': {\n                'type': 'v3',\n                'value': new THREE.Vector3()\n            },\n            'fadeInComplete': {\n                'type': 'i',\n                'value': 0\n            },\n            'orthographicMode': {\n                'type': 'i',\n                'value': 0\n            },\n            'visibleRegionFadeStartRadius': {\n                'type': 'f',\n                'value': 0.0\n            },\n            'visibleRegionRadius': {\n                'type': 'f',\n                'value': 0.0\n            },\n            'currentTime': {\n                'type': 'f',\n                'value': 0.0\n            },\n            'firstRenderTime': {\n                'type': 'f',\n                'value': 0.0\n            },\n            'centersColorsTexture': {\n                'type': 't',\n                'value': null\n            },\n            'sphericalHarmonicsTexture': {\n                'type': 't',\n                'value': null\n            },\n            'sphericalHarmonicsTextureR': {\n                'type': 't',\n                'value': null\n            },\n            'sphericalHarmonicsTextureG': {\n                'type': 't',\n                'value': null\n            },\n            'sphericalHarmonicsTextureB': {\n                'type': 't',\n                'value': null\n            },\n            'sphericalHarmonics8BitCompressionRangeMin': {\n                'type': 'f',\n                'value': []\n            },\n            'sphericalHarmonics8BitCompressionRangeMax': {\n                'type': 'f',\n                'value': []\n            },\n            'focal': {\n                'type': 'v2',\n                'value': new THREE.Vector2()\n            },\n            'orthoZoom': {\n                'type': 'f',\n                'value': 1.0\n            },\n            'inverseFocalAdjustment': {\n                'type': 'f',\n                'value': 1.0\n            },\n            'viewport': {\n                'type': 'v2',\n                'value': new THREE.Vector2()\n            },\n            'basisViewport': {\n                'type': 'v2',\n                'value': new THREE.Vector2()\n            },\n            'debugColor': {\n                'type': 'v3',\n                'value': new THREE.Color()\n            },\n            'centersColorsTextureSize': {\n                'type': 'v2',\n                'value': new THREE.Vector2(1024, 1024)\n            },\n            'sphericalHarmonicsDegree': {\n                'type': 'i',\n                'value': maxSphericalHarmonicsDegree\n            },\n            'sphericalHarmonicsTextureSize': {\n                'type': 'v2',\n                'value': new THREE.Vector2(1024, 1024)\n            },\n            'sphericalHarmonics8BitMode': {\n                'type': 'i',\n                'value': 0\n            },\n            'sphericalHarmonicsMultiTextureMode': {\n                'type': 'i',\n                'value': 0\n            },\n            'splatScale': {\n                'type': 'f',\n                'value': splatScale\n            },\n            'pointCloudModeEnabled': {\n                'type': 'i',\n                'value': pointCloudModeEnabled ? 1 : 0\n            },\n            'sceneIndexesTexture': {\n                'type': 't',\n                'value': null\n            },\n            'sceneIndexesTextureSize': {\n                'type': 'v2',\n                'value': new THREE.Vector2(1024, 1024)\n            },\n            'sceneCount': {\n                'type': 'i',\n                'value': 1\n            }\n        };\n        for (let i = 0; i < Constants.MaxScenes; i++) {\n            uniforms.sphericalHarmonics8BitCompressionRangeMin.value.push(-Constants.SphericalHarmonics8BitCompressionRange / 2.0);\n            uniforms.sphericalHarmonics8BitCompressionRangeMax.value.push(Constants.SphericalHarmonics8BitCompressionRange / 2.0);\n        }\n\n        if (enableOptionalEffects) {\n            const sceneOpacity = [];\n            for (let i = 0; i < Constants.MaxScenes; i++) {\n                sceneOpacity.push(1.0);\n            }\n            uniforms['sceneOpacity'] ={\n                'type': 'f',\n                'value': sceneOpacity\n            };\n\n            const sceneVisibility = [];\n            for (let i = 0; i < Constants.MaxScenes; i++) {\n                sceneVisibility.push(1);\n            }\n            uniforms['sceneVisibility'] ={\n                'type': 'i',\n                'value': sceneVisibility\n            };\n        }\n\n        if (dynamicMode) {\n            const transformMatrices = [];\n            for (let i = 0; i < Constants.MaxScenes; i++) {\n                transformMatrices.push(new THREE.Matrix4());\n            }\n            uniforms['transforms'] = {\n                'type': 'mat4',\n                'value': transformMatrices\n            };\n        }\n\n        return uniforms;\n    }\n\n}\n\nclass SplatMaterial3D {\n\n    /**\n     * Build the Three.js material that is used to render the splats.\n     * @param {number} dynamicMode If true, it means the scene geometry represented by this splat mesh is not stationary or\n     *                             that the splat count might change\n     * @param {boolean} enableOptionalEffects When true, allows for usage of extra properties and attributes in the shader for effects\n     *                                        such as opacity adjustment. Default is false for performance reasons.\n     * @param {boolean} antialiased If true, calculate compensation factor to deal with gaussians being rendered at a significantly\n     *                              different resolution than that of their training\n     * @param {number} maxScreenSpaceSplatSize The maximum clip space splat size\n     * @param {number} splatScale Value by which all splats are scaled in screen-space (default is 1.0)\n     * @param {number} pointCloudModeEnabled Render all splats as screen-space circles\n     * @param {number} maxSphericalHarmonicsDegree Degree of spherical harmonics to utilize in rendering splats\n     * @return {THREE.ShaderMaterial}\n     */\n    static build(dynamicMode = false, enableOptionalEffects = false, antialiased = false, maxScreenSpaceSplatSize = 2048,\n                 splatScale = 1.0, pointCloudModeEnabled = false, maxSphericalHarmonicsDegree = 0, kernel2DSize = 0.3) {\n\n        const customVertexVars = `\n            uniform vec2 covariancesTextureSize;\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D covariancesTextureHalfFloat;\n            uniform int covariancesAreHalfFloat;\n\n            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {\n                vec2 r = unpackHalf2x16(val.r);\n                vec2 g = unpackHalf2x16(val.g);\n                vec2 b = unpackHalf2x16(val.b);\n\n                first = vec4(r.x, r.y, g.x, g.y);\n                second = vec4(b.x, b.y, 0.0, 0.0);\n            }\n        `;\n\n        let vertexShaderSource = SplatMaterial.buildVertexShaderBase(dynamicMode, enableOptionalEffects,\n                                                                     maxSphericalHarmonicsDegree, customVertexVars);\n        vertexShaderSource += SplatMaterial3D.buildVertexShaderProjection(antialiased, enableOptionalEffects,\n                                                                          maxScreenSpaceSplatSize, kernel2DSize);\n        const fragmentShaderSource = SplatMaterial3D.buildFragmentShader();\n\n        const uniforms = SplatMaterial.getUniforms(dynamicMode, enableOptionalEffects,\n                                                   maxSphericalHarmonicsDegree, splatScale, pointCloudModeEnabled);\n\n        uniforms['covariancesTextureSize'] = {\n            'type': 'v2',\n            'value': new THREE.Vector2(1024, 1024)\n        };\n        uniforms['covariancesTexture'] = {\n            'type': 't',\n            'value': null\n        };\n        uniforms['covariancesTextureHalfFloat'] = {\n            'type': 't',\n            'value': null\n        };\n        uniforms['covariancesAreHalfFloat'] = {\n            'type': 'i',\n            'value': 0\n        };\n\n        const material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: vertexShaderSource,\n            fragmentShader: fragmentShaderSource,\n            transparent: true,\n            alphaTest: 1.0,\n            blending: THREE.NormalBlending,\n            depthTest: true,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n\n        return material;\n    }\n\n    static buildVertexShaderProjection(antialiased, enableOptionalEffects, maxScreenSpaceSplatSize, kernel2DSize) {\n        let vertexShaderSource = `\n\n            vec4 sampledCovarianceA;\n            vec4 sampledCovarianceB;\n            vec3 cov3D_M11_M12_M13;\n            vec3 cov3D_M22_M23_M33;\n            if (covariancesAreHalfFloat == 0) {\n                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,\n                                                                            covariancesTextureSize));\n                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),\n                                                                            covariancesTextureSize));\n\n                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceB.gba) * fOddOffset;\n            } else {\n                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));\n                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);\n                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);\n            }\n        \n            // Construct the 3D covariance matrix\n            mat3 Vrk = mat3(\n                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n            );\n\n            mat3 J;\n            if (orthographicMode == 1) {\n                // Since the projection is linear, we don't need an approximation\n                J = transpose(mat3(orthoZoom, 0.0, 0.0,\n                                0.0, orthoZoom, 0.0,\n                                0.0, 0.0, 0.0));\n            } else {\n                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the\n                // 3D covariance matrix instead of using the actual projection matrix because that transformation would\n                // require a non-linear component (perspective division) which would yield a non-gaussian result.\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n            }\n\n            // Concatenate the projection approximation with the model-view transformation\n            mat3 W = transpose(mat3(transformModelViewMatrix));\n            mat3 T = W * J;\n\n            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix\n            mat3 cov2Dm = transpose(T) * Vrk * T;\n            `;\n\n        if (antialiased) {\n            vertexShaderSource += `\n                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                cov2Dm[0][0] += ${kernel2DSize};\n                cov2Dm[1][1] += ${kernel2DSize};\n                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));\n                if (vColor.a < minAlpha) return;\n            `;\n        } else {\n            vertexShaderSource += `\n                cov2Dm[0][0] += ${kernel2DSize};\n                cov2Dm[1][1] += ${kernel2DSize};\n            `;\n        }\n\n        vertexShaderSource += `\n\n            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n            // need cov2Dm[1][0] because it is a symetric matrix.\n            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n            // so that we can determine the 2D basis for the splat. This is done using the method described\n            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat\n            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is\n            // equal to scaling them by sqrt(8) standard deviations.\n            //\n            // This is a different approach than in the original work at INRIA. In that work they compute the\n            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle\n            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0\n            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse\n            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by\n            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity\n            float a = cov2Dv.x;\n            float d = cov2Dv.z;\n            float b = cov2Dv.y;\n            float D = a * d - b * b;\n            float trace = a + d;\n            float traceOver2 = 0.5 * trace;\n            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\n            float eigenValue1 = traceOver2 + term2;\n            float eigenValue2 = traceOver2 - term2;\n\n            if (pointCloudModeEnabled == 1) {\n                eigenValue1 = eigenValue2 = 0.2;\n            }\n\n            if (eigenValue2 <= 0.0) return;\n\n            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n            // since the eigen vectors are orthogonal, we derive the second one from the first\n            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n\n            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\n            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(maxScreenSpaceSplatSize)}.0);\n            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(maxScreenSpaceSplatSize)}.0);\n            `;\n\n        if (enableOptionalEffects) {\n            vertexShaderSource += `\n                vColor.a *= splatOpacityFromScene;\n            `;\n        }\n\n        vertexShaderSource += `\n            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *\n                             basisViewport * 2.0 * inverseFocalAdjustment;\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            gl_Position = quadPos;\n\n            // Scale the position data we send to the fragment shader\n            vPosition *= sqrt8;\n        `;\n\n        vertexShaderSource += SplatMaterial.getVertexShaderFadeIn();\n        vertexShaderSource += `}`;\n\n        return vertexShaderSource;\n    }\n\n    static buildFragmentShader() {\n        let fragmentShaderSource = `\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n        `;\n\n        fragmentShaderSource += `\n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n                if (A > 8.0) discard;\n                vec3 color = vColor.rgb;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp(-0.5 * A) * vColor.a;\n\n                gl_FragColor = vec4(color.rgb, opacity);\n            }\n        `;\n\n        return fragmentShaderSource;\n    }\n\n}\n\nclass SplatMaterial2D {\n\n    /**\n     * Build the Three.js material that is used to render the splats.\n     * @param {number} dynamicMode If true, it means the scene geometry represented by this splat mesh is not stationary or\n     *                             that the splat count might change\n     * @param {boolean} enableOptionalEffects When true, allows for usage of extra properties and attributes in the shader for effects\n     *                                        such as opacity adjustment. Default is false for performance reasons.\n     * @param {number} splatScale Value by which all splats are scaled in screen-space (default is 1.0)\n     * @param {number} pointCloudModeEnabled Render all splats as screen-space circles\n     * @param {number} maxSphericalHarmonicsDegree Degree of spherical harmonics to utilize in rendering splats\n     * @return {THREE.ShaderMaterial}\n     */\n    static build(dynamicMode = false, enableOptionalEffects = false, splatScale = 1.0,\n                 pointCloudModeEnabled = false, maxSphericalHarmonicsDegree = 0) {\n\n        const customVertexVars = `\n            uniform vec2 scaleRotationsTextureSize;\n            uniform highp sampler2D scaleRotationsTexture;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n        `;\n\n        let vertexShaderSource = SplatMaterial.buildVertexShaderBase(dynamicMode, enableOptionalEffects,\n                                                                     maxSphericalHarmonicsDegree, customVertexVars);\n        vertexShaderSource += SplatMaterial2D.buildVertexShaderProjection();\n        const fragmentShaderSource = SplatMaterial2D.buildFragmentShader();\n\n        const uniforms = SplatMaterial.getUniforms(dynamicMode, enableOptionalEffects,\n                                                   maxSphericalHarmonicsDegree, splatScale, pointCloudModeEnabled);\n\n        uniforms['scaleRotationsTexture'] = {\n            'type': 't',\n            'value': null\n        };\n        uniforms['scaleRotationsTextureSize'] = {\n            'type': 'v2',\n            'value': new THREE.Vector2(1024, 1024)\n        };\n\n        const material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: vertexShaderSource,\n            fragmentShader: fragmentShaderSource,\n            transparent: true,\n            alphaTest: 1.0,\n            blending: THREE.NormalBlending,\n            depthTest: true,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n\n        return material;\n    }\n\n    static buildVertexShaderProjection() {\n\n        // Original CUDA code for calculating splat-to-screen transformation, for reference\n        /*\n            glm::mat3 R = quat_to_rotmat(rot);\n            glm::mat3 S = scale_to_mat(scale, mod);\n            glm::mat3 L = R * S;\n\n            // center of Gaussians in the camera coordinate\n            glm::mat3x4 splat2world = glm::mat3x4(\n                glm::vec4(L[0], 0.0),\n                glm::vec4(L[1], 0.0),\n                glm::vec4(p_orig.x, p_orig.y, p_orig.z, 1)\n            );\n\n            glm::mat4 world2ndc = glm::mat4(\n                projmatrix[0], projmatrix[4], projmatrix[8], projmatrix[12],\n                projmatrix[1], projmatrix[5], projmatrix[9], projmatrix[13],\n                projmatrix[2], projmatrix[6], projmatrix[10], projmatrix[14],\n                projmatrix[3], projmatrix[7], projmatrix[11], projmatrix[15]\n            );\n\n            glm::mat3x4 ndc2pix = glm::mat3x4(\n                glm::vec4(float(W) / 2.0, 0.0, 0.0, float(W-1) / 2.0),\n                glm::vec4(0.0, float(H) / 2.0, 0.0, float(H-1) / 2.0),\n                glm::vec4(0.0, 0.0, 0.0, 1.0)\n            );\n\n            T = glm::transpose(splat2world) * world2ndc * ndc2pix;\n            normal = transformVec4x3({L[2].x, L[2].y, L[2].z}, viewmatrix);\n        */\n\n        // Compute a 2D-to-2D mapping matrix from a tangent plane into a image plane\n        // given a 2D gaussian parameters. T = WH (from the paper: https://arxiv.org/pdf/2403.17888)\n        let vertexShaderSource = `\n\n            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset, scaleRotationsTextureSize));\n            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset + uint(1), scaleRotationsTextureSize));\n\n            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;\n            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationB.gba) * fOddOffset;\n\n            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *\n                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);\n            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);\n            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,\n                            0.0, scaleRotation123.g, 0.0,\n                            0.0, 0.0, scaleRotation123.b);\n            \n            mat3 L = R * S;\n\n            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);\n\n            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),\n                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),\n                                    vec4(0.0, 0.0, 0.0, 1.0));\n\n            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;\n            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));\n        `;\n\n        // Original CUDA code for projection to 2D, for reference\n        /*\n            float3 T0 = {T[0][0], T[0][1], T[0][2]};\n            float3 T1 = {T[1][0], T[1][1], T[1][2]};\n            float3 T3 = {T[2][0], T[2][1], T[2][2]};\n\n            // Compute AABB\n            float3 temp_point = {1.0f, 1.0f, -1.0f};\n            float distance = sumf3(T3 * T3 * temp_point);\n            float3 f = (1 / distance) * temp_point;\n            if (distance == 0.0) return false;\n\n            point_image = {\n                sumf3(f * T0 * T3),\n                sumf3(f * T1 * T3)\n            };\n\n            float2 temp = {\n                sumf3(f * T0 * T0),\n                sumf3(f * T1 * T1)\n            };\n            float2 half_extend = point_image * point_image - temp;\n            extent = sqrtf2(maxf2(1e-4, half_extend));\n            return true;\n        */\n\n        // Computing the bounding box of the 2D Gaussian and its center\n        // The center of the bounding box is used to create a low pass filter.\n        // This code is based off the reference implementation and creates an AABB aligned\n        // with the screen for the quad to be rendered.\n        const referenceQuadGeneration = `\n            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);\n            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);\n            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);\n\n            vec3 tempPoint = vec3(1.0, 1.0, -1.0);\n            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);\n            vec3 f = (1.0 / distance) * tempPoint;\n            if (abs(distance) < 0.00001) return;\n\n            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);\n            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);\n            vec2 pointImage = vec2(pointImageX, pointImageY);\n\n            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);\n            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);\n            vec2 temp = vec2(tempX, tempY);\n\n            vec2 halfExtend = pointImage * pointImage - temp;\n            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));\n            float radius = max(extent.x, extent.y);\n\n            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            gl_Position = quadPos;\n\n            vT = T;\n            vQuadCenter = pointImage;\n            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n        `;\n\n        const useRefImplementation = false;\n        if (useRefImplementation) {\n            vertexShaderSource += referenceQuadGeneration;\n        } else {\n            // Create a quad that is aligned with the eigen vectors of the projected gaussian for rendering.\n            // This is a different approach than the reference implementation, similar to how the rendering of\n            // 3D gaussians in this viewer differs from the reference implementation. If the quad is too small\n            // (smaller than a pixel), then revert to the reference implementation.\n            vertexShaderSource += `\n\n                mat4 splat2World4 = mat4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(L[2], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);\n\n                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);\n                tempPoint1 /= tempPoint1.w;\n\n                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);\n                tempPoint2 /= tempPoint2.w;\n\n                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);\n                center /= center.w;\n\n                vec2 basisVector1 = tempPoint1.xy - center.xy;\n                vec2 basisVector2 = tempPoint2.xy - center.xy;\n\n                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;\n                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;\n\n                const float minPix = 1.;\n                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {\n                    ${referenceQuadGeneration}\n                } else {\n                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;\n                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n                    gl_Position = quadPos;\n\n                    vT = T;\n                    vQuadCenter = center.xy;\n                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n                }\n            `;\n        }\n\n        vertexShaderSource += SplatMaterial.getVertexShaderFadeIn();\n        vertexShaderSource += `}`;\n\n        return vertexShaderSource;\n    }\n\n    static buildFragmentShader() {\n\n        // Original CUDA code for splat intersection, for reference\n        /*\n            const float2 xy = collected_xy[j];\n            const float3 Tu = collected_Tu[j];\n            const float3 Tv = collected_Tv[j];\n            const float3 Tw = collected_Tw[j];\n            float3 k = pix.x * Tw - Tu;\n            float3 l = pix.y * Tw - Tv;\n            float3 p = cross(k, l);\n            if (p.z == 0.0) continue;\n            float2 s = {p.x / p.z, p.y / p.z};\n            float rho3d = (s.x * s.x + s.y * s.y);\n            float2 d = {xy.x - pixf.x, xy.y - pixf.y};\n            float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y);\n\n            // compute intersection and depth\n            float rho = min(rho3d, rho2d);\n            float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z;\n            if (depth < near_n) continue;\n            float4 nor_o = collected_normal_opacity[j];\n            float normal[3] = {nor_o.x, nor_o.y, nor_o.z};\n            float opa = nor_o.w;\n\n            float power = -0.5f * rho;\n            if (power > 0.0f)\n                continue;\n\n            // Eq. (2) from 3D Gaussian splatting paper.\n            // Obtain alpha by multiplying with Gaussian opacity\n            // and its exponential falloff from mean.\n            // Avoid numerical instabilities (see paper appendix).\n            float alpha = min(0.99f, opa * exp(power));\n            if (alpha < 1.0f / 255.0f)\n                continue;\n            float test_T = T * (1 - alpha);\n            if (test_T < 0.0001f)\n            {\n                done = true;\n                continue;\n            }\n\n            float w = alpha * T;\n        */\n        let fragmentShaderSource = `\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n\n            void main () {\n\n                const float FilterInvSquare = 2.0;\n                const float near_n = 0.2;\n                const float T = 1.0;\n\n                vec2 xy = vQuadCenter;\n                vec3 Tu = vT[0];\n                vec3 Tv = vT[1];\n                vec3 Tw = vT[2];\n                vec3 k = vFragCoord.x * Tw - Tu;\n                vec3 l = vFragCoord.y * Tw - Tv;\n                vec3 p = cross(k, l);\n                if (p.z == 0.0) discard;\n                vec2 s = vec2(p.x / p.z, p.y / p.z);\n                float rho3d = (s.x * s.x + s.y * s.y); \n                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);\n                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); \n\n                // compute intersection and depth\n                float rho = min(rho3d, rho2d);\n                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; \n                if (depth < near_n) discard;\n                //  vec4 nor_o = collected_normal_opacity[j];\n                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};\n                float opa = vColor.a;\n\n                float power = -0.5f * rho;\n                if (power > 0.0f) discard;\n\n                // Eq. (2) from 3D Gaussian splatting paper.\n                // Obtain alpha by multiplying with Gaussian opacity\n                // and its exponential falloff from mean.\n                // Avoid numerical instabilities (see paper appendix). \n                float alpha = min(0.99f, opa * exp(power));\n                if (alpha < 1.0f / 255.0f) discard;\n                float test_T = T * (1.0 - alpha);\n                if (test_T < 0.0001)discard;\n\n                float w = alpha * T;\n                gl_FragColor = vec4(vColor.rgb, w);\n            }\n        `;\n\n        return fragmentShaderSource;\n    }\n}\n\nclass SplatGeometry {\n\n    /**\n     * Build the Three.js geometry that will be used to render the splats. The geometry is instanced and is made up of\n     * vertices for a single quad as well as an attribute buffer for the splat indexes.\n     * @param {number} maxSplatCount The maximum number of splats that the geometry will need to accomodate\n     * @return {THREE.InstancedBufferGeometry}\n     */\n    static build(maxSplatCount) {\n\n        const baseGeometry = new THREE.BufferGeometry();\n        baseGeometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n        // Vertices for the instanced quad\n        const positionsArray = new Float32Array(4 * 3);\n        const positions = new THREE.BufferAttribute(positionsArray, 3);\n        baseGeometry.setAttribute('position', positions);\n        positions.setXYZ(0, -1.0, -1.0, 0.0);\n        positions.setXYZ(1, -1.0, 1.0, 0.0);\n        positions.setXYZ(2, 1.0, 1.0, 0.0);\n        positions.setXYZ(3, 1.0, -1.0, 0.0);\n        positions.needsUpdate = true;\n\n        const geometry = new THREE.InstancedBufferGeometry().copy(baseGeometry);\n\n        // Splat index buffer\n        const splatIndexArray = new Uint32Array(maxSplatCount);\n        const splatIndexes = new THREE.InstancedBufferAttribute(splatIndexArray, 1, false);\n        splatIndexes.setUsage(THREE.DynamicDrawUsage);\n        geometry.setAttribute('splatIndex', splatIndexes);\n\n        geometry.instanceCount = 0;\n\n        return geometry;\n    }\n}\n\n/**\n * SplatScene: Descriptor for a single splat scene managed by an instance of SplatMesh.\n */\nclass SplatScene extends THREE.Object3D {\n\n    constructor(splatBuffer, position = new THREE.Vector3(), quaternion = new THREE.Quaternion(),\n                scale = new THREE.Vector3(1, 1, 1), minimumAlpha = 1, opacity = 1.0, visible = true) {\n        super();\n        this.splatBuffer = splatBuffer;\n        this.position.copy(position);\n        this.quaternion.copy(quaternion);\n        this.scale.copy(scale);\n        this.transform = new THREE.Matrix4();\n        this.minimumAlpha = minimumAlpha;\n        this.opacity = opacity;\n        this.visible = visible;\n    }\n\n    copyTransformData(otherScene) {\n        this.position.copy(otherScene.position);\n        this.quaternion.copy(otherScene.quaternion);\n        this.scale.copy(otherScene.scale);\n        this.transform.copy(otherScene.transform);\n    }\n\n    updateTransform(dynamicMode) {\n        if (dynamicMode) {\n            if (this.matrixWorldAutoUpdate) this.updateWorldMatrix(true, false);\n            this.transform.copy(this.matrixWorld);\n        } else {\n            if (this.matrixAutoUpdate) this.updateMatrix();\n            this.transform.copy(this.matrix);\n        }\n    }\n}\n\nclass SplatTreeNode {\n\n    static idGen = 0;\n\n    constructor(min, max, depth, id) {\n        this.min = new THREE.Vector3().copy(min);\n        this.max = new THREE.Vector3().copy(max);\n        this.boundingBox = new THREE.Box3(this.min, this.max);\n        this.center = new THREE.Vector3().copy(this.max).sub(this.min).multiplyScalar(0.5).add(this.min);\n        this.depth = depth;\n        this.children = [];\n        this.data = null;\n        this.id = id || SplatTreeNode.idGen++;\n    }\n\n}\n\nclass SplatSubTree {\n\n    constructor(maxDepth, maxCentersPerNode) {\n        this.maxDepth = maxDepth;\n        this.maxCentersPerNode = maxCentersPerNode;\n        this.sceneDimensions = new THREE.Vector3();\n        this.sceneMin = new THREE.Vector3();\n        this.sceneMax = new THREE.Vector3();\n        this.rootNode = null;\n        this.nodesWithIndexes = [];\n        this.splatMesh = null;\n    }\n\n    static convertWorkerSubTreeNode(workerSubTreeNode) {\n        const minVector = new THREE.Vector3().fromArray(workerSubTreeNode.min);\n        const maxVector = new THREE.Vector3().fromArray(workerSubTreeNode.max);\n        const convertedNode = new SplatTreeNode(minVector, maxVector, workerSubTreeNode.depth, workerSubTreeNode.id);\n        if (workerSubTreeNode.data.indexes) {\n            convertedNode.data = {\n                'indexes': []\n            };\n            for (let index of workerSubTreeNode.data.indexes) {\n                convertedNode.data.indexes.push(index);\n            }\n        }\n        if (workerSubTreeNode.children) {\n            for (let child of workerSubTreeNode.children) {\n                convertedNode.children.push(SplatSubTree.convertWorkerSubTreeNode(child));\n            }\n        }\n        return convertedNode;\n    }\n\n    static convertWorkerSubTree(workerSubTree, splatMesh) {\n        const convertedSubTree = new SplatSubTree(workerSubTree.maxDepth, workerSubTree.maxCentersPerNode);\n        convertedSubTree.sceneMin = new THREE.Vector3().fromArray(workerSubTree.sceneMin);\n        convertedSubTree.sceneMax = new THREE.Vector3().fromArray(workerSubTree.sceneMax);\n\n        convertedSubTree.splatMesh = splatMesh;\n        convertedSubTree.rootNode = SplatSubTree.convertWorkerSubTreeNode(workerSubTree.rootNode);\n\n\n        const visitLeavesFromNode = (node, visitFunc) => {\n            if (node.children.length === 0) visitFunc(node);\n            for (let child of node.children) {\n                visitLeavesFromNode(child, visitFunc);\n            }\n        };\n\n        convertedSubTree.nodesWithIndexes = [];\n        visitLeavesFromNode(convertedSubTree.rootNode, (node) => {\n            if (node.data && node.data.indexes && node.data.indexes.length > 0) {\n                convertedSubTree.nodesWithIndexes.push(node);\n            }\n        });\n\n        return convertedSubTree;\n    }\n}\n\nfunction createSplatTreeWorker(self) {\n\n    let WorkerSplatTreeNodeIDGen = 0;\n\n    class WorkerBox3 {\n\n        constructor(min, max) {\n            this.min = [min[0], min[1], min[2]];\n            this.max = [max[0], max[1], max[2]];\n        }\n\n        containsPoint(point) {\n            return point[0] >= this.min[0] && point[0] <= this.max[0] &&\n                   point[1] >= this.min[1] && point[1] <= this.max[1] &&\n                   point[2] >= this.min[2] && point[2] <= this.max[2];\n        }\n    }\n\n    class WorkerSplatSubTree {\n\n        constructor(maxDepth, maxCentersPerNode) {\n            this.maxDepth = maxDepth;\n            this.maxCentersPerNode = maxCentersPerNode;\n            this.sceneDimensions = [];\n            this.sceneMin = [];\n            this.sceneMax = [];\n            this.rootNode = null;\n            this.addedIndexes = {};\n            this.nodesWithIndexes = [];\n            this.splatMesh = null;\n            this.disposed = false;\n        }\n\n    }\n\n    class WorkerSplatTreeNode {\n\n        constructor(min, max, depth, id) {\n            this.min = [min[0], min[1], min[2]];\n            this.max = [max[0], max[1], max[2]];\n            this.center = [(max[0] - min[0]) * 0.5 + min[0],\n                           (max[1] - min[1]) * 0.5 + min[1],\n                           (max[2] - min[2]) * 0.5 + min[2]];\n            this.depth = depth;\n            this.children = [];\n            this.data = null;\n            this.id = id || WorkerSplatTreeNodeIDGen++;\n        }\n\n    }\n\n    processSplatTreeNode = function(tree, node, indexToCenter, sceneCenters) {\n        const splatCount = node.data.indexes.length;\n\n        if (splatCount < tree.maxCentersPerNode || node.depth > tree.maxDepth) {\n            const newIndexes = [];\n            for (let i = 0; i < node.data.indexes.length; i++) {\n                if (!tree.addedIndexes[node.data.indexes[i]]) {\n                    newIndexes.push(node.data.indexes[i]);\n                    tree.addedIndexes[node.data.indexes[i]] = true;\n                }\n            }\n            node.data.indexes = newIndexes;\n            node.data.indexes.sort((a, b) => {\n                if (a > b) return 1;\n                else return -1;\n            });\n            tree.nodesWithIndexes.push(node);\n            return;\n        }\n\n        const nodeDimensions = [node.max[0] - node.min[0],\n                                node.max[1] - node.min[1],\n                                node.max[2] - node.min[2]];\n        const halfDimensions = [nodeDimensions[0] * 0.5,\n                                nodeDimensions[1] * 0.5,\n                                nodeDimensions[2] * 0.5];\n        const nodeCenter = [node.min[0] + halfDimensions[0],\n                            node.min[1] + halfDimensions[1],\n                            node.min[2] + halfDimensions[2]];\n\n        const childrenBounds = [\n            // top section, clockwise from upper-left (looking from above, +Y)\n            new WorkerBox3([nodeCenter[0] - halfDimensions[0], nodeCenter[1], nodeCenter[2] - halfDimensions[2]],\n                           [nodeCenter[0], nodeCenter[1] + halfDimensions[1], nodeCenter[2]]),\n            new WorkerBox3([nodeCenter[0], nodeCenter[1], nodeCenter[2] - halfDimensions[2]],\n                           [nodeCenter[0] + halfDimensions[0], nodeCenter[1] + halfDimensions[1], nodeCenter[2]]),\n            new WorkerBox3([nodeCenter[0], nodeCenter[1], nodeCenter[2]],\n                           [nodeCenter[0] + halfDimensions[0], nodeCenter[1] + halfDimensions[1], nodeCenter[2] + halfDimensions[2]]),\n            new WorkerBox3([nodeCenter[0] - halfDimensions[0], nodeCenter[1], nodeCenter[2]],\n                           [nodeCenter[0], nodeCenter[1] + halfDimensions[1], nodeCenter[2] + halfDimensions[2]]),\n\n            // bottom section, clockwise from lower-left (looking from above, +Y)\n            new WorkerBox3([nodeCenter[0] - halfDimensions[0], nodeCenter[1] - halfDimensions[1], nodeCenter[2] - halfDimensions[2]],\n                           [nodeCenter[0], nodeCenter[1], nodeCenter[2]]),\n            new WorkerBox3([nodeCenter[0], nodeCenter[1] - halfDimensions[1], nodeCenter[2] - halfDimensions[2]],\n                           [nodeCenter[0] + halfDimensions[0], nodeCenter[1], nodeCenter[2]]),\n            new WorkerBox3([nodeCenter[0], nodeCenter[1] - halfDimensions[1], nodeCenter[2]],\n                           [nodeCenter[0] + halfDimensions[0], nodeCenter[1], nodeCenter[2] + halfDimensions[2]]),\n            new WorkerBox3([nodeCenter[0] - halfDimensions[0], nodeCenter[1] - halfDimensions[1], nodeCenter[2]],\n                           [nodeCenter[0], nodeCenter[1], nodeCenter[2] + halfDimensions[2]]),\n        ];\n\n        const splatCounts = [];\n        const baseIndexes = [];\n        for (let i = 0; i < childrenBounds.length; i++) {\n            splatCounts[i] = 0;\n            baseIndexes[i] = [];\n        }\n\n        const center = [0, 0, 0];\n        for (let i = 0; i < splatCount; i++) {\n            const splatGlobalIndex = node.data.indexes[i];\n            const centerBase = indexToCenter[splatGlobalIndex];\n            center[0] = sceneCenters[centerBase];\n            center[1] = sceneCenters[centerBase + 1];\n            center[2] = sceneCenters[centerBase + 2];\n            for (let j = 0; j < childrenBounds.length; j++) {\n                if (childrenBounds[j].containsPoint(center)) {\n                    splatCounts[j]++;\n                    baseIndexes[j].push(splatGlobalIndex);\n                }\n            }\n        }\n\n        for (let i = 0; i < childrenBounds.length; i++) {\n            const childNode = new WorkerSplatTreeNode(childrenBounds[i].min, childrenBounds[i].max, node.depth + 1);\n            childNode.data = {\n                'indexes': baseIndexes[i]\n            };\n            node.children.push(childNode);\n        }\n\n        node.data = {};\n        for (let child of node.children) {\n            processSplatTreeNode(tree, child, indexToCenter, sceneCenters);\n        }\n        return;\n    };\n\n    const buildSubTree = (sceneCenters, maxDepth, maxCentersPerNode) => {\n\n        const sceneMin = [0, 0, 0];\n        const sceneMax = [0, 0, 0];\n        const indexes = [];\n        const centerCount = Math.floor(sceneCenters.length / 4);\n        for ( let i = 0; i < centerCount; i ++) {\n            const base = i * 4;\n            const x = sceneCenters[base];\n            const y = sceneCenters[base + 1];\n            const z = sceneCenters[base + 2];\n            const index = Math.round(sceneCenters[base + 3]);\n            if (i === 0 || x < sceneMin[0]) sceneMin[0] = x;\n            if (i === 0 || x > sceneMax[0]) sceneMax[0] = x;\n            if (i === 0 || y < sceneMin[1]) sceneMin[1] = y;\n            if (i === 0 || y > sceneMax[1]) sceneMax[1] = y;\n            if (i === 0 || z < sceneMin[2]) sceneMin[2] = z;\n            if (i === 0 || z > sceneMax[2]) sceneMax[2] = z;\n            indexes.push(index);\n        }\n        const subTree = new WorkerSplatSubTree(maxDepth, maxCentersPerNode);\n        subTree.sceneMin = sceneMin;\n        subTree.sceneMax = sceneMax;\n        subTree.rootNode = new WorkerSplatTreeNode(subTree.sceneMin, subTree.sceneMax, 0);\n        subTree.rootNode.data = {\n            'indexes': indexes\n        };\n\n        return subTree;\n    };\n\n    function createSplatTree(allCenters, maxDepth, maxCentersPerNode) {\n        const indexToCenter = [];\n        for (let sceneCenters of allCenters) {\n            const centerCount = Math.floor(sceneCenters.length / 4);\n            for ( let i = 0; i < centerCount; i ++) {\n                const base = i * 4;\n                const index = Math.round(sceneCenters[base + 3]);\n                indexToCenter[index] = base;\n            }\n        }\n        const subTrees = [];\n        for (let sceneCenters of allCenters) {\n            const subTree = buildSubTree(sceneCenters, maxDepth, maxCentersPerNode);\n            subTrees.push(subTree);\n            processSplatTreeNode(subTree, subTree.rootNode, indexToCenter, sceneCenters);\n        }\n        self.postMessage({\n            'subTrees': subTrees\n        });\n    }\n\n    self.onmessage = (e) => {\n        if (e.data.process) {\n            createSplatTree(e.data.process.centers, e.data.process.maxDepth, e.data.process.maxCentersPerNode);\n        }\n    };\n}\n\nfunction workerProcessCenters(splatTreeWorker, centers, transferBuffers, maxDepth, maxCentersPerNode) {\n    splatTreeWorker.postMessage({\n        'process': {\n            'centers': centers,\n            'maxDepth': maxDepth,\n            'maxCentersPerNode': maxCentersPerNode\n        }\n    }, transferBuffers);\n}\n\nfunction checkAndCreateWorker() {\n    const splatTreeWorker = new Worker(\n        URL.createObjectURL(\n            new Blob(['(', createSplatTreeWorker.toString(), ')(self)'], {\n                type: 'application/javascript',\n            }),\n        ),\n    );\n    return splatTreeWorker;\n}\n\n/**\n * SplatTree: Octree tailored to splat data from a SplatMesh instance\n */\nclass SplatTree {\n\n    constructor(maxDepth, maxCentersPerNode) {\n        this.maxDepth = maxDepth;\n        this.maxCentersPerNode = maxCentersPerNode;\n        this.subTrees = [];\n        this.splatMesh = null;\n    }\n\n\n    dispose() {\n        this.diposeSplatTreeWorker();\n        this.disposed = true;\n    }\n\n    diposeSplatTreeWorker() {\n        if (this.splatTreeWorker) this.splatTreeWorker.terminate();\n        this.splatTreeWorker = null;\n    };\n\n    /**\n     * Construct this instance of SplatTree from an instance of SplatMesh.\n     *\n     * @param {SplatMesh} splatMesh The instance of SplatMesh from which to construct this splat tree.\n     * @param {function} filterFunc Optional function to filter out unwanted splats.\n     * @param {function} onIndexesUpload Function to be called when the upload of splat centers to the splat tree\n     *                                   builder worker starts and finishes.\n     * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from\n     *                                           the format produced by the splat tree builder worker starts and ends.\n     * @return {undefined}\n     */\n    processSplatMesh = function(splatMesh, filterFunc = () => true, onIndexesUpload, onSplatTreeConstruction) {\n        if (!this.splatTreeWorker) this.splatTreeWorker = checkAndCreateWorker();\n\n        this.splatMesh = splatMesh;\n        this.subTrees = [];\n        const center = new THREE.Vector3();\n\n        const addCentersForScene = (splatOffset, splatCount) => {\n            const sceneCenters = new Float32Array(splatCount * 4);\n            let addedCount = 0;\n            for (let i = 0; i < splatCount; i++) {\n                const globalSplatIndex = i + splatOffset;\n                if (filterFunc(globalSplatIndex)) {\n                    splatMesh.getSplatCenter(globalSplatIndex, center);\n                    const addBase = addedCount * 4;\n                    sceneCenters[addBase] = center.x;\n                    sceneCenters[addBase + 1] = center.y;\n                    sceneCenters[addBase + 2] = center.z;\n                    sceneCenters[addBase + 3] = globalSplatIndex;\n                    addedCount++;\n                }\n            }\n            return sceneCenters;\n        };\n\n        return new Promise((resolve) => {\n\n            const checkForEarlyExit = () => {\n                if (this.disposed) {\n                    this.diposeSplatTreeWorker();\n                    resolve();\n                    return true;\n                }\n                return false;\n            };\n\n            if (onIndexesUpload) onIndexesUpload(false);\n\n            delayedExecute(() => {\n\n                if (checkForEarlyExit()) return;\n\n                const allCenters = [];\n                if (splatMesh.dynamicMode) {\n                    let splatOffset = 0;\n                    for (let s = 0; s < splatMesh.scenes.length; s++) {\n                        const scene = splatMesh.getScene(s);\n                        const splatCount = scene.splatBuffer.getSplatCount();\n                        const sceneCenters = addCentersForScene(splatOffset, splatCount);\n                        allCenters.push(sceneCenters);\n                        splatOffset += splatCount;\n                    }\n                } else {\n                    const sceneCenters = addCentersForScene(0, splatMesh.getSplatCount());\n                    allCenters.push(sceneCenters);\n                }\n\n                this.splatTreeWorker.onmessage = (e) => {\n\n                    if (checkForEarlyExit()) return;\n\n                    if (e.data.subTrees) {\n\n                        if (onSplatTreeConstruction) onSplatTreeConstruction(false);\n\n                        delayedExecute(() => {\n\n                            if (checkForEarlyExit()) return;\n\n                            for (let workerSubTree of e.data.subTrees) {\n                                const convertedSubTree = SplatSubTree.convertWorkerSubTree(workerSubTree, splatMesh);\n                                this.subTrees.push(convertedSubTree);\n                            }\n                            this.diposeSplatTreeWorker();\n\n                            if (onSplatTreeConstruction) onSplatTreeConstruction(true);\n\n                            delayedExecute(() => {\n                                resolve();\n                            });\n\n                        });\n                    }\n                };\n\n                delayedExecute(() => {\n                    if (checkForEarlyExit()) return;\n                    if (onIndexesUpload) onIndexesUpload(true);\n                    const transferBuffers = allCenters.map((array) => array.buffer);\n                    workerProcessCenters(this.splatTreeWorker, allCenters, transferBuffers, this.maxDepth, this.maxCentersPerNode);\n                });\n\n            });\n\n        });\n\n    };\n\n    countLeaves() {\n\n        let leafCount = 0;\n        this.visitLeaves(() => {\n            leafCount++;\n        });\n\n        return leafCount;\n    }\n\n    visitLeaves(visitFunc) {\n\n        const visitLeavesFromNode = (node, visitFunc) => {\n            if (node.children.length === 0) visitFunc(node);\n            for (let child of node.children) {\n                visitLeavesFromNode(child, visitFunc);\n            }\n        };\n\n        for (let subTree of this.subTrees) {\n            visitLeavesFromNode(subTree.rootNode, visitFunc);\n        }\n    }\n\n}\n\nfunction WebGLExtensions( gl ) {\n\n    const extensions = {};\n\n    function getExtension( name ) {\n\n        if ( extensions[name] !== undefined ) {\n\n            return extensions[name];\n\n        }\n\n        let extension;\n\n        switch ( name ) {\n\n            case 'WEBGL_depth_texture':\n                extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) ||\n                            gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n                break;\n\n            case 'EXT_texture_filter_anisotropic':\n                extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) ||\n                            gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) ||\n                            gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n                break;\n\n            case 'WEBGL_compressed_texture_s3tc':\n                extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) ||\n                            gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) ||\n                            gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n                break;\n\n            case 'WEBGL_compressed_texture_pvrtc':\n                extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) ||\n                           gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n                break;\n\n            default:\n                extension = gl.getExtension( name );\n\n        }\n\n        extensions[name] = extension;\n\n        return extension;\n\n    }\n\n    return {\n\n        has: function( name ) {\n\n            return getExtension( name ) !== null;\n\n        },\n\n        init: function( capabilities ) {\n\n            if ( capabilities.isWebGL2 ) {\n\n                getExtension( 'EXT_color_buffer_float' );\n                getExtension( 'WEBGL_clip_cull_distance' );\n\n            } else {\n\n                getExtension( 'WEBGL_depth_texture' );\n                getExtension( 'OES_texture_float' );\n                getExtension( 'OES_texture_half_float' );\n                getExtension( 'OES_texture_half_float_linear' );\n                getExtension( 'OES_standard_derivatives' );\n                getExtension( 'OES_element_index_uint' );\n                getExtension( 'OES_vertex_array_object' );\n                getExtension( 'ANGLE_instanced_arrays' );\n\n            }\n\n            getExtension( 'OES_texture_float_linear' );\n            getExtension( 'EXT_color_buffer_half_float' );\n            getExtension( 'WEBGL_multisampled_render_to_texture' );\n\n        },\n\n        get: function( name ) {\n\n            const extension = getExtension( name );\n\n            if ( extension === null ) {\n\n                console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n            }\n\n            return extension;\n\n        }\n\n    };\n\n}\n\nfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n    let maxAnisotropy;\n\n    function getMaxAnisotropy() {\n\n        if ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n        if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n            const extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n            maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n        } else {\n\n            maxAnisotropy = 0;\n\n        }\n\n        return maxAnisotropy;\n\n    }\n\n    function getMaxPrecision( precision ) {\n\n        if ( precision === 'highp' ) {\n\n            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n                return 'highp';\n\n            }\n\n            precision = 'mediump';\n\n        }\n\n        if ( precision === 'mediump' ) {\n\n            if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n                gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n                return 'mediump';\n\n            }\n\n        }\n\n        return 'lowp';\n\n    }\n\n    const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl.constructor.name === 'WebGL2RenderingContext';\n\n    let precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n    const maxPrecision = getMaxPrecision( precision );\n\n    if ( maxPrecision !== precision ) {\n\n        console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n        precision = maxPrecision;\n\n    }\n\n    const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );\n\n    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n    const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n    const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n    const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n    const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n    const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n    const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n    const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n    const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n    const vertexTextures = maxVertexTextures > 0;\n    const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );\n    const floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n    const maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;\n\n    return {\n\n        isWebGL2: isWebGL2,\n\n        drawBuffers: drawBuffers,\n\n        getMaxAnisotropy: getMaxAnisotropy,\n        getMaxPrecision: getMaxPrecision,\n\n        precision: precision,\n        logarithmicDepthBuffer: logarithmicDepthBuffer,\n\n        maxTextures: maxTextures,\n        maxVertexTextures: maxVertexTextures,\n        maxTextureSize: maxTextureSize,\n        maxCubemapSize: maxCubemapSize,\n\n        maxAttributes: maxAttributes,\n        maxVertexUniforms: maxVertexUniforms,\n        maxVaryings: maxVaryings,\n        maxFragmentUniforms: maxFragmentUniforms,\n\n        vertexTextures: vertexTextures,\n        floatFragmentTextures: floatFragmentTextures,\n        floatVertexTextures: floatVertexTextures,\n\n        maxSamples: maxSamples\n\n    };\n\n}\n\nconst SceneRevealMode = {\n    Default: 0,\n    Gradual: 1,\n    Instant: 2\n};\n\nconst LogLevel = {\n    None: 0,\n    Error: 1,\n    Warning: 2,\n    Info: 3,\n    Debug: 4\n};\n\nconst dummyGeometry = new THREE.BufferGeometry();\nconst dummyMaterial = new THREE.MeshBasicMaterial();\n\nconst COVARIANCES_ELEMENTS_PER_SPLAT = 6;\nconst CENTER_COLORS_ELEMENTS_PER_SPLAT = 4;\n\nconst COVARIANCES_ELEMENTS_PER_TEXEL_STORED = 4;\nconst COVARIANCES_ELEMENTS_PER_TEXEL_ALLOCATED = 4;\nconst COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_STORED = 6;\nconst COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_ALLOCATED = 8;\nconst SCALES_ROTATIONS_ELEMENTS_PER_TEXEL = 4;\nconst CENTER_COLORS_ELEMENTS_PER_TEXEL = 4;\nconst SCENE_INDEXES_ELEMENTS_PER_TEXEL = 1;\n\nconst SCENE_FADEIN_RATE_FAST = 0.012;\nconst SCENE_FADEIN_RATE_GRADUAL = 0.003;\n\nconst VISIBLE_REGION_EXPANSION_DELTA = 1;\n\n// Based on my own observations across multiple devices, OSes and browsers, using textures that have one dimension\n// greater than 4096 while the other is greater than or equal to 4096 causes issues (Essentially any texture larger\n// than 4096 x 4096 (16777216) texels). Specifically it seems all texture data beyond the 4096 x 4096 texel boundary\n// is corrupted, while data below that boundary is usable. In these cases the texture has been valid in the eyes of\n// both Three.js and WebGL, and the texel format (RG, RGBA, etc.) has not mattered. More investigation will be needed,\n// but for now the work-around is to split the spherical harmonics into three textures (one for each color channel).\nconst MAX_TEXTURE_TEXELS = 16777216;\n\n/**\n * SplatMesh: Container for one or more splat scenes, abstracting them into a single unified container for\n * splat data. Additionally contains data structures and code to make the splat data renderable as a Three.js mesh.\n */\nclass SplatMesh extends THREE.Mesh {\n\n    constructor(splatRenderMode = SplatRenderMode.ThreeD, dynamicMode = false, enableOptionalEffects = false,\n                halfPrecisionCovariancesOnGPU = false, devicePixelRatio = 1, enableDistancesComputationOnGPU = true,\n                integerBasedDistancesComputation = false, antialiased = false, maxScreenSpaceSplatSize = 1024, logLevel = LogLevel.None,\n                sphericalHarmonicsDegree = 0, sceneFadeInRateMultiplier = 1.0, kernel2DSize = 0.3) {\n        super(dummyGeometry, dummyMaterial);\n\n        // Reference to a Three.js renderer\n        this.renderer = undefined;\n\n        // Determine how the splats are rendered\n        this.splatRenderMode = splatRenderMode;\n\n        // When 'dynamicMode' is true, scenes are assumed to be non-static. Dynamic scenes are handled differently\n        // and certain optimizations cannot be made for them. Additionally, by default, all splat data retrieved from\n        // this splat mesh will not have their scene transform applied to them if the splat mesh is dynamic. That\n        // can be overriden via parameters to the individual functions that are used to retrieve splat data.\n        this.dynamicMode = dynamicMode;\n\n        // When true, allows for usage of extra properties and attributes during rendering for effects such as opacity adjustment.\n        // Default is false for performance reasons. These properties are separate from transform properties (scale, rotation, position)\n        // that are enabled by the 'dynamicScene' parameter.\n        this.enableOptionalEffects = enableOptionalEffects;\n\n        // Use 16-bit floating point values when storing splat covariance data in textures, instead of 32-bit\n        this.halfPrecisionCovariancesOnGPU = halfPrecisionCovariancesOnGPU;\n\n        // Ratio of the resolution in physical pixels to the resolution in CSS pixels for the current display device\n        this.devicePixelRatio = devicePixelRatio;\n\n        // Use a transform feedback to calculate splat distances from the camera\n        this.enableDistancesComputationOnGPU = enableDistancesComputationOnGPU;\n\n        // Use a faster integer-based approach for calculating splat distances from the camera\n        this.integerBasedDistancesComputation = integerBasedDistancesComputation;\n\n        // When true, will perform additional steps during rendering to address artifacts caused by the rendering of gaussians at a\n        // substantially different resolution than that at which they were rendered during training. This will only work correctly\n        // for models that were trained using a process that utilizes this compensation calculation. For more details:\n        // https://github.com/nerfstudio-project/gsplat/pull/117\n        // https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093\n        this.antialiased = antialiased;\n\n        // The size of the 2D kernel used for splat rendering\n        // This will adjust the 2D kernel size after the projection\n        this.kernel2DSize = kernel2DSize;\n\n        // Specify the maximum clip space splat size, can help deal with large splats that get too unwieldy\n        this.maxScreenSpaceSplatSize = maxScreenSpaceSplatSize;\n\n        // The verbosity of console logging\n        this.logLevel = logLevel;\n\n        // Degree 0 means no spherical harmonics\n        this.sphericalHarmonicsDegree = sphericalHarmonicsDegree;\n        this.minSphericalHarmonicsDegree = 0;\n\n        this.sceneFadeInRateMultiplier = sceneFadeInRateMultiplier;\n\n        // The individual splat scenes stored in this splat mesh, each containing their own transform\n        this.scenes = [];\n\n        // Special octree tailored to SplatMesh instances\n        this.splatTree = null;\n        this.baseSplatTree = null;\n\n        // Cache textures and the intermediate data used to populate them\n        this.splatDataTextures = {};\n\n        this.distancesTransformFeedback = {\n            'id': null,\n            'vertexShader': null,\n            'fragmentShader': null,\n            'program': null,\n            'centersBuffer': null,\n            'sceneIndexesBuffer': null,\n            'outDistancesBuffer': null,\n            'centersLoc': -1,\n            'modelViewProjLoc': -1,\n            'sceneIndexesLoc': -1,\n            'transformsLocs': []\n        };\n\n        this.globalSplatIndexToLocalSplatIndexMap = [];\n        this.globalSplatIndexToSceneIndexMap = [];\n\n        this.lastBuildSplatCount = 0;\n        this.lastBuildScenes = [];\n        this.lastBuildMaxSplatCount = 0;\n        this.lastBuildSceneCount = 0;\n        this.firstRenderTime = -1;\n        this.finalBuild = false;\n\n        this.webGLUtils = null;\n\n        this.boundingBox = new THREE.Box3();\n        this.calculatedSceneCenter = new THREE.Vector3();\n        this.maxSplatDistanceFromSceneCenter = 0;\n        this.visibleRegionBufferRadius = 0;\n        this.visibleRegionRadius = 0;\n        this.visibleRegionFadeStartRadius = 0;\n        this.visibleRegionChanging = false;\n\n        this.splatScale = 1.0;\n        this.pointCloudModeEnabled = false;\n\n        this.disposed = false;\n        this.lastRenderer = null;\n        this.visible = false;\n    }\n\n    /**\n     * Build a container for each scene managed by this splat mesh based on an instance of SplatBuffer, along with optional\n     * transform data (position, scale, rotation) passed to the splat mesh during the build process.\n     * @param {Array<THREE.Matrix4>} splatBuffers SplatBuffer instances containing splats for each scene\n     * @param {Array<object>} sceneOptions Array of options objects: {\n     *\n     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n     *\n     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n     *\n     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n     * }\n     * @return {Array<THREE.Matrix4>}\n     */\n    static buildScenes(parentObject, splatBuffers, sceneOptions) {\n        const scenes = [];\n        scenes.length = splatBuffers.length;\n        for (let i = 0; i < splatBuffers.length; i++) {\n            const splatBuffer = splatBuffers[i];\n            const options = sceneOptions[i] || {};\n            let positionArray = options['position'] || [0, 0, 0];\n            let rotationArray = options['rotation'] || [0, 0, 0, 1];\n            let scaleArray = options['scale'] || [1, 1, 1];\n            const position = new THREE.Vector3().fromArray(positionArray);\n            const rotation = new THREE.Quaternion().fromArray(rotationArray);\n            const scale = new THREE.Vector3().fromArray(scaleArray);\n            const scene = SplatMesh.createScene(splatBuffer, position, rotation, scale,\n                                                options.splatAlphaRemovalThreshold || 1, options.opacity, options.visible);\n            parentObject.add(scene);\n            scenes[i] = scene;\n        }\n        return scenes;\n    }\n\n    static createScene(splatBuffer, position, rotation, scale, minimumAlpha, opacity = 1.0, visible = true) {\n        return new SplatScene(splatBuffer, position, rotation, scale, minimumAlpha, opacity, visible);\n    }\n\n    /**\n     * Build data structures that map global splat indexes (based on a unified index across all splat buffers) to\n     * local data within a single scene.\n     * @param {Array<SplatBuffer>} splatBuffers Instances of SplatBuffer off which to build the maps\n     * @return {object}\n     */\n    static buildSplatIndexMaps(splatBuffers) {\n        const localSplatIndexMap = [];\n        const sceneIndexMap = [];\n        let totalSplatCount = 0;\n        for (let s = 0; s < splatBuffers.length; s++) {\n            const splatBuffer = splatBuffers[s];\n            const maxSplatCount = splatBuffer.getMaxSplatCount();\n            for (let i = 0; i < maxSplatCount; i++) {\n                localSplatIndexMap[totalSplatCount] = i;\n                sceneIndexMap[totalSplatCount] = s;\n                totalSplatCount++;\n            }\n        }\n        return {\n            localSplatIndexMap,\n            sceneIndexMap\n        };\n    }\n\n    /**\n     * Build an instance of SplatTree (a specialized octree) for the given splat mesh.\n     * @param {Array<number>} minAlphas Array of minimum splat slphas for each scene\n     * @param {function} onSplatTreeIndexesUpload Function to be called when the upload of splat centers to the splat tree\n     *                                            builder worker starts and finishes.\n     * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from\n     *                                           the format produced by the splat tree builder worker starts and ends.\n     * @return {SplatTree}\n     */\n     buildSplatTree = function(minAlphas = [], onSplatTreeIndexesUpload, onSplatTreeConstruction) {\n        return new Promise((resolve) => {\n            this.disposeSplatTree();\n            // TODO: expose SplatTree constructor parameters (maximumDepth and maxCentersPerNode) so that they can\n            // be configured on a per-scene basis\n            this.baseSplatTree = new SplatTree(8, 1000);\n            const buildStartTime = performance.now();\n            const splatColor = new THREE.Vector4();\n            this.baseSplatTree.processSplatMesh(this, (splatIndex) => {\n                this.getSplatColor(splatIndex, splatColor);\n                const sceneIndex = this.getSceneIndexForSplat(splatIndex);\n                const minAlpha = minAlphas[sceneIndex] || 1;\n                return splatColor.w >= minAlpha;\n            }, onSplatTreeIndexesUpload, onSplatTreeConstruction)\n            .then(() => {\n                const buildTime = performance.now() - buildStartTime;\n                if (this.logLevel >= LogLevel.Info) console.log('SplatTree build: ' + buildTime + ' ms');\n                if (this.disposed) {\n                    resolve();\n                } else {\n\n                    this.splatTree = this.baseSplatTree;\n                    this.baseSplatTree = null;\n\n                    let leavesWithVertices = 0;\n                    let avgSplatCount = 0;\n                    let maxSplatCount = 0;\n                    let nodeCount = 0;\n\n                    this.splatTree.visitLeaves((node) => {\n                        const nodeSplatCount = node.data.indexes.length;\n                        if (nodeSplatCount > 0) {\n                            avgSplatCount += nodeSplatCount;\n                            maxSplatCount = Math.max(maxSplatCount, nodeSplatCount);\n                            nodeCount++;\n                            leavesWithVertices++;\n                        }\n                    });\n                    if (this.logLevel >= LogLevel.Info) {\n                        console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`);\n                        console.log(`SplatTree leaves with splats:${leavesWithVertices}`);\n                        avgSplatCount = avgSplatCount / nodeCount;\n                        console.log(`Avg splat count per node: ${avgSplatCount}`);\n                        console.log(`Total splat count: ${this.getSplatCount()}`);\n                    }\n                    resolve();\n                }\n            });\n        });\n    };\n\n    /**\n     * Construct this instance of SplatMesh.\n     * @param {Array<SplatBuffer>} splatBuffers The base splat data, instances of SplatBuffer\n     * @param {Array<object>} sceneOptions Dynamic options for each scene {\n     *\n     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n     *                                     value (valid range: 0 - 255), defaults to 1\n     *\n     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n     *\n     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n     *\n     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n     *\n     * }\n     * @param {boolean} keepSceneTransforms For a scene that already exists and is being overwritten, this flag\n     *                                      says to keep the transform from the existing scene.\n     * @param {boolean} finalBuild Will the splat mesh be in its final state after this build?\n     * @param {function} onSplatTreeIndexesUpload Function to be called when the upload of splat centers to the splat tree\n     *                                            builder worker starts and finishes.\n     * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from\n     *                                           the format produced by the splat tree builder worker starts and ends.\n     * @return {object} Object containing info about the splats that are updated\n     */\n    build(splatBuffers, sceneOptions, keepSceneTransforms = true, finalBuild = false,\n          onSplatTreeIndexesUpload, onSplatTreeConstruction, preserveVisibleRegion = true) {\n\n        this.sceneOptions = sceneOptions;\n        this.finalBuild = finalBuild;\n\n        const maxSplatCount = SplatMesh.getTotalMaxSplatCountForSplatBuffers(splatBuffers);\n\n        const newScenes = SplatMesh.buildScenes(this, splatBuffers, sceneOptions);\n        if (keepSceneTransforms) {\n            for (let i = 0; i < this.scenes.length && i < newScenes.length; i++) {\n                const newScene = newScenes[i];\n                const existingScene = this.getScene(i);\n                newScene.copyTransformData(existingScene);\n            }\n        }\n        this.scenes = newScenes;\n\n        let minSphericalHarmonicsDegree = 3;\n        for (let splatBuffer of splatBuffers) {\n            const splatBufferSphericalHarmonicsDegree = splatBuffer.getMinSphericalHarmonicsDegree();\n            if (splatBufferSphericalHarmonicsDegree < minSphericalHarmonicsDegree) {\n                minSphericalHarmonicsDegree = splatBufferSphericalHarmonicsDegree;\n            }\n        }\n        this.minSphericalHarmonicsDegree = Math.min(minSphericalHarmonicsDegree, this.sphericalHarmonicsDegree);\n\n        let splatBuffersChanged = false;\n        if (splatBuffers.length !== this.lastBuildScenes.length) {\n            splatBuffersChanged = true;\n        } else {\n            for (let i = 0; i < splatBuffers.length; i++) {\n                const splatBuffer = splatBuffers[i];\n                if (splatBuffer !== this.lastBuildScenes[i].splatBuffer) {\n                    splatBuffersChanged = true;\n                    break;\n                }\n            }\n        }\n\n        let isUpdateBuild = true;\n        if (this.scenes.length !== 1 ||\n            this.lastBuildSceneCount !== this.scenes.length ||\n            this.lastBuildMaxSplatCount !== maxSplatCount ||\n            splatBuffersChanged) {\n                isUpdateBuild = false;\n       }\n\n       if (!isUpdateBuild) {\n            this.boundingBox = new THREE.Box3();\n            if (!preserveVisibleRegion) {\n                this.maxSplatDistanceFromSceneCenter = 0;\n                this.visibleRegionBufferRadius = 0;\n                this.visibleRegionRadius = 0;\n                this.visibleRegionFadeStartRadius = 0;\n                this.firstRenderTime = -1;\n            }\n            this.lastBuildScenes = [];\n            this.lastBuildSplatCount = 0;\n            this.lastBuildMaxSplatCount = 0;\n            this.disposeMeshData();\n            this.geometry = SplatGeometry.build(maxSplatCount);\n            if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n                this.material = SplatMaterial3D.build(this.dynamicMode, this.enableOptionalEffects, this.antialiased,\n                                                      this.maxScreenSpaceSplatSize, this.splatScale, this.pointCloudModeEnabled,\n                                                      this.minSphericalHarmonicsDegree, this.kernel2DSize);\n            } else {\n                this.material = SplatMaterial2D.build(this.dynamicMode, this.enableOptionalEffects,\n                                                      this.splatScale, this.pointCloudModeEnabled, this.minSphericalHarmonicsDegree);\n            }\n\n            const indexMaps = SplatMesh.buildSplatIndexMaps(splatBuffers);\n            this.globalSplatIndexToLocalSplatIndexMap = indexMaps.localSplatIndexMap;\n            this.globalSplatIndexToSceneIndexMap = indexMaps.sceneIndexMap;\n        }\n\n        const splatBufferSplatCount = this.getSplatCount(true);\n        if (this.enableDistancesComputationOnGPU) this.setupDistancesComputationTransformFeedback();\n        const dataUpdateResults = this.refreshGPUDataFromSplatBuffers(isUpdateBuild);\n\n        for (let i = 0; i < this.scenes.length; i++) {\n            this.lastBuildScenes[i] = this.scenes[i];\n        }\n        this.lastBuildSplatCount = splatBufferSplatCount;\n        this.lastBuildMaxSplatCount = this.getMaxSplatCount();\n        this.lastBuildSceneCount = this.scenes.length;\n\n        if (finalBuild && this.scenes.length > 0) {\n            this.buildSplatTree(sceneOptions.map(options => options.splatAlphaRemovalThreshold || 1),\n                                onSplatTreeIndexesUpload, onSplatTreeConstruction)\n            .then(() => {\n                if (this.onSplatTreeReadyCallback) this.onSplatTreeReadyCallback(this.splatTree);\n                this.onSplatTreeReadyCallback = null;\n            });\n        }\n\n        this.visible = (this.scenes.length > 0);\n\n        return dataUpdateResults;\n    }\n\n    freeIntermediateSplatData() {\n\n        const deleteTextureData = (texture) => {\n            delete texture.source.data;\n            delete texture.image;\n            texture.onUpdate = null;\n        };\n\n        delete this.splatDataTextures.baseData.covariances;\n        delete this.splatDataTextures.baseData.centers;\n        delete this.splatDataTextures.baseData.colors;\n        delete this.splatDataTextures.baseData.sphericalHarmonics;\n\n        delete this.splatDataTextures.centerColors.data;\n        delete this.splatDataTextures.covariances.data;\n        if (this.splatDataTextures.sphericalHarmonics) {\n            delete this.splatDataTextures.sphericalHarmonics.data;\n        }\n        if (this.splatDataTextures.sceneIndexes) {\n            delete this.splatDataTextures.sceneIndexes.data;\n        }\n\n        this.splatDataTextures.centerColors.texture.needsUpdate = true;\n        this.splatDataTextures.centerColors.texture.onUpdate = () => {\n            deleteTextureData(this.splatDataTextures.centerColors.texture);\n        };\n\n        this.splatDataTextures.covariances.texture.needsUpdate = true;\n        this.splatDataTextures.covariances.texture.onUpdate = () => {\n            deleteTextureData(this.splatDataTextures.covariances.texture);\n        };\n\n        if (this.splatDataTextures.sphericalHarmonics) {\n            if (this.splatDataTextures.sphericalHarmonics.texture) {\n                this.splatDataTextures.sphericalHarmonics.texture.needsUpdate = true;\n                this.splatDataTextures.sphericalHarmonics.texture.onUpdate = () => {\n                    deleteTextureData(this.splatDataTextures.sphericalHarmonics.texture);\n                };\n            } else {\n                this.splatDataTextures.sphericalHarmonics.textures.forEach((texture) => {\n                    texture.needsUpdate = true;\n                    texture.onUpdate = () => {\n                        deleteTextureData(texture);\n                    };\n                });\n            }\n        }\n        if (this.splatDataTextures.sceneIndexes) {\n            this.splatDataTextures.sceneIndexes.texture.needsUpdate = true;\n            this.splatDataTextures.sceneIndexes.texture.onUpdate = () => {\n                deleteTextureData(this.splatDataTextures.sceneIndexes.texture);\n            };\n        }\n    }\n    /**\n     * Dispose all resources held by the splat mesh\n     */\n    dispose() {\n        this.disposeMeshData();\n        this.disposeTextures();\n        this.disposeSplatTree();\n        if (this.enableDistancesComputationOnGPU) {\n            if (this.computeDistancesOnGPUSyncTimeout) {\n                clearTimeout(this.computeDistancesOnGPUSyncTimeout);\n                this.computeDistancesOnGPUSyncTimeout = null;\n            }\n            this.disposeDistancesComputationGPUResources();\n        }\n        this.scenes = [];\n        this.distancesTransformFeedback = {\n            'id': null,\n            'vertexShader': null,\n            'fragmentShader': null,\n            'program': null,\n            'centersBuffer': null,\n            'sceneIndexesBuffer': null,\n            'outDistancesBuffer': null,\n            'centersLoc': -1,\n            'modelViewProjLoc': -1,\n            'sceneIndexesLoc': -1,\n            'transformsLocs': []\n        };\n        this.renderer = null;\n\n        this.globalSplatIndexToLocalSplatIndexMap = [];\n        this.globalSplatIndexToSceneIndexMap = [];\n\n        this.lastBuildSplatCount = 0;\n        this.lastBuildScenes = [];\n        this.lastBuildMaxSplatCount = 0;\n        this.lastBuildSceneCount = 0;\n        this.firstRenderTime = -1;\n        this.finalBuild = false;\n\n        this.webGLUtils = null;\n\n        this.boundingBox = new THREE.Box3();\n        this.calculatedSceneCenter = new THREE.Vector3();\n        this.maxSplatDistanceFromSceneCenter = 0;\n        this.visibleRegionBufferRadius = 0;\n        this.visibleRegionRadius = 0;\n        this.visibleRegionFadeStartRadius = 0;\n        this.visibleRegionChanging = false;\n\n        this.splatScale = 1.0;\n        this.pointCloudModeEnabled = false;\n\n        this.disposed = true;\n        this.lastRenderer = null;\n        this.visible = false;\n    }\n\n    /**\n     * Dispose of only the Three.js mesh resources (geometry, material, and texture)\n     */\n    disposeMeshData() {\n        if (this.geometry && this.geometry !== dummyGeometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n        if (this.material) {\n            this.material.dispose();\n            this.material = null;\n        }\n    }\n\n    disposeTextures() {\n        for (let textureKey in this.splatDataTextures) {\n            if (this.splatDataTextures.hasOwnProperty(textureKey)) {\n                const textureContainer = this.splatDataTextures[textureKey];\n                if (textureContainer.texture) {\n                    textureContainer.texture.dispose();\n                    textureContainer.texture = null;\n                }\n            }\n        }\n        this.splatDataTextures = null;\n    }\n\n    disposeSplatTree() {\n        if (this.splatTree) {\n            this.splatTree.dispose();\n            this.splatTree = null;\n        }\n        if (this.baseSplatTree) {\n            this.baseSplatTree.dispose();\n            this.baseSplatTree = null;\n        }\n    }\n\n    getSplatTree() {\n        return this.splatTree;\n    }\n\n    onSplatTreeReady(callback) {\n        this.onSplatTreeReadyCallback = callback;\n    }\n\n    /**\n     * Get copies of data that are necessary for splat distance computation: splat center positions and splat\n     * scene indexes (necessary for applying dynamic scene transformations during distance computation)\n     * @param {*} start The index at which to start copying data\n     * @param {*} end  The index at which to stop copying data\n     * @return {object}\n     */\n    getDataForDistancesComputation(start, end) {\n        const centers = this.integerBasedDistancesComputation ?\n                        this.getIntegerCenters(start, end, true) :\n                        this.getFloatCenters(start, end, true);\n        const sceneIndexes = this.getSceneIndexes(start, end);\n        return {\n            centers,\n            sceneIndexes\n        };\n    }\n\n    /**\n     * Refresh data textures and GPU buffers with splat data from the splat buffers belonging to this mesh.\n     * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.\n     * @return {object}\n     */\n    refreshGPUDataFromSplatBuffers(sinceLastBuildOnly) {\n        const splatCount = this.getSplatCount(true);\n        this.refreshDataTexturesFromSplatBuffers(sinceLastBuildOnly);\n        const updateStart = sinceLastBuildOnly ? this.lastBuildSplatCount : 0;\n        const { centers, sceneIndexes } = this.getDataForDistancesComputation(updateStart, splatCount - 1);\n        if (this.enableDistancesComputationOnGPU) {\n            this.refreshGPUBuffersForDistancesComputation(centers, sceneIndexes, sinceLastBuildOnly);\n        }\n        return {\n            'from': updateStart,\n            'to': splatCount - 1,\n            'count': splatCount - updateStart,\n            'centers': centers,\n            'sceneIndexes': sceneIndexes\n        };\n    }\n\n    /**\n     * Update the GPU buffers that are used for computing splat distances on the GPU.\n     * @param {Array<number>} centers Splat center positions\n     * @param {Array<number>} sceneIndexes Indexes of the scene to which each splat belongs\n     * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.\n     */\n    refreshGPUBuffersForDistancesComputation(centers, sceneIndexes, sinceLastBuildOnly = false) {\n        const offset = sinceLastBuildOnly ? this.lastBuildSplatCount : 0;\n        this.updateGPUCentersBufferForDistancesComputation(sinceLastBuildOnly, centers, offset);\n        this.updateGPUTransformIndexesBufferForDistancesComputation(sinceLastBuildOnly, sceneIndexes, offset);\n    }\n\n    /**\n     * Refresh data textures with data from the splat buffers for this mesh.\n     * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.\n     */\n    refreshDataTexturesFromSplatBuffers(sinceLastBuildOnly) {\n        const splatCount = this.getSplatCount(true);\n        const fromSplat = this.lastBuildSplatCount;\n        const toSplat = splatCount - 1;\n\n        if (!sinceLastBuildOnly) {\n            this.setupDataTextures();\n            this.updateBaseDataFromSplatBuffers();\n        } else {\n            this.updateBaseDataFromSplatBuffers(fromSplat, toSplat);\n        }\n\n        this.updateDataTexturesFromBaseData(fromSplat, toSplat);\n        this.updateVisibleRegion(sinceLastBuildOnly);\n    }\n\n    setupDataTextures() {\n        const maxSplatCount = this.getMaxSplatCount();\n        const splatCount = this.getSplatCount(true);\n\n        this.disposeTextures();\n\n        const computeDataTextureSize = (elementsPerTexel, elementsPerSplat) => {\n            const texSize = new THREE.Vector2(4096, 1024);\n            while (texSize.x * texSize.y * elementsPerTexel < maxSplatCount * elementsPerSplat) texSize.y *= 2;\n            return texSize;\n        };\n\n        const getCovariancesElementsPertexelStored = (compressionLevel) => {\n            return compressionLevel >= 1 ? COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_STORED : COVARIANCES_ELEMENTS_PER_TEXEL_STORED;\n        };\n\n        const getCovariancesInitialTextureSpecs = (compressionLevel) => {\n            const elementsPerTexelStored = getCovariancesElementsPertexelStored(compressionLevel);\n            const texSize = computeDataTextureSize(elementsPerTexelStored, 6);\n            return {elementsPerTexelStored, texSize};\n        };\n\n        let covarianceCompressionLevel = this.getTargetCovarianceCompressionLevel();\n        const scaleRotationCompressionLevel = 0;\n        const shCompressionLevel = this.getTargetSphericalHarmonicsCompressionLevel();\n\n        let covariances;\n        let scales;\n        let rotations;\n        if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n            const initialCovTexSpecs = getCovariancesInitialTextureSpecs(covarianceCompressionLevel);\n            if (initialCovTexSpecs.texSize.x * initialCovTexSpecs.texSize.y > MAX_TEXTURE_TEXELS && covarianceCompressionLevel === 0) {\n                covarianceCompressionLevel = 1;\n            }\n            covariances = new Float32Array(maxSplatCount * COVARIANCES_ELEMENTS_PER_SPLAT);\n        } else {\n            scales = new Float32Array(maxSplatCount * 3);\n            rotations = new Float32Array(maxSplatCount * 4);\n        }\n\n        const centers = new Float32Array(maxSplatCount * 3);\n        const colors = new Uint8Array(maxSplatCount * 4);\n\n        let SphericalHarmonicsArrayType = Float32Array;\n        if (shCompressionLevel === 1) SphericalHarmonicsArrayType = Uint16Array;\n        else if (shCompressionLevel === 2) SphericalHarmonicsArrayType = Uint8Array;\n        const shComponentCount = getSphericalHarmonicsComponentCountForDegree(this.minSphericalHarmonicsDegree);\n        const shData = this.minSphericalHarmonicsDegree ? new SphericalHarmonicsArrayType(maxSplatCount * shComponentCount) : undefined;\n\n        // set up centers/colors data texture\n        const centersColsTexSize = computeDataTextureSize(CENTER_COLORS_ELEMENTS_PER_TEXEL, 4);\n        const paddedCentersCols = new Uint32Array(centersColsTexSize.x * centersColsTexSize.y * CENTER_COLORS_ELEMENTS_PER_TEXEL);\n        SplatMesh.updateCenterColorsPaddedData(0, splatCount - 1, centers, colors, paddedCentersCols);\n\n        const centersColsTex = new THREE.DataTexture(paddedCentersCols, centersColsTexSize.x, centersColsTexSize.y,\n                                                     THREE.RGBAIntegerFormat, THREE.UnsignedIntType);\n        centersColsTex.internalFormat = 'RGBA32UI';\n        centersColsTex.needsUpdate = true;\n        this.material.uniforms.centersColorsTexture.value = centersColsTex;\n        this.material.uniforms.centersColorsTextureSize.value.copy(centersColsTexSize);\n        this.material.uniformsNeedUpdate = true;\n\n        this.splatDataTextures = {\n            'baseData': {\n                'covariances': covariances,\n                'scales': scales,\n                'rotations': rotations,\n                'centers': centers,\n                'colors': colors,\n                'sphericalHarmonics': shData\n            },\n            'centerColors': {\n                'data': paddedCentersCols,\n                'texture': centersColsTex,\n                'size': centersColsTexSize\n            }\n        };\n\n        if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n            // set up covariances data texture\n\n            const covTexSpecs = getCovariancesInitialTextureSpecs(covarianceCompressionLevel);\n            const covariancesElementsPerTexelStored = covTexSpecs.elementsPerTexelStored;\n            const covTexSize = covTexSpecs.texSize;\n\n            let CovariancesDataType = covarianceCompressionLevel >= 1 ? Uint32Array : Float32Array;\n            const covariancesElementsPerTexelAllocated = covarianceCompressionLevel >= 1 ?\n                                                         COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_ALLOCATED :\n                                                         COVARIANCES_ELEMENTS_PER_TEXEL_ALLOCATED;\n            const covariancesTextureData = new CovariancesDataType(covTexSize.x * covTexSize.y * covariancesElementsPerTexelAllocated);\n\n            if (covarianceCompressionLevel === 0) {\n                covariancesTextureData.set(covariances);\n            } else {\n                SplatMesh.updatePaddedCompressedCovariancesTextureData(covariances, covariancesTextureData, 0, 0, covariances.length);\n            }\n\n            let covTex;\n            if (covarianceCompressionLevel >= 1) {\n                covTex = new THREE.DataTexture(covariancesTextureData, covTexSize.x, covTexSize.y,\n                                               THREE.RGBAIntegerFormat, THREE.UnsignedIntType);\n                covTex.internalFormat = 'RGBA32UI';\n                this.material.uniforms.covariancesTextureHalfFloat.value = covTex;\n            } else {\n                covTex = new THREE.DataTexture(covariancesTextureData, covTexSize.x, covTexSize.y, THREE.RGBAFormat, THREE.FloatType);\n                this.material.uniforms.covariancesTexture.value = covTex;\n\n                // For some reason a usampler2D needs to have a valid texture attached or WebGL complains\n                const dummyTex = new THREE.DataTexture(new Uint32Array(32), 2, 2, THREE.RGBAIntegerFormat, THREE.UnsignedIntType);\n                dummyTex.internalFormat = 'RGBA32UI';\n                this.material.uniforms.covariancesTextureHalfFloat.value = dummyTex;\n                dummyTex.needsUpdate = true;\n            }\n            covTex.needsUpdate = true;\n\n            this.material.uniforms.covariancesAreHalfFloat.value = (covarianceCompressionLevel >= 1) ? 1 : 0;\n            this.material.uniforms.covariancesTextureSize.value.copy(covTexSize);\n\n            this.splatDataTextures['covariances'] = {\n                'data': covariancesTextureData,\n                'texture': covTex,\n                'size': covTexSize,\n                'compressionLevel': covarianceCompressionLevel,\n                'elementsPerTexelStored': covariancesElementsPerTexelStored,\n                'elementsPerTexelAllocated': covariancesElementsPerTexelAllocated\n            };\n        } else {\n            // set up scale & rotations data texture\n            const elementsPerSplat = 6;\n            const scaleRotationsTexSize = computeDataTextureSize(SCALES_ROTATIONS_ELEMENTS_PER_TEXEL, elementsPerSplat);\n            let ScaleRotationsDataType = scaleRotationCompressionLevel >= 1 ? Uint16Array : Float32Array;\n            let scaleRotationsTextureType = scaleRotationCompressionLevel >= 1 ? THREE.HalfFloatType : THREE.FloatType;\n            const paddedScaleRotations = new ScaleRotationsDataType(scaleRotationsTexSize.x * scaleRotationsTexSize.y *\n                                                                    SCALES_ROTATIONS_ELEMENTS_PER_TEXEL);\n\n            SplatMesh.updateScaleRotationsPaddedData(0, splatCount - 1, scales, rotations, paddedScaleRotations);\n\n            const scaleRotationsTex = new THREE.DataTexture(paddedScaleRotations, scaleRotationsTexSize.x, scaleRotationsTexSize.y,\n                                                            THREE.RGBAFormat, scaleRotationsTextureType);\n            scaleRotationsTex.needsUpdate = true;\n            this.material.uniforms.scaleRotationsTexture.value = scaleRotationsTex;\n            this.material.uniforms.scaleRotationsTextureSize.value.copy(scaleRotationsTexSize);\n\n            this.splatDataTextures['scaleRotations'] = {\n                'data': paddedScaleRotations,\n                'texture': scaleRotationsTex,\n                'size': scaleRotationsTexSize,\n                'compressionLevel': scaleRotationCompressionLevel\n            };\n        }\n\n        if (shData) {\n            const shTextureType = shCompressionLevel === 2 ? THREE.UnsignedByteType : THREE.HalfFloatType;\n\n            let paddedSHComponentCount = shComponentCount;\n            if (paddedSHComponentCount % 2 !== 0) paddedSHComponentCount++;\n            const shElementsPerTexel = 4;\n            const texelFormat = shElementsPerTexel === 4 ? THREE.RGBAFormat : THREE.RGFormat;\n            let shTexSize = computeDataTextureSize(shElementsPerTexel, paddedSHComponentCount);\n\n            // Use one texture for all spherical harmonics data\n            if (shTexSize.x * shTexSize.y <= MAX_TEXTURE_TEXELS) {\n                const paddedSHArraySize = shTexSize.x * shTexSize.y * shElementsPerTexel;\n                const paddedSHArray = new SphericalHarmonicsArrayType(paddedSHArraySize);\n                for (let c = 0; c < splatCount; c++) {\n                    const srcBase = shComponentCount * c;\n                    const destBase = paddedSHComponentCount * c;\n                    for (let i = 0; i < shComponentCount; i++) {\n                        paddedSHArray[destBase + i] = shData[srcBase + i];\n                    }\n                }\n\n                const shTexture = new THREE.DataTexture(paddedSHArray, shTexSize.x, shTexSize.y, texelFormat, shTextureType);\n                shTexture.needsUpdate = true;\n                this.material.uniforms.sphericalHarmonicsTexture.value = shTexture;\n                this.splatDataTextures['sphericalHarmonics'] = {\n                    'componentCount': shComponentCount,\n                    'paddedComponentCount': paddedSHComponentCount,\n                    'data': paddedSHArray,\n                    'textureCount': 1,\n                    'texture': shTexture,\n                    'size': shTexSize,\n                    'compressionLevel': shCompressionLevel,\n                    'elementsPerTexel': shElementsPerTexel\n                };\n            // Use three textures for spherical harmonics data, one per color channel\n            } else {\n                const shComponentCountPerChannel = shComponentCount / 3;\n                paddedSHComponentCount = shComponentCountPerChannel;\n                if (paddedSHComponentCount % 2 !== 0) paddedSHComponentCount++;\n                shTexSize = computeDataTextureSize(shElementsPerTexel, paddedSHComponentCount);\n\n                const paddedSHArraySize = shTexSize.x * shTexSize.y * shElementsPerTexel;\n                const textureUniforms = [this.material.uniforms.sphericalHarmonicsTextureR,\n                                         this.material.uniforms.sphericalHarmonicsTextureG,\n                                         this.material.uniforms.sphericalHarmonicsTextureB];\n                const paddedSHArrays = [];\n                const shTextures = [];\n                for (let t = 0; t < 3; t++) {\n                    const paddedSHArray = new SphericalHarmonicsArrayType(paddedSHArraySize);\n                    paddedSHArrays.push(paddedSHArray);\n                    for (let c = 0; c < splatCount; c++) {\n                        const srcBase = shComponentCount * c;\n                        const destBase = paddedSHComponentCount * c;\n                        if (shComponentCountPerChannel >= 3) {\n                            for (let i = 0; i < 3; i++) paddedSHArray[destBase + i] = shData[srcBase + t * 3 + i];\n                            if (shComponentCountPerChannel >= 8) {\n                                for (let i = 0; i < 5; i++) paddedSHArray[destBase + 3 + i] = shData[srcBase + 9 + t * 5 + i];\n                            }\n                        }\n                    }\n\n                    const shTexture = new THREE.DataTexture(paddedSHArray, shTexSize.x, shTexSize.y, texelFormat, shTextureType);\n                    shTextures.push(shTexture);\n                    shTexture.needsUpdate = true;\n                    textureUniforms[t].value = shTexture;\n                }\n\n                this.material.uniforms.sphericalHarmonicsMultiTextureMode.value = 1;\n                this.splatDataTextures['sphericalHarmonics'] = {\n                    'componentCount': shComponentCount,\n                    'componentCountPerChannel': shComponentCountPerChannel,\n                    'paddedComponentCount': paddedSHComponentCount,\n                    'data': paddedSHArrays,\n                    'textureCount': 3,\n                    'textures': shTextures,\n                    'size': shTexSize,\n                    'compressionLevel': shCompressionLevel,\n                    'elementsPerTexel': shElementsPerTexel\n                };\n            }\n\n            this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(shTexSize);\n            this.material.uniforms.sphericalHarmonics8BitMode.value = shCompressionLevel === 2 ? 1 : 0;\n            for (let s = 0; s < this.scenes.length; s++) {\n                const splatBuffer = this.scenes[s].splatBuffer;\n                this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[s] =\n                    splatBuffer.minSphericalHarmonicsCoeff;\n                this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[s] =\n                    splatBuffer.maxSphericalHarmonicsCoeff;\n            }\n            this.material.uniformsNeedUpdate = true;\n        }\n\n        const sceneIndexesTexSize = computeDataTextureSize(SCENE_INDEXES_ELEMENTS_PER_TEXEL, 4);\n        const paddedTransformIndexes = new Uint32Array(sceneIndexesTexSize.x *\n                                                       sceneIndexesTexSize.y * SCENE_INDEXES_ELEMENTS_PER_TEXEL);\n        for (let c = 0; c < splatCount; c++) paddedTransformIndexes[c] = this.globalSplatIndexToSceneIndexMap[c];\n        const sceneIndexesTexture = new THREE.DataTexture(paddedTransformIndexes, sceneIndexesTexSize.x, sceneIndexesTexSize.y,\n                                                          THREE.RedIntegerFormat, THREE.UnsignedIntType);\n        sceneIndexesTexture.internalFormat = 'R32UI';\n        sceneIndexesTexture.needsUpdate = true;\n        this.material.uniforms.sceneIndexesTexture.value = sceneIndexesTexture;\n        this.material.uniforms.sceneIndexesTextureSize.value.copy(sceneIndexesTexSize);\n        this.material.uniformsNeedUpdate = true;\n        this.splatDataTextures['sceneIndexes'] = {\n            'data': paddedTransformIndexes,\n            'texture': sceneIndexesTexture,\n            'size': sceneIndexesTexSize\n        };\n        this.material.uniforms.sceneCount.value = this.scenes.length;\n    }\n\n    updateBaseDataFromSplatBuffers(fromSplat, toSplat) {\n        const covarancesTextureDesc = this.splatDataTextures['covariances'];\n        const covarianceCompressionLevel = covarancesTextureDesc ? covarancesTextureDesc.compressionLevel : undefined;\n        const scaleRotationsTextureDesc = this.splatDataTextures['scaleRotations'];\n        const scaleRotationCompressionLevel = scaleRotationsTextureDesc ? scaleRotationsTextureDesc.compressionLevel : undefined;\n        const shITextureDesc = this.splatDataTextures['sphericalHarmonics'];\n        const shCompressionLevel = shITextureDesc ? shITextureDesc.compressionLevel : 0;\n\n        this.fillSplatDataArrays(this.splatDataTextures.baseData.covariances, this.splatDataTextures.baseData.scales,\n                                 this.splatDataTextures.baseData.rotations, this.splatDataTextures.baseData.centers,\n                                 this.splatDataTextures.baseData.colors, this.splatDataTextures.baseData.sphericalHarmonics, undefined,\n                                 covarianceCompressionLevel, scaleRotationCompressionLevel, shCompressionLevel,\n                                 fromSplat, toSplat, fromSplat);\n    }\n\n    updateDataTexturesFromBaseData(fromSplat, toSplat) {\n        const covarancesTextureDesc = this.splatDataTextures['covariances'];\n        const covarianceCompressionLevel = covarancesTextureDesc ? covarancesTextureDesc.compressionLevel : undefined;\n        const scaleRotationsTextureDesc = this.splatDataTextures['scaleRotations'];\n        const scaleRotationCompressionLevel = scaleRotationsTextureDesc ? scaleRotationsTextureDesc.compressionLevel : undefined;\n        const shTextureDesc = this.splatDataTextures['sphericalHarmonics'];\n        const shCompressionLevel = shTextureDesc ? shTextureDesc.compressionLevel : 0;\n\n        // Update center & color data texture\n        const centerColorsTextureDescriptor = this.splatDataTextures['centerColors'];\n        const paddedCenterColors = centerColorsTextureDescriptor.data;\n        const centerColorsTexture = centerColorsTextureDescriptor.texture;\n        SplatMesh.updateCenterColorsPaddedData(fromSplat, toSplat, this.splatDataTextures.baseData.centers,\n                                               this.splatDataTextures.baseData.colors, paddedCenterColors);\n        const centerColorsTextureProps = this.renderer ? this.renderer.properties.get(centerColorsTexture) : null;\n        if (!centerColorsTextureProps || !centerColorsTextureProps.__webglTexture) {\n            centerColorsTexture.needsUpdate = true;\n        } else {\n            this.updateDataTexture(paddedCenterColors, centerColorsTextureDescriptor.texture, centerColorsTextureDescriptor.size,\n                                   centerColorsTextureProps, CENTER_COLORS_ELEMENTS_PER_TEXEL, CENTER_COLORS_ELEMENTS_PER_SPLAT, 4,\n                                   fromSplat, toSplat);\n        }\n\n        // update covariance data texture\n        if (covarancesTextureDesc) {\n            const covariancesTexture = covarancesTextureDesc.texture;\n            const covarancesStartElement = fromSplat * COVARIANCES_ELEMENTS_PER_SPLAT;\n            const covariancesEndElement = toSplat * COVARIANCES_ELEMENTS_PER_SPLAT;\n\n            if (covarianceCompressionLevel === 0) {\n                for (let i = covarancesStartElement; i <= covariancesEndElement; i++) {\n                    const covariance = this.splatDataTextures.baseData.covariances[i];\n                    covarancesTextureDesc.data[i] = covariance;\n                }\n            } else {\n                SplatMesh.updatePaddedCompressedCovariancesTextureData(this.splatDataTextures.baseData.covariances,\n                                                                       covarancesTextureDesc.data,\n                                                                       fromSplat * covarancesTextureDesc.elementsPerTexelAllocated,\n                                                                       covarancesStartElement, covariancesEndElement);\n            }\n\n            const covariancesTextureProps = this.renderer ? this.renderer.properties.get(covariancesTexture) : null;\n            if (!covariancesTextureProps || !covariancesTextureProps.__webglTexture) {\n                covariancesTexture.needsUpdate = true;\n            } else {\n                if (covarianceCompressionLevel === 0) {\n                    this.updateDataTexture(covarancesTextureDesc.data, covarancesTextureDesc.texture, covarancesTextureDesc.size,\n                                           covariancesTextureProps, covarancesTextureDesc.elementsPerTexelStored,\n                                           COVARIANCES_ELEMENTS_PER_SPLAT, 4, fromSplat, toSplat);\n                } else {\n                    this.updateDataTexture(covarancesTextureDesc.data, covarancesTextureDesc.texture, covarancesTextureDesc.size,\n                                           covariancesTextureProps, covarancesTextureDesc.elementsPerTexelAllocated,\n                                           covarancesTextureDesc.elementsPerTexelAllocated, 2, fromSplat, toSplat);\n                }\n            }\n        }\n\n        // update scale and rotation data texture\n        if (scaleRotationsTextureDesc) {\n            const paddedScaleRotations = scaleRotationsTextureDesc.data;\n            const scaleRotationsTexture = scaleRotationsTextureDesc.texture;\n            const elementsPerSplat = 6;\n            const bytesPerElement = scaleRotationCompressionLevel === 0 ? 4 : 2;\n\n            SplatMesh.updateScaleRotationsPaddedData(fromSplat, toSplat, this.splatDataTextures.baseData.scales,\n                                                     this.splatDataTextures.baseData.rotations, paddedScaleRotations);\n            const scaleRotationsTextureProps = this.renderer ? this.renderer.properties.get(scaleRotationsTexture) : null;\n            if (!scaleRotationsTextureProps || !scaleRotationsTextureProps.__webglTexture) {\n                scaleRotationsTexture.needsUpdate = true;\n            } else {\n                this.updateDataTexture(paddedScaleRotations, scaleRotationsTextureDesc.texture, scaleRotationsTextureDesc.size,\n                                       scaleRotationsTextureProps, SCALES_ROTATIONS_ELEMENTS_PER_TEXEL, elementsPerSplat, bytesPerElement,\n                                       fromSplat, toSplat);\n            }\n        }\n\n        // update spherical harmonics data texture\n        const shData = this.splatDataTextures.baseData.sphericalHarmonics;\n        if (shData) {\n            let shBytesPerElement = 4;\n            if (shCompressionLevel === 1) shBytesPerElement = 2;\n            else if (shCompressionLevel === 2) shBytesPerElement = 1;\n\n            const updateTexture = (shTexture, shTextureSize, elementsPerTexel, paddedSHArray, paddedSHComponentCount) => {\n                const shTextureProps = this.renderer ? this.renderer.properties.get(shTexture) : null;\n                if (!shTextureProps || !shTextureProps.__webglTexture) {\n                    shTexture.needsUpdate = true;\n                } else {\n                    this.updateDataTexture(paddedSHArray, shTexture, shTextureSize, shTextureProps, elementsPerTexel,\n                                           paddedSHComponentCount, shBytesPerElement, fromSplat, toSplat);\n                }\n            };\n\n            const shComponentCount = shTextureDesc.componentCount;\n            const paddedSHComponentCount = shTextureDesc.paddedComponentCount;\n\n            // Update for the case of a single texture for all spherical harmonics data\n            if (shTextureDesc.textureCount === 1) {\n                const paddedSHArray = shTextureDesc.data;\n                for (let c = fromSplat; c <= toSplat; c++) {\n                    const srcBase = shComponentCount * c;\n                    const destBase = paddedSHComponentCount * c;\n                    for (let i = 0; i < shComponentCount; i++) {\n                        paddedSHArray[destBase + i] = shData[srcBase + i];\n                    }\n                }\n                updateTexture(shTextureDesc.texture, shTextureDesc.size,\n                              shTextureDesc.elementsPerTexel, paddedSHArray, paddedSHComponentCount);\n            // Update for the case of spherical harmonics data split among three textures, one for each color channel\n            } else {\n                const shComponentCountPerChannel = shTextureDesc.componentCountPerChannel;\n                for (let t = 0; t < 3; t++) {\n                    const paddedSHArray = shTextureDesc.data[t];\n                    for (let c = fromSplat; c <= toSplat; c++) {\n                        const srcBase = shComponentCount * c;\n                        const destBase = paddedSHComponentCount * c;\n                        if (shComponentCountPerChannel >= 3) {\n                            for (let i = 0; i < 3; i++) paddedSHArray[destBase + i] = shData[srcBase + t * 3 + i];\n                            if (shComponentCountPerChannel >= 8) {\n                                for (let i = 0; i < 5; i++) paddedSHArray[destBase + 3 + i] = shData[srcBase + 9 + t * 5 + i];\n                            }\n                        }\n                    }\n                    updateTexture(shTextureDesc.textures[t], shTextureDesc.size,\n                                  shTextureDesc.elementsPerTexel, paddedSHArray, paddedSHComponentCount);\n                }\n            }\n        }\n\n        // update scene index & transform data\n        const sceneIndexesTexDesc = this.splatDataTextures['sceneIndexes'];\n        const paddedSceneIndexes = sceneIndexesTexDesc.data;\n        for (let c = this.lastBuildSplatCount; c <= toSplat; c++) {\n            paddedSceneIndexes[c] = this.globalSplatIndexToSceneIndexMap[c];\n        }\n        const sceneIndexesTexture = sceneIndexesTexDesc.texture;\n        const sceneIndexesTextureProps = this.renderer ? this.renderer.properties.get(sceneIndexesTexture) : null;\n        if (!sceneIndexesTextureProps || !sceneIndexesTextureProps.__webglTexture) {\n            sceneIndexesTexture.needsUpdate = true;\n        } else {\n            this.updateDataTexture(paddedSceneIndexes, sceneIndexesTexDesc.texture, sceneIndexesTexDesc.size,\n                                   sceneIndexesTextureProps, 1, 1, 1, this.lastBuildSplatCount, toSplat);\n        }\n    }\n\n    getTargetCovarianceCompressionLevel() {\n        return this.halfPrecisionCovariancesOnGPU ? 1 : 0;\n    }\n\n    getTargetSphericalHarmonicsCompressionLevel() {\n        return Math.max(1, this.getMaximumSplatBufferCompressionLevel());\n    }\n\n    getMaximumSplatBufferCompressionLevel() {\n        let maxCompressionLevel;\n        for (let i = 0; i < this.scenes.length; i++) {\n            const scene = this.getScene(i);\n            const splatBuffer = scene.splatBuffer;\n            if (i === 0 || splatBuffer.compressionLevel > maxCompressionLevel) {\n                maxCompressionLevel = splatBuffer.compressionLevel;\n            }\n        }\n        return maxCompressionLevel;\n    }\n\n    getMinimumSplatBufferCompressionLevel() {\n        let minCompressionLevel;\n        for (let i = 0; i < this.scenes.length; i++) {\n            const scene = this.getScene(i);\n            const splatBuffer = scene.splatBuffer;\n            if (i === 0 || splatBuffer.compressionLevel < minCompressionLevel) {\n                minCompressionLevel = splatBuffer.compressionLevel;\n            }\n        }\n        return minCompressionLevel;\n    }\n\n    static computeTextureUpdateRegion(startSplat, endSplat, textureWidth, elementsPerTexel, elementsPerSplat) {\n        const texelsPerSplat = elementsPerSplat / elementsPerTexel;\n\n        const startSplatTexels = startSplat * texelsPerSplat;\n        const startRow = Math.floor(startSplatTexels / textureWidth);\n        const startRowElement = startRow * textureWidth * elementsPerTexel;\n\n        const endSplatTexels = endSplat * texelsPerSplat;\n        const endRow = Math.floor(endSplatTexels / textureWidth);\n        const endRowEndElement = endRow * textureWidth * elementsPerTexel + (textureWidth * elementsPerTexel);\n\n        return {\n            'dataStart': startRowElement,\n            'dataEnd': endRowEndElement,\n            'startRow': startRow,\n            'endRow': endRow\n        };\n    }\n\n    updateDataTexture(paddedData, texture, textureSize, textureProps, elementsPerTexel, elementsPerSplat, bytesPerElement, from, to) {\n        const gl = this.renderer.getContext();\n        const updateRegion = SplatMesh.computeTextureUpdateRegion(from, to, textureSize.x, elementsPerTexel, elementsPerSplat);\n        const updateElementCount = updateRegion.dataEnd - updateRegion.dataStart;\n        const updateDataView = new paddedData.constructor(paddedData.buffer,\n                                                          updateRegion.dataStart * bytesPerElement, updateElementCount);\n        const updateHeight = updateRegion.endRow - updateRegion.startRow + 1;\n        const glType = this.webGLUtils.convert(texture.type);\n        const glFormat = this.webGLUtils.convert(texture.format, texture.colorSpace);\n        const currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\n        gl.bindTexture(gl.TEXTURE_2D, textureProps.__webglTexture);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, updateRegion.startRow,\n                         textureSize.x, updateHeight, glFormat, glType, updateDataView);\n        gl.bindTexture(gl.TEXTURE_2D, currentTexture);\n    }\n\n    static updatePaddedCompressedCovariancesTextureData(sourceData, textureData, textureDataStartIndex, fromElement, toElement) {\n        let textureDataView = new DataView(textureData.buffer);\n        let textureDataIndex = textureDataStartIndex;\n        let sequentialCount = 0;\n        for (let i = fromElement; i <= toElement; i+=2) {\n            textureDataView.setUint16(textureDataIndex * 2, sourceData[i], true);\n            textureDataView.setUint16(textureDataIndex * 2 + 2, sourceData[i + 1], true);\n            textureDataIndex += 2;\n            sequentialCount++;\n            if (sequentialCount >= 3) {\n                textureDataIndex += 2;\n                sequentialCount = 0;\n            }\n        }\n    }\n\n    static updateCenterColorsPaddedData(from, to, centers, colors, paddedCenterColors) {\n        for (let c = from; c <= to; c++) {\n            const colorsBase = c * 4;\n            const centersBase = c * 3;\n            const centerColorsBase = c * 4;\n            paddedCenterColors[centerColorsBase] = rgbaArrayToInteger(colors, colorsBase);\n            paddedCenterColors[centerColorsBase + 1] = uintEncodedFloat(centers[centersBase]);\n            paddedCenterColors[centerColorsBase + 2] = uintEncodedFloat(centers[centersBase + 1]);\n            paddedCenterColors[centerColorsBase + 3] = uintEncodedFloat(centers[centersBase + 2]);\n        }\n    }\n\n    static updateScaleRotationsPaddedData(from, to, scales, rotations, paddedScaleRotations) {\n        const combinedSize = 6;\n        for (let c = from; c <= to; c++) {\n            const scaleBase = c * 3;\n            const rotationBase = c * 4;\n            const scaleRotationsBase = c * combinedSize;\n\n            paddedScaleRotations[scaleRotationsBase] = scales[scaleBase];\n            paddedScaleRotations[scaleRotationsBase + 1] = scales[scaleBase + 1];\n            paddedScaleRotations[scaleRotationsBase + 2] = scales[scaleBase + 2];\n\n            paddedScaleRotations[scaleRotationsBase + 3] = rotations[rotationBase];\n            paddedScaleRotations[scaleRotationsBase + 4] = rotations[rotationBase + 1];\n            paddedScaleRotations[scaleRotationsBase + 5] = rotations[rotationBase + 2];\n        }\n    }\n\n    updateVisibleRegion(sinceLastBuildOnly) {\n        const splatCount = this.getSplatCount(true);\n        const tempCenter = new THREE.Vector3();\n        if (!sinceLastBuildOnly) {\n            const avgCenter = new THREE.Vector3();\n            this.scenes.forEach((scene) => {\n                avgCenter.add(scene.splatBuffer.sceneCenter);\n            });\n            avgCenter.multiplyScalar(1.0 / this.scenes.length);\n            this.calculatedSceneCenter.copy(avgCenter);\n            this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter);\n            this.material.uniformsNeedUpdate = true;\n        }\n\n        const startSplatFormMaxDistanceCalc = sinceLastBuildOnly ? this.lastBuildSplatCount : 0;\n        for (let i = startSplatFormMaxDistanceCalc; i < splatCount; i++) {\n            this.getSplatCenter(i, tempCenter, true);\n            const distFromCSceneCenter = tempCenter.sub(this.calculatedSceneCenter).length();\n            if (distFromCSceneCenter > this.maxSplatDistanceFromSceneCenter) this.maxSplatDistanceFromSceneCenter = distFromCSceneCenter;\n        }\n\n        if (this.maxSplatDistanceFromSceneCenter - this.visibleRegionBufferRadius > VISIBLE_REGION_EXPANSION_DELTA) {\n            this.visibleRegionBufferRadius = this.maxSplatDistanceFromSceneCenter;\n            this.visibleRegionRadius = Math.max(this.visibleRegionBufferRadius - VISIBLE_REGION_EXPANSION_DELTA, 0.0);\n        }\n        if (this.finalBuild) this.visibleRegionRadius = this.visibleRegionBufferRadius = this.maxSplatDistanceFromSceneCenter;\n        this.updateVisibleRegionFadeDistance();\n    }\n\n    updateVisibleRegionFadeDistance(sceneRevealMode = SceneRevealMode.Default) {\n        const fastFadeRate = SCENE_FADEIN_RATE_FAST * this.sceneFadeInRateMultiplier;\n        const gradualFadeRate = SCENE_FADEIN_RATE_GRADUAL * this.sceneFadeInRateMultiplier;\n        const defaultFadeInRate = this.finalBuild ? fastFadeRate : gradualFadeRate;\n        const fadeInRate = sceneRevealMode === SceneRevealMode.Default ? defaultFadeInRate : gradualFadeRate;\n        this.visibleRegionFadeStartRadius = (this.visibleRegionRadius - this.visibleRegionFadeStartRadius) *\n                                             fadeInRate + this.visibleRegionFadeStartRadius;\n        const fadeInPercentage = (this.visibleRegionBufferRadius > 0) ?\n                                 (this.visibleRegionFadeStartRadius / this.visibleRegionBufferRadius) : 0;\n        const fadeInComplete = fadeInPercentage > 0.99;\n        const shaderFadeInComplete = (fadeInComplete || sceneRevealMode === SceneRevealMode.Instant) ? 1 : 0;\n\n        this.material.uniforms.visibleRegionFadeStartRadius.value = this.visibleRegionFadeStartRadius;\n        this.material.uniforms.visibleRegionRadius.value = this.visibleRegionRadius;\n        this.material.uniforms.firstRenderTime.value = this.firstRenderTime;\n        this.material.uniforms.currentTime.value = performance.now();\n        this.material.uniforms.fadeInComplete.value = shaderFadeInComplete;\n        this.material.uniformsNeedUpdate = true;\n        this.visibleRegionChanging = !fadeInComplete;\n    }\n\n    /**\n     * Set the indexes of splats that should be rendered; should be sorted in desired render order.\n     * @param {Uint32Array} globalIndexes Sorted index list of splats to be rendered\n     * @param {number} renderSplatCount Total number of splats to be rendered. Necessary because we may not want to render\n     *                                  every splat.\n     */\n    updateRenderIndexes(globalIndexes, renderSplatCount) {\n        const geometry = this.geometry;\n        geometry.attributes.splatIndex.set(globalIndexes);\n        geometry.attributes.splatIndex.needsUpdate = true;\n        if (renderSplatCount > 0 && this.firstRenderTime === -1) this.firstRenderTime = performance.now();\n        geometry.instanceCount = renderSplatCount;\n        geometry.setDrawRange(0, renderSplatCount);\n    }\n\n    /**\n     * Update the transforms for each scene in this splat mesh from their individual components (position,\n     * quaternion, and scale)\n     */\n    updateTransforms() {\n        for (let i = 0; i < this.scenes.length; i++) {\n            const scene = this.getScene(i);\n            scene.updateTransform(this.dynamicMode);\n        }\n    }\n\n    updateUniforms = function() {\n\n        const viewport = new THREE.Vector2();\n\n        return function(renderDimensions, cameraFocalLengthX, cameraFocalLengthY,\n                        orthographicMode, orthographicZoom, inverseFocalAdjustment) {\n            const splatCount = this.getSplatCount();\n            if (splatCount > 0) {\n                viewport.set(renderDimensions.x * this.devicePixelRatio,\n                             renderDimensions.y * this.devicePixelRatio);\n                this.material.uniforms.viewport.value.copy(viewport);\n                this.material.uniforms.basisViewport.value.set(1.0 / viewport.x, 1.0 / viewport.y);\n                this.material.uniforms.focal.value.set(cameraFocalLengthX, cameraFocalLengthY);\n                this.material.uniforms.orthographicMode.value = orthographicMode ? 1 : 0;\n                this.material.uniforms.orthoZoom.value = orthographicZoom;\n                this.material.uniforms.inverseFocalAdjustment.value = inverseFocalAdjustment;\n                if (this.dynamicMode) {\n                    for (let i = 0; i < this.scenes.length; i++) {\n                        this.material.uniforms.transforms.value[i].copy(this.getScene(i).transform);\n                    }\n                }\n                if (this.enableOptionalEffects) {\n                    for (let i = 0; i < this.scenes.length; i++) {\n                        this.material.uniforms.sceneOpacity.value[i] = clamp(this.getScene(i).opacity, 0.0, 1.0);\n                        this.material.uniforms.sceneVisibility.value[i] = this.getScene(i).visible ? 1 : 0;\n                        this.material.uniformsNeedUpdate = true;\n                    }\n                }\n                this.material.uniformsNeedUpdate = true;\n            }\n        };\n\n    }();\n\n    setSplatScale(splatScale = 1) {\n        this.splatScale = splatScale;\n        this.material.uniforms.splatScale.value = splatScale;\n        this.material.uniformsNeedUpdate = true;\n    }\n\n    getSplatScale() {\n        return this.splatScale;\n    }\n\n    setPointCloudModeEnabled(enabled) {\n        this.pointCloudModeEnabled = enabled;\n        this.material.uniforms.pointCloudModeEnabled.value = enabled ? 1 : 0;\n        this.material.uniformsNeedUpdate = true;\n    }\n\n    getPointCloudModeEnabled() {\n        return this.pointCloudModeEnabled;\n    }\n\n    getSplatDataTextures() {\n        return this.splatDataTextures;\n    }\n\n    getSplatCount(includeSinceLastBuild = false) {\n        if (!includeSinceLastBuild) return this.lastBuildSplatCount;\n        else return SplatMesh.getTotalSplatCountForScenes(this.scenes);\n    }\n\n    static getTotalSplatCountForScenes(scenes) {\n        let totalSplatCount = 0;\n        for (let scene of scenes) {\n            if (scene && scene.splatBuffer) totalSplatCount += scene.splatBuffer.getSplatCount();\n        }\n        return totalSplatCount;\n    }\n\n    static getTotalSplatCountForSplatBuffers(splatBuffers) {\n        let totalSplatCount = 0;\n        for (let splatBuffer of splatBuffers) totalSplatCount += splatBuffer.getSplatCount();\n        return totalSplatCount;\n    }\n\n    getMaxSplatCount() {\n        return SplatMesh.getTotalMaxSplatCountForScenes(this.scenes);\n    }\n\n    static getTotalMaxSplatCountForScenes(scenes) {\n        let totalSplatCount = 0;\n        for (let scene of scenes) {\n            if (scene && scene.splatBuffer) totalSplatCount += scene.splatBuffer.getMaxSplatCount();\n        }\n        return totalSplatCount;\n    }\n\n    static getTotalMaxSplatCountForSplatBuffers(splatBuffers) {\n        let totalSplatCount = 0;\n        for (let splatBuffer of splatBuffers) totalSplatCount += splatBuffer.getMaxSplatCount();\n        return totalSplatCount;\n    }\n\n    disposeDistancesComputationGPUResources() {\n\n        if (!this.renderer) return;\n\n        const gl = this.renderer.getContext();\n\n        if (this.distancesTransformFeedback.vao) {\n            gl.deleteVertexArray(this.distancesTransformFeedback.vao);\n            this.distancesTransformFeedback.vao = null;\n        }\n        if (this.distancesTransformFeedback.program) {\n            gl.deleteProgram(this.distancesTransformFeedback.program);\n            gl.deleteShader(this.distancesTransformFeedback.vertexShader);\n            gl.deleteShader(this.distancesTransformFeedback.fragmentShader);\n            this.distancesTransformFeedback.program = null;\n            this.distancesTransformFeedback.vertexShader = null;\n            this.distancesTransformFeedback.fragmentShader = null;\n        }\n        this.disposeDistancesComputationGPUBufferResources();\n        if (this.distancesTransformFeedback.id) {\n            gl.deleteTransformFeedback(this.distancesTransformFeedback.id);\n            this.distancesTransformFeedback.id = null;\n        }\n    }\n\n    disposeDistancesComputationGPUBufferResources() {\n\n        if (!this.renderer) return;\n\n        const gl = this.renderer.getContext();\n\n        if (this.distancesTransformFeedback.centersBuffer) {\n            this.distancesTransformFeedback.centersBuffer = null;\n            gl.deleteBuffer(this.distancesTransformFeedback.centersBuffer);\n        }\n        if (this.distancesTransformFeedback.outDistancesBuffer) {\n            gl.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer);\n            this.distancesTransformFeedback.outDistancesBuffer = null;\n        }\n    }\n\n    /**\n     * Set the Three.js renderer used by this splat mesh\n     * @param {THREE.WebGLRenderer} renderer Instance of THREE.WebGLRenderer\n     */\n    setRenderer(renderer) {\n        if (renderer !== this.renderer) {\n            this.renderer = renderer;\n            const gl = this.renderer.getContext();\n            const extensions = new WebGLExtensions(gl);\n            const capabilities = new WebGLCapabilities(gl, extensions, {});\n            extensions.init(capabilities);\n            this.webGLUtils = new THREE.WebGLUtils(gl, extensions, capabilities);\n            if (this.enableDistancesComputationOnGPU && this.getSplatCount() > 0) {\n                this.setupDistancesComputationTransformFeedback();\n                const { centers, sceneIndexes } = this.getDataForDistancesComputation(0, this.getSplatCount() - 1);\n                this.refreshGPUBuffersForDistancesComputation(centers, sceneIndexes);\n            }\n        }\n    }\n\n    setupDistancesComputationTransformFeedback = function() {\n\n        let currentMaxSplatCount;\n\n        return function() {\n            const maxSplatCount = this.getMaxSplatCount();\n\n            if (!this.renderer) return;\n\n            const rebuildGPUObjects = (this.lastRenderer !== this.renderer);\n            const rebuildBuffers = currentMaxSplatCount !== maxSplatCount;\n\n            if (!rebuildGPUObjects && !rebuildBuffers) return;\n\n            if (rebuildGPUObjects) {\n                this.disposeDistancesComputationGPUResources();\n            } else if (rebuildBuffers) {\n                this.disposeDistancesComputationGPUBufferResources();\n            }\n\n            const gl = this.renderer.getContext();\n\n            const createShader = (gl, type, source) => {\n                const shader = gl.createShader(type);\n                if (!shader) {\n                    console.error('Fatal error: gl could not create a shader object.');\n                    return null;\n                }\n\n                gl.shaderSource(shader, source);\n                gl.compileShader(shader);\n\n                const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n                if (!compiled) {\n                    let typeName = 'unknown';\n                    if (type === gl.VERTEX_SHADER) typeName = 'vertex shader';\n                    else if (type === gl.FRAGMENT_SHADER) typeName = 'fragement shader';\n                    const errors = gl.getShaderInfoLog(shader);\n                    console.error('Failed to compile ' + typeName + ' with these errors:' + errors);\n                    gl.deleteShader(shader);\n                    return null;\n                }\n\n                return shader;\n            };\n\n            let vsSource;\n            if (this.integerBasedDistancesComputation) {\n                vsSource =\n                `#version 300 es\n                in ivec4 center;\n                flat out int distance;`;\n                if (this.dynamicMode) {\n                    vsSource += `\n                        in uint sceneIndex;\n                        uniform ivec4 transforms[${Constants.MaxScenes}];\n                        void main(void) {\n                            ivec4 transform = transforms[sceneIndex];\n                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;\n                        }\n                    `;\n                } else {\n                    vsSource += `\n                        uniform ivec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    `;\n                }\n            } else {\n                vsSource =\n                `#version 300 es\n                in vec4 center;\n                flat out float distance;`;\n                if (this.dynamicMode) {\n                    vsSource += `\n                        in uint sceneIndex;\n                        uniform mat4 transforms[${Constants.MaxScenes}];\n                        void main(void) {\n                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);\n                            distance = transformedCenter.z;\n                        }\n                    `;\n                } else {\n                    vsSource += `\n                        uniform vec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    `;\n                }\n            }\n\n            const fsSource =\n            `#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            `;\n\n            const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n            const currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n            const currentProgramDeleted = currentProgram ? gl.getProgramParameter(currentProgram, gl.DELETE_STATUS) : false;\n\n            if (rebuildGPUObjects) {\n                this.distancesTransformFeedback.vao = gl.createVertexArray();\n            }\n\n            gl.bindVertexArray(this.distancesTransformFeedback.vao);\n\n            if (rebuildGPUObjects) {\n                const program = gl.createProgram();\n                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);\n                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);\n                if (!vertexShader || !fragmentShader) {\n                    throw new Error('Could not compile shaders for distances computation on GPU.');\n                }\n                gl.attachShader(program, vertexShader);\n                gl.attachShader(program, fragmentShader);\n                gl.transformFeedbackVaryings(program, ['distance'], gl.SEPARATE_ATTRIBS);\n                gl.linkProgram(program);\n\n                const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n                if (!linked) {\n                    const error = gl.getProgramInfoLog(program);\n                    console.error('Fatal error: Failed to link program: ' + error);\n                    gl.deleteProgram(program);\n                    gl.deleteShader(fragmentShader);\n                    gl.deleteShader(vertexShader);\n                    throw new Error('Could not link shaders for distances computation on GPU.');\n                }\n\n                this.distancesTransformFeedback.program = program;\n                this.distancesTransformFeedback.vertexShader = vertexShader;\n                this.distancesTransformFeedback.vertexShader = fragmentShader;\n            }\n\n            gl.useProgram(this.distancesTransformFeedback.program);\n\n            this.distancesTransformFeedback.centersLoc =\n                gl.getAttribLocation(this.distancesTransformFeedback.program, 'center');\n            if (this.dynamicMode) {\n                this.distancesTransformFeedback.sceneIndexesLoc =\n                    gl.getAttribLocation(this.distancesTransformFeedback.program, 'sceneIndex');\n                for (let i = 0; i < this.scenes.length; i++) {\n                    this.distancesTransformFeedback.transformsLocs[i] =\n                        gl.getUniformLocation(this.distancesTransformFeedback.program, `transforms[${i}]`);\n                }\n            } else {\n                this.distancesTransformFeedback.modelViewProjLoc =\n                    gl.getUniformLocation(this.distancesTransformFeedback.program, 'modelViewProj');\n            }\n\n            if (rebuildGPUObjects || rebuildBuffers) {\n                this.distancesTransformFeedback.centersBuffer = gl.createBuffer();\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer);\n                gl.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc);\n                if (this.integerBasedDistancesComputation) {\n                    gl.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, gl.INT, 0, 0);\n                } else {\n                    gl.vertexAttribPointer(this.distancesTransformFeedback.centersLoc, 4, gl.FLOAT, false, 0, 0);\n                }\n\n                if (this.dynamicMode) {\n                    this.distancesTransformFeedback.sceneIndexesBuffer = gl.createBuffer();\n                    gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.sceneIndexesBuffer);\n                    gl.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc);\n                    gl.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc, 1, gl.UNSIGNED_INT, 0, 0);\n                }\n            }\n\n            if (rebuildGPUObjects || rebuildBuffers) {\n                this.distancesTransformFeedback.outDistancesBuffer = gl.createBuffer();\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.outDistancesBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, maxSplatCount * 4, gl.STATIC_READ);\n\n            if (rebuildGPUObjects) {\n                this.distancesTransformFeedback.id = gl.createTransformFeedback();\n            }\n            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id);\n            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.distancesTransformFeedback.outDistancesBuffer);\n\n            if (currentProgram && currentProgramDeleted !== true) gl.useProgram(currentProgram);\n            if (currentVao) gl.bindVertexArray(currentVao);\n\n            this.lastRenderer = this.renderer;\n            currentMaxSplatCount = maxSplatCount;\n        };\n\n    }();\n\n    /**\n     * Refresh GPU buffers used for computing splat distances with centers data from the scenes for this mesh.\n     * @param {boolean} isUpdate Specify whether or not to update the GPU buffer or to initialize & fill\n     * @param {Array<number>} centers The splat centers data\n     * @param {number} offsetSplats Offset in the GPU buffer at which to start updating data, specified in splats\n     */\n    updateGPUCentersBufferForDistancesComputation(isUpdate, centers, offsetSplats) {\n\n        if (!this.renderer) return;\n\n        const gl = this.renderer.getContext();\n\n        const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n        gl.bindVertexArray(this.distancesTransformFeedback.vao);\n\n        const ArrayType = this.integerBasedDistancesComputation ? Uint32Array : Float32Array;\n        const attributeBytesPerCenter = 16;\n        const subBufferOffset = offsetSplats * attributeBytesPerCenter;\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer);\n\n        if (isUpdate) {\n            gl.bufferSubData(gl.ARRAY_BUFFER, subBufferOffset, centers);\n        } else {\n            const maxArray = new ArrayType(this.getMaxSplatCount() * attributeBytesPerCenter);\n            maxArray.set(centers);\n            gl.bufferData(gl.ARRAY_BUFFER, maxArray, gl.STATIC_DRAW);\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n        if (currentVao) gl.bindVertexArray(currentVao);\n    }\n\n    /**\n     * Refresh GPU buffers used for pre-computing splat distances with centers data from the scenes for this mesh.\n     * @param {boolean} isUpdate Specify whether or not to update the GPU buffer or to initialize & fill\n     * @param {Array<number>} sceneIndexes The splat scene indexes\n     * @param {number} offsetSplats Offset in the GPU buffer at which to start updating data, specified in splats\n     */\n    updateGPUTransformIndexesBufferForDistancesComputation(isUpdate, sceneIndexes, offsetSplats) {\n\n        if (!this.renderer || !this.dynamicMode) return;\n\n        const gl = this.renderer.getContext();\n\n        const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n        gl.bindVertexArray(this.distancesTransformFeedback.vao);\n\n        const subBufferOffset = offsetSplats * 4;\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.sceneIndexesBuffer);\n\n        if (isUpdate) {\n            gl.bufferSubData(gl.ARRAY_BUFFER, subBufferOffset, sceneIndexes);\n        } else {\n            const maxArray = new Uint32Array(this.getMaxSplatCount() * 4);\n            maxArray.set(sceneIndexes);\n            gl.bufferData(gl.ARRAY_BUFFER, maxArray, gl.STATIC_DRAW);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n        if (currentVao) gl.bindVertexArray(currentVao);\n    }\n\n    /**\n     * Get a typed array containing a mapping from global splat indexes to their scene index.\n     * @param {number} start Starting splat index to store\n     * @param {number} end Ending splat index to store\n     * @return {Uint32Array}\n     */\n    getSceneIndexes(start, end) {\n\n        let sceneIndexes;\n        const fillCount = end - start + 1;\n        sceneIndexes = new Uint32Array(fillCount);\n        for (let i = start; i <= end; i++) {\n            sceneIndexes[i] = this.globalSplatIndexToSceneIndexMap[i];\n        }\n\n        return sceneIndexes;\n    }\n\n    /**\n     * Fill 'array' with the transforms for each scene in this splat mesh.\n     * @param {Array} array Empty array to be filled with scene transforms. If not empty, contents will be overwritten.\n     */\n    fillTransformsArray = function() {\n\n        const tempArray = [];\n\n        return function(array) {\n            if (tempArray.length !== array.length) tempArray.length = array.length;\n            for (let i = 0; i < this.scenes.length; i++) {\n                const sceneTransform = this.getScene(i).transform;\n                const sceneTransformElements = sceneTransform.elements;\n                for (let j = 0; j < 16; j++) {\n                    tempArray[i * 16 + j] = sceneTransformElements[j];\n                }\n            }\n            array.set(tempArray);\n        };\n\n    }();\n\n    computeDistancesOnGPU = function() {\n\n        const tempMatrix = new THREE.Matrix4();\n\n        return function(modelViewProjMatrix, outComputedDistances) {\n            if (!this.renderer) return;\n\n            // console.time(\"gpu_compute_distances\");\n            const gl = this.renderer.getContext();\n\n            const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n            const currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n            const currentProgramDeleted = currentProgram ? gl.getProgramParameter(currentProgram, gl.DELETE_STATUS) : false;\n\n            gl.bindVertexArray(this.distancesTransformFeedback.vao);\n            gl.useProgram(this.distancesTransformFeedback.program);\n\n            gl.enable(gl.RASTERIZER_DISCARD);\n\n            if (this.dynamicMode) {\n                for (let i = 0; i < this.scenes.length; i++) {\n                    tempMatrix.copy(this.getScene(i).transform);\n                    tempMatrix.premultiply(modelViewProjMatrix);\n\n                    if (this.integerBasedDistancesComputation) {\n                        const iTempMatrix = SplatMesh.getIntegerMatrixArray(tempMatrix);\n                        const iTransform = [iTempMatrix[2], iTempMatrix[6], iTempMatrix[10], iTempMatrix[14]];\n                        gl.uniform4i(this.distancesTransformFeedback.transformsLocs[i], iTransform[0], iTransform[1],\n                                                                                        iTransform[2], iTransform[3]);\n                    } else {\n                        gl.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[i], false, tempMatrix.elements);\n                    }\n                }\n            } else {\n                if (this.integerBasedDistancesComputation) {\n                    const iViewProjMatrix = SplatMesh.getIntegerMatrixArray(modelViewProjMatrix);\n                    const iViewProj = [iViewProjMatrix[2], iViewProjMatrix[6], iViewProjMatrix[10]];\n                    gl.uniform3i(this.distancesTransformFeedback.modelViewProjLoc, iViewProj[0], iViewProj[1], iViewProj[2]);\n                } else {\n                    const viewProj = [modelViewProjMatrix.elements[2], modelViewProjMatrix.elements[6], modelViewProjMatrix.elements[10]];\n                    gl.uniform3f(this.distancesTransformFeedback.modelViewProjLoc, viewProj[0], viewProj[1], viewProj[2]);\n                }\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer);\n            gl.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc);\n            if (this.integerBasedDistancesComputation) {\n                gl.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, gl.INT, 0, 0);\n            } else {\n                gl.vertexAttribPointer(this.distancesTransformFeedback.centersLoc, 4, gl.FLOAT, false, 0, 0);\n            }\n\n            if (this.dynamicMode) {\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.sceneIndexesBuffer);\n                gl.enableVertexAttribArray(this.distancesTransformFeedback.sceneIndexesLoc);\n                gl.vertexAttribIPointer(this.distancesTransformFeedback.sceneIndexesLoc, 1, gl.UNSIGNED_INT, 0, 0);\n            }\n\n            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id);\n            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.distancesTransformFeedback.outDistancesBuffer);\n\n            gl.beginTransformFeedback(gl.POINTS);\n            gl.drawArrays(gl.POINTS, 0, this.getSplatCount());\n            gl.endTransformFeedback();\n\n            gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);\n            gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\n            gl.disable(gl.RASTERIZER_DISCARD);\n\n            const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            gl.flush();\n\n            const promise = new Promise((resolve) => {\n                const checkSync = () => {\n                    if (this.disposed) {\n                        resolve();\n                    } else {\n                        const timeout = 0;\n                        const bitflags = 0;\n                        const status = gl.clientWaitSync(sync, bitflags, timeout);\n                        switch (status) {\n                            case gl.TIMEOUT_EXPIRED:\n                                this.computeDistancesOnGPUSyncTimeout = setTimeout(checkSync);\n                                return this.computeDistancesOnGPUSyncTimeout;\n                            case gl.WAIT_FAILED:\n                                throw new Error('should never get here');\n                            default:\n                                this.computeDistancesOnGPUSyncTimeout = null;\n                                gl.deleteSync(sync);\n                                const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n                                gl.bindVertexArray(this.distancesTransformFeedback.vao);\n                                gl.bindBuffer(gl.ARRAY_BUFFER, this.distancesTransformFeedback.outDistancesBuffer);\n                                gl.getBufferSubData(gl.ARRAY_BUFFER, 0, outComputedDistances);\n                                gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n                                if (currentVao) gl.bindVertexArray(currentVao);\n\n                                // console.timeEnd(\"gpu_compute_distances\");\n\n                                resolve();\n                        }\n                    }\n                };\n                this.computeDistancesOnGPUSyncTimeout = setTimeout(checkSync);\n            });\n\n            if (currentProgram && currentProgramDeleted !== true) gl.useProgram(currentProgram);\n            if (currentVao) gl.bindVertexArray(currentVao);\n\n            return promise;\n        };\n\n    }();\n\n    /**\n     * Given a global splat index, return corresponding local data (splat buffer, index of splat in that splat\n     * buffer, and the corresponding transform)\n     * @param {number} globalIndex Global splat index\n     * @param {object} paramsObj Object in which to store local data\n     * @param {boolean} returnSceneTransform By default, the transform of the scene to which the splat at 'globalIndex' belongs will be\n     *                                       returned via the 'sceneTransform' property of 'paramsObj' only if the splat mesh is static.\n     *                                       If 'returnSceneTransform' is true, the 'sceneTransform' property will always contain the scene\n     *                                       transform, and if 'returnSceneTransform' is false, the 'sceneTransform' property will always\n     *                                       be null.\n     */\n    getLocalSplatParameters(globalIndex, paramsObj, returnSceneTransform) {\n        if (returnSceneTransform === undefined || returnSceneTransform === null) {\n            returnSceneTransform = this.dynamicMode ? false : true;\n        }\n        paramsObj.splatBuffer = this.getSplatBufferForSplat(globalIndex);\n        paramsObj.localIndex = this.getSplatLocalIndex(globalIndex);\n        paramsObj.sceneTransform = returnSceneTransform ? this.getSceneTransformForSplat(globalIndex) : null;\n    }\n\n    /**\n     * Fill arrays with splat data and apply transforms if appropriate. Each array is optional.\n     * @param {Float32Array} covariances Target storage for splat covariances\n     * @param {Float32Array} scales Target storage for splat scales\n     * @param {Float32Array} rotations Target storage for splat rotations\n     * @param {Float32Array} centers Target storage for splat centers\n     * @param {Uint8Array} colors Target storage for splat colors\n     * @param {Float32Array} sphericalHarmonics Target storage for spherical harmonics\n     * @param {boolean} applySceneTransform By default, scene transforms are applied to relevant splat data only if the splat mesh is\n     *                                      static. If 'applySceneTransform' is true, scene transforms will always be applied and if\n     *                                      it is false, they will never be applied. If undefined, the default behavior will apply.\n     * @param {number} covarianceCompressionLevel The compression level for covariances in the destination array\n     * @param {number} sphericalHarmonicsCompressionLevel The compression level for spherical harmonics in the destination array\n     * @param {number} srcStart The start location from which to pull source data\n     * @param {number} srcEnd The end location from which to pull source data\n     * @param {number} destStart The start location from which to write data\n     */\n    fillSplatDataArrays(covariances, scales, rotations, centers, colors, sphericalHarmonics, applySceneTransform,\n                        covarianceCompressionLevel = 0, scaleRotationCompressionLevel = 0, sphericalHarmonicsCompressionLevel = 1,\n                        srcStart, srcEnd, destStart = 0, sceneIndex) {\n        const scaleOverride = new THREE.Vector3();\n        scaleOverride.x = undefined;\n        scaleOverride.y = undefined;\n        if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n            scaleOverride.z = undefined;\n        } else {\n            scaleOverride.z = 1;\n        }\n        const tempTransform = new THREE.Matrix4();\n\n        let startSceneIndex = 0;\n        let endSceneIndex = this.scenes.length - 1;\n        if (sceneIndex !== undefined && sceneIndex !== null && sceneIndex >= 0 && sceneIndex <= this.scenes.length) {\n            startSceneIndex = sceneIndex;\n            endSceneIndex = sceneIndex;\n        }\n        for (let i = startSceneIndex; i <= endSceneIndex; i++) {\n            if (applySceneTransform === undefined || applySceneTransform === null) {\n                applySceneTransform = this.dynamicMode ? false : true;\n            }\n\n            const scene = this.getScene(i);\n            const splatBuffer = scene.splatBuffer;\n            let sceneTransform;\n            if (applySceneTransform) {\n                this.getSceneTransform(i, tempTransform);\n                sceneTransform = tempTransform;\n            }\n            if (covariances) {\n                splatBuffer.fillSplatCovarianceArray(covariances, sceneTransform, srcStart, srcEnd, destStart, covarianceCompressionLevel);\n            }\n            if (scales || rotations) {\n                if (!scales || !rotations) {\n                    throw new Error('SplatMesh::fillSplatDataArrays() -> \"scales\" and \"rotations\" must both be valid.');\n                }\n                splatBuffer.fillSplatScaleRotationArray(scales, rotations, sceneTransform,\n                                                        srcStart, srcEnd, destStart, scaleRotationCompressionLevel, scaleOverride);\n            }\n            if (centers) splatBuffer.fillSplatCenterArray(centers, sceneTransform, srcStart, srcEnd, destStart);\n            if (colors) splatBuffer.fillSplatColorArray(colors, scene.minimumAlpha, srcStart, srcEnd, destStart);\n            if (sphericalHarmonics) {\n                splatBuffer.fillSphericalHarmonicsArray(sphericalHarmonics, this.minSphericalHarmonicsDegree,\n                                                        sceneTransform, srcStart, srcEnd, destStart, sphericalHarmonicsCompressionLevel);\n            }\n            destStart += splatBuffer.getSplatCount();\n        }\n    }\n\n    /**\n     * Convert splat centers, which are floating point values, to an array of integers and multiply\n     * each by 1000. Centers will get transformed as appropriate before conversion to integer.\n     * @param {number} start The index at which to start retrieving data\n     * @param {number} end The index at which to stop retrieving data\n     * @param {boolean} padFour Enforce alignment of 4 by inserting a 1 after every 3 values\n     * @return {Int32Array}\n     */\n    getIntegerCenters(start, end, padFour = false) {\n        const splatCount = end - start + 1;\n        const floatCenters = new Float32Array(splatCount * 3);\n        this.fillSplatDataArrays(null, null, null, floatCenters, null, null, undefined, undefined, undefined, undefined, start);\n        let intCenters;\n        let componentCount = padFour ? 4 : 3;\n        intCenters = new Int32Array(splatCount * componentCount);\n        for (let i = 0; i < splatCount; i++) {\n            for (let t = 0; t < 3; t++) {\n                intCenters[i * componentCount + t] = Math.round(floatCenters[i * 3 + t] * 1000.0);\n            }\n            if (padFour) intCenters[i * componentCount + 3] = 1000;\n        }\n        return intCenters;\n    }\n\n    /**\n     * Returns an array of splat centers, transformed as appropriate, optionally padded.\n     * @param {number} start The index at which to start retrieving data\n     * @param {number} end The index at which to stop retrieving data\n     * @param {boolean} padFour Enforce alignment of 4 by inserting a 1 after every 3 values\n     * @return {Float32Array}\n     */\n    getFloatCenters(start, end, padFour = false) {\n        const splatCount = end - start + 1;\n        const floatCenters = new Float32Array(splatCount * 3);\n        this.fillSplatDataArrays(null, null, null, floatCenters, null, null, undefined, undefined, undefined, undefined, start);\n        if (!padFour) return floatCenters;\n        let paddedFloatCenters = new Float32Array(splatCount * 4);\n        for (let i = 0; i < splatCount; i++) {\n            for (let t = 0; t < 3; t++) {\n                paddedFloatCenters[i * 4 + t] = floatCenters[i * 3 + t];\n            }\n            paddedFloatCenters[i * 4 + 3] = 1.0;\n        }\n        return paddedFloatCenters;\n    }\n\n    /**\n     * Get the center for a splat, transformed as appropriate.\n     * @param {number} globalIndex Global index of splat\n     * @param {THREE.Vector3} outCenter THREE.Vector3 instance in which to store splat center\n     * @param {boolean} applySceneTransform By default, if the splat mesh is static, the transform of the scene to which the splat at\n     *                                      'globalIndex' belongs will be applied to the splat center. If 'applySceneTransform' is true,\n     *                                      the scene transform will always be applied and if 'applySceneTransform' is false, the\n     *                                      scene transform will never be applied. If undefined, the default behavior will apply.\n     */\n    getSplatCenter = function() {\n\n        const paramsObj = {};\n\n        return function(globalIndex, outCenter, applySceneTransform) {\n            this.getLocalSplatParameters(globalIndex, paramsObj, applySceneTransform);\n            paramsObj.splatBuffer.getSplatCenter(paramsObj.localIndex, outCenter, paramsObj.sceneTransform);\n        };\n\n    }();\n\n    /**\n     * Get the scale and rotation for a splat, transformed as appropriate.\n     * @param {number} globalIndex Global index of splat\n     * @param {THREE.Vector3} outScale THREE.Vector3 instance in which to store splat scale\n     * @param {THREE.Quaternion} outRotation THREE.Quaternion instance in which to store splat rotation\n     * @param {boolean} applySceneTransform By default, if the splat mesh is static, the transform of the scene to which the splat at\n     *                                      'globalIndex' belongs will be applied to the splat scale and rotation. If\n     *                                      'applySceneTransform' is true, the scene transform will always be applied and if\n     *                                      'applySceneTransform' is false, the scene transform will never be applied. If undefined,\n     *                                      the default behavior will apply.\n     */\n    getSplatScaleAndRotation = function() {\n\n        const paramsObj = {};\n        const scaleOverride = new THREE.Vector3();\n\n        return function(globalIndex, outScale, outRotation, applySceneTransform) {\n            this.getLocalSplatParameters(globalIndex, paramsObj, applySceneTransform);\n            scaleOverride.x = undefined;\n            scaleOverride.y = undefined;\n            scaleOverride.z = undefined;\n            if (this.splatRenderMode === SplatRenderMode.TwoD) scaleOverride.z = 0;\n            paramsObj.splatBuffer.getSplatScaleAndRotation(paramsObj.localIndex, outScale, outRotation,\n                                                           paramsObj.sceneTransform, scaleOverride);\n        };\n\n    }();\n\n    /**\n     * Get the color for a splat.\n     * @param {number} globalIndex Global index of splat\n     * @param {THREE.Vector4} outColor THREE.Vector4 instance in which to store splat color\n     */\n    getSplatColor = function() {\n\n        const paramsObj = {};\n\n        return function(globalIndex, outColor) {\n            this.getLocalSplatParameters(globalIndex, paramsObj);\n            paramsObj.splatBuffer.getSplatColor(paramsObj.localIndex, outColor);\n        };\n\n    }();\n\n    /**\n     * Store the transform of the scene at 'sceneIndex' in 'outTransform'.\n     * @param {number} sceneIndex Index of the desired scene\n     * @param {THREE.Matrix4} outTransform Instance of THREE.Matrix4 in which to store the scene's transform\n     */\n    getSceneTransform(sceneIndex, outTransform) {\n        const scene = this.getScene(sceneIndex);\n        scene.updateTransform(this.dynamicMode);\n        outTransform.copy(scene.transform);\n    }\n\n    /**\n     * Get the scene at 'sceneIndex'.\n     * @param {number} sceneIndex Index of the desired scene\n     * @return {SplatScene}\n     */\n    getScene(sceneIndex) {\n        if (sceneIndex < 0 || sceneIndex >= this.scenes.length) {\n            throw new Error('SplatMesh::getScene() -> Invalid scene index.');\n        }\n        return this.scenes[sceneIndex];\n    }\n\n    getSceneCount() {\n        return this.scenes.length;\n    }\n\n    getSplatBufferForSplat(globalIndex) {\n        return this.getScene(this.globalSplatIndexToSceneIndexMap[globalIndex]).splatBuffer;\n    }\n\n    getSceneIndexForSplat(globalIndex) {\n        return this.globalSplatIndexToSceneIndexMap[globalIndex];\n    }\n\n    getSceneTransformForSplat(globalIndex) {\n        return this.getScene(this.globalSplatIndexToSceneIndexMap[globalIndex]).transform;\n    }\n\n    getSplatLocalIndex(globalIndex) {\n        return this.globalSplatIndexToLocalSplatIndexMap[globalIndex];\n    }\n\n    static getIntegerMatrixArray(matrix) {\n        const matrixElements = matrix.elements;\n        const intMatrixArray = [];\n        for (let i = 0; i < 16; i++) {\n            intMatrixArray[i] = Math.round(matrixElements[i] * 1000.0);\n        }\n        return intMatrixArray;\n    }\n\n    computeBoundingBox(applySceneTransforms = false, sceneIndex) {\n        let splatCount = this.getSplatCount();\n        if (sceneIndex !== undefined && sceneIndex !== null) {\n            if (sceneIndex < 0 || sceneIndex >= this.scenes.length) {\n                throw new Error('SplatMesh::computeBoundingBox() -> Invalid scene index.');\n            }\n            splatCount = this.scenes[sceneIndex].splatBuffer.getSplatCount();\n        }\n\n        const floatCenters = new Float32Array(splatCount * 3);\n        this.fillSplatDataArrays(null, null, null, floatCenters, null, null, applySceneTransforms,\n                                 undefined, undefined, undefined, undefined, sceneIndex);\n\n        const min = new THREE.Vector3();\n        const max = new THREE.Vector3();\n        for (let i = 0; i < splatCount; i++) {\n            const offset = i * 3;\n            const x = floatCenters[offset];\n            const y = floatCenters[offset + 1];\n            const z = floatCenters[offset + 2];\n            if (i === 0 || x < min.x) min.x = x;\n            if (i === 0 || y < min.y) min.y = y;\n            if (i === 0 || z < min.z) min.z = z;\n            if (i === 0 || x > max.x) max.x = x;\n            if (i === 0 || y > max.y) max.y = y;\n            if (i === 0 || z > max.z) max.z = z;\n        }\n\n        return new THREE.Box3(min, max);\n    }\n}\n\nvar SorterWasm = \"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\";\n\nvar SorterWasmNoSIMD = \"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\";\n\nvar SorterWasmNonShared = \"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\";\n\nvar SorterWasmNoSIMDNonShared = \"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\";\n\nfunction sortWorker(self) {\n\n    let wasmInstance;\n    let wasmMemory;\n    let useSharedMemory;\n    let integerBasedSort;\n    let dynamicMode;\n    let splatCount;\n    let indexesToSortOffset;\n    let sortedIndexesOffset;\n    let sceneIndexesOffset;\n    let transformsOffset;\n    let precomputedDistancesOffset;\n    let mappedDistancesOffset;\n    let frequenciesOffset;\n    let centersOffset;\n    let modelViewProjOffset;\n    let countsZero;\n    let sortedIndexesOut;\n    let distanceMapRange;\n    let uploadedSplatCount;\n    let Constants;\n\n    function sort(splatSortCount, splatRenderCount, modelViewProj,\n                  usePrecomputedDistances, copyIndexesToSort, copyPrecomputedDistances, copyTransforms) {\n        const sortStartTime = performance.now();\n\n        if (!useSharedMemory) {\n            const indexesToSort = new Uint32Array(wasmMemory, indexesToSortOffset, copyIndexesToSort.byteLength / Constants.BytesPerInt);\n            indexesToSort.set(copyIndexesToSort);\n            const transforms = new Float32Array(wasmMemory, transformsOffset, copyTransforms.byteLength / Constants.BytesPerFloat);\n            transforms.set(copyTransforms);\n            if (usePrecomputedDistances) {\n                let precomputedDistances;\n                if (integerBasedSort) {\n                    precomputedDistances = new Int32Array(wasmMemory, precomputedDistancesOffset,\n                                                          copyPrecomputedDistances.byteLength / Constants.BytesPerInt);\n                } else {\n                    precomputedDistances = new Float32Array(wasmMemory, precomputedDistancesOffset,\n                                                            copyPrecomputedDistances.byteLength / Constants.BytesPerFloat);\n                }\n                precomputedDistances.set(copyPrecomputedDistances);\n            }\n        }\n\n        if (!countsZero) countsZero = new Uint32Array(distanceMapRange);\n        new Float32Array(wasmMemory, modelViewProjOffset, 16).set(modelViewProj);\n        new Uint32Array(wasmMemory, frequenciesOffset, distanceMapRange).set(countsZero);\n        wasmInstance.exports.sortIndexes(indexesToSortOffset, centersOffset, precomputedDistancesOffset,\n                                         mappedDistancesOffset, frequenciesOffset, modelViewProjOffset,\n                                         sortedIndexesOffset, sceneIndexesOffset, transformsOffset, distanceMapRange,\n                                         splatSortCount, splatRenderCount, splatCount, usePrecomputedDistances, integerBasedSort,\n                                         dynamicMode);\n\n        const sortMessage = {\n            'sortDone': true,\n            'splatSortCount': splatSortCount,\n            'splatRenderCount': splatRenderCount,\n            'sortTime': 0\n        };\n        if (!useSharedMemory) {\n            const sortedIndexes = new Uint32Array(wasmMemory, sortedIndexesOffset, splatRenderCount);\n            if (!sortedIndexesOut || sortedIndexesOut.length < splatRenderCount) {\n                sortedIndexesOut = new Uint32Array(splatRenderCount);\n            }\n            sortedIndexesOut.set(sortedIndexes);\n            sortMessage.sortedIndexes = sortedIndexesOut;\n        }\n        const sortEndTime = performance.now();\n\n        sortMessage.sortTime = sortEndTime - sortStartTime;\n\n        self.postMessage(sortMessage);\n    }\n\n    self.onmessage = (e) => {\n        if (e.data.centers) {\n            centers = e.data.centers;\n            sceneIndexes = e.data.sceneIndexes;\n            if (integerBasedSort) {\n                new Int32Array(wasmMemory, centersOffset + e.data.range.from * Constants.BytesPerInt * 4,\n                               e.data.range.count * 4).set(new Int32Array(centers));\n            } else {\n                new Float32Array(wasmMemory, centersOffset + e.data.range.from * Constants.BytesPerFloat * 4,\n                                 e.data.range.count * 4).set(new Float32Array(centers));\n            }\n            if (dynamicMode) {\n                new Uint32Array(wasmMemory, sceneIndexesOffset + e.data.range.from * 4,\n                                e.data.range.count).set(new Uint32Array(sceneIndexes));\n            }\n            uploadedSplatCount = e.data.range.from + e.data.range.count;\n        } else if (e.data.sort) {\n            const renderCount = Math.min(e.data.sort.splatRenderCount || 0, uploadedSplatCount);\n            const sortCount = Math.min(e.data.sort.splatSortCount || 0, uploadedSplatCount);\n            const usePrecomputedDistances = e.data.sort.usePrecomputedDistances;\n\n            let copyIndexesToSort;\n            let copyPrecomputedDistances;\n            let copyTransforms;\n            if (!useSharedMemory) {\n                copyIndexesToSort = e.data.sort.indexesToSort;\n                copyTransforms = e.data.sort.transforms;\n                if (usePrecomputedDistances) copyPrecomputedDistances = e.data.sort.precomputedDistances;\n            }\n            sort(sortCount, renderCount, e.data.sort.modelViewProj, usePrecomputedDistances,\n                 copyIndexesToSort, copyPrecomputedDistances, copyTransforms);\n        } else if (e.data.init) {\n            // Yep, this is super hacky and gross :(\n            Constants = e.data.init.Constants;\n\n            splatCount = e.data.init.splatCount;\n            useSharedMemory = e.data.init.useSharedMemory;\n            integerBasedSort = e.data.init.integerBasedSort;\n            dynamicMode = e.data.init.dynamicMode;\n            distanceMapRange = e.data.init.distanceMapRange;\n            uploadedSplatCount = 0;\n\n            const CENTERS_BYTES_PER_ENTRY = integerBasedSort ? (Constants.BytesPerInt * 4) : (Constants.BytesPerFloat * 4);\n\n            const sorterWasmBytes = new Uint8Array(e.data.init.sorterWasmBytes);\n\n            const matrixSize = 16 * Constants.BytesPerFloat;\n            const memoryRequiredForIndexesToSort = splatCount * Constants.BytesPerInt;\n            const memoryRequiredForCenters = splatCount * CENTERS_BYTES_PER_ENTRY;\n            const memoryRequiredForModelViewProjectionMatrix = matrixSize;\n            const memoryRequiredForPrecomputedDistances = integerBasedSort ?\n                                                          (splatCount * Constants.BytesPerInt) : (splatCount * Constants.BytesPerFloat);\n            const memoryRequiredForMappedDistances = splatCount * Constants.BytesPerInt;\n            const memoryRequiredForSortedIndexes = splatCount * Constants.BytesPerInt;\n            const memoryRequiredForIntermediateSortBuffers = integerBasedSort ? (distanceMapRange * Constants.BytesPerInt * 2) :\n                                                                                (distanceMapRange * Constants.BytesPerFloat * 2);\n            const memoryRequiredforTransformIndexes = dynamicMode ? (splatCount * Constants.BytesPerInt) : 0;\n            const memoryRequiredforTransforms = dynamicMode ? (Constants.MaxScenes * matrixSize) : 0;\n            const extraMemory = Constants.MemoryPageSize * 32;\n\n            const totalRequiredMemory = memoryRequiredForIndexesToSort +\n                                        memoryRequiredForCenters +\n                                        memoryRequiredForModelViewProjectionMatrix +\n                                        memoryRequiredForPrecomputedDistances +\n                                        memoryRequiredForMappedDistances +\n                                        memoryRequiredForIntermediateSortBuffers +\n                                        memoryRequiredForSortedIndexes +\n                                        memoryRequiredforTransformIndexes +\n                                        memoryRequiredforTransforms +\n                                        extraMemory;\n            const totalPagesRequired = Math.floor(totalRequiredMemory / Constants.MemoryPageSize ) + 1;\n            const sorterWasmImport = {\n                module: {},\n                env: {\n                    memory: new WebAssembly.Memory({\n                        initial: totalPagesRequired,\n                        maximum: totalPagesRequired,\n                        shared: true,\n                    }),\n                }\n            };\n            WebAssembly.compile(sorterWasmBytes)\n            .then((wasmModule) => {\n                return WebAssembly.instantiate(wasmModule, sorterWasmImport);\n            })\n            .then((instance) => {\n                wasmInstance = instance;\n                indexesToSortOffset = 0;\n                centersOffset = indexesToSortOffset + memoryRequiredForIndexesToSort;\n                modelViewProjOffset = centersOffset + memoryRequiredForCenters;\n                precomputedDistancesOffset = modelViewProjOffset + memoryRequiredForModelViewProjectionMatrix;\n                mappedDistancesOffset = precomputedDistancesOffset + memoryRequiredForPrecomputedDistances;\n                frequenciesOffset = mappedDistancesOffset + memoryRequiredForMappedDistances;\n                sortedIndexesOffset = frequenciesOffset + memoryRequiredForIntermediateSortBuffers;\n                sceneIndexesOffset = sortedIndexesOffset + memoryRequiredForSortedIndexes;\n                transformsOffset = sceneIndexesOffset + memoryRequiredforTransformIndexes;\n                wasmMemory = sorterWasmImport.env.memory.buffer;\n                if (useSharedMemory) {\n                    self.postMessage({\n                        'sortSetupPhase1Complete': true,\n                        'indexesToSortBuffer': wasmMemory,\n                        'indexesToSortOffset': indexesToSortOffset,\n                        'sortedIndexesBuffer': wasmMemory,\n                        'sortedIndexesOffset': sortedIndexesOffset,\n                        'precomputedDistancesBuffer': wasmMemory,\n                        'precomputedDistancesOffset': precomputedDistancesOffset,\n                        'transformsBuffer': wasmMemory,\n                        'transformsOffset': transformsOffset\n                    });\n                } else {\n                    self.postMessage({\n                        'sortSetupPhase1Complete': true\n                    });\n                }\n            });\n        }\n    };\n}\n\nfunction createSortWorker(splatCount, useSharedMemory, enableSIMDInSort, integerBasedSort, dynamicMode,\n                                 splatSortDistanceMapPrecision = Constants.DefaultSplatSortDistanceMapPrecision) {\n    const worker = new Worker(\n        URL.createObjectURL(\n            new Blob(['(', sortWorker.toString(), ')(self)'], {\n                type: 'application/javascript',\n            }),\n        ),\n    );\n\n    let sourceWasm = SorterWasm;\n\n    // iOS makes choosing the right WebAssembly configuration tricky :(\n    const iOSSemVer = isIOS() ? getIOSSemever() : null;\n    if (!enableSIMDInSort && !useSharedMemory) {\n        sourceWasm = SorterWasmNoSIMD;\n        // Testing on various devices has shown that even when shared memory is disabled, the WASM module with shared\n        // memory can still be used most of the time -- the exception seems to be iOS devices below 16.4\n        if (iOSSemVer && iOSSemVer.major <= 16 && iOSSemVer.minor < 4) {\n            sourceWasm = SorterWasmNoSIMDNonShared;\n        }\n    } else if (!enableSIMDInSort) {\n        sourceWasm = SorterWasmNoSIMD;\n    } else if (!useSharedMemory) {\n        // Same issue with shared memory as above on iOS devices\n        if (iOSSemVer && iOSSemVer.major <= 16 && iOSSemVer.minor < 4) {\n            sourceWasm = SorterWasmNonShared;\n        }\n    }\n\n    const sorterWasmBinaryString = atob(sourceWasm);\n    const sorterWasmBytes = new Uint8Array(sorterWasmBinaryString.length);\n    for (let i = 0; i < sorterWasmBinaryString.length; i++) {\n        sorterWasmBytes[i] = sorterWasmBinaryString.charCodeAt(i);\n    }\n\n    worker.postMessage({\n        'init': {\n            'sorterWasmBytes': sorterWasmBytes.buffer,\n            'splatCount': splatCount,\n            'useSharedMemory': useSharedMemory,\n            'integerBasedSort': integerBasedSort,\n            'dynamicMode': dynamicMode,\n            'distanceMapRange': 1 << splatSortDistanceMapPrecision,\n            // Super hacky\n            'Constants': {\n                'BytesPerFloat': Constants.BytesPerFloat,\n                'BytesPerInt': Constants.BytesPerInt,\n                'MemoryPageSize': Constants.MemoryPageSize,\n                'MaxScenes': Constants.MaxScenes\n            }\n        }\n    });\n    return worker;\n}\n\nconst WebXRMode = {\n    None: 0,\n    VR: 1,\n    AR: 2\n};\n\n/*\nCopyright  2010-2024 three.js authors & Mark Kellogg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n*/\n\nclass VRButton {\n\n    static createButton( renderer, sessionInit = {} ) {\n\n        const button = document.createElement( 'button' );\n\n        function showEnterVR( /* device */ ) {\n\n            let currentSession = null;\n\n            async function onSessionStarted( session ) {\n\n                session.addEventListener( 'end', onSessionEnded );\n\n                await renderer.xr.setSession( session );\n                button.textContent = 'EXIT VR';\n\n                currentSession = session;\n\n            }\n\n            function onSessionEnded( /* event */ ) {\n\n                currentSession.removeEventListener( 'end', onSessionEnded );\n\n                button.textContent = 'ENTER VR';\n\n                currentSession = null;\n\n            }\n\n            //\n\n            button.style.display = '';\n\n            button.style.cursor = 'pointer';\n            button.style.left = 'calc(50% - 50px)';\n            button.style.width = '100px';\n\n            button.textContent = 'ENTER VR';\n\n            // WebXR's requestReferenceSpace only works if the corresponding feature\n            // was requested at session creation time. For simplicity, just ask for\n            // the interesting ones as optional features, but be aware that the\n            // requestReferenceSpace call will fail if it turns out to be unavailable.\n            // ('local' is always available for immersive sessions and doesn't need to\n            // be requested separately.)\n\n            const sessionOptions = {\n                ...sessionInit,\n                optionalFeatures: [\n                    'local-floor',\n                    'bounded-floor',\n                    'layers',\n                    ...( sessionInit.optionalFeatures || [] )\n                ],\n            };\n\n            button.onmouseenter = function() {\n\n                button.style.opacity = '1.0';\n\n            };\n\n            button.onmouseleave = function() {\n\n                button.style.opacity = '0.5';\n\n            };\n\n            button.onclick = function() {\n\n                if ( currentSession === null ) {\n\n                    navigator.xr.requestSession( 'immersive-vr', sessionOptions ).then( onSessionStarted );\n\n                } else {\n\n                    currentSession.end();\n\n                    if ( navigator.xr.offerSession !== undefined ) {\n\n                        navigator.xr.offerSession( 'immersive-vr', sessionOptions )\n                            .then( onSessionStarted )\n                            .catch( ( err ) => {\n\n                                console.warn( err );\n\n                            } );\n\n                    }\n\n                }\n\n            };\n\n            if ( navigator.xr.offerSession !== undefined ) {\n\n                navigator.xr.offerSession( 'immersive-vr', sessionOptions )\n                    .then( onSessionStarted )\n                    .catch( ( err ) => {\n\n                        console.warn( err );\n\n                    } );\n\n            }\n\n        }\n\n        function disableButton() {\n\n            button.style.display = '';\n\n            button.style.cursor = 'auto';\n            button.style.left = 'calc(50% - 75px)';\n            button.style.width = '150px';\n\n            button.onmouseenter = null;\n            button.onmouseleave = null;\n\n            button.onclick = null;\n\n        }\n\n        function showWebXRNotFound() {\n\n            disableButton();\n\n            button.textContent = 'VR NOT SUPPORTED';\n\n        }\n\n        function showVRNotAllowed( exception ) {\n\n            disableButton();\n\n            console.warn( 'Exception when trying to call xr.isSessionSupported', exception );\n\n            button.textContent = 'VR NOT ALLOWED';\n\n        }\n\n        function stylizeElement( element ) {\n\n            element.style.position = 'absolute';\n            element.style.bottom = '20px';\n            element.style.padding = '12px 6px';\n            element.style.border = '1px solid #fff';\n            element.style.borderRadius = '4px';\n            element.style.background = 'rgba(0,0,0,0.1)';\n            element.style.color = '#fff';\n            element.style.font = 'normal 13px sans-serif';\n            element.style.textAlign = 'center';\n            element.style.opacity = '0.5';\n            element.style.outline = 'none';\n            element.style.zIndex = '999';\n\n        }\n\n        if ( 'xr' in navigator ) {\n\n            button.id = 'VRButton';\n            button.style.display = 'none';\n\n            stylizeElement( button );\n\n            navigator.xr.isSessionSupported( 'immersive-vr' ).then( function( supported ) {\n\n                supported ? showEnterVR() : showWebXRNotFound();\n\n                if ( supported && VRButton.xrSessionIsGranted ) {\n\n                    button.click();\n\n                }\n\n            } ).catch( showVRNotAllowed );\n\n            return button;\n\n        } else {\n\n            const message = document.createElement( 'a' );\n\n            if ( window.isSecureContext === false ) {\n\n                message.href = document.location.href.replace( /^http:/, 'https:' );\n                message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n\n            } else {\n\n                message.href = 'https://immersiveweb.dev/';\n                message.innerHTML = 'WEBXR NOT AVAILABLE';\n\n            }\n\n            message.style.left = 'calc(50% - 90px)';\n            message.style.width = '180px';\n            message.style.textDecoration = 'none';\n\n            stylizeElement( message );\n\n            return message;\n\n        }\n\n    }\n\n    static registerSessionGrantedListener() {\n\n        if ( typeof navigator !== 'undefined' && 'xr' in navigator ) {\n\n            // WebXRViewer (based on Firefox) has a bug where addEventListener\n            // throws a silent exception and aborts execution entirely.\n            if ( /WebXRViewer\\//i.test( navigator.userAgent ) ) return;\n\n            navigator.xr.addEventListener( 'sessiongranted', () => {\n\n                VRButton.xrSessionIsGranted = true;\n\n            } );\n\n        }\n\n    }\n\n}\n\nVRButton.xrSessionIsGranted = false;\nVRButton.registerSessionGrantedListener();\n\n/*\nCopyright  2010-2024 three.js authors & Mark Kellogg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n*/\n\nclass ARButton {\n\n    static createButton( renderer, sessionInit = {} ) {\n\n        const button = document.createElement( 'button' );\n\n        function showStartAR( /* device */ ) {\n\n            if ( sessionInit.domOverlay === undefined ) {\n\n                const overlay = document.createElement( 'div' );\n                overlay.style.display = 'none';\n                document.body.appendChild( overlay );\n\n                const svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );\n                svg.setAttribute( 'width', 38 );\n                svg.setAttribute( 'height', 38 );\n                svg.style.position = 'absolute';\n                svg.style.right = '20px';\n                svg.style.top = '20px';\n                svg.addEventListener( 'click', function() {\n\n                    currentSession.end();\n\n                } );\n                overlay.appendChild( svg );\n\n                const path = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );\n                path.setAttribute( 'd', 'M 12,12 L 28,28 M 28,12 12,28' );\n                path.setAttribute( 'stroke', '#fff' );\n                path.setAttribute( 'stroke-width', 2 );\n                svg.appendChild( path );\n\n                if ( sessionInit.optionalFeatures === undefined ) {\n\n                    sessionInit.optionalFeatures = [];\n\n                }\n\n                sessionInit.optionalFeatures.push( 'dom-overlay' );\n                sessionInit.domOverlay = { root: overlay };\n\n            }\n\n            //\n\n            let currentSession = null;\n\n            async function onSessionStarted( session ) {\n\n                session.addEventListener( 'end', onSessionEnded );\n\n                renderer.xr.setReferenceSpaceType( 'local' );\n\n                await renderer.xr.setSession( session );\n\n                button.textContent = 'STOP AR';\n                sessionInit.domOverlay.root.style.display = '';\n\n                currentSession = session;\n\n            }\n\n            function onSessionEnded( /* event */ ) {\n\n                currentSession.removeEventListener( 'end', onSessionEnded );\n\n                button.textContent = 'START AR';\n                sessionInit.domOverlay.root.style.display = 'none';\n\n                currentSession = null;\n\n            }\n\n            //\n\n            button.style.display = '';\n\n            button.style.cursor = 'pointer';\n            button.style.left = 'calc(50% - 50px)';\n            button.style.width = '100px';\n\n            button.textContent = 'START AR';\n\n            button.onmouseenter = function() {\n\n                button.style.opacity = '1.0';\n\n            };\n\n            button.onmouseleave = function() {\n\n                button.style.opacity = '0.5';\n\n            };\n\n            button.onclick = function() {\n\n                if ( currentSession === null ) {\n\n                    navigator.xr.requestSession( 'immersive-ar', sessionInit ).then( onSessionStarted );\n\n                } else {\n\n                    currentSession.end();\n\n                    if ( navigator.xr.offerSession !== undefined ) {\n\n                        navigator.xr.offerSession( 'immersive-ar', sessionInit )\n                            .then( onSessionStarted )\n                            .catch( ( err ) => {\n\n                                console.warn( err );\n\n                            } );\n\n                    }\n\n                }\n\n            };\n\n            if ( navigator.xr.offerSession !== undefined ) {\n\n                navigator.xr.offerSession( 'immersive-ar', sessionInit )\n                    .then( onSessionStarted )\n                    .catch( ( err ) => {\n\n                        console.warn( err );\n\n                    } );\n\n            }\n\n        }\n\n        function disableButton() {\n\n            button.style.display = '';\n\n            button.style.cursor = 'auto';\n            button.style.left = 'calc(50% - 75px)';\n            button.style.width = '150px';\n\n            button.onmouseenter = null;\n            button.onmouseleave = null;\n\n            button.onclick = null;\n\n        }\n\n        function showARNotSupported() {\n\n            disableButton();\n\n            button.textContent = 'AR NOT SUPPORTED';\n\n        }\n\n        function showARNotAllowed( exception ) {\n\n            disableButton();\n\n            console.warn( 'Exception when trying to call xr.isSessionSupported', exception );\n\n            button.textContent = 'AR NOT ALLOWED';\n\n        }\n\n        function stylizeElement( element ) {\n\n            element.style.position = 'absolute';\n            element.style.bottom = '20px';\n            element.style.padding = '12px 6px';\n            element.style.border = '1px solid #fff';\n            element.style.borderRadius = '4px';\n            element.style.background = 'rgba(0,0,0,0.1)';\n            element.style.color = '#fff';\n            element.style.font = 'normal 13px sans-serif';\n            element.style.textAlign = 'center';\n            element.style.opacity = '0.5';\n            element.style.outline = 'none';\n            element.style.zIndex = '999';\n\n        }\n\n        if ( 'xr' in navigator ) {\n\n            button.id = 'ARButton';\n            button.style.display = 'none';\n\n            stylizeElement( button );\n\n            navigator.xr.isSessionSupported( 'immersive-ar' ).then( function( supported ) {\n\n                supported ? showStartAR() : showARNotSupported();\n\n            } ).catch( showARNotAllowed );\n\n            return button;\n\n        } else {\n\n            const message = document.createElement( 'a' );\n\n            if ( window.isSecureContext === false ) {\n\n                message.href = document.location.href.replace( /^http:/, 'https:' );\n                message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n\n            } else {\n\n                message.href = 'https://immersiveweb.dev/';\n                message.innerHTML = 'WEBXR NOT AVAILABLE';\n\n            }\n\n            message.style.left = 'calc(50% - 90px)';\n            message.style.width = '180px';\n            message.style.textDecoration = 'none';\n\n            stylizeElement( message );\n\n            return message;\n\n        }\n\n    }\n\n}\n\nconst RenderMode = {\n    Always: 0,\n    OnChange: 1,\n    Never: 2\n};\n\nconst THREE_CAMERA_FOV = 50;\nconst MINIMUM_DISTANCE_TO_NEW_FOCAL_POINT = .75;\nconst MIN_SPLAT_COUNT_TO_SHOW_SPLAT_TREE_LOADING_SPINNER = 1500000;\nconst FOCUS_MARKER_FADE_IN_SPEED = 10.0;\nconst FOCUS_MARKER_FADE_OUT_SPEED = 2.5;\nconst CONSECUTIVE_RENDERED_FRAMES_FOR_FPS_CALCULATION = 60;\n\n/**\n * Viewer: Manages the rendering of splat scenes. Manages an instance of SplatMesh as well as a web worker\n * that performs the sort for its splats.\n */\nclass Viewer {\n\n    constructor(options = {}) {\n\n        // The natural 'up' vector for viewing the scene (only has an effect when used with orbit controls and\n        // when the viewer uses its own camera).\n        if (!options.cameraUp) options.cameraUp = [0, 1, 0];\n        this.cameraUp = new THREE.Vector3().fromArray(options.cameraUp);\n\n        // The camera's initial position (only used when the viewer uses its own camera).\n        if (!options.initialCameraPosition) options.initialCameraPosition = [0, 10, 15];\n        this.initialCameraPosition = new THREE.Vector3().fromArray(options.initialCameraPosition);\n\n        // The initial focal point of the camera and center of the camera's orbit (only used when the viewer uses its own camera).\n        if (!options.initialCameraLookAt) options.initialCameraLookAt = [0, 0, 0];\n        this.initialCameraLookAt = new THREE.Vector3().fromArray(options.initialCameraLookAt);\n\n        // 'dropInMode' is a flag that is used internally to support the usage of the viewer as a Three.js scene object\n        this.dropInMode = options.dropInMode || false;\n\n        // If 'selfDrivenMode' is true, the viewer manages its own update/animation loop via requestAnimationFrame()\n        if (options.selfDrivenMode === undefined || options.selfDrivenMode === null) options.selfDrivenMode = true;\n        this.selfDrivenMode = options.selfDrivenMode && !this.dropInMode;\n        this.selfDrivenUpdateFunc = this.selfDrivenUpdate.bind(this);\n\n        // If 'useBuiltInControls' is true, the viewer will create its own instance of OrbitControls and attach to the camera\n        if (options.useBuiltInControls === undefined) options.useBuiltInControls = true;\n        this.useBuiltInControls = options.useBuiltInControls;\n\n        // parent element of the Three.js renderer canvas\n        this.rootElement = options.rootElement;\n\n        // Tells the viewer to pretend the device pixel ratio is 1, which can boost performance on devices where it is larger,\n        // at a small cost to visual quality\n        this.ignoreDevicePixelRatio = options.ignoreDevicePixelRatio || false;\n        this.devicePixelRatio = this.ignoreDevicePixelRatio ? 1 : (window.devicePixelRatio || 1);\n\n        // Tells the viewer to use 16-bit floating point values when storing splat covariance data in textures, instead of 32-bit\n        this.halfPrecisionCovariancesOnGPU = options.halfPrecisionCovariancesOnGPU || false;\n\n        // If 'threeScene' is valid, it will be rendered by the viewer along with the splat mesh\n        this.threeScene = options.threeScene;\n        // Allows for usage of an external Three.js renderer\n        this.renderer = options.renderer;\n        // Allows for usage of an external Three.js camera\n        this.camera = options.camera;\n\n        // If 'gpuAcceleratedSort' is true, a partially GPU-accelerated approach to sorting splats will be used.\n        // Currently this means pre-computing splat distances from the camera on the GPU\n        this.gpuAcceleratedSort = options.gpuAcceleratedSort || false;\n\n        // if 'integerBasedSort' is true, the integer version of splat centers as well as other values used to calculate\n        // splat distances are used instead of the float version. This speeds up computation, but introduces the possibility of\n        // overflow in larger scenes.\n        if (options.integerBasedSort === undefined || options.integerBasedSort === null) {\n            options.integerBasedSort = true;\n        }\n        this.integerBasedSort = options.integerBasedSort;\n\n        // If 'sharedMemoryForWorkers' is true, a SharedArrayBuffer will be used to communicate with web workers. This method\n        // is faster than copying memory to or from web workers, but comes with security implications as outlined here:\n        // https://web.dev/articles/cross-origin-isolation-guide\n        // If enabled, it requires specific CORS headers to be present in the response from the server that is sent when\n        // loading the application. More information is available in the README.\n        if (options.sharedMemoryForWorkers === undefined || options.sharedMemoryForWorkers === null) options.sharedMemoryForWorkers = true;\n        this.sharedMemoryForWorkers = options.sharedMemoryForWorkers;\n\n        // if 'dynamicScene' is true, it tells the viewer to assume scene elements are not stationary or that the number of splats in the\n        // scene may change. This prevents optimizations that depend on a static scene from being made. Additionally, if 'dynamicScene' is\n        // true it tells the splat mesh to not apply scene tranforms to splat data that is returned by functions like\n        // SplatMesh.getSplatCenter() by default.\n        this.dynamicScene = !!options.dynamicScene;\n\n        // When true, will perform additional steps during rendering to address artifacts caused by the rendering of gaussians at a\n        // substantially different resolution than that at which they were rendered during training. This will only work correctly\n        // for models that were trained using a process that utilizes this compensation calculation. For more details:\n        // https://github.com/nerfstudio-project/gsplat/pull/117\n        // https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093\n        this.antialiased = options.antialiased || false;\n\n        // This constant is added to the projected 2D screen-space splat scales\n        this.kernel2DSize = (options.kernel2DSize === undefined) ? 0.3 : options.kernel2DSize;\n\n        this.webXRMode = options.webXRMode || WebXRMode.None;\n        if (this.webXRMode !== WebXRMode.None) {\n            this.gpuAcceleratedSort = false;\n        }\n        this.webXRActive = false;\n\n        this.webXRSessionInit = options.webXRSessionInit || {};\n\n        // if 'renderMode' is RenderMode.Always, then the viewer will rrender the scene on every update. If it is RenderMode.OnChange,\n        // it will only render when something in the scene has changed.\n        this.renderMode = options.renderMode || RenderMode.Always;\n\n        // SceneRevealMode.Default results in a nice, slow fade-in effect for progressively loaded scenes,\n        // and a fast fade-in for non progressively loaded scenes.\n        // SceneRevealMode.Gradual will force a slow fade-in for all scenes.\n        // SceneRevealMode.Instant will force all loaded scene data to be immediately visible.\n        this.sceneRevealMode = options.sceneRevealMode || SceneRevealMode.Default;\n\n        // Hacky, experimental, non-scientific parameter for tweaking focal length related calculations. For scenes with very\n        // small gaussians, small details, and small dimensions -- increasing this value can help improve visual quality.\n        this.focalAdjustment = options.focalAdjustment || 1.0;\n\n        // Specify the maximum screen-space splat size, can help deal with large splats that get too unwieldy\n        this.maxScreenSpaceSplatSize = options.maxScreenSpaceSplatSize || 1024;\n\n        // The verbosity of console logging\n        this.logLevel = options.logLevel || LogLevel.None;\n\n        // Degree of spherical harmonics to utilize in rendering splats (assuming the data is present in the splat scene).\n        // Valid values are 0 - 2. Default value is 0.\n        this.sphericalHarmonicsDegree = options.sphericalHarmonicsDegree || 0;\n\n        // When true, allows for usage of extra properties and attributes during rendering for effects such as opacity adjustment.\n        // Default is false for performance reasons. These properties are separate from transform properties (scale, rotation, position)\n        // that are enabled by the 'dynamicScene' parameter.\n        this.enableOptionalEffects = options.enableOptionalEffects || false;\n\n        // Enable the usage of SIMD WebAssembly instructions for the splat sort\n        if (options.enableSIMDInSort === undefined || options.enableSIMDInSort === null) options.enableSIMDInSort = true;\n        this.enableSIMDInSort = options.enableSIMDInSort;\n\n        // Level to compress non KSPLAT files when loading them for direct rendering\n        if (options.inMemoryCompressionLevel === undefined || options.inMemoryCompressionLevel === null) {\n            options.inMemoryCompressionLevel = 0;\n        }\n        this.inMemoryCompressionLevel = options.inMemoryCompressionLevel;\n\n        // Reorder splat data in memory after loading is complete to optimize cache utilization. Default is true.\n        // Does not apply if splat scene is progressively loaded.\n        if (options.optimizeSplatData === undefined || options.optimizeSplatData === null) {\n            options.optimizeSplatData = true;\n        }\n        this.optimizeSplatData = options.optimizeSplatData;\n\n        // When true, the intermediate splat data that is the result of decompressing splat bufffer(s) and is used to\n        // populate the data textures will be freed. This will reduces memory usage, but if that data needs to be modified\n        // it will need to be re-populated from the splat buffer(s). Default is false.\n        if (options.freeIntermediateSplatData === undefined || options.freeIntermediateSplatData === null) {\n            options.freeIntermediateSplatData = false;\n        }\n        this.freeIntermediateSplatData = options.freeIntermediateSplatData;\n\n        // It appears that for certain iOS versions, special actions need to be taken with the\n        // usage of SIMD instructions and shared memory\n        if (isIOS()) {\n            const semver = getIOSSemever();\n            if (semver.major < 17) {\n                this.enableSIMDInSort = false;\n            }\n            if (semver.major < 16) {\n                this.sharedMemoryForWorkers = false;\n            }\n        }\n\n        // Tell the viewer how to render the splats\n        if (options.splatRenderMode === undefined || options.splatRenderMode === null) {\n            options.splatRenderMode = SplatRenderMode.ThreeD;\n        }\n        this.splatRenderMode = options.splatRenderMode;\n\n        // Customize the speed at which the scene is revealed\n        this.sceneFadeInRateMultiplier = options.sceneFadeInRateMultiplier || 1.0;\n\n        // Set the range for the depth map for the counting sort used to sort the splats\n        this.splatSortDistanceMapPrecision = options.splatSortDistanceMapPrecision || Constants.DefaultSplatSortDistanceMapPrecision;\n        const maxPrecision = this.integerBasedSort ? 20 : 24;\n        this.splatSortDistanceMapPrecision = clamp(this.splatSortDistanceMapPrecision, 10, maxPrecision);\n\n        this.onSplatMeshChangedCallback = null;\n        this.createSplatMesh();\n\n        this.controls = null;\n        this.perspectiveControls = null;\n        this.orthographicControls = null;\n\n        this.orthographicCamera = null;\n        this.perspectiveCamera = null;\n\n        this.showMeshCursor = false;\n        this.showControlPlane = false;\n        this.showInfo = false;\n\n        this.sceneHelper = null;\n\n        this.sortWorker = null;\n        this.sortRunning = false;\n        this.splatRenderCount = 0;\n        this.splatSortCount = 0;\n        this.lastSplatSortCount = 0;\n        this.sortWorkerIndexesToSort = null;\n        this.sortWorkerSortedIndexes = null;\n        this.sortWorkerPrecomputedDistances = null;\n        this.sortWorkerTransforms = null;\n        this.preSortMessages = [];\n        this.runAfterNextSort = [];\n\n        this.selfDrivenModeRunning = false;\n        this.splatRenderReady = false;\n\n        this.raycaster = new Raycaster();\n\n        this.infoPanel = null;\n\n        this.startInOrthographicMode = false;\n\n        this.currentFPS = 0;\n        this.lastSortTime = 0;\n        this.consecutiveRenderFrames = 0;\n\n        this.previousCameraTarget = new THREE.Vector3();\n        this.nextCameraTarget = new THREE.Vector3();\n\n        this.mousePosition = new THREE.Vector2();\n        this.mouseDownPosition = new THREE.Vector2();\n        this.mouseDownTime = null;\n\n        this.resizeObserver = null;\n        this.mouseMoveListener = null;\n        this.mouseDownListener = null;\n        this.mouseUpListener = null;\n        this.keyDownListener = null;\n\n        this.sortPromise = null;\n        this.sortPromiseResolver = null;\n        this.splatSceneDownloadPromises = {};\n        this.splatSceneDownloadAndBuildPromise = null;\n        this.splatSceneRemovalPromise = null;\n\n        this.loadingSpinner = new LoadingSpinner(null, this.rootElement || document.body);\n        this.loadingSpinner.hide();\n        this.loadingProgressBar = new LoadingProgressBar(this.rootElement || document.body);\n        this.loadingProgressBar.hide();\n        this.infoPanel = new InfoPanel(this.rootElement || document.body);\n        this.infoPanel.hide();\n\n        this.usingExternalCamera = (this.dropInMode || this.camera) ? true : false;\n        this.usingExternalRenderer = (this.dropInMode || this.renderer) ? true : false;\n\n        this.initialized = false;\n        this.disposing = false;\n        this.disposed = false;\n        this.disposePromise = null;\n        if (!this.dropInMode) this.init();\n    }\n\n    createSplatMesh() {\n        this.splatMesh = new SplatMesh(this.splatRenderMode, this.dynamicScene, this.enableOptionalEffects,\n                                       this.halfPrecisionCovariancesOnGPU, this.devicePixelRatio, this.gpuAcceleratedSort,\n                                       this.integerBasedSort, this.antialiased, this.maxScreenSpaceSplatSize, this.logLevel,\n                                       this.sphericalHarmonicsDegree, this.sceneFadeInRateMultiplier, this.kernel2DSize);\n        this.splatMesh.frustumCulled = false;\n        if (this.onSplatMeshChangedCallback) this.onSplatMeshChangedCallback();\n    }\n\n    init() {\n\n        if (this.initialized) return;\n\n        if (!this.rootElement) {\n            if (!this.usingExternalRenderer) {\n                this.rootElement = document.createElement('div');\n                this.rootElement.style.width = '100%';\n                this.rootElement.style.height = '100%';\n                this.rootElement.style.position = 'absolute';\n                document.body.appendChild(this.rootElement);\n            } else {\n                this.rootElement = this.renderer.domElement || document.body;\n            }\n        }\n\n        this.setupCamera();\n        this.setupRenderer();\n        this.setupWebXR(this.webXRSessionInit);\n        this.setupControls();\n        this.setupEventHandlers();\n\n        this.threeScene = this.threeScene || new THREE.Scene();\n        this.sceneHelper = new SceneHelper(this.threeScene);\n        this.sceneHelper.setupMeshCursor();\n        this.sceneHelper.setupFocusMarker();\n        this.sceneHelper.setupControlPlane();\n\n        this.loadingProgressBar.setContainer(this.rootElement);\n        this.loadingSpinner.setContainer(this.rootElement);\n        this.infoPanel.setContainer(this.rootElement);\n\n        this.initialized = true;\n    }\n\n    setupCamera() {\n        if (!this.usingExternalCamera) {\n            const renderDimensions = new THREE.Vector2();\n            this.getRenderDimensions(renderDimensions);\n\n            this.perspectiveCamera = new THREE.PerspectiveCamera(THREE_CAMERA_FOV, renderDimensions.x / renderDimensions.y, 0.1, 1000);\n            this.orthographicCamera = new THREE.OrthographicCamera(renderDimensions.x / -2, renderDimensions.x / 2,\n                                                                   renderDimensions.y / 2, renderDimensions.y / -2, 0.1, 1000 );\n            this.camera = this.startInOrthographicMode ? this.orthographicCamera : this.perspectiveCamera;\n            this.camera.position.copy(this.initialCameraPosition);\n            this.camera.up.copy(this.cameraUp).normalize();\n            this.camera.lookAt(this.initialCameraLookAt);\n        }\n    }\n\n    setupRenderer() {\n        if (!this.usingExternalRenderer) {\n            const renderDimensions = new THREE.Vector2();\n            this.getRenderDimensions(renderDimensions);\n\n            this.renderer = new THREE.WebGLRenderer({\n                antialias: false,\n                precision: 'highp'\n            });\n            this.renderer.setPixelRatio(this.devicePixelRatio);\n            this.renderer.autoClear = true;\n            this.renderer.setClearColor(new THREE.Color( 0x000000 ), 0.0);\n            this.renderer.setSize(renderDimensions.x, renderDimensions.y);\n\n            this.resizeObserver = new ResizeObserver(() => {\n                this.getRenderDimensions(renderDimensions);\n                this.renderer.setSize(renderDimensions.x, renderDimensions.y);\n                this.forceRenderNextFrame();\n            });\n            this.resizeObserver.observe(this.rootElement);\n            this.rootElement.appendChild(this.renderer.domElement);\n        }\n\n    }\n\n    setupWebXR(webXRSessionInit) {\n        if (this.webXRMode) {\n            if (this.webXRMode === WebXRMode.VR) {\n                this.rootElement.appendChild(VRButton.createButton(this.renderer, webXRSessionInit));\n            } else if (this.webXRMode === WebXRMode.AR) {\n                this.rootElement.appendChild(ARButton.createButton(this.renderer, webXRSessionInit));\n            }\n            this.renderer.xr.addEventListener('sessionstart', (e) => {\n                this.webXRActive = true;\n            });\n            this.renderer.xr.addEventListener('sessionend', (e) => {\n                this.webXRActive = false;\n            });\n            this.renderer.xr.enabled = true;\n            this.camera.position.copy(this.initialCameraPosition);\n            this.camera.up.copy(this.cameraUp).normalize();\n            this.camera.lookAt(this.initialCameraLookAt);\n        }\n    }\n\n    setupControls() {\n        if (this.useBuiltInControls && this.webXRMode === WebXRMode.None) {\n            if (!this.usingExternalCamera) {\n                this.perspectiveControls = new OrbitControls(this.perspectiveCamera, this.renderer.domElement);\n                this.orthographicControls = new OrbitControls(this.orthographicCamera, this.renderer.domElement);\n            } else {\n                if (this.camera.isOrthographicCamera) {\n                    this.orthographicControls = new OrbitControls(this.camera, this.renderer.domElement);\n                } else {\n                    this.perspectiveControls = new OrbitControls(this.camera, this.renderer.domElement);\n                }\n            }\n            for (let controls of [this.orthographicControls, this.perspectiveControls,]) {\n                if (controls) {\n                    controls.listenToKeyEvents(window);\n                    controls.rotateSpeed = 0.5;\n                    controls.maxPolarAngle = Math.PI * .75;\n                    controls.minPolarAngle = 0.1;\n                    controls.enableDamping = true;\n                    controls.dampingFactor = 0.05;\n                    controls.target.copy(this.initialCameraLookAt);\n                    controls.update();\n                }\n            }\n            this.controls = this.camera.isOrthographicCamera ? this.orthographicControls : this.perspectiveControls;\n            this.controls.update();\n        }\n    }\n\n    setupEventHandlers() {\n        if (this.useBuiltInControls && this.webXRMode === WebXRMode.None) {\n            this.mouseMoveListener = this.onMouseMove.bind(this);\n            this.renderer.domElement.addEventListener('pointermove', this.mouseMoveListener, false);\n            this.mouseDownListener = this.onMouseDown.bind(this);\n            this.renderer.domElement.addEventListener('pointerdown', this.mouseDownListener, false);\n            this.mouseUpListener = this.onMouseUp.bind(this);\n            this.renderer.domElement.addEventListener('pointerup', this.mouseUpListener, false);\n            this.keyDownListener = this.onKeyDown.bind(this);\n            window.addEventListener('keydown', this.keyDownListener, false);\n        }\n    }\n\n    removeEventHandlers() {\n        if (this.useBuiltInControls) {\n            this.renderer.domElement.removeEventListener('pointermove', this.mouseMoveListener);\n            this.mouseMoveListener = null;\n            this.renderer.domElement.removeEventListener('pointerdown', this.mouseDownListener);\n            this.mouseDownListener = null;\n            this.renderer.domElement.removeEventListener('pointerup', this.mouseUpListener);\n            this.mouseUpListener = null;\n            window.removeEventListener('keydown', this.keyDownListener);\n            this.keyDownListener = null;\n        }\n    }\n\n    setRenderMode(renderMode) {\n        this.renderMode = renderMode;\n    }\n\n    setActiveSphericalHarmonicsDegrees(activeSphericalHarmonicsDegrees) {\n        this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value = activeSphericalHarmonicsDegrees;\n        this.splatMesh.material.uniformsNeedUpdate = true;\n    }\n\n    onSplatMeshChanged(callback) {\n        this.onSplatMeshChangedCallback = callback;\n    }\n\n    onKeyDown = function() {\n\n        const forward = new THREE.Vector3();\n        const tempMatrixLeft = new THREE.Matrix4();\n        const tempMatrixRight = new THREE.Matrix4();\n\n        return function(e) {\n            forward.set(0, 0, -1);\n            forward.transformDirection(this.camera.matrixWorld);\n            tempMatrixLeft.makeRotationAxis(forward, Math.PI / 128);\n            tempMatrixRight.makeRotationAxis(forward, -Math.PI / 128);\n            switch (e.code) {\n                case 'KeyG':\n                    this.focalAdjustment += 0.02;\n                    this.forceRenderNextFrame();\n                break;\n                case 'KeyF':\n                    this.focalAdjustment -= 0.02;\n                    this.forceRenderNextFrame();\n                break;\n                case 'ArrowLeft':\n                    this.camera.up.transformDirection(tempMatrixLeft);\n                break;\n                case 'ArrowRight':\n                    this.camera.up.transformDirection(tempMatrixRight);\n                break;\n                case 'KeyC':\n                    this.showMeshCursor = !this.showMeshCursor;\n                break;\n                case 'KeyU':\n                    this.showControlPlane = !this.showControlPlane;\n                break;\n                case 'KeyI':\n                    this.showInfo = !this.showInfo;\n                    if (this.showInfo) {\n                        this.infoPanel.show();\n                    } else {\n                        this.infoPanel.hide();\n                    }\n                break;\n                case 'KeyO':\n                    if (!this.usingExternalCamera) {\n                        this.setOrthographicMode(!this.camera.isOrthographicCamera);\n                    }\n                break;\n                case 'KeyP':\n                    if (!this.usingExternalCamera) {\n                        this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());\n                    }\n                break;\n                case 'Equal':\n                    if (!this.usingExternalCamera) {\n                        this.splatMesh.setSplatScale(this.splatMesh.getSplatScale() + 0.05);\n                    }\n                break;\n                case 'Minus':\n                    if (!this.usingExternalCamera) {\n                        this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale() - 0.05, 0.0));\n                    }\n                break;\n            }\n        };\n\n    }();\n\n    onMouseMove(mouse) {\n        this.mousePosition.set(mouse.offsetX, mouse.offsetY);\n    }\n\n    onMouseDown() {\n        this.mouseDownPosition.copy(this.mousePosition);\n        this.mouseDownTime = getCurrentTime();\n    }\n\n    onMouseUp = function() {\n\n        const clickOffset = new THREE.Vector2();\n\n        return function(mouse) {\n            clickOffset.copy(this.mousePosition).sub(this.mouseDownPosition);\n            const mouseUpTime = getCurrentTime();\n            const wasClick = mouseUpTime - this.mouseDownTime < 0.5 && clickOffset.length() < 2;\n            if (wasClick) {\n                this.onMouseClick(mouse);\n            }\n        };\n\n    }();\n\n    onMouseClick(mouse) {\n        this.mousePosition.set(mouse.offsetX, mouse.offsetY);\n        this.checkForFocalPointChange();\n    }\n\n    checkForFocalPointChange = function() {\n\n        const renderDimensions = new THREE.Vector2();\n        const toNewFocalPoint = new THREE.Vector3();\n        const outHits = [];\n\n        return function() {\n            if (!this.transitioningCameraTarget) {\n                this.getRenderDimensions(renderDimensions);\n                outHits.length = 0;\n                this.raycaster.setFromCameraAndScreenPosition(this.camera, this.mousePosition, renderDimensions);\n                this.raycaster.intersectSplatMesh(this.splatMesh, outHits);\n                if (outHits.length > 0) {\n                    const hit = outHits[0];\n                    const intersectionPoint = hit.origin;\n                    toNewFocalPoint.copy(intersectionPoint).sub(this.camera.position);\n                    if (toNewFocalPoint.length() > MINIMUM_DISTANCE_TO_NEW_FOCAL_POINT) {\n                        this.previousCameraTarget.copy(this.controls.target);\n                        this.nextCameraTarget.copy(intersectionPoint);\n                        this.transitioningCameraTarget = true;\n                        this.transitioningCameraTargetStartTime = getCurrentTime();\n                    }\n                }\n            }\n        };\n\n    }();\n\n    getRenderDimensions(outDimensions) {\n        if (this.rootElement) {\n            outDimensions.x = this.rootElement.offsetWidth;\n            outDimensions.y = this.rootElement.offsetHeight;\n        } else {\n            this.renderer.getSize(outDimensions);\n        }\n    }\n\n    setOrthographicMode(orthographicMode) {\n        if (orthographicMode === this.camera.isOrthographicCamera) return;\n        const fromCamera = this.camera;\n        const toCamera = orthographicMode ? this.orthographicCamera : this.perspectiveCamera;\n        toCamera.position.copy(fromCamera.position);\n        toCamera.up.copy(fromCamera.up);\n        toCamera.rotation.copy(fromCamera.rotation);\n        toCamera.quaternion.copy(fromCamera.quaternion);\n        toCamera.matrix.copy(fromCamera.matrix);\n        this.camera = toCamera;\n\n        if (this.controls) {\n\n            const resetControls = (controls) => {\n                controls.saveState();\n                controls.reset();\n            };\n\n            const fromControls = this.controls;\n            const toControls = orthographicMode ? this.orthographicControls : this.perspectiveControls;\n\n            resetControls(toControls);\n            resetControls(fromControls);\n\n            toControls.target.copy(fromControls.target);\n            if (orthographicMode) {\n                Viewer.setCameraZoomFromPosition(toCamera, fromCamera, fromControls);\n            } else {\n                Viewer.setCameraPositionFromZoom(toCamera, fromCamera, toControls);\n            }\n            this.controls = toControls;\n            this.camera.lookAt(this.controls.target);\n        }\n    }\n\n    static setCameraPositionFromZoom = function() {\n\n        const tempVector = new THREE.Vector3();\n\n        return function(positionCamera, zoomedCamera, controls) {\n            const toLookAtDistance = 1 / (zoomedCamera.zoom * 0.001);\n            tempVector.copy(controls.target).sub(positionCamera.position).normalize().multiplyScalar(toLookAtDistance).negate();\n            positionCamera.position.copy(controls.target).add(tempVector);\n        };\n\n    }();\n\n\n    static setCameraZoomFromPosition = function() {\n\n        const tempVector = new THREE.Vector3();\n\n        return function(zoomCamera, positionZamera, controls) {\n            const toLookAtDistance = tempVector.copy(controls.target).sub(positionZamera.position).length();\n            zoomCamera.zoom = 1 / (toLookAtDistance * .001);\n        };\n\n    }();\n\n    updateSplatMesh = function() {\n\n        const renderDimensions = new THREE.Vector2();\n\n        return function() {\n            if (!this.splatMesh) return;\n            const splatCount = this.splatMesh.getSplatCount();\n            if (splatCount > 0) {\n                this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode);\n                this.splatMesh.updateTransforms();\n                this.getRenderDimensions(renderDimensions);\n                const focalLengthX = this.camera.projectionMatrix.elements[0] * 0.5 *\n                                     this.devicePixelRatio * renderDimensions.x;\n                const focalLengthY = this.camera.projectionMatrix.elements[5] * 0.5 *\n                                     this.devicePixelRatio * renderDimensions.y;\n\n                const focalMultiplier = this.camera.isOrthographicCamera ? (1.0 / this.devicePixelRatio) : 1.0;\n                const focalAdjustment = this.focalAdjustment * focalMultiplier;\n                const inverseFocalAdjustment = 1.0 / focalAdjustment;\n\n                this.adjustForWebXRStereo(renderDimensions);\n                this.splatMesh.updateUniforms(renderDimensions, focalLengthX * focalAdjustment, focalLengthY * focalAdjustment,\n                                              this.camera.isOrthographicCamera, this.camera.zoom || 1.0, inverseFocalAdjustment);\n            }\n        };\n\n    }();\n\n    adjustForWebXRStereo(renderDimensions) {\n        // TODO: Figure out a less hacky way to determine if stereo rendering is active\n        if (this.camera && this.webXRActive) {\n            const xrCamera = this.renderer.xr.getCamera();\n            const xrCameraProj00 = xrCamera.projectionMatrix.elements[0];\n            const cameraProj00 = this.camera.projectionMatrix.elements[0];\n            renderDimensions.x *= (cameraProj00 / xrCameraProj00);\n        }\n    }\n\n    isLoadingOrUnloading() {\n        return Object.keys(this.splatSceneDownloadPromises).length > 0 || this.splatSceneDownloadAndBuildPromise !== null ||\n                           this.splatSceneRemovalPromise !== null;\n    }\n\n    isDisposingOrDisposed() {\n        return this.disposing || this.disposed;\n    }\n\n    addSplatSceneDownloadPromise(promise) {\n        this.splatSceneDownloadPromises[promise.id] = promise;\n    }\n\n    removeSplatSceneDownloadPromise(promise) {\n        delete this.splatSceneDownloadPromises[promise.id];\n    }\n\n    setSplatSceneDownloadAndBuildPromise(promise) {\n        this.splatSceneDownloadAndBuildPromise = promise;\n    }\n\n    clearSplatSceneDownloadAndBuildPromise() {\n        this.splatSceneDownloadAndBuildPromise = null;\n    }\n\n    /**\n     * Add a splat scene to the viewer and display any loading UI if appropriate.\n     * @param {string} path Path to splat scene to be loaded\n     * @param {object} options {\n     *\n     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n     *                                     value (valid range: 0 - 255), defaults to 1\n     *\n     *         showLoadingUI:         Display a loading spinner while the scene is loading, defaults to true\n     *\n     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n     *\n     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n     *\n     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n     *\n     *         onProgress:                 Function to be called as file data are received, or other processing occurs\n     *\n     *         headers:                    Optional HTTP headers to be sent along with splat requests\n     * }\n     * @return {AbortablePromise}\n     */\n    addSplatScene(path, options = {}) {\n\n        if (this.isLoadingOrUnloading()) {\n            throw new Error('Cannot add splat scene while another load or unload is already in progress.');\n        }\n\n        if (this.isDisposingOrDisposed()) {\n            throw new Error('Cannot add splat scene after dispose() is called.');\n        }\n\n        if (options.progressiveLoad && this.splatMesh.scenes && this.splatMesh.scenes.length > 0) {\n            console.log('addSplatScene(): \"progressiveLoad\" option ignore because there are multiple splat scenes');\n            options.progressiveLoad = false;\n        }\n\n        const format = (options.format !== undefined && options.format !== null) ? options.format : sceneFormatFromPath(path);\n        const progressiveLoad = Viewer.isProgressivelyLoadable(format) && options.progressiveLoad;\n        const showLoadingUI = (options.showLoadingUI !== undefined && options.showLoadingUI !== null) ? options.showLoadingUI : true;\n\n        let loadingUITaskId = null;\n        if (showLoadingUI) {\n            this.loadingSpinner.removeAllTasks();\n            loadingUITaskId = this.loadingSpinner.addTask('Downloading...');\n        }\n        const hideLoadingUI = () => {\n            this.loadingProgressBar.hide();\n            this.loadingSpinner.removeAllTasks();\n        };\n\n        const onProgressUIUpdate = (percentComplete, percentCompleteLabel, loaderStatus) => {\n            if (showLoadingUI) {\n                if (loaderStatus === LoaderStatus.Downloading) {\n                    if (percentComplete == 100) {\n                        this.loadingSpinner.setMessageForTask(loadingUITaskId, 'Download complete!');\n                    } else {\n                        if (progressiveLoad) {\n                            this.loadingSpinner.setMessageForTask(loadingUITaskId, 'Downloading splats...');\n                        } else {\n                            const suffix = percentCompleteLabel ? `: ${percentCompleteLabel}` : `...`;\n                            this.loadingSpinner.setMessageForTask(loadingUITaskId, `Downloading${suffix}`);\n                        }\n                    }\n                } else if (loaderStatus === LoaderStatus.Processing) {\n                    this.loadingSpinner.setMessageForTask(loadingUITaskId, 'Processing splats...');\n                }\n            }\n        };\n\n        let downloadDone = false;\n        let downloadedPercentage = 0;\n        const splatBuffersAddedUIUpdate = (firstBuild, finalBuild) => {\n            if (showLoadingUI) {\n                if (firstBuild && progressiveLoad || finalBuild && !progressiveLoad) {\n                    this.loadingSpinner.removeTask(loadingUITaskId);\n                    if (!finalBuild && !downloadDone) this.loadingProgressBar.show();\n                }\n                if (progressiveLoad) {\n                    if (finalBuild) {\n                        downloadDone = true;\n                        this.loadingProgressBar.hide();\n                    } else {\n                        this.loadingProgressBar.setProgress(downloadedPercentage);\n                    }\n                }\n            }\n        };\n\n        const onProgress = (percentComplete, percentCompleteLabel, loaderStatus) => {\n            downloadedPercentage = percentComplete;\n            onProgressUIUpdate(percentComplete, percentCompleteLabel, loaderStatus);\n            if (options.onProgress) options.onProgress(percentComplete, percentCompleteLabel, loaderStatus);\n        };\n\n        const buildSection = (splatBuffer, firstBuild, finalBuild) => {\n            if (!progressiveLoad && options.onProgress) options.onProgress(0, '0%', LoaderStatus.Processing);\n            const addSplatBufferOptions = {\n                'rotation': options.rotation || options.orientation,\n                'position': options.position,\n                'scale': options.scale,\n                'splatAlphaRemovalThreshold': options.splatAlphaRemovalThreshold,\n            };\n            return this.addSplatBuffers([splatBuffer], [addSplatBufferOptions],\n                                         finalBuild, firstBuild && showLoadingUI, showLoadingUI,\n                                         progressiveLoad, progressiveLoad).then(() => {\n                if (!progressiveLoad && options.onProgress) options.onProgress(100, '100%', LoaderStatus.Processing);\n                splatBuffersAddedUIUpdate(firstBuild, finalBuild);\n            });\n        };\n\n        const loadFunc = progressiveLoad ? this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this) :\n                                           this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this);\n        return loadFunc(path, format, options.splatAlphaRemovalThreshold, buildSection.bind(this),\n                        onProgress, hideLoadingUI.bind(this), options.headers);\n    }\n\n    /**\n     * Download a single splat scene, convert to splat buffer and then rebuild the viewer's splat mesh\n     * by calling 'buildFunc' -- all before displaying the scene. Also sets/clears relevant instance synchronization objects,\n     * and calls appropriate functions on success or failure.\n     * @param {string} path Path to splat scene to be loaded\n     * @param {SceneFormat} format Format of the splat scene file\n     * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified value (valid range: 0 - 255)\n     * @param {function} buildFunc Function to build the viewer's splat mesh with the downloaded splat buffer\n     * @param {function} onProgress Function to be called as file data are received, or other processing occurs\n     * @param {function} onException Function to be called when exception occurs\n     * @param {object} headers Optional HTTP headers to pass to use for downloading splat scene\n     * @return {AbortablePromise}\n     */\n    downloadAndBuildSingleSplatSceneStandardLoad(path, format, splatAlphaRemovalThreshold, buildFunc, onProgress, onException, headers) {\n\n        const downloadPromise = this.downloadSplatSceneToSplatBuffer(path, splatAlphaRemovalThreshold, onProgress, false,\n                                                                     undefined, format, headers);\n        const downloadAndBuildPromise = abortablePromiseWithExtractedComponents(downloadPromise.abortHandler);\n\n        downloadPromise.then((splatBuffer) => {\n            this.removeSplatSceneDownloadPromise(downloadPromise);\n            return buildFunc(splatBuffer, true, true).then(() => {\n                downloadAndBuildPromise.resolve();\n                this.clearSplatSceneDownloadAndBuildPromise();\n            });\n        })\n        .catch((e) => {\n            if (onException) onException();\n            this.clearSplatSceneDownloadAndBuildPromise();\n            this.removeSplatSceneDownloadPromise(downloadPromise);\n            downloadAndBuildPromise.reject(this.updateError(e, `Viewer::addSplatScene -> Could not load file ${path}`));\n        });\n\n        this.addSplatSceneDownloadPromise(downloadPromise);\n        this.setSplatSceneDownloadAndBuildPromise(downloadAndBuildPromise.promise);\n\n        return downloadAndBuildPromise.promise;\n    }\n\n    /**\n     * Download a single splat scene and convert to splat buffer in a progressive manner, allowing rendering as the file downloads.\n     * As each section is downloaded, the viewer's splat mesh is rebuilt by calling 'buildFunc'\n     * Also sets/clears relevant instance synchronization objects, and calls appropriate functions on success or failure.\n     * @param {string} path Path to splat scene to be loaded\n     * @param {SceneFormat} format Format of the splat scene file\n     * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified value (valid range: 0 - 255)\n     * @param {function} buildFunc Function to rebuild the viewer's splat mesh after a new splat buffer section is downloaded\n     * @param {function} onDownloadProgress Function to be called as file data are received\n     * @param {function} onDownloadException Function to be called when exception occurs at any point during the full download\n     * @param {object} headers Optional HTTP headers to pass to use for downloading splat scene\n     * @return {AbortablePromise}\n     */\n    downloadAndBuildSingleSplatSceneProgressiveLoad(path, format, splatAlphaRemovalThreshold, buildFunc,\n                                                    onDownloadProgress, onDownloadException, headers) {\n        let progressiveLoadedSectionBuildCount = 0;\n        let progressiveLoadedSectionBuilding = false;\n        const queuedProgressiveLoadSectionBuilds = [];\n\n        const checkAndBuildProgressiveLoadSections = () => {\n            if (queuedProgressiveLoadSectionBuilds.length > 0 &&\n                !progressiveLoadedSectionBuilding &&\n                !this.isDisposingOrDisposed()) {\n                progressiveLoadedSectionBuilding = true;\n                const queuedBuild = queuedProgressiveLoadSectionBuilds.shift();\n                buildFunc(queuedBuild.splatBuffer, queuedBuild.firstBuild, queuedBuild.finalBuild)\n                .then(() => {\n                    progressiveLoadedSectionBuilding = false;\n                    if (queuedBuild.firstBuild) {\n                        progressiveLoadFirstSectionBuildPromise.resolve();\n                    } else if (queuedBuild.finalBuild) {\n                        splatSceneDownloadAndBuildPromise.resolve();\n                        this.clearSplatSceneDownloadAndBuildPromise();\n                    }\n                    if (queuedProgressiveLoadSectionBuilds.length > 0) {\n                        delayedExecute(() => checkAndBuildProgressiveLoadSections());\n                    }\n                });\n            }\n        };\n\n        const onProgressiveLoadSectionProgress = (splatBuffer, finalBuild) => {\n            if (!this.isDisposingOrDisposed()) {\n                if (finalBuild || queuedProgressiveLoadSectionBuilds.length === 0 ||\n                    splatBuffer.getSplatCount() > queuedProgressiveLoadSectionBuilds[0].splatBuffer.getSplatCount()) {\n                    queuedProgressiveLoadSectionBuilds.push({\n                        splatBuffer,\n                        firstBuild: progressiveLoadedSectionBuildCount === 0,\n                        finalBuild\n                    });\n                    progressiveLoadedSectionBuildCount++;\n                    checkAndBuildProgressiveLoadSections();\n                }\n            }\n        };\n\n        const splatSceneDownloadPromise = this.downloadSplatSceneToSplatBuffer(path, splatAlphaRemovalThreshold, onDownloadProgress, true,\n                                                                               onProgressiveLoadSectionProgress, format, headers);\n\n        const progressiveLoadFirstSectionBuildPromise = abortablePromiseWithExtractedComponents(splatSceneDownloadPromise.abortHandler);\n        const splatSceneDownloadAndBuildPromise = abortablePromiseWithExtractedComponents();\n\n        this.addSplatSceneDownloadPromise(splatSceneDownloadPromise);\n        this.setSplatSceneDownloadAndBuildPromise(splatSceneDownloadAndBuildPromise.promise);\n\n        splatSceneDownloadPromise.then(() => {\n            this.removeSplatSceneDownloadPromise(splatSceneDownloadPromise);\n        })\n        .catch((e) => {\n            this.clearSplatSceneDownloadAndBuildPromise();\n            this.removeSplatSceneDownloadPromise(splatSceneDownloadPromise);\n            const error = this.updateError(e, `Viewer::addSplatScene -> Could not load one or more scenes`);\n            progressiveLoadFirstSectionBuildPromise.reject(error);\n            if (onDownloadException) onDownloadException(error);\n        });\n\n        return progressiveLoadFirstSectionBuildPromise.promise;\n    }\n\n    /**\n     * Add multiple splat scenes to the viewer and display any loading UI if appropriate.\n     * @param {Array<object>} sceneOptions Array of per-scene options: {\n     *\n     *         path: Path to splat scene to be loaded\n     *\n     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n     *                                     value (valid range: 0 - 255), defaults to 1\n     *\n     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n     *\n     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n     *\n     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n     *\n     *         headers:                    Optional HTTP headers to be sent along with splat requests\n     *\n     *         format (SceneFormat)        Optional, the format of the scene data (.ply, .ksplat, .splat). If not present, the\n     *                                     file extension in 'path' will be used to determine the format (if it is present)\n     * }\n     * @param {boolean} showLoadingUI Display a loading spinner while the scene is loading, defaults to true\n     * @param {function} onProgress Function to be called as file data are received\n     * @return {AbortablePromise}\n     */\n    addSplatScenes(sceneOptions, showLoadingUI = true, onProgress = undefined) {\n\n        if (this.isLoadingOrUnloading()) {\n            throw new Error('Cannot add splat scene while another load or unload is already in progress.');\n        }\n\n        if (this.isDisposingOrDisposed()) {\n            throw new Error('Cannot add splat scene after dispose() is called.');\n        }\n\n        const fileCount = sceneOptions.length;\n        const percentComplete = [];\n\n        let loadingUITaskId;\n        if (showLoadingUI) {\n            this.loadingSpinner.removeAllTasks();\n            loadingUITaskId = this.loadingSpinner.addTask('Downloading...');\n        }\n\n        const onLoadProgress = (fileIndex, percent, percentLabel, loaderStatus) => {\n            percentComplete[fileIndex] = percent;\n            let totalPercent = 0;\n            for (let i = 0; i < fileCount; i++) totalPercent += percentComplete[i] || 0;\n            totalPercent = totalPercent / fileCount;\n            percentLabel = `${totalPercent.toFixed(2)}%`;\n            if (showLoadingUI) {\n                if (loaderStatus === LoaderStatus.Downloading) {\n                    this.loadingSpinner.setMessageForTask(loadingUITaskId, totalPercent == 100 ?\n                                                          `Download complete!` : `Downloading: ${percentLabel}`);\n                }\n            }\n            if (onProgress) onProgress(totalPercent, percentLabel, loaderStatus);\n        };\n\n        const baseDownloadPromises = [];\n        const nativeDownloadPromises = [];\n        for (let i = 0; i < sceneOptions.length; i++) {\n            const options = sceneOptions[i];\n            const format = (options.format !== undefined && options.format !== null) ? options.format : sceneFormatFromPath(options.path);\n            const baseDownloadPromise = this.downloadSplatSceneToSplatBuffer(options.path, options.splatAlphaRemovalThreshold,\n                                                                             onLoadProgress.bind(this, i), false, undefined,\n                                                                             format, options.headers);\n            baseDownloadPromises.push(baseDownloadPromise);\n            nativeDownloadPromises.push(baseDownloadPromise.promise);\n        }\n\n        const downloadAndBuildPromise = new AbortablePromise((resolve, reject) => {\n            Promise.all(nativeDownloadPromises)\n            .then((splatBuffers) => {\n                if (showLoadingUI) this.loadingSpinner.removeTask(loadingUITaskId);\n                if (onProgress) onProgress(0, '0%', LoaderStatus.Processing);\n                this.addSplatBuffers(splatBuffers, sceneOptions, true, showLoadingUI, showLoadingUI, false, false).then(() => {\n                    if (onProgress) onProgress(100, '100%', LoaderStatus.Processing);\n                    this.clearSplatSceneDownloadAndBuildPromise();\n                    resolve();\n                });\n            })\n            .catch((e) => {\n                if (showLoadingUI) this.loadingSpinner.removeTask(loadingUITaskId);\n                this.clearSplatSceneDownloadAndBuildPromise();\n                reject(this.updateError(e, `Viewer::addSplatScenes -> Could not load one or more splat scenes.`));\n            })\n            .finally(() => {\n                this.removeSplatSceneDownloadPromise(downloadAndBuildPromise);\n            });\n        }, (reason) => {\n            for (let baseDownloadPromise of baseDownloadPromises) {\n                baseDownloadPromise.abort(reason);\n            }\n        });\n        this.addSplatSceneDownloadPromise(downloadAndBuildPromise);\n        this.setSplatSceneDownloadAndBuildPromise(downloadAndBuildPromise);\n        return downloadAndBuildPromise;\n    }\n\n    /**\n     * Download a splat scene and convert to SplatBuffer instance.\n     * @param {string} path Path to splat scene to be loaded\n     * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified\n     *                                            value (valid range: 0 - 255), defaults to 1\n     *\n     * @param {function} onProgress Function to be called as file data are received\n     * @param {boolean} progressiveBuild Construct file sections into splat buffers as they are downloaded\n     * @param {function} onSectionBuilt Function to be called when new section is added to the file\n     * @param {string} format File format of the scene\n     * @param {object} headers Optional HTTP headers to pass to use for downloading splat scene\n     * @return {AbortablePromise}\n     */\n    downloadSplatSceneToSplatBuffer(path, splatAlphaRemovalThreshold = 1, onProgress = undefined,\n                                    progressiveBuild = false, onSectionBuilt = undefined, format, headers) {\n        try {\n            if (format === SceneFormat.Splat || format === SceneFormat.KSplat || format === SceneFormat.Ply) {\n                const optimizeSplatData = progressiveBuild ? false : this.optimizeSplatData;\n                if (format === SceneFormat.Splat) {\n                    return SplatLoader.loadFromURL(path, onProgress, progressiveBuild, onSectionBuilt, splatAlphaRemovalThreshold,\n                                                   this.inMemoryCompressionLevel, optimizeSplatData, headers);\n                } else if (format === SceneFormat.KSplat) {\n                    return KSplatLoader.loadFromURL(path, onProgress, progressiveBuild, onSectionBuilt, headers);\n                } else if (format === SceneFormat.Ply) {\n                    return PlyLoader.loadFromURL(path, onProgress, progressiveBuild, onSectionBuilt, splatAlphaRemovalThreshold,\n                                                 this.inMemoryCompressionLevel, optimizeSplatData, this.sphericalHarmonicsDegree, headers);\n                }\n            } else if (format === SceneFormat.Spz) {\n                return SpzLoader.loadFromURL(path, onProgress, splatAlphaRemovalThreshold, this.inMemoryCompressionLevel,\n                                             this.optimizeSplatData, this.sphericalHarmonicsDegree, headers);\n            }\n        } catch (e) {\n            throw this.updateError(e, null);\n        }\n\n        throw new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${path}`);\n    }\n\n    static isProgressivelyLoadable(format) {\n        return format === SceneFormat.Splat || format === SceneFormat.KSplat || format === SceneFormat.Ply;\n    }\n\n    /**\n     * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer and set up the sorting web worker.\n     * This function will terminate the existing sort worker (if there is one).\n     */\n    addSplatBuffers = function() {\n\n        return function(splatBuffers, splatBufferOptions = [], finalBuild = true, showLoadingUI = true,\n                        showLoadingUIForSplatTreeBuild = true, replaceExisting = false,\n                        enableRenderBeforeFirstSort = false, preserveVisibleRegion = true) {\n\n            if (this.isDisposingOrDisposed()) return Promise.resolve();\n\n            let splatProcessingTaskId = null;\n            const removeSplatProcessingTask = () => {\n                if (splatProcessingTaskId !== null) {\n                    this.loadingSpinner.removeTask(splatProcessingTaskId);\n                    splatProcessingTaskId = null;\n                }\n            };\n\n            this.splatRenderReady = false;\n            return new Promise((resolve) => {\n                if (showLoadingUI) {\n                    splatProcessingTaskId = this.loadingSpinner.addTask('Processing splats...');\n                }\n                delayedExecute(() => {\n                    if (this.isDisposingOrDisposed()) {\n                        resolve();\n                    } else {\n                        const buildResults = this.addSplatBuffersToMesh(splatBuffers, splatBufferOptions, finalBuild,\n                                                                        showLoadingUIForSplatTreeBuild, replaceExisting,\n                                                                        preserveVisibleRegion);\n\n                        const maxSplatCount = this.splatMesh.getMaxSplatCount();\n                        if (this.sortWorker && this.sortWorker.maxSplatCount !== maxSplatCount) this.disposeSortWorker();\n                        // If we aren't calculating the splat distances from the center on the GPU, the sorting worker needs\n                        // splat centers and transform indexes so that it can calculate those distance values.\n                        if (!this.gpuAcceleratedSort) {\n                            this.preSortMessages.push({\n                                'centers': buildResults.centers.buffer,\n                                'sceneIndexes': buildResults.sceneIndexes.buffer,\n                                'range': {\n                                    'from': buildResults.from,\n                                    'to': buildResults.to,\n                                    'count': buildResults.count\n                                }\n                            });\n                        }\n                        const sortWorkerSetupPromise = (!this.sortWorker && maxSplatCount > 0) ?\n                                                         this.setupSortWorker(this.splatMesh) : Promise.resolve();\n                        sortWorkerSetupPromise.then(() => {\n                            if (this.isDisposingOrDisposed()) return;\n                            this.runSplatSort(true, true).then((sortRunning) => {\n                                if (!this.sortWorker || !sortRunning) {\n                                    this.splatRenderReady = true;\n                                    removeSplatProcessingTask();\n                                    resolve();\n                                } else {\n                                    if (enableRenderBeforeFirstSort) {\n                                        this.splatRenderReady = true;\n                                    } else {\n                                        this.runAfterNextSort.push(() => {\n                                            this.splatRenderReady = true;\n                                        });\n                                    }\n                                    this.runAfterNextSort.push(() => {\n                                        removeSplatProcessingTask();\n                                        resolve();\n                                    });\n                                }\n                            });\n                        });\n                    }\n                }, true);\n            });\n        };\n\n    }();\n\n    /**\n     * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer. By default, this function is additive;\n     * all splat buffers contained by the viewer's splat mesh before calling this function will be preserved. This behavior can be\n     * changed by passing 'true' for 'replaceExisting'.\n     * @param {Array<SplatBuffer>} splatBuffers SplatBuffer instances\n     * @param {Array<object>} splatBufferOptions Array of options objects: {\n     *\n     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n     *                                     value (valid range: 0 - 255), defaults to 1\n     *\n     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n     *\n     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n     *\n     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n     * }\n     * @param {boolean} finalBuild Will the splat mesh be in its final state after this build?\n     * @param {boolean} showLoadingUIForSplatTreeBuild Whether or not to show the loading spinner during construction of the splat tree.\n     * @return {object} Object containing info about the splats that are updated\n     */\n    addSplatBuffersToMesh = function() {\n\n        let splatOptimizingTaskId;\n\n        return function(splatBuffers, splatBufferOptions, finalBuild = true, showLoadingUIForSplatTreeBuild = false,\n                        replaceExisting = false, preserveVisibleRegion = true) {\n            if (this.isDisposingOrDisposed()) return;\n            let allSplatBuffers = [];\n            let allSplatBufferOptions = [];\n            if (!replaceExisting) {\n                allSplatBuffers = this.splatMesh.scenes.map((scene) => scene.splatBuffer) || [];\n                allSplatBufferOptions = this.splatMesh.sceneOptions ? this.splatMesh.sceneOptions.map((sceneOptions) => sceneOptions) : [];\n            }\n            allSplatBuffers.push(...splatBuffers);\n            allSplatBufferOptions.push(...splatBufferOptions);\n            if (this.renderer) this.splatMesh.setRenderer(this.renderer);\n            const onSplatTreeIndexesUpload = (finished) => {\n                if (this.isDisposingOrDisposed()) return;\n                const splatCount = this.splatMesh.getSplatCount();\n                if (showLoadingUIForSplatTreeBuild && splatCount >= MIN_SPLAT_COUNT_TO_SHOW_SPLAT_TREE_LOADING_SPINNER) {\n                    if (!finished && !splatOptimizingTaskId) {\n                        this.loadingSpinner.setMinimized(true, true);\n                        splatOptimizingTaskId = this.loadingSpinner.addTask('Optimizing data structures...');\n                    }\n                }\n            };\n            const onSplatTreeReady = (finished) => {\n                if (this.isDisposingOrDisposed()) return;\n                if (finished && splatOptimizingTaskId) {\n                    this.loadingSpinner.removeTask(splatOptimizingTaskId);\n                    splatOptimizingTaskId = null;\n                }\n            };\n            const buildResults = this.splatMesh.build(allSplatBuffers, allSplatBufferOptions, true, finalBuild, onSplatTreeIndexesUpload,\n                                                      onSplatTreeReady, preserveVisibleRegion);\n            if (finalBuild && this.freeIntermediateSplatData) this.splatMesh.freeIntermediateSplatData();\n            return buildResults;\n        };\n\n    }();\n\n    /**\n     * Set up the splat sorting web worker.\n     * @param {SplatMesh} splatMesh SplatMesh instance that contains the splats to be sorted\n     * @return {Promise}\n     */\n    setupSortWorker(splatMesh) {\n        if (this.isDisposingOrDisposed()) return;\n        return new Promise((resolve) => {\n            const DistancesArrayType = this.integerBasedSort ? Int32Array : Float32Array;\n            const splatCount = splatMesh.getSplatCount();\n            const maxSplatCount = splatMesh.getMaxSplatCount();\n            this.sortWorker = createSortWorker(maxSplatCount, this.sharedMemoryForWorkers, this.enableSIMDInSort,\n                                               this.integerBasedSort, this.splatMesh.dynamicMode, this.splatSortDistanceMapPrecision);\n            this.sortWorker.onmessage = (e) => {\n                if (e.data.sortDone) {\n                    this.sortRunning = false;\n                    if (this.sharedMemoryForWorkers) {\n                        this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes, e.data.splatRenderCount);\n                    } else {\n                        const sortedIndexes = new Uint32Array(e.data.sortedIndexes.buffer, 0, e.data.splatRenderCount);\n                        this.splatMesh.updateRenderIndexes(sortedIndexes, e.data.splatRenderCount);\n                    }\n\n                    this.lastSplatSortCount = this.splatSortCount;\n\n                    this.lastSortTime = e.data.sortTime;\n                    this.sortPromiseResolver();\n                    this.sortPromiseResolver = null;\n                    this.forceRenderNextFrame();\n                    if (this.runAfterNextSort.length > 0) {\n                        this.runAfterNextSort.forEach((func) => {\n                            func();\n                        });\n                        this.runAfterNextSort.length = 0;\n                    }\n                } else if (e.data.sortCanceled) {\n                    this.sortRunning = false;\n                } else if (e.data.sortSetupPhase1Complete) {\n                    if (this.logLevel >= LogLevel.Info) console.log('Sorting web worker WASM setup complete.');\n                    if (this.sharedMemoryForWorkers) {\n                        this.sortWorkerSortedIndexes = new Uint32Array(e.data.sortedIndexesBuffer,\n                                                                       e.data.sortedIndexesOffset, maxSplatCount);\n                        this.sortWorkerIndexesToSort = new Uint32Array(e.data.indexesToSortBuffer,\n                                                                       e.data.indexesToSortOffset, maxSplatCount);\n                        this.sortWorkerPrecomputedDistances = new DistancesArrayType(e.data.precomputedDistancesBuffer,\n                                                                                     e.data.precomputedDistancesOffset,\n                                                                                     maxSplatCount);\n                         this.sortWorkerTransforms = new Float32Array(e.data.transformsBuffer,\n                                                                      e.data.transformsOffset, Constants.MaxScenes * 16);\n                    } else {\n                        this.sortWorkerIndexesToSort = new Uint32Array(maxSplatCount);\n                        this.sortWorkerPrecomputedDistances = new DistancesArrayType(maxSplatCount);\n                        this.sortWorkerTransforms = new Float32Array(Constants.MaxScenes * 16);\n                    }\n                    for (let i = 0; i < splatCount; i++) this.sortWorkerIndexesToSort[i] = i;\n                    this.sortWorker.maxSplatCount = maxSplatCount;\n\n                    if (this.logLevel >= LogLevel.Info) {\n                        console.log('Sorting web worker ready.');\n                        const splatDataTextures = this.splatMesh.getSplatDataTextures();\n                        const covariancesTextureSize = splatDataTextures.covariances.size;\n                        const centersColorsTextureSize = splatDataTextures.centerColors.size;\n                        console.log('Covariances texture size: ' + covariancesTextureSize.x + ' x ' + covariancesTextureSize.y);\n                        console.log('Centers/colors texture size: ' + centersColorsTextureSize.x + ' x ' + centersColorsTextureSize.y);\n                    }\n\n                    resolve();\n                }\n            };\n        });\n    }\n\n    updateError(error, defaultMessage) {\n        if (error instanceof AbortedPromiseError) return error;\n        if (error instanceof DirectLoadError) {\n            return new Error('File type or server does not support progressive loading.');\n        }\n        return defaultMessage ? new Error(defaultMessage) : error;\n    }\n\n    disposeSortWorker() {\n        if (this.sortWorker) this.sortWorker.terminate();\n        this.sortWorker = null;\n        this.sortPromise = null;\n        if (this.sortPromiseResolver) {\n            this.sortPromiseResolver();\n            this.sortPromiseResolver = null;\n        }\n        this.preSortMessages = [];\n        this.sortRunning = false;\n    }\n\n    removeSplatScene(indexToRemove, showLoadingUI = true) {\n        return this.removeSplatScenes([indexToRemove], showLoadingUI);\n    }\n\n    removeSplatScenes(indexesToRemove, showLoadingUI = true) {\n        if (this.isLoadingOrUnloading()) {\n            throw new Error('Cannot remove splat scene while another load or unload is already in progress.');\n        }\n\n        if (this.isDisposingOrDisposed()) {\n            throw new Error('Cannot remove splat scene after dispose() is called.');\n        }\n\n        let sortPromise;\n\n        this.splatSceneRemovalPromise = new Promise((resolve, reject) => {\n            let revmovalTaskId;\n\n            if (showLoadingUI) {\n                this.loadingSpinner.removeAllTasks();\n                this.loadingSpinner.show();\n                revmovalTaskId = this.loadingSpinner.addTask('Removing splat scene...');\n            }\n\n            const checkAndHideLoadingUI = () => {\n                if (showLoadingUI) {\n                    this.loadingSpinner.hide();\n                    this.loadingSpinner.removeTask(revmovalTaskId);\n                }\n            };\n\n            const onDone = (error) => {\n                checkAndHideLoadingUI();\n                this.splatSceneRemovalPromise = null;\n                if (!error) resolve();\n                else reject(error);\n            };\n\n            const checkForEarlyExit = () => {\n                if (this.isDisposingOrDisposed()) {\n                    onDone();\n                    return true;\n                }\n                return false;\n            };\n\n            sortPromise = this.sortPromise || Promise.resolve();\n            sortPromise.then(() => {\n                if (checkForEarlyExit()) return;\n                const savedSplatBuffers = [];\n                const savedSceneOptions = [];\n                const savedSceneTransformComponents = [];\n                for (let i = 0; i < this.splatMesh.scenes.length; i++) {\n                    let shouldRemove = false;\n                    for (let indexToRemove of indexesToRemove) {\n                        if (indexToRemove === i) {\n                            shouldRemove = true;\n                            break;\n                        }\n                    }\n                    if (!shouldRemove) {\n                        const scene = this.splatMesh.scenes[i];\n                        savedSplatBuffers.push(scene.splatBuffer);\n                        savedSceneOptions.push(this.splatMesh.sceneOptions[i]);\n                        savedSceneTransformComponents.push({\n                            'position': scene.position.clone(),\n                            'quaternion': scene.quaternion.clone(),\n                            'scale': scene.scale.clone()\n                        });\n                    }\n                }\n                this.disposeSortWorker();\n                this.splatMesh.dispose();\n                this.sceneRevealMode = SceneRevealMode.Instant;\n                this.createSplatMesh();\n                this.addSplatBuffers(savedSplatBuffers, savedSceneOptions, true, false, true)\n                .then(() => {\n                    if (checkForEarlyExit()) return;\n                    checkAndHideLoadingUI();\n                    this.splatMesh.scenes.forEach((scene, index) => {\n                        scene.position.copy(savedSceneTransformComponents[index].position);\n                        scene.quaternion.copy(savedSceneTransformComponents[index].quaternion);\n                        scene.scale.copy(savedSceneTransformComponents[index].scale);\n                    });\n                    this.splatMesh.updateTransforms();\n                    this.splatRenderReady = false;\n\n                    this.runSplatSort(true)\n                    .then(() => {\n                        if (checkForEarlyExit()) {\n                            this.splatRenderReady = true;\n                            return;\n                        }\n                        sortPromise = this.sortPromise || Promise.resolve();\n                        sortPromise.then(() => {\n                            this.splatRenderReady = true;\n                            onDone();\n                        });\n                    });\n                })\n                .catch((e) => {\n                    onDone(e);\n                });\n            });\n        });\n\n        return this.splatSceneRemovalPromise;\n    }\n\n    /**\n     * Start self-driven mode\n     */\n    start() {\n        if (this.selfDrivenMode) {\n            if (this.webXRMode) {\n                this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc);\n            } else {\n                this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc);\n            }\n            this.selfDrivenModeRunning = true;\n        } else {\n            throw new Error('Cannot start viewer unless it is in self driven mode.');\n        }\n    }\n\n    /**\n     * Stop self-driven mode\n     */\n    stop() {\n        if (this.selfDrivenMode && this.selfDrivenModeRunning) {\n            if (this.webXRMode) {\n                this.renderer.setAnimationLoop(null);\n            } else {\n                cancelAnimationFrame(this.requestFrameId);\n            }\n            this.selfDrivenModeRunning = false;\n        }\n    }\n\n    /**\n     * Dispose of all resources held directly and indirectly by this viewer.\n     */\n    async dispose() {\n        if (this.isDisposingOrDisposed()) return this.disposePromise;\n\n        let waitPromises = [];\n        let promisesToAbort = [];\n        for (let promiseKey in this.splatSceneDownloadPromises) {\n            if (this.splatSceneDownloadPromises.hasOwnProperty(promiseKey)) {\n                const downloadPromiseToAbort = this.splatSceneDownloadPromises[promiseKey];\n                promisesToAbort.push(downloadPromiseToAbort);\n                waitPromises.push(downloadPromiseToAbort.promise);\n            }\n        }\n        if (this.sortPromise) {\n            waitPromises.push(this.sortPromise);\n        }\n\n        this.disposing = true;\n        this.disposePromise = Promise.all(waitPromises).finally(() => {\n            this.stop();\n            if (this.orthographicControls) {\n                this.orthographicControls.dispose();\n                this.orthographicControls = null;\n            }\n            if (this.perspectiveControls) {\n                this.perspectiveControls.dispose();\n                this.perspectiveControls = null;\n            }\n            this.controls = null;\n            if (this.splatMesh) {\n                this.splatMesh.dispose();\n                this.splatMesh = null;\n            }\n            if (this.sceneHelper) {\n                this.sceneHelper.dispose();\n                this.sceneHelper = null;\n            }\n            if (this.resizeObserver) {\n                this.resizeObserver.unobserve(this.rootElement);\n                this.resizeObserver = null;\n            }\n            this.disposeSortWorker();\n            this.removeEventHandlers();\n\n            this.loadingSpinner.removeAllTasks();\n            this.loadingSpinner.setContainer(null);\n            this.loadingProgressBar.hide();\n            this.loadingProgressBar.setContainer(null);\n            this.infoPanel.setContainer(null);\n\n            this.camera = null;\n            this.threeScene = null;\n            this.splatRenderReady = false;\n            this.initialized = false;\n            if (this.renderer) {\n                if (!this.usingExternalRenderer) {\n                    this.rootElement.removeChild(this.renderer.domElement);\n                    this.renderer.dispose();\n                }\n                this.renderer = null;\n            }\n\n            if (!this.usingExternalRenderer) {\n                document.body.removeChild(this.rootElement);\n            }\n\n            this.sortWorkerSortedIndexes = null;\n            this.sortWorkerIndexesToSort = null;\n            this.sortWorkerPrecomputedDistances = null;\n            this.sortWorkerTransforms = null;\n            this.disposed = true;\n            this.disposing = false;\n            this.disposePromise = null;\n        });\n        promisesToAbort.forEach((toAbort) => {\n            toAbort.abort('Scene disposed');\n        });\n        return this.disposePromise;\n    }\n\n    selfDrivenUpdate() {\n        if (this.selfDrivenMode && !this.webXRMode) {\n            this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc);\n        }\n        this.update();\n        if (this.shouldRender()) {\n            this.render();\n            this.consecutiveRenderFrames++;\n        } else {\n            this.consecutiveRenderFrames = 0;\n        }\n        this.renderNextFrame = false;\n    }\n\n    forceRenderNextFrame() {\n        this.renderNextFrame = true;\n    }\n\n    shouldRender = function() {\n\n        let renderCount = 0;\n        const lastCameraPosition = new THREE.Vector3();\n        const lastCameraOrientation = new THREE.Quaternion();\n        const changeEpsilon = 0.0001;\n\n        return function() {\n            if (!this.initialized || !this.splatRenderReady || this.isDisposingOrDisposed()) return false;\n\n            let shouldRender = false;\n            let cameraChanged = false;\n            if (this.camera) {\n                const cp = this.camera.position;\n                const co = this.camera.quaternion;\n                cameraChanged = Math.abs(cp.x - lastCameraPosition.x) > changeEpsilon ||\n                                Math.abs(cp.y - lastCameraPosition.y) > changeEpsilon ||\n                                Math.abs(cp.z - lastCameraPosition.z) > changeEpsilon ||\n                                Math.abs(co.x - lastCameraOrientation.x) > changeEpsilon ||\n                                Math.abs(co.y - lastCameraOrientation.y) > changeEpsilon ||\n                                Math.abs(co.z - lastCameraOrientation.z) > changeEpsilon ||\n                                Math.abs(co.w - lastCameraOrientation.w) > changeEpsilon;\n            }\n\n            shouldRender = this.renderMode !== RenderMode.Never && (renderCount === 0 || this.splatMesh.visibleRegionChanging ||\n                           cameraChanged || this.renderMode === RenderMode.Always || this.dynamicMode === true || this.renderNextFrame);\n\n            if (this.camera) {\n                lastCameraPosition.copy(this.camera.position);\n                lastCameraOrientation.copy(this.camera.quaternion);\n            }\n\n            renderCount++;\n            return shouldRender;\n        };\n\n    }();\n\n    render = function() {\n\n        return function() {\n            if (!this.initialized || !this.splatRenderReady || this.isDisposingOrDisposed()) return;\n\n            const hasRenderables = (threeScene) => {\n                for (let child of threeScene.children) {\n                    if (child.visible) return true;\n                }\n                return false;\n            };\n\n            const savedAuoClear = this.renderer.autoClear;\n            if (hasRenderables(this.threeScene)) {\n                this.renderer.render(this.threeScene, this.camera);\n                this.renderer.autoClear = false;\n            }\n            this.renderer.render(this.splatMesh, this.camera);\n            this.renderer.autoClear = false;\n            if (this.sceneHelper.getFocusMarkerOpacity() > 0.0) this.renderer.render(this.sceneHelper.focusMarker, this.camera);\n            if (this.showControlPlane) this.renderer.render(this.sceneHelper.controlPlane, this.camera);\n            this.renderer.autoClear = savedAuoClear;\n        };\n\n    }();\n\n    update(renderer, camera) {\n        if (this.dropInMode) this.updateForDropInMode(renderer, camera);\n\n        if (!this.initialized || !this.splatRenderReady || this.isDisposingOrDisposed()) return;\n\n        if (this.controls) {\n            this.controls.update();\n            if (this.camera.isOrthographicCamera && !this.usingExternalCamera) {\n                Viewer.setCameraPositionFromZoom(this.camera, this.camera, this.controls);\n            }\n        }\n        this.runSplatSort();\n        this.updateForRendererSizeChanges();\n        this.updateSplatMesh();\n        this.updateMeshCursor();\n        this.updateFPS();\n        this.timingSensitiveUpdates();\n        this.updateInfoPanel();\n        this.updateControlPlane();\n    }\n\n    updateForDropInMode(renderer, camera) {\n        this.renderer = renderer;\n        if (this.splatMesh) this.splatMesh.setRenderer(this.renderer);\n        this.camera = camera;\n        if (this.controls) this.controls.object = camera;\n        this.init();\n    }\n\n    updateFPS = function() {\n\n        let lastCalcTime = getCurrentTime();\n        let frameCount = 0;\n\n        return function() {\n            if (this.consecutiveRenderFrames > CONSECUTIVE_RENDERED_FRAMES_FOR_FPS_CALCULATION) {\n                const currentTime = getCurrentTime();\n                const calcDelta = currentTime - lastCalcTime;\n                if (calcDelta >= 1.0) {\n                    this.currentFPS = frameCount;\n                    frameCount = 0;\n                    lastCalcTime = currentTime;\n                } else {\n                    frameCount++;\n                }\n            } else {\n                this.currentFPS = null;\n            }\n        };\n\n    }();\n\n    updateForRendererSizeChanges = function() {\n\n        const lastRendererSize = new THREE.Vector2();\n        const currentRendererSize = new THREE.Vector2();\n        let lastCameraOrthographic;\n\n        return function() {\n            if (!this.usingExternalCamera) {\n                this.renderer.getSize(currentRendererSize);\n                if (lastCameraOrthographic === undefined || lastCameraOrthographic !== this.camera.isOrthographicCamera ||\n                    currentRendererSize.x !== lastRendererSize.x || currentRendererSize.y !== lastRendererSize.y) {\n                    if (this.camera.isOrthographicCamera) {\n                        this.camera.left = -currentRendererSize.x / 2.0;\n                        this.camera.right = currentRendererSize.x / 2.0;\n                        this.camera.top = currentRendererSize.y / 2.0;\n                        this.camera.bottom = -currentRendererSize.y / 2.0;\n                    } else {\n                        this.camera.aspect = currentRendererSize.x / currentRendererSize.y;\n                    }\n                    this.camera.updateProjectionMatrix();\n                    lastRendererSize.copy(currentRendererSize);\n                    lastCameraOrthographic = this.camera.isOrthographicCamera;\n                }\n            }\n        };\n\n    }();\n\n    timingSensitiveUpdates = function() {\n\n        let lastUpdateTime;\n\n        return function() {\n            const currentTime = getCurrentTime();\n            if (!lastUpdateTime) lastUpdateTime = currentTime;\n            const timeDelta = currentTime - lastUpdateTime;\n\n            this.updateCameraTransition(currentTime);\n            this.updateFocusMarker(timeDelta);\n\n            lastUpdateTime = currentTime;\n        };\n\n    }();\n\n    updateCameraTransition = function() {\n\n        let tempCameraTarget = new THREE.Vector3();\n        let toPreviousTarget = new THREE.Vector3();\n        let toNextTarget = new THREE.Vector3();\n\n        return function(currentTime) {\n            if (this.transitioningCameraTarget) {\n                toPreviousTarget.copy(this.previousCameraTarget).sub(this.camera.position).normalize();\n                toNextTarget.copy(this.nextCameraTarget).sub(this.camera.position).normalize();\n                const rotationAngle = Math.acos(toPreviousTarget.dot(toNextTarget));\n                const rotationSpeed = rotationAngle / (Math.PI / 3) * .65 + .3;\n                const t = (rotationSpeed / rotationAngle * (currentTime - this.transitioningCameraTargetStartTime));\n                tempCameraTarget.copy(this.previousCameraTarget).lerp(this.nextCameraTarget, t);\n                this.camera.lookAt(tempCameraTarget);\n                this.controls.target.copy(tempCameraTarget);\n                if (t >= 1.0) {\n                    this.transitioningCameraTarget = false;\n                }\n            }\n        };\n\n    }();\n\n    updateFocusMarker = function() {\n\n        const renderDimensions = new THREE.Vector2();\n        let wasTransitioning = false;\n\n        return function(timeDelta) {\n            this.getRenderDimensions(renderDimensions);\n            if (this.transitioningCameraTarget) {\n                this.sceneHelper.setFocusMarkerVisibility(true);\n                const currentFocusMarkerOpacity = Math.max(this.sceneHelper.getFocusMarkerOpacity(), 0.0);\n                let newFocusMarkerOpacity = Math.min(currentFocusMarkerOpacity + FOCUS_MARKER_FADE_IN_SPEED * timeDelta, 1.0);\n                this.sceneHelper.setFocusMarkerOpacity(newFocusMarkerOpacity);\n                this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, renderDimensions);\n                wasTransitioning = true;\n                this.forceRenderNextFrame();\n            } else {\n                let currentFocusMarkerOpacity;\n                if (wasTransitioning) currentFocusMarkerOpacity = 1.0;\n                else currentFocusMarkerOpacity = Math.min(this.sceneHelper.getFocusMarkerOpacity(), 1.0);\n                if (currentFocusMarkerOpacity > 0) {\n                    this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, renderDimensions);\n                    let newFocusMarkerOpacity = Math.max(currentFocusMarkerOpacity - FOCUS_MARKER_FADE_OUT_SPEED * timeDelta, 0.0);\n                    this.sceneHelper.setFocusMarkerOpacity(newFocusMarkerOpacity);\n                    if (newFocusMarkerOpacity === 0.0) this.sceneHelper.setFocusMarkerVisibility(false);\n                }\n                if (currentFocusMarkerOpacity > 0.0) this.forceRenderNextFrame();\n                wasTransitioning = false;\n            }\n        };\n\n    }();\n\n    updateMeshCursor = function() {\n\n        const outHits = [];\n        const renderDimensions = new THREE.Vector2();\n\n        return function() {\n            if (this.showMeshCursor) {\n                this.forceRenderNextFrame();\n                this.getRenderDimensions(renderDimensions);\n                outHits.length = 0;\n                this.raycaster.setFromCameraAndScreenPosition(this.camera, this.mousePosition, renderDimensions);\n                this.raycaster.intersectSplatMesh(this.splatMesh, outHits);\n                if (outHits.length > 0) {\n                    this.sceneHelper.setMeshCursorVisibility(true);\n                    this.sceneHelper.positionAndOrientMeshCursor(outHits[0].origin, this.camera);\n                } else {\n                    this.sceneHelper.setMeshCursorVisibility(false);\n                }\n            } else {\n                if (this.sceneHelper.getMeschCursorVisibility()) this.forceRenderNextFrame();\n                this.sceneHelper.setMeshCursorVisibility(false);\n            }\n        };\n\n    }();\n\n    updateInfoPanel = function() {\n\n        const renderDimensions = new THREE.Vector2();\n\n        return function() {\n            if (!this.showInfo) return;\n            const splatCount = this.splatMesh.getSplatCount();\n            this.getRenderDimensions(renderDimensions);\n            const cameraLookAtPosition = this.controls ? this.controls.target : null;\n            const meshCursorPosition = this.showMeshCursor ? this.sceneHelper.meshCursor.position : null;\n            const splatRenderCountPct = splatCount > 0 ? this.splatRenderCount / splatCount * 100 : 0;\n            this.infoPanel.update(renderDimensions, this.camera.position, cameraLookAtPosition,\n                                  this.camera.up, this.camera.isOrthographicCamera, meshCursorPosition,\n                                  this.currentFPS || 'N/A', splatCount, this.splatRenderCount, splatRenderCountPct,\n                                  this.lastSortTime, this.focalAdjustment, this.splatMesh.getSplatScale(),\n                                  this.splatMesh.getPointCloudModeEnabled());\n        };\n\n    }();\n\n    updateControlPlane() {\n        if (this.showControlPlane) {\n            this.sceneHelper.setControlPlaneVisibility(true);\n            this.sceneHelper.positionAndOrientControlPlane(this.controls.target, this.camera.up);\n        } else {\n            this.sceneHelper.setControlPlaneVisibility(false);\n        }\n    }\n\n    runSplatSort = function() {\n\n        const mvpMatrix = new THREE.Matrix4();\n        const cameraPositionArray = [];\n        const lastSortViewDir = new THREE.Vector3(0, 0, -1);\n        const sortViewDir = new THREE.Vector3(0, 0, -1);\n        const lastSortViewPos = new THREE.Vector3();\n        const sortViewOffset = new THREE.Vector3();\n        const queuedSorts = [];\n\n        const partialSorts = [\n            {\n                'angleThreshold': 0.55,\n                'sortFractions': [0.125, 0.33333, 0.75]\n            },\n            {\n                'angleThreshold': 0.65,\n                'sortFractions': [0.33333, 0.66667]\n            },\n            {\n                'angleThreshold': 0.8,\n                'sortFractions': [0.5]\n            }\n        ];\n\n        return function(force = false, forceSortAll = false) {\n            if (!this.initialized) return Promise.resolve(false);\n            if (this.sortRunning) return Promise.resolve(true);\n            if (this.splatMesh.getSplatCount() <= 0) {\n                this.splatRenderCount = 0;\n                return Promise.resolve(false);\n            }\n\n            let angleDiff = 0;\n            let positionDiff = 0;\n            let needsRefreshForRotation = false;\n            let needsRefreshForPosition = false;\n\n            sortViewDir.set(0, 0, -1).applyQuaternion(this.camera.quaternion);\n            angleDiff = sortViewDir.dot(lastSortViewDir);\n            positionDiff = sortViewOffset.copy(this.camera.position).sub(lastSortViewPos).length();\n\n            if (!force) {\n                if (!this.splatMesh.dynamicMode && queuedSorts.length === 0) {\n                    if (angleDiff <= 0.99) needsRefreshForRotation = true;\n                    if (positionDiff >= 1.0) needsRefreshForPosition = true;\n                    if (!needsRefreshForRotation && !needsRefreshForPosition) return Promise.resolve(false);\n                }\n            }\n\n            this.sortRunning = true;\n            let { splatRenderCount, shouldSortAll } = this.gatherSceneNodesForSort();\n            shouldSortAll = shouldSortAll || forceSortAll;\n            this.splatRenderCount = splatRenderCount;\n\n            mvpMatrix.copy(this.camera.matrixWorld).invert();\n            const mvpCamera = this.perspectiveCamera || this.camera;\n            mvpMatrix.premultiply(mvpCamera.projectionMatrix);\n            if (!this.splatMesh.dynamicMode) mvpMatrix.multiply(this.splatMesh.matrixWorld);\n\n            let gpuAcceleratedSortPromise = Promise.resolve(true);\n            if (this.gpuAcceleratedSort && (queuedSorts.length <= 1 || queuedSorts.length % 2 === 0)) {\n                gpuAcceleratedSortPromise = this.splatMesh.computeDistancesOnGPU(mvpMatrix, this.sortWorkerPrecomputedDistances);\n            }\n\n            gpuAcceleratedSortPromise.then(() => {\n                if (queuedSorts.length === 0) {\n                    if (this.splatMesh.dynamicMode || shouldSortAll) {\n                        queuedSorts.push(this.splatRenderCount);\n                    } else {\n                            for (let partialSort of partialSorts) {\n                            if (angleDiff < partialSort.angleThreshold) {\n                                for (let sortFraction of partialSort.sortFractions) {\n                                    queuedSorts.push(Math.floor(this.splatRenderCount * sortFraction));\n                                }\n                                break;\n                            }\n                        }\n                        queuedSorts.push(this.splatRenderCount);\n                    }\n                }\n                let sortCount = Math.min(queuedSorts.shift(), this.splatRenderCount);\n                this.splatSortCount = sortCount;\n\n                cameraPositionArray[0] = this.camera.position.x;\n                cameraPositionArray[1] = this.camera.position.y;\n                cameraPositionArray[2] = this.camera.position.z;\n\n                const sortMessage = {\n                    'modelViewProj': mvpMatrix.elements,\n                    'cameraPosition': cameraPositionArray,\n                    'splatRenderCount': this.splatRenderCount,\n                    'splatSortCount': sortCount,\n                    'usePrecomputedDistances': this.gpuAcceleratedSort\n                };\n                if (this.splatMesh.dynamicMode) {\n                    this.splatMesh.fillTransformsArray(this.sortWorkerTransforms);\n                }\n                if (!this.sharedMemoryForWorkers) {\n                    sortMessage.indexesToSort = this.sortWorkerIndexesToSort;\n                    sortMessage.transforms = this.sortWorkerTransforms;\n                    if (this.gpuAcceleratedSort) {\n                        sortMessage.precomputedDistances = this.sortWorkerPrecomputedDistances;\n                    }\n                }\n\n                this.sortPromise = new Promise((resolve) => {\n                    this.sortPromiseResolver = resolve;\n                });\n\n                if (this.preSortMessages.length > 0) {\n                    this.preSortMessages.forEach((message) => {\n                        this.sortWorker.postMessage(message);\n                    });\n                    this.preSortMessages = [];\n                }\n                this.sortWorker.postMessage({\n                    'sort': sortMessage\n                });\n\n                if (queuedSorts.length === 0) {\n                    lastSortViewPos.copy(this.camera.position);\n                    lastSortViewDir.copy(sortViewDir);\n                }\n\n                return true;\n            });\n\n            return gpuAcceleratedSortPromise;\n        };\n\n    }();\n\n    /**\n     * Determine which splats to render by checking which are inside or close to the view frustum\n     */\n    gatherSceneNodesForSort = function() {\n\n        const nodeRenderList = [];\n        let allSplatsSortBuffer = null;\n        const tempVectorYZ = new THREE.Vector3();\n        const tempVectorXZ = new THREE.Vector3();\n        const tempVector = new THREE.Vector3();\n        const modelView = new THREE.Matrix4();\n        const baseModelView = new THREE.Matrix4();\n        const sceneTransform = new THREE.Matrix4();\n        const renderDimensions = new THREE.Vector3();\n        const forward = new THREE.Vector3(0, 0, -1);\n\n        const tempMax = new THREE.Vector3();\n        const nodeSize = (node) => {\n            return tempMax.copy(node.max).sub(node.min).length();\n        };\n\n        return function(gatherAllNodes = false) {\n\n            this.getRenderDimensions(renderDimensions);\n            const cameraFocalLength = (renderDimensions.y / 2.0) / Math.tan(this.camera.fov / 2.0 * THREE.MathUtils.DEG2RAD);\n            const fovXOver2 = Math.atan(renderDimensions.x / 2.0 / cameraFocalLength);\n            const fovYOver2 = Math.atan(renderDimensions.y / 2.0 / cameraFocalLength);\n            const cosFovXOver2 = Math.cos(fovXOver2);\n            const cosFovYOver2 = Math.cos(fovYOver2);\n\n            const splatTree = this.splatMesh.getSplatTree();\n\n            if (splatTree) {\n                baseModelView.copy(this.camera.matrixWorld).invert();\n                if (!this.splatMesh.dynamicMode) baseModelView.multiply(this.splatMesh.matrixWorld);\n\n                let nodeRenderCount = 0;\n                let splatRenderCount = 0;\n\n                for (let s = 0; s < splatTree.subTrees.length; s++) {\n                    const subTree = splatTree.subTrees[s];\n                    modelView.copy(baseModelView);\n                    if (this.splatMesh.dynamicMode) {\n                        this.splatMesh.getSceneTransform(s, sceneTransform);\n                        modelView.multiply(sceneTransform);\n                    }\n                    const nodeCount = subTree.nodesWithIndexes.length;\n                    for (let i = 0; i < nodeCount; i++) {\n                        const node = subTree.nodesWithIndexes[i];\n                        if (!node.data || !node.data.indexes || node.data.indexes.length === 0) continue;\n                        tempVector.copy(node.center).applyMatrix4(modelView);\n\n                        const distanceToNode = tempVector.length();\n                        tempVector.normalize();\n\n                        tempVectorYZ.copy(tempVector).setX(0).normalize();\n                        tempVectorXZ.copy(tempVector).setY(0).normalize();\n\n                        const cameraAngleXZDot = forward.dot(tempVectorXZ);\n                        const cameraAngleYZDot = forward.dot(tempVectorYZ);\n\n                        const ns = nodeSize(node);\n                        const outOfFovY = cameraAngleYZDot < (cosFovYOver2 - .6);\n                        const outOfFovX = cameraAngleXZDot < (cosFovXOver2 - .6);\n                        if (!gatherAllNodes && ((outOfFovX || outOfFovY) && distanceToNode > ns)) {\n                            continue;\n                        }\n                        splatRenderCount += node.data.indexes.length;\n                        nodeRenderList[nodeRenderCount] = node;\n                        node.data.distanceToNode = distanceToNode;\n                        nodeRenderCount++;\n                    }\n                }\n\n                nodeRenderList.length = nodeRenderCount;\n                nodeRenderList.sort((a, b) => {\n                    if (a.data.distanceToNode < b.data.distanceToNode) return -1;\n                    else return 1;\n                });\n\n                let currentByteOffset = splatRenderCount * Constants.BytesPerInt;\n                for (let i = 0; i < nodeRenderCount; i++) {\n                    const node = nodeRenderList[i];\n                    const windowSizeInts = node.data.indexes.length;\n                    const windowSizeBytes = windowSizeInts * Constants.BytesPerInt;\n                    let destView = new Uint32Array(this.sortWorkerIndexesToSort.buffer,\n                                                   currentByteOffset - windowSizeBytes, windowSizeInts);\n                    destView.set(node.data.indexes);\n                    currentByteOffset -= windowSizeBytes;\n                }\n\n                return {\n                    'splatRenderCount': splatRenderCount,\n                    'shouldSortAll': false\n                };\n            } else {\n                const totalSplatCount = this.splatMesh.getSplatCount();\n                if (!allSplatsSortBuffer || allSplatsSortBuffer.length !== totalSplatCount) {\n                    allSplatsSortBuffer = new Uint32Array(totalSplatCount);\n                    for (let i = 0; i < totalSplatCount; i++) {\n                        allSplatsSortBuffer[i] = i;\n                    }\n                }\n                this.sortWorkerIndexesToSort.set(allSplatsSortBuffer);\n                return {\n                    'splatRenderCount': totalSplatCount,\n                    'shouldSortAll': true\n                };\n            }\n        };\n\n    }();\n\n    getSplatMesh() {\n        return this.splatMesh;\n    }\n\n    /**\n     * Get a reference to a splat scene.\n     * @param {number} sceneIndex The index of the scene to which the reference will be returned\n     * @return {SplatScene}\n     */\n    getSplatScene(sceneIndex) {\n        return this.splatMesh.getScene(sceneIndex);\n    }\n\n    getSceneCount() {\n        return this.splatMesh.getSceneCount();\n    }\n\n    isMobile() {\n        return navigator.userAgent.includes('Mobi');\n    }\n}\n\n/**\n * DropInViewer: Wrapper for a Viewer instance that enables it to be added to a Three.js scene like\n * any other Three.js scene object (Mesh, Object3D, etc.)\n */\nclass DropInViewer extends THREE.Group {\n\n    constructor(options = {}) {\n        super();\n\n        options.selfDrivenMode = false;\n        options.useBuiltInControls = false;\n        options.rootElement = null;\n        options.dropInMode = true;\n        options.camera = undefined;\n        options.renderer = undefined;\n\n        this.viewer = new Viewer(options);\n        this.splatMesh = null;\n        this.updateSplatMesh();\n\n        this.callbackMesh = DropInViewer.createCallbackMesh();\n        this.add(this.callbackMesh);\n        this.callbackMesh.onBeforeRender = DropInViewer.onBeforeRender.bind(this, this.viewer);\n\n        this.viewer.onSplatMeshChanged(() => {\n            this.updateSplatMesh();\n        });\n\n    }\n\n    updateSplatMesh() {\n        if (this.splatMesh !== this.viewer.splatMesh) {\n            if (this.splatMesh) {\n                this.remove(this.splatMesh);\n            }\n            this.splatMesh = this.viewer.splatMesh;\n            this.add(this.viewer.splatMesh);\n        }\n    }\n\n    /**\n     * Add a single splat scene to the viewer.\n     * @param {string} path Path to splat scene to be loaded\n     * @param {object} options {\n     *\n     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n     *                                     value (valid range: 0 - 255), defaults to 1\n     *\n     *         showLoadingUI:         Display a loading spinner while the scene is loading, defaults to true\n     *\n     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n     *\n     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n     *\n     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n     *\n     *         onProgress:                 Function to be called as file data are received\n     *\n     * }\n     * @return {AbortablePromise}\n     */\n    addSplatScene(path, options = {}) {\n        if (options.showLoadingUI !== false) options.showLoadingUI = true;\n        return this.viewer.addSplatScene(path, options);\n    }\n\n    /**\n     * Add multiple splat scenes to the viewer.\n     * @param {Array<object>} sceneOptions Array of per-scene options: {\n     *\n     *         path: Path to splat scene to be loaded\n     *\n     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n     *                                     value (valid range: 0 - 255), defaults to 1\n     *\n     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n     *\n     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n     *\n     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n     * }\n     * @param {boolean} showLoadingUI Display a loading spinner while the scene is loading, defaults to true\n     * @return {AbortablePromise}\n     */\n    addSplatScenes(sceneOptions, showLoadingUI) {\n        if (showLoadingUI !== false) showLoadingUI = true;\n        return this.viewer.addSplatScenes(sceneOptions, showLoadingUI);\n    }\n\n    /**\n     * Get a reference to a splat scene.\n     * @param {number} sceneIndex The index of the scene to which the reference will be returned\n     * @return {SplatScene}\n     */\n    getSplatScene(sceneIndex) {\n        return this.viewer.getSplatScene(sceneIndex);\n    }\n\n    removeSplatScene(index, showLoadingUI = true) {\n        return this.viewer.removeSplatScene(index, showLoadingUI);\n    }\n\n    removeSplatScenes(indexes, showLoadingUI = true) {\n        return this.viewer.removeSplatScenes(indexes, showLoadingUI);\n    }\n\n    getSceneCount() {\n        return this.viewer.getSceneCount();\n    }\n\n    setActiveSphericalHarmonicsDegrees(activeSphericalHarmonicsDegrees) {\n        this.viewer.setActiveSphericalHarmonicsDegrees(activeSphericalHarmonicsDegrees);\n    }\n\n    async dispose() {\n        return await this.viewer.dispose();\n    }\n\n    static onBeforeRender(viewer, renderer, threeScene, camera) {\n        viewer.update(renderer, camera);\n    }\n\n    static createCallbackMesh() {\n        const geometry = new THREE.SphereGeometry(1, 8, 8);\n        const material = new THREE.MeshBasicMaterial();\n        material.colorWrite = false;\n        material.depthWrite = false;\n        const mesh = new THREE.Mesh(geometry, material);\n        mesh.frustumCulled = false;\n        return mesh;\n    }\n\n}\n\nexport { AbortablePromise, DropInViewer, KSplatLoader, Utils as LoaderUtils, LogLevel, OrbitControls, PlayCanvasCompressedPlyParser, PlyLoader, PlyParser, RenderMode, SceneFormat, SceneRevealMode, SplatBuffer, SplatBufferGenerator, SplatLoader, SplatParser, SplatPartitioner, SplatRenderMode, SpzLoader, Viewer, WebXRMode };\n//# sourceMappingURL=gaussian-splats-3d.module.js.map\n"],"names":["_AbortablePromise","promiseFunc","abortHandler","resolver","rejecter","resolve","reject","promiseResolve","promiseReject","args","error","onResolve","onResolveResult","args2","onFail","reason","__publicField","AbortablePromise","AbortedPromiseError","msg","floatView","int32View","val","x","bits","m","e","uintEncodedFloat","f","rgbaArrayToInteger","arr","offset","fetchWithProgress","path","onProgress","saveChunks","headers","abortController","signal","aborted","onProgressCalledAtComplete","localOnProgress","percent","percentLabel","chunk","fileSize","fetchOptions","data","errorText","reader","bytesDownloaded","_fileSize","chunks","done","buffer","clamp","min","max","getCurrentTime","disposeAllMeshes","object3D","child","delayedExecute","func","fast","getSphericalHarmonicsComponentCountForDegree","sphericalHarmonicsDegree","shCoeffPerSplat","nativePromiseWithExtractedComponents","abortablePromiseWithExtractedComponents","Semver","major","minor","patch","isIOS","ua","getIOSSemever","extract","BASE_COMPONENT_COUNT","_UncompressedSplatArray","baseSplat","shEntries","i","splat","index","newSplat","y","z","scale0","scale1","scale2","rot0","rot1","rot2","rot3","r","g","b","opacity","rest","src","srcIndex","srcSplat","UncompressedSplatArray","Constants","DefaultSphericalHarmonics8BitCompressionRange","DefaultSphericalHarmonics8BitCompressionHalfRange","toHalfFloat","THREE.DataUtils","fromHalfFloat$1","toUncompressedFloat","compressionLevel","isSH","range8BitMin","range8BitMax","fromUint8","toUint8","v","rangeMin","rangeMax","range","fromHalfFloatToUint8","fromUint8ToHalfFloat","dataViewFloatForCompressionLevel","dataView","floatIndex","convertBetweenCompressionLevels","noop","fromLevel","toLevel","outputConversionFunc","copyBetweenBuffers","srcBuffer","srcOffset","destBuffer","destOffset","byteCount","dest","_SplatBuffer","bufferData","secLoadedCountsToMax","scaleMatrix","THREE.Matrix4","rotationMatrix","tempMatrix","tempPosition","THREE.Vector3","scale","rotation","THREE.Quaternion","outScale","outRotation","transform","scaleOverride","sectionIndex","section","localSplatIndex","srcSplatScalesBase","ensurePositiveW","quaternion","flip","outScaleArray","outRotationArray","srcFrom","srcTo","destFrom","desiredOutputCompressionLevel","splatCount","outputConversion","value","srcCompressionLevel","scaleDestBase","rotationDestBase","srcScaleX","srcScaleY","srcScaleZ","srcRotationW","srcRotationX","srcRotationY","srcRotationZ","tempMatrix3","THREE.Matrix3","tempMatrix4","tempTranslation","tempScale","tempRotation","sh11","sh12","sh13","sh21","sh22","sh23","sh24","sh25","shIn1","shIn2","shIn3","shIn4","shIn5","shOut1","shOut2","shOut3","shOut4","shOut5","set3","array","val1","val2","val3","set3FromArray","srcDestView","stride","srcBase","copy3","srcArray","destArray","setOutput3","destBase","conversionFunc","toUncompressedFloatArray3","outSphericalHarmonicsArray","outSphericalHarmonicsDegree","localFromHalfFloatToUint8","localToUint8","outSphericalHarmonicsComponentsCount","srcSplatSHBase","shDestBase","compressionLevelForOutputConversion","minShCoeff","maxShCoeff","minSphericalHarmonicsDegree","bucketIndex","maxSplatIndexInFullBuckets","bucketSplatIndex","partiallyFullBucketIndex","currentPartiallyFilledBucketSize","globalSplatIndex","outCenter","srcSplatCentersBase","bucketBase","sf","sr","outColor","srcSplatColorsBase","splatColorsArray","outCenterArray","center","centerDestBase","covarianceArray","covarianceDestBase","outColorArray","minimumAlpha","colorDestBase","alpha","headerArrayUint8","headerArrayUint16","headerArrayUint32","headerArrayFloat32","versionMajor","versionMinor","maxSectionCount","sectionCount","maxSplatCount","sceneCenter","minSphericalHarmonicsCoeff","maxSphericalHarmonicsCoeff","header","sectionHeaderArrayUint16","sectionHeaderArrayUint32","sectionHeaderArrayFloat32","sectionHeaders","sectionHeaderBase","sectionHeaderBaseUint16","sectionHeaderBaseUint32","sectionBase","splatCountOffset","bucketSize","bucketCount","bucketBlockSize","halfBucketBlockSize","bucketStorageSizeBytes","compressionScaleRange","fullBucketCount","partiallyFilledBucketCount","bucketsMetaDataSizeBytes","bucketsStorageSizeBytes","bytesPerSplat","splatDataStorageSizeBytes","storageSizeBytes","sectionHeader","sectionHeadeArrayUint16","sectionHeadeArrayUint32","sectionHeadeArrayFloat32","bytesPerCenter","bytesPerScale","bytesPerRotation","bytesPerColor","sphericalHarmonicsComponentsPerSplat","sphericalHarmonicsBytesPerSplat","cumulativeSplatCount","j","newSectionCount","newSplatCount","sectionHeaderOffset","splatArrays","blockSize","options","shDegree","sa","splatArray","sc","sectionBuffers","sectionHeaderBuffers","totalSplatCount","validSplats","targetSplat","sectionOptions","sectionBlockSize","sectionBucketSize","bucketInfo","partiallyFullBucketLengths","bucket","buckets","sectionDataSizeBytes","bucketMetaDataSizeBytes","bucketDataBytes","sectionSizeBytes","sectionBuffer","compressionScaleFactor","bucketCenter","outSplatCount","row","bufferOffset","bucketMetaDataArray","pfb","bucketArray","base","sectionHeaderBuffer","sectionsCumulativeSizeBytes","unifiedBufferSize","unifiedBuffer","currentUnifiedBase","halfBlockSize","dimensions","yBlocks","zBlocks","blockCenter","fullBuckets","partiallyFullBuckets","xBlock","yBlock","zBlock","bucketId","partiallyFullBucketArray","sphericalHarmonicsDegrees","shDescriptor","splatBufferDataOffsetBytes","splatBufferSizeBytes","outBuffer","covarianceMatrix","transformedCovariance","transform3x3","transform3x3Transpose","outCovariance","outOffset","v1","v2","v3","transformRow","outArray","t0","t1","t2","v4","v5","t3","t4","in1","in2","in3","tsh11","tsh12","tsh13","out1","out2","out3","in4","in5","tsh21","tsh22","tsh23","tsh24","tsh25","out4","out5","kSqrt0104","kSqrt0304","kSqrt0103","kSqrt0403","kSqrt0112","tempCenterBuffer","tempScaleBuffer","tempRotationBuffer","tempColorBuffer","tempSHBuffer","tempRot","bucketCenterDelta","OFFSET_X","OFFSET_Y","OFFSET_Z","OFFSET_SCALE0","OFFSET_SCALE1","OFFSET_SCALE2","OFFSET_ROT0","OFFSET_ROT1","OFFSET_ROT2","OFFSET_ROT3","OFFSET_FDC0","OFFSET_FDC1","OFFSET_FDC2","OFFSET_OPACITY","OFFSET_FRC0","OFFSET_FRC9","compressPositionOffset","doubleCompressionScaleRange","centerBase","scaleBase","rotationBase","colorBase","sphericalHarmonicsBase","rot","shOut","s","SHArrayType","bytesPerSHComponent","srcVal","degree1ByteCount","rgba","SplatBuffer","HeaderMagicBytes","HeaderEndTokenBytes","HeaderEndToken","DataTypeMap","unpackUnorm","t","unpack111011","result","unpack8888","unpackRot","norm","a","c","lerp","getElementPropStorage","element","name","_a","p","_PlayCanvasCompressedPlyParser","headerText","chunkElement","vertexElement","shElement","headerLines","line","words","StorageType","storageSizeByes","sphericalHarmonicsPerSplat","plyBuffer","find","buf","search","endIndex","startsWith","endHeaderTokenOffset","readBuffer","readOffset","fromIndex","toIndex","propertyFilter","property","requiredStorageSizeBytes","readIndex","storageArrays","minR","minG","minB","maxR","maxG","maxB","minX","minY","minZ","maxX","maxY","maxZ","minScaleX","minScaleY","minScaleZ","maxScaleX","maxScaleY","maxScaleZ","position","color","shStorageArrays","fRestKey","fRest","chunkSplatIndexOffset","vertexDataBuffer","outBytesPerSplat","positionExtremes","scaleExtremes","colorExtremes","tempSplat","outBase","vertexReadOffset","readSphericalHarmonicsDegree","sh","shArrays","splatBuffer","THREE.Vector4","OFFSET","positionArray","scaleArray","rotationArray","colorArray","outSplat","chunkIndex","shCoeffMap","shIndexMap","shArray","outSHCoeff","readSHCoeff","k","outIndex","PlayCanvasCompressedPlyParser","PlyFormat","FieldSizeIdDouble","FieldSizeIdInt","FieldSizeIdUInt","FieldSizeIdFloat","FieldSizeIdShort","FieldSizeIdUShort","FieldSizeIdUChar","FieldSizeStringMap","FieldSize","_PlyParserUtils","fieldNameIdMap","headerStartLine","extractedLines","processingSection","headerEndLine","vertexCount","endOfHeader","sectionName","fieldIds","fieldTypes","allFieldNames","fieldTypesByName","lineComponents","validComponents","lineComponent","trimmedComponent","fieldMatch","fieldTypeStr","fieldName","fieldId","fieldType","fieldOffsets","bytesPerVertex","sphericalHarmonics","fieldNames","sphericalHarmonicsFieldCount","coefficientsPerChannel","degree","degree1Fields","degree2Fields","rgb","sectionNames","headerLine","endHeaderTestText","searchOfset","chunkSize","decoder","endHeaderTestChunk","headerOffset","readChunkSize","headerChunk","prunedLines","headertText","format","vertexData","dataOffset","fieldsToRead","rawVertex","normalize","PlyParserUtils","BaseFieldNamesToRead","BaseFieldsToReadIndexes","SCALE_0","SCALE_1","SCALE_2","ROT_0","ROT_1","ROT_2","ROT_3","X","Y","Z","F_DC_0","F_DC_1","F_DC_2","OPACITY","RED$1","GREEN$1","BLUE$1","F_REST_0","_INRIAV1PlyParser","shLineCount","shFieldsToReadCount","shRemainingFieldNamesToRead","fieldNamesToRead","fieldsToReadIndexes","acc","fromSplat","toSplat","splatData","splatDataOffset","toBuffer","toOffset","parsedSplat","sectionSplatData","toSplatArray","rawSplat","separatePlyHeaderAndData","OFFSET_ROTATION0","OFFSET_ROTATION1","OFFSET_ROTATION2","OFFSET_ROTATION3","OFFSET_FRC","SH_C0","INRIAV1PlyParser","CodeBookEntryNamesToRead","CodeBookEntriesToReadIndexes","CB_FEATURES_DC","CB_FEATURES_REST_0","CB_FEATURES_REST_3","CB_OPACITY","CB_SCALING","CB_ROTATION_RE","CB_ROTATION_IM","FieldNamesToRead","FieldsToReadIndexes","PLY_SCALE_0","PLY_SCALE_1","PLY_SCALE_2","PLY_ROT_0","PLY_ROT_1","PLY_ROT_2","PLY_ROT_3","PLY_X","PLY_Y","PLY_Z","PLY_F_DC_0","PLY_F_DC_1","PLY_F_DC_2","PLY_OPACITY","PLY_RED","PLY_GREEN","PLY_BLUE","fromHalfFloat","hf","_INRIAV2PlyParser","codeBookEntriesToReadIdMap","codeBookSectionIndex","currentStartLine","lastSectionFound","headerSizeBytes","targetSection","byteOffset","codeBookData","codeBook","codeBookElementOffset","codeBookPage","page","baseValue","unified","INRIAV2PlyParser","PlyParser","plyFormat","SplatPartitioner","sectionFilters","groupingParameters","partitionGenerator","results","newArrays","sectionSplats","sectionFilter","partitionSize","clampDistance","clampPoint","point","centerADist","centerBDist","patitionCount","currentStartSplat","startSplat","splatIndex","SplatBufferGenerator","splatPartitioner","alphaRemovalThreshold","sectionSize","partitionResults","LoaderStatus","DirectLoadError","InternalLoadType","storeChunksInBuffer","inBytes","finalize$1","optimizeSplatData","PlyLoader","fileName","progressiveLoadToSplatBuffer","onProgressiveLoadSectionProgress","internalLoadType","directLoadSectionSizeBytes","directLoadBufferIn","directLoadBufferOut","directLoadSplatBuffer","compressedPlyHeaderChunksBuffer","processedBaseSplatCount","processedSphericalHarmonicsSplatCount","headerLoaded","readyToLoadSplatData","baseSplatDataLoaded","loadPromise","numBytesStreamed","numBytesParsed","numBytesDownloaded","endOfBaseSplatDataBytes","standardLoadUncompressedSplatArray","textDecoder","chunkData","loadComplete","sizeRequiredForHeaderAndChunks","numBytesToProcess","addedSplatCount","numBytesToParse","numBytesLeftOver","parsedDataViewOffset","dataToParse","shDesc","keepChunks","keepSize","chunkDatas","plyFileData","createStream","controller","decompressGzipped","stream","decompressGzipStream","decompressedStream","SPZ_MAGIC","FLAG_ANTIALIASED","COLOR_SCALE","halfToFloat","h","sgn","exponent","mantissa","signMul","unquantizeSH","dimForDegree","unpackedSplatToUncompressedSplat","unpackedSplat","unpackedSphericalHarmonicsDegree","checkSizes2","packed","numPoints","shDim","usesFloat16","unpackGaussians","directToSplatBuffer","outTarget","outTargetOffset","halfData","fullPrecisionPositionScale","shCoeffPerChannelPerSplat","fixed32","xyz","squaredNorm","uncompressedSplat","HEADER_SIZE","MAX_POINTS_TO_READ","deserializePackedGaussians","view","uint8View","positionsSize","currentOffset","loadSpzPacked","compressedData","decompressed","SpzLoader","fileData","spzFileData","_SplatParser","fromBuffer","fromOffset","outBytesPerCenter","outBytesPerScale","outBytesPerRotation","inBase","inCenter","inScale","inColor","inRotation","quat","inBuffer","SplatParser","finalize","SplatLoader","splatDataOffsetBytes","numBytesLoaded","percentStr","bytesLoadedSinceLastSection","splatFileData","_KSplatLoader","minVersionMajor","minVersionMinor","externalOnProgress","onSectionBuilt","directLoadBuffer","headerBuffer","headerLoading","sectionHeadersBuffer","sectionHeadersLoaded","sectionHeadersLoading","numBytesProgressivelyLoaded","totalBytesToDownload","downloadComplete","loadSectionQueued","directLoadPromise","checkAndLoadHeader","checkAndLoadSectionHeaders","queuedCheckAndLoadSectionsCount","queueCheckAndLoadSections","checkAndLoadSections","performLoad","totalSectionStorageStorageByes","totalStorageSizeBytes","checkAndLoadFunc","baseDataOffset","reachedSections","loadedSplatCount","bucketsDataOffset","bytesRequiredToReachSectionSplatData","bytesPastSSectionSplatDataStart","loadedSplatsForSection","percentComplete","fullBuffer","downLoadLink","blob","KSplatLoader","SceneFormat","sceneFormatFromPath","_changeEvent","_startEvent","_endEvent","_ray","Ray$1","_plane","Plane","TILT_LIMIT","MathUtils","OrbitControls","EventDispatcher","object","domElement","Vector3","MOUSE","TOUCH","spherical","onKeyDown","scope","state","STATE","sphericalDelta","panOffset","Quaternion","quatInverse","lastPosition","lastQuaternion","lastTargetPosition","twoPI","rotateLeft","getAutoRotationAngle","performCursorZoom","zoomChanged","newRadius","prevRadius","radiusDelta","dollyDirection","mouseBefore","mouse","mouseAfter","EPS","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","onPointerMove","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","angle","rotateUp","panLeft","distance","objectMatrix","panUp","pan","deltaX","deltaY","targetDistance","dollyOut","dollyScale","dollyIn","updateMouseParameters","event","rect","w","dist","handleMouseDownRotate","handleMouseDownDolly","handleMouseDownPan","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","handleMouseWheel","handleKeyDown","needsUpdate","handleTouchStartRotate","handleTouchStartPan","handleTouchStartDolly","dx","dy","handleTouchStartDollyPan","handleTouchStartDollyRotate","handleTouchMoveRotate","getSecondPointerPosition","handleTouchMovePan","handleTouchMoveDolly","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","addPointer","onTouchStart","onMouseDown","onTouchMove","onMouseMove","removePointer","mouseAction","trackPointer","pointer","fadeElement","out","displayStyle","duration","onComplete","startTime","startOpacity","interval","elapsed","STANDARD_FADE_DURATION","_LoadingSpinner","message","container","style","newTask","id","task","minimized","instant","showHideSpinner","show","fadeTransitionsIndex","LoadingSpinner","LoadingProgressBar","progress","InfoPanel","renderDimensions","cameraPosition","cameraLookAtPosition","cameraUp","orthographicCamera","meshCursorPosition","currentFPS","splatRenderCount","splatRenderCountPct","lastSortTime","focalAdjustment","splatScale","pointCloudMode","cameraPosString","cla","cameraLookAtString","cameraUpString","cursPos","cursorPosString","layout","infoTable","layoutEntry","labelCell","spacerCell","infoCell","_axis","ArrowHelper","THREE.Object3D","dir","origin","length","radius","headLength","headRadius","lineGeometry","THREE.CylinderGeometry","coneGeometry","THREE.Mesh","THREE.MeshBasicMaterial","radians","source","SceneHelper","threeScene","toCamera","camera","viewport","toCameraDistance","tempQuaternion","defaultUp","up","width","height","THREE.WebGLRenderTarget","THREE.RGBAFormat","THREE.DepthTexture","THREE.DepthFormat","THREE.UnsignedIntType","uniforms","renderTargetCopyMaterial","THREE.ShaderMaterial","THREE.CustomBlending","THREE.SrcAlphaFactor","THREE.OneMinusSrcAlphaFactor","THREE.PlaneGeometry","THREE.OrthographicCamera","THREE.ConeGeometry","coneMaterial","downArrow","upArrow","leftArrow","rightArrow","visible","sphereGeometry","THREE.SphereGeometry","focusMarkerMaterial","planeGeometry","planeMaterial","THREE.DoubleSide","planeMesh","arrowDir","arrowOrigin","arrowLength","arrowRadius","arrowColor","arrowHelper","debugRoot","renderOrder","debugMeshRoot","createMesh","sphereMesh","boxGeometry","THREE.BoxGeometry","boxColor","boxMesh","separation","vertexShaderSource","fragmentShaderSource","THREE.Color","material","THREE.FrontSide","THREE.Vector2","VectorRight","VectorUp","VectorBackward","Ray","direction","planeIntersectionPoint","planeIntersectionPointArray","originArray","directionArray","box","outHit","hitNormal","extremeVec","multiplier","toSide","idx1","idx2","toSphereCenterVec","toClosestApproach","toClosestApproachSq","diffSq","radiusSq","thc","epsilon","Hit","normal","hitClone","SplatRenderMode","Raycaster","raycastAgainstTrueSplatEllipsoid","ndcCoords","screenPosition","screenDimensions","toLocal","fromLocal","sceneTransform","localRay","tempPoint","splatMesh","outHits","splatTree","subTree","outHitsForSubTree","hit","tempColor","tempCenter","tempHit","scaleEpsilon","uniformScaleMatrix","toSphereSpace","fromSphereSpace","tempRay","ray","node","splatGlobalIndex","splatSceneIndex","uniformScale","componentCount","SplatMaterial","dynamicMode","enableOptionalEffects","maxSphericalHarmonicsDegree","customVars","pointCloudModeEnabled","sceneOpacity","sceneVisibility","transformMatrices","SplatMaterial3D","antialiased","maxScreenSpaceSplatSize","kernel2DSize","THREE.NormalBlending","SplatMaterial2D","SplatGeometry","baseGeometry","THREE.BufferGeometry","positionsArray","positions","THREE.BufferAttribute","geometry","THREE.InstancedBufferGeometry","splatIndexArray","splatIndexes","THREE.InstancedBufferAttribute","THREE.DynamicDrawUsage","SplatScene","otherScene","_SplatTreeNode","depth","THREE.Box3","SplatTreeNode","SplatSubTree","maxDepth","maxCentersPerNode","workerSubTreeNode","minVector","maxVector","convertedNode","workerSubTree","convertedSubTree","visitLeavesFromNode","visitFunc","createSplatTreeWorker","self","WorkerSplatTreeNodeIDGen","WorkerBox3","WorkerSplatSubTree","WorkerSplatTreeNode","tree","indexToCenter","sceneCenters","newIndexes","nodeDimensions","halfDimensions","nodeCenter","childrenBounds","baseIndexes","childNode","buildSubTree","sceneMin","sceneMax","indexes","centerCount","createSplatTree","allCenters","subTrees","workerProcessCenters","splatTreeWorker","centers","transferBuffers","checkAndCreateWorker","SplatTree","filterFunc","onIndexesUpload","onSplatTreeConstruction","addCentersForScene","splatOffset","addedCount","addBase","checkForEarlyExit","leafCount","WebGLExtensions","gl","extensions","getExtension","extension","capabilities","WebGLCapabilities","parameters","maxAnisotropy","getMaxAnisotropy","getMaxPrecision","precision","isWebGL2","maxPrecision","drawBuffers","logarithmicDepthBuffer","maxTextures","maxVertexTextures","maxTextureSize","maxCubemapSize","maxAttributes","maxVertexUniforms","maxVaryings","maxFragmentUniforms","vertexTextures","floatFragmentTextures","floatVertexTextures","maxSamples","SceneRevealMode","LogLevel","dummyGeometry","dummyMaterial","COVARIANCES_ELEMENTS_PER_SPLAT","CENTER_COLORS_ELEMENTS_PER_SPLAT","COVARIANCES_ELEMENTS_PER_TEXEL_STORED","COVARIANCES_ELEMENTS_PER_TEXEL_ALLOCATED","COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_STORED","COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_ALLOCATED","SCALES_ROTATIONS_ELEMENTS_PER_TEXEL","CENTER_COLORS_ELEMENTS_PER_TEXEL","SCENE_INDEXES_ELEMENTS_PER_TEXEL","SCENE_FADEIN_RATE_FAST","SCENE_FADEIN_RATE_GRADUAL","VISIBLE_REGION_EXPANSION_DELTA","MAX_TEXTURE_TEXELS","SplatMesh","splatRenderMode","halfPrecisionCovariancesOnGPU","devicePixelRatio","enableDistancesComputationOnGPU","integerBasedDistancesComputation","logLevel","sceneFadeInRateMultiplier","minAlphas","onSplatTreeIndexesUpload","buildStartTime","splatColor","sceneIndex","minAlpha","buildTime","leavesWithVertices","avgSplatCount","nodeCount","nodeSplatCount","cameraFocalLengthX","cameraFocalLengthY","orthographicMode","orthographicZoom","inverseFocalAdjustment","currentMaxSplatCount","rebuildGPUObjects","rebuildBuffers","createShader","type","shader","typeName","errors","vsSource","fsSource","currentVao","currentProgram","currentProgramDeleted","program","vertexShader","fragmentShader","tempArray","sceneTransformElements","modelViewProjMatrix","outComputedDistances","iTempMatrix","iTransform","iViewProjMatrix","iViewProj","viewProj","sync","promise","checkSync","paramsObj","globalIndex","applySceneTransform","parentObject","splatBuffers","sceneOptions","scenes","scene","localSplatIndexMap","sceneIndexMap","keepSceneTransforms","finalBuild","preserveVisibleRegion","newScenes","newScene","existingScene","splatBufferSphericalHarmonicsDegree","splatBuffersChanged","isUpdateBuild","indexMaps","splatBufferSplatCount","dataUpdateResults","deleteTextureData","texture","textureKey","textureContainer","callback","start","end","sceneIndexes","sinceLastBuildOnly","updateStart","computeDataTextureSize","elementsPerTexel","elementsPerSplat","texSize","getCovariancesElementsPertexelStored","getCovariancesInitialTextureSpecs","elementsPerTexelStored","covarianceCompressionLevel","scaleRotationCompressionLevel","shCompressionLevel","covariances","scales","rotations","initialCovTexSpecs","colors","SphericalHarmonicsArrayType","shComponentCount","shData","centersColsTexSize","paddedCentersCols","centersColsTex","THREE.DataTexture","THREE.RGBAIntegerFormat","covTexSpecs","covariancesElementsPerTexelStored","covTexSize","CovariancesDataType","covariancesElementsPerTexelAllocated","covariancesTextureData","covTex","THREE.FloatType","dummyTex","scaleRotationsTexSize","ScaleRotationsDataType","scaleRotationsTextureType","paddedScaleRotations","scaleRotationsTex","shTextureType","THREE.UnsignedByteType","THREE.HalfFloatType","paddedSHComponentCount","shElementsPerTexel","texelFormat","shTexSize","paddedSHArraySize","paddedSHArray","shTexture","shComponentCountPerChannel","textureUniforms","paddedSHArrays","shTextures","sceneIndexesTexSize","paddedTransformIndexes","sceneIndexesTexture","THREE.RedIntegerFormat","covarancesTextureDesc","scaleRotationsTextureDesc","shITextureDesc","shTextureDesc","centerColorsTextureDescriptor","paddedCenterColors","centerColorsTexture","centerColorsTextureProps","covariancesTexture","covarancesStartElement","covariancesEndElement","covariance","covariancesTextureProps","scaleRotationsTexture","bytesPerElement","scaleRotationsTextureProps","shBytesPerElement","updateTexture","shTextureSize","shTextureProps","sceneIndexesTexDesc","paddedSceneIndexes","sceneIndexesTextureProps","maxCompressionLevel","minCompressionLevel","endSplat","textureWidth","texelsPerSplat","startSplatTexels","startRow","startRowElement","endSplatTexels","endRow","endRowEndElement","paddedData","textureSize","textureProps","from","to","updateRegion","updateElementCount","updateDataView","updateHeight","glType","glFormat","currentTexture","sourceData","textureData","textureDataStartIndex","fromElement","toElement","textureDataView","textureDataIndex","sequentialCount","colorsBase","centersBase","centerColorsBase","scaleRotationsBase","avgCenter","startSplatFormMaxDistanceCalc","distFromCSceneCenter","sceneRevealMode","fastFadeRate","gradualFadeRate","defaultFadeInRate","fadeInRate","fadeInComplete","shaderFadeInComplete","globalIndexes","renderSplatCount","enabled","includeSinceLastBuild","renderer","THREE.WebGLUtils","isUpdate","offsetSplats","ArrayType","attributeBytesPerCenter","subBufferOffset","maxArray","fillCount","returnSceneTransform","sphericalHarmonicsCompressionLevel","srcStart","srcEnd","destStart","tempTransform","startSceneIndex","endSceneIndex","padFour","floatCenters","intCenters","paddedFloatCenters","outTransform","matrix","matrixElements","intMatrixArray","applySceneTransforms","SorterWasm","SorterWasmNoSIMD","SorterWasmNonShared","SorterWasmNoSIMDNonShared","sortWorker","wasmInstance","wasmMemory","useSharedMemory","integerBasedSort","indexesToSortOffset","sortedIndexesOffset","sceneIndexesOffset","transformsOffset","precomputedDistancesOffset","mappedDistancesOffset","frequenciesOffset","centersOffset","modelViewProjOffset","countsZero","sortedIndexesOut","distanceMapRange","uploadedSplatCount","sort","splatSortCount","modelViewProj","usePrecomputedDistances","copyIndexesToSort","copyPrecomputedDistances","copyTransforms","sortStartTime","precomputedDistances","sortMessage","sortedIndexes","sortEndTime","renderCount","sortCount","CENTERS_BYTES_PER_ENTRY","sorterWasmBytes","matrixSize","memoryRequiredForIndexesToSort","memoryRequiredForCenters","memoryRequiredForModelViewProjectionMatrix","memoryRequiredForPrecomputedDistances","memoryRequiredForMappedDistances","memoryRequiredForSortedIndexes","memoryRequiredForIntermediateSortBuffers","memoryRequiredforTransformIndexes","memoryRequiredforTransforms","extraMemory","totalRequiredMemory","totalPagesRequired","sorterWasmImport","wasmModule","instance","createSortWorker","enableSIMDInSort","splatSortDistanceMapPrecision","worker","sourceWasm","iOSSemVer","sorterWasmBinaryString","WebXRMode","VRButton","sessionInit","button","showEnterVR","currentSession","onSessionStarted","session","onSessionEnded","sessionOptions","err","disableButton","showWebXRNotFound","showVRNotAllowed","exception","stylizeElement","supported","ARButton","showStartAR","overlay","svg","showARNotSupported","showARNotAllowed","RenderMode","THREE_CAMERA_FOV","MINIMUM_DISTANCE_TO_NEW_FOCAL_POINT","MIN_SPLAT_COUNT_TO_SHOW_SPLAT_TREE_LOADING_SPINNER","FOCUS_MARKER_FADE_IN_SPEED","FOCUS_MARKER_FADE_OUT_SPEED","CONSECUTIVE_RENDERED_FRAMES_FOR_FPS_CALCULATION","_Viewer","forward","tempMatrixLeft","tempMatrixRight","clickOffset","toNewFocalPoint","intersectionPoint","focalLengthX","focalLengthY","focalMultiplier","splatBufferOptions","showLoadingUI","showLoadingUIForSplatTreeBuild","replaceExisting","enableRenderBeforeFirstSort","splatProcessingTaskId","removeSplatProcessingTask","buildResults","sortRunning","splatOptimizingTaskId","allSplatBuffers","allSplatBufferOptions","finished","onSplatTreeReady","lastCameraPosition","lastCameraOrientation","changeEpsilon","shouldRender","cameraChanged","cp","co","hasRenderables","savedAuoClear","lastCalcTime","frameCount","currentTime","lastRendererSize","currentRendererSize","lastCameraOrthographic","lastUpdateTime","timeDelta","tempCameraTarget","toPreviousTarget","toNextTarget","rotationAngle","wasTransitioning","currentFocusMarkerOpacity","newFocusMarkerOpacity","mvpMatrix","cameraPositionArray","lastSortViewDir","sortViewDir","lastSortViewPos","sortViewOffset","queuedSorts","partialSorts","force","forceSortAll","angleDiff","positionDiff","needsRefreshForRotation","needsRefreshForPosition","shouldSortAll","mvpCamera","gpuAcceleratedSortPromise","partialSort","sortFraction","nodeRenderList","allSplatsSortBuffer","tempVectorYZ","tempVectorXZ","tempVector","modelView","baseModelView","tempMax","nodeSize","gatherAllNodes","cameraFocalLength","THREE.MathUtils","fovXOver2","fovYOver2","cosFovXOver2","cosFovYOver2","nodeRenderCount","distanceToNode","cameraAngleXZDot","cameraAngleYZDot","ns","outOfFovY","outOfFovX","currentByteOffset","windowSizeInts","windowSizeBytes","semver","THREE.Scene","THREE.PerspectiveCamera","THREE.WebGLRenderer","webXRSessionInit","controls","renderMode","activeSphericalHarmonicsDegrees","outDimensions","fromCamera","resetControls","fromControls","toControls","xrCameraProj00","cameraProj00","progressiveLoad","loadingUITaskId","hideLoadingUI","onProgressUIUpdate","percentCompleteLabel","loaderStatus","suffix","downloadDone","downloadedPercentage","splatBuffersAddedUIUpdate","firstBuild","buildSection","addSplatBufferOptions","splatAlphaRemovalThreshold","buildFunc","onException","downloadPromise","downloadAndBuildPromise","onDownloadProgress","onDownloadException","progressiveLoadedSectionBuildCount","progressiveLoadedSectionBuilding","queuedProgressiveLoadSectionBuilds","checkAndBuildProgressiveLoadSections","queuedBuild","progressiveLoadFirstSectionBuildPromise","splatSceneDownloadAndBuildPromise","splatSceneDownloadPromise","fileCount","onLoadProgress","fileIndex","totalPercent","baseDownloadPromises","nativeDownloadPromises","baseDownloadPromise","progressiveBuild","DistancesArrayType","splatDataTextures","covariancesTextureSize","centersColorsTextureSize","defaultMessage","indexToRemove","indexesToRemove","sortPromise","revmovalTaskId","checkAndHideLoadingUI","onDone","savedSplatBuffers","savedSceneOptions","savedSceneTransformComponents","shouldRemove","waitPromises","promisesToAbort","promiseKey","downloadPromiseToAbort","toAbort","positionCamera","zoomedCamera","toLookAtDistance","zoomCamera","positionZamera","Viewer"],"mappings":"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","x_google_ignoreList":[0]}