{"version":3,"file":"spark-vendor-B1iD0OwS.js","sources":["../../../node_modules/@sparkjsdev/spark/dist/spark.module.js"],"sourcesContent":["import * as THREE from \"three\";\nimport { Mesh, OrthographicCamera, BufferGeometry, Float32BufferAttribute, Loader, FileLoader, Quaternion, Vector3, Color, Matrix4 } from \"three\";\nconst _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\nclass FullscreenTriangleGeometry extends BufferGeometry {\n  constructor() {\n    super();\n    this.setAttribute(\"position\", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));\n  }\n}\nconst _geometry = new FullscreenTriangleGeometry();\nclass FullScreenQuad {\n  constructor(material) {\n    this._mesh = new Mesh(_geometry, material);\n  }\n  dispose() {\n    this._mesh.geometry.dispose();\n  }\n  render(renderer) {\n    renderer.render(this._mesh, _camera);\n  }\n  get material() {\n    return this._mesh.material;\n  }\n  set material(value) {\n    this._mesh.material = value;\n  }\n}\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\nvar fleb = new u8([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b;\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n  var x = (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) << 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n}\nvar hMap = function(cd, mb, r) {\n  var s = cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = 1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n};\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n  flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n  flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n  flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n  fdt[i] = 5;\nvar flrm = /* @__PURE__ */ hMap(flt, 9, 1);\nvar fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max$1 = function(a) {\n  var m = a[0];\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m)\n      m = a[i];\n  }\n  return m;\n};\nvar bits = function(d, p, m) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\nvar bits16 = function(d, p) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\nvar shft = function(p) {\n  return (p + 7) / 8 | 0;\n};\nvar slc = function(v, s, e) {\n  if (s == null || s < 0)\n    s = 0;\n  if (e == null || e > v.length)\n    e = v.length;\n  return new u8(v.subarray(s, e));\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n];\nvar err = function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  if (!nt)\n    throw e;\n  return e;\n};\nvar inflt = function(dat, st, buf, dict) {\n  var sl = dat.length, dl = dict ? dict.length : 0;\n  if (!sl || st.f && !st.l)\n    return buf || new u8(0);\n  var noBuf = !buf;\n  var resize = noBuf || st.i != 2;\n  var noSt = st.i;\n  if (noBuf)\n    buf = new u8(sl * 3);\n  var cbuf = function(l2) {\n    var bl = buf.length;\n    if (l2 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l2));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  var tbts = sl * 8;\n  do {\n    if (!lm) {\n      final = bits(dat, pos, 1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n        if (t > sl) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (resize)\n          cbuf(bt + l);\n        buf.set(dat.subarray(s, t), bt);\n        st.b = bt += l, st.p = pos = t * 8, st.f = final;\n        continue;\n      } else if (type == 1)\n        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i = 0; i < hcLen; ++i) {\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n        pos += hcLen * 3;\n        var clb = max$1(clt), clbmsk = (1 << clb) - 1;\n        var clm = hMap(clt, clb, 1);\n        for (var i = 0; i < tl; ) {\n          var r = clm[bits(dat, pos, clbmsk)];\n          pos += r & 15;\n          var s = r >> 4;\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            var c = 0, n = 0;\n            if (s == 16)\n              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n            else if (s == 17)\n              n = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s == 18)\n              n = 11 + bits(dat, pos, 127), pos += 7;\n            while (n--)\n              ldt[i++] = c;\n          }\n        }\n        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n        lbt = max$1(lt);\n        dbt = max$1(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else\n        err(1);\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n    }\n    if (resize)\n      cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var lpos = pos;\n    for (; ; lpos = pos) {\n      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n      pos += c & 15;\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n      if (!c)\n        err(2);\n      if (sym < 256)\n        buf[bt++] = sym;\n      else if (sym == 256) {\n        lpos = pos, lm = null;\n        break;\n      } else {\n        var add2 = sym - 254;\n        if (sym > 264) {\n          var i = sym - 257, b = fleb[i];\n          add2 = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        }\n        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n        if (!d)\n          err(3);\n        pos += d & 15;\n        var dt = fd[dsym];\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (resize)\n          cbuf(bt + 131072);\n        var end = bt + add2;\n        if (bt < dt) {\n          var shift = dl - dt, dend = Math.min(dt, end);\n          if (shift + bt < 0)\n            err(3);\n          for (; bt < dend; ++bt)\n            buf[bt] = dict[shift + bt];\n        }\n        for (; bt < end; ++bt)\n          buf[bt] = buf[bt - dt];\n      }\n    }\n    st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n    if (lm)\n      final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\nvar et = /* @__PURE__ */ new u8(0);\nvar b2 = function(d, b) {\n  return d[b] | d[b + 1] << 8;\n};\nvar b4 = function(d, b) {\n  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n  return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\nvar gzs = function(d) {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n    err(6, \"invalid gzip data\");\n  var flg = d[3];\n  var st = 10;\n  if (flg & 4)\n    st += (d[10] | d[11] << 8) + 2;\n  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n    ;\n  return st + (flg & 2);\n};\nvar Inflate = /* @__PURE__ */ function() {\n  function Inflate2(opts, cb) {\n    if (typeof opts == \"function\")\n      cb = opts, opts = {};\n    this.ondata = cb;\n    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n    this.s = { i: 0, b: dict ? dict.length : 0 };\n    this.o = new u8(32768);\n    this.p = new u8(0);\n    if (dict)\n      this.o.set(dict);\n  }\n  Inflate2.prototype.e = function(c) {\n    if (!this.ondata)\n      err(5);\n    if (this.d)\n      err(4);\n    if (!this.p.length)\n      this.p = c;\n    else if (c.length) {\n      var n = new u8(this.p.length + c.length);\n      n.set(this.p), n.set(c, this.p.length), this.p = n;\n    }\n  };\n  Inflate2.prototype.c = function(final) {\n    this.s.i = +(this.d = final || false);\n    var bts = this.s.b;\n    var dt = inflt(this.p, this.s, this.o);\n    this.ondata(slc(dt, bts, this.s.b), this.d);\n    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n  };\n  Inflate2.prototype.push = function(chunk, final) {\n    this.e(chunk), this.c(final);\n  };\n  return Inflate2;\n}();\nfunction inflateSync(data, opts) {\n  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nvar Gunzip = /* @__PURE__ */ function() {\n  function Gunzip2(opts, cb) {\n    this.v = 1;\n    this.r = 0;\n    Inflate.call(this, opts, cb);\n  }\n  Gunzip2.prototype.push = function(chunk, final) {\n    Inflate.prototype.e.call(this, chunk);\n    this.r += chunk.length;\n    if (this.v) {\n      var p = this.p.subarray(this.v - 1);\n      var s = p.length > 3 ? gzs(p) : 4;\n      if (s > p.length) {\n        if (!final)\n          return;\n      } else if (this.v > 1 && this.onmember) {\n        this.onmember(this.r - p.length);\n      }\n      this.p = p.subarray(s), this.v = 0;\n    }\n    Inflate.prototype.c.call(this, final);\n    if (this.s.f && !this.s.l && !final) {\n      this.v = shft(this.s.p) + 9;\n      this.s = { i: 0 };\n      this.o = new u8(0);\n      this.push(new u8(0), final);\n    }\n  };\n  return Gunzip2;\n}();\nvar td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\nvar dutf8 = function(d) {\n  for (var r = \"\", i = 0; ; ) {\n    var c = d[i++];\n    var eb = (c > 127) + (c > 223) + (c > 239);\n    if (i + eb > d.length)\n      return { s: r, r: slc(d, i - 1) };\n    if (!eb)\n      r += String.fromCharCode(c);\n    else if (eb == 3) {\n      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n    } else if (eb & 1)\n      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n    else\n      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n  }\n};\nfunction strFromU8(dat, latin1) {\n  if (latin1) {\n    var r = \"\";\n    for (var i = 0; i < dat.length; i += 16384)\n      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n    return r;\n  } else if (td) {\n    return td.decode(dat);\n  } else {\n    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;\n    if (r.length)\n      err(8);\n    return s;\n  }\n}\nvar slzh = function(d, b) {\n  return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\nvar zh = function(d, b, z) {\n  var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n  var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];\n  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\nvar z64e = function(d, b) {\n  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n    ;\n  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\nfunction unzipSync(data, opts) {\n  var files = {};\n  var e = data.length - 22;\n  for (; b4(data, e) != 101010256; --e) {\n    if (!e || data.length - e > 65558)\n      err(13);\n  }\n  var c = b2(data, e + 8);\n  if (!c)\n    return {};\n  var o = b4(data, e + 16);\n  var z = o == 4294967295 || c == 65535;\n  if (z) {\n    var ze = b4(data, e - 12);\n    z = b4(data, ze) == 101075792;\n    if (z) {\n      c = b4(data, ze + 32);\n      o = b4(data, ze + 48);\n    }\n  }\n  var fltr = opts && opts.filter;\n  for (var i = 0; i < c; ++i) {\n    var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\n    o = no;\n    if (!fltr || fltr({\n      name: fn,\n      size: sc,\n      originalSize: su,\n      compression: c_2\n    })) {\n      if (!c_2)\n        files[fn] = slc(data, b, b + sc);\n      else if (c_2 == 8)\n        files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n      else\n        err(14, \"unknown compression type \" + c_2);\n    }\n  }\n  return files;\n}\nlet wasm;\nconst cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true }) : { decode: () => {\n  throw Error(\"TextDecoder not available\");\n} };\nif (typeof TextDecoder !== \"undefined\") {\n  cachedTextDecoder.decode();\n}\nlet cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8ArrayMemory0;\n}\nfunction getStringFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\nfunction raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max) {\n  const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max);\n  return ret;\n}\nasync function __wbg_load(module, imports) {\n  if (typeof Response === \"function\" && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n          console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        } else {\n          throw e;\n        }\n      }\n    }\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\nfunction __wbg_get_imports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n    const ret = arg0.buffer;\n    return ret;\n  };\n  imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n    const ret = arg0.length;\n    return ret;\n  };\n  imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n    const ret = arg0.length;\n    return ret;\n  };\n  imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n    const ret = arg0.length;\n    return ret;\n  };\n  imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n    const ret = new Uint16Array(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n    const ret = new Uint32Array(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n    const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n    const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n  };\n  imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n  };\n  imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n  };\n  imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbindgen_init_externref_table = function() {\n    const table = wasm.__wbindgen_export_0;\n    const offset = table.grow(4);\n    table.set(0, void 0);\n    table.set(offset + 0, void 0);\n    table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    table.set(offset + 3, false);\n  };\n  imports.wbg.__wbindgen_memory = function() {\n    const ret = wasm.memory;\n    return ret;\n  };\n  imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n  return imports;\n}\nfunction __wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  __wbg_init.__wbindgen_wasm_module = module;\n  cachedUint8ArrayMemory0 = null;\n  wasm.__wbindgen_start();\n  return wasm;\n}\nasync function __wbg_init(module_or_path) {\n  if (wasm !== void 0) return wasm;\n  if (typeof module_or_path !== \"undefined\") {\n    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n      ({ module_or_path } = module_or_path);\n    } else {\n      console.warn(\"using deprecated parameters for the initialization function; pass a single object instead\");\n    }\n  }\n  if (typeof module_or_path === \"undefined\") {\n    module_or_path = new URL(\"data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYG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ACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkb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QQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUE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ZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==\", import.meta.url);\n  }\n  const imports = __wbg_get_imports();\n  if (typeof module_or_path === \"string\" || typeof Request === \"function\" && module_or_path instanceof Request || typeof URL === \"function\" && module_or_path instanceof URL) {\n    module_or_path = fetch(module_or_path);\n  }\n  const { instance, module } = await __wbg_load(await module_or_path, imports);\n  return __wbg_finalize_init(instance, module);\n}\nconst LN_SCALE_MIN = -12;\nconst LN_SCALE_MAX = 9;\nconst SCALE_MIN = Math.exp(LN_SCALE_MIN);\nconst SCALE_MAX = Math.exp(LN_SCALE_MAX);\nconst LN_SCALE_ZERO = -30;\nconst SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\nconst SPLAT_TEX_WIDTH_BITS = 11;\nconst SPLAT_TEX_HEIGHT_BITS = 11;\nconst SPLAT_TEX_DEPTH_BITS = 11;\nconst SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\nconst SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\nconst SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\nconst SPLAT_TEX_DEPTH = 1 << SPLAT_TEX_DEPTH_BITS;\nconst SPLAT_TEX_MIN_HEIGHT = 1;\nconst SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1;\nconst SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1;\nconst SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1;\nconst WASM_SPLAT_SORT = true;\nconst defines = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  LN_SCALE_MAX,\n  LN_SCALE_MIN,\n  LN_SCALE_ZERO,\n  SCALE_MAX,\n  SCALE_MIN,\n  SCALE_ZERO,\n  SPLAT_TEX_DEPTH,\n  SPLAT_TEX_DEPTH_BITS,\n  SPLAT_TEX_DEPTH_MASK,\n  SPLAT_TEX_HEIGHT,\n  SPLAT_TEX_HEIGHT_BITS,\n  SPLAT_TEX_HEIGHT_MASK,\n  SPLAT_TEX_LAYER_BITS,\n  SPLAT_TEX_MIN_HEIGHT,\n  SPLAT_TEX_WIDTH,\n  SPLAT_TEX_WIDTH_BITS,\n  SPLAT_TEX_WIDTH_MASK,\n  WASM_SPLAT_SORT\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction isBoolType(type) {\n  return type === \"bool\" || type === \"bvec2\" || type === \"bvec3\" || type === \"bvec4\";\n}\nfunction isScalarType(type) {\n  return type === \"int\" || type === \"uint\" || type === \"float\";\n}\nfunction isIntType(type) {\n  return type === \"int\" || type === \"ivec2\" || type === \"ivec3\" || type === \"ivec4\";\n}\nfunction isUintType(type) {\n  return type === \"uint\" || type === \"uvec2\" || type === \"uvec3\" || type === \"uvec4\";\n}\nfunction isFloatType(type) {\n  return type === \"float\" || type === \"vec2\" || type === \"vec3\" || type === \"vec4\";\n}\nfunction isMatFloatType(type) {\n  return type === \"mat2\" || type === \"mat2x2\" || type === \"mat2x3\" || type === \"mat2x4\" || type === \"mat3\" || type === \"mat3x2\" || type === \"mat3x3\" || type === \"mat3x4\" || type === \"mat4\" || type === \"mat4x2\" || type === \"mat4x3\" || type === \"mat4x4\";\n}\nfunction isAllFloatType(type) {\n  return isFloatType(type) || isMatFloatType(type);\n}\nfunction isVector2Type(type) {\n  return type === \"vec2\" || type === \"ivec2\" || type === \"uvec2\";\n}\nfunction isVector3Type(type) {\n  return type === \"vec3\" || type === \"ivec3\" || type === \"uvec3\";\n}\nfunction isVector4Type(type) {\n  return type === \"vec4\" || type === \"ivec4\" || type === \"uvec4\";\n}\nfunction isVectorType(type) {\n  return isVector2Type(type) || isVector3Type(type) || isVector4Type(type);\n}\nfunction isMat2(type) {\n  return type === \"mat2\" || type === \"mat2x2\";\n}\nfunction isMat3(type) {\n  return type === \"mat3\" || type === \"mat3x3\";\n}\nfunction isMat4(type) {\n  return type === \"mat4\" || type === \"mat4x4\";\n}\nfunction vectorElementType(type) {\n  switch (type) {\n    case \"vec2\":\n      return \"float\";\n    case \"vec3\":\n      return \"float\";\n    case \"vec4\":\n      return \"float\";\n    case \"ivec2\":\n      return \"int\";\n    case \"ivec3\":\n      return \"int\";\n    case \"ivec4\":\n      return \"int\";\n    case \"uvec2\":\n      return \"uint\";\n    case \"uvec3\":\n      return \"uint\";\n    case \"uvec4\":\n      return \"uint\";\n    default:\n      throw new Error(`Invalid vector type: ${type}`);\n  }\n}\nfunction vectorDim(type) {\n  switch (type) {\n    case \"vec2\":\n    case \"ivec2\":\n    case \"uvec2\":\n      return 2;\n    case \"vec3\":\n    case \"ivec3\":\n    case \"uvec3\":\n      return 3;\n    case \"vec4\":\n    case \"ivec4\":\n    case \"uvec4\":\n      return 4;\n    default:\n      throw new Error(`Invalid vector type: ${type}`);\n  }\n}\nfunction sameSizeVec(type) {\n  if (isScalarType(type)) {\n    return \"float\";\n  }\n  if (isVector2Type(type)) {\n    return \"vec2\";\n  }\n  if (isVector3Type(type)) {\n    return \"vec3\";\n  }\n  if (isVector4Type(type)) {\n    return \"vec4\";\n  }\n  throw new Error(`Invalid vector type: ${type}`);\n}\nfunction sameSizeUvec(type) {\n  if (isScalarType(type)) {\n    return \"uint\";\n  }\n  if (isVector2Type(type)) {\n    return \"uvec2\";\n  }\n  if (isVector3Type(type)) {\n    return \"uvec3\";\n  }\n  if (isVector4Type(type)) {\n    return \"uvec4\";\n  }\n  throw new Error(`Invalid vector type: ${type}`);\n}\nfunction sameSizeIvec(type) {\n  if (isScalarType(type)) {\n    return \"int\";\n  }\n  if (isVector2Type(type)) {\n    return \"ivec2\";\n  }\n  if (isVector3Type(type)) {\n    return \"ivec3\";\n  }\n  if (isVector4Type(type)) {\n    return \"ivec4\";\n  }\n  throw new Error(`Invalid vector type: ${type}`);\n}\nfunction typeLiteral(type) {\n  if (typeof type === \"string\") {\n    return type;\n  }\n  if (typeof type === \"object\" && type.type) {\n    return type.type;\n  }\n  throw new Error(`Invalid DynoType: ${String(type)}`);\n}\nfunction numberAsInt(value) {\n  return Math.trunc(value).toString();\n}\nfunction numberAsUint(value) {\n  const v = Math.max(0, Math.trunc(value));\n  return `${v.toString()}u`;\n}\nfunction numberAsFloat(value) {\n  return value === Number.POSITIVE_INFINITY ? \"INFINITY\" : value === Number.NEGATIVE_INFINITY ? \"-INFINITY\" : Number.isInteger(value) ? value.toFixed(1) : value.toString();\n}\nfunction valType(val) {\n  if (val instanceof DynoValue) {\n    return val.type;\n  }\n  const value = val.dynoOut();\n  return value.type;\n}\nclass DynoValue {\n  constructor(type) {\n    this.__isDynoValue = true;\n    this.type = type;\n  }\n}\nclass DynoOutput extends DynoValue {\n  constructor(dyno2, key) {\n    super(dyno2.outTypes[key]);\n    this.dyno = dyno2;\n    this.key = key;\n  }\n}\nclass DynoLiteral extends DynoValue {\n  constructor(type, literal) {\n    super(type);\n    this.literal = literal;\n  }\n  getLiteral() {\n    return this.literal;\n  }\n}\nfunction dynoLiteral(type, literal) {\n  return new DynoLiteral(type, literal);\n}\nclass DynoConst extends DynoLiteral {\n  constructor(type, value) {\n    super(type, \"\");\n    this.value = value;\n  }\n  getLiteral() {\n    const { type, value } = this;\n    switch (type) {\n      case \"bool\":\n        return value ? \"true\" : \"false\";\n      case \"uint\":\n        return numberAsUint(value);\n      case \"int\":\n        return numberAsInt(value);\n      case \"float\":\n        return numberAsFloat(value);\n      case \"bvec2\": {\n        const v = value;\n        return `bvec2(${v[0]}, ${v[1]})`;\n      }\n      case \"uvec2\": {\n        if (value instanceof THREE.Vector2) {\n          return `uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\n        }\n        const v = value;\n        return `uvec2(${numberAsUint(v[0])}, ${numberAsUint(v[1])})`;\n      }\n      case \"ivec2\": {\n        if (value instanceof THREE.Vector2) {\n          return `ivec2(${numberAsInt(value.x)}, ${numberAsInt(value.y)})`;\n        }\n        const v = value;\n        return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\n      }\n      case \"vec2\": {\n        if (value instanceof THREE.Vector2) {\n          return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\n        }\n        const v = value;\n        return `vec2(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])})`;\n      }\n      case \"bvec3\": {\n        const v = value;\n        return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\n      }\n      case \"uvec3\": {\n        if (value instanceof THREE.Vector3) {\n          return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)})`;\n        }\n        const v = value;\n        return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])})`;\n      }\n      case \"ivec3\": {\n        if (value instanceof THREE.Vector3) {\n          return `ivec3(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\n        }\n        const v = value;\n        return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])})`;\n      }\n      case \"vec3\": {\n        if (value instanceof THREE.Vector3) {\n          return `vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)})`;\n        }\n        const v = value;\n        return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])})`;\n      }\n      case \"bvec4\": {\n        const v = value;\n        return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\n      }\n      case \"uvec4\": {\n        if (value instanceof THREE.Vector4) {\n          return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, ${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\n        }\n        const v = value;\n        return `uvec4(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\n      }\n      case \"ivec4\": {\n        if (value instanceof THREE.Vector4) {\n          return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, ${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\n        }\n        const v = value;\n        return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, ${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\n      }\n      case \"vec4\": {\n        if (value instanceof THREE.Vector4) {\n          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n        }\n        if (value instanceof THREE.Quaternion) {\n          return `vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, ${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n        }\n        const v = value;\n        return `vec4(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\n      }\n      case \"mat2\":\n      case \"mat2x2\": {\n        const m = value;\n        const e = m instanceof THREE.Matrix2 ? m.elements : value;\n        const arg = new Array(4).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat2x3\": {\n        const e = value;\n        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat2x4\": {\n        const e = value;\n        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat3\":\n      case \"mat3x3\": {\n        const m = value;\n        const e = m instanceof THREE.Matrix3 ? m.elements : value;\n        const arg = new Array(9).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat3x2\": {\n        const e = value;\n        const arg = new Array(6).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat3x4\": {\n        const e = value;\n        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat4\":\n      case \"mat4x4\": {\n        const m = value;\n        const e = m instanceof THREE.Matrix4 ? m.elements : value;\n        const arg = new Array(16).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat4x2\": {\n        const e = value;\n        const arg = new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat4x3\": {\n        const e = value;\n        const arg = new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      }\n      default:\n        throw new Error(`Type not implemented: ${String(type)}`);\n    }\n  }\n}\nfunction dynoConst(type, value) {\n  return new DynoConst(type, value);\n}\nfunction literalZero(type) {\n  const typeString = String(type);\n  if (isBoolType(type)) {\n    return `${typeString}(false)`;\n  }\n  if (isAllFloatType(type)) {\n    return `${typeString}(0.0)`;\n  }\n  if (isIntType(type)) {\n    return `${typeString}(0)`;\n  }\n  if (isUintType(type)) {\n    return `${typeString}(0u)`;\n  }\n  throw new Error(`Type not implemented: ${typeString}`);\n}\nfunction literalOne(type) {\n  const typeString = String(type);\n  if (isBoolType(type)) {\n    return `${typeString}(true)`;\n  }\n  if (isAllFloatType(type)) {\n    return `${typeString}(1.0)`;\n  }\n  if (isIntType(type)) {\n    return `${typeString}(1)`;\n  }\n  if (isUintType(type)) {\n    return `${typeString}(1u)`;\n  }\n  throw new Error(`Type not implemented: ${typeString}`);\n}\nfunction literalNegOne(type) {\n  const typeString = String(type);\n  if (isBoolType(type)) {\n    return `${typeString}(true)`;\n  }\n  if (isAllFloatType(type)) {\n    return `${typeString}(-1.0)`;\n  }\n  if (isIntType(type)) {\n    return `${typeString}(-1)`;\n  }\n  if (isUintType(type)) {\n    return `${typeString}(0xFFFFFFFFu)`;\n  }\n  throw new Error(`Type not implemented: ${typeString}`);\n}\nconst DEFAULT_INDENT = \"    \";\nclass Compilation {\n  constructor({ indent } = {}) {\n    this.globals = /* @__PURE__ */ new Set();\n    this.statements = [];\n    this.uniforms = {};\n    this.declares = /* @__PURE__ */ new Set();\n    this.updaters = [];\n    this.sequence = 0;\n    this.indent = DEFAULT_INDENT;\n    this.indent = indent ?? DEFAULT_INDENT;\n  }\n  nextSequence() {\n    return this.sequence++;\n  }\n}\nclass Dyno {\n  constructor({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  }) {\n    this.inTypes = inTypes ?? {};\n    this.outTypes = outTypes ?? {};\n    this.inputs = inputs ?? {};\n    this.update = update;\n    this.globals = globals;\n    this.statements = statements;\n    this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {\n      var _a2, _b2;\n      return {\n        globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),\n        statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n      };\n    });\n  }\n  get outputs() {\n    const outputs = {};\n    for (const key in this.outTypes) {\n      outputs[key] = new DynoOutput(this, key);\n    }\n    return outputs;\n  }\n  apply(inputs) {\n    Object.assign(this.inputs, inputs);\n    return this.outputs;\n  }\n  compile({\n    inputs,\n    outputs,\n    compile\n  }) {\n    const result = [\n      `// ${this.constructor.name}(${Object.values(inputs).join(\", \")}) => (${Object.values(outputs).join(\", \")})`\n    ];\n    const declares = [];\n    for (const key in outputs) {\n      const name = outputs[key];\n      if (name && !compile.declares.has(name)) {\n        compile.declares.add(name);\n        declares.push(key);\n      }\n    }\n    const { globals, statements, uniforms } = this.generate({\n      inputs,\n      outputs,\n      compile\n    });\n    for (const global of globals ?? []) {\n      compile.globals.add(global);\n    }\n    for (const key in uniforms) {\n      compile.uniforms[key] = uniforms[key];\n    }\n    if (this.update) {\n      compile.updaters.push(this.update);\n    }\n    for (const key of declares) {\n      const name = outputs[key];\n      if (name) {\n        if (!compile.uniforms[name]) {\n          result.push(`${dynoDeclare(name, this.outTypes[key])};`);\n        }\n      }\n    }\n    if (statements == null ? void 0 : statements.length) {\n      result.push(\"{\");\n      result.push(...statements.map((line) => compile.indent + line));\n      result.push(\"}\");\n    }\n    return result;\n  }\n}\nclass DynoBlock extends Dyno {\n  constructor({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    construct\n  }) {\n    super({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      generate: (args) => this.generateBlock(args)\n    });\n    this.construct = construct;\n  }\n  generateBlock({\n    inputs,\n    outputs,\n    compile\n  }) {\n    var _a2, _b2;\n    const blockInputs = {};\n    const blockOutputs = {};\n    for (const key in inputs) {\n      if (inputs[key] != null) {\n        blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n      }\n    }\n    for (const key in outputs) {\n      if (outputs[key] != null) {\n        blockOutputs[key] = new DynoValue(this.outTypes[key]);\n      }\n    }\n    const options = { roots: [] };\n    const returned = this.construct(blockInputs, blockOutputs, options);\n    for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {\n      compile.globals.add(global);\n    }\n    const ordering = [];\n    const nodeOuts = /* @__PURE__ */ new Map();\n    function visit(node, outKey, outName) {\n      let outs = nodeOuts.get(node);\n      if (!outs) {\n        outs = {\n          sequence: compile.nextSequence(),\n          outNames: /* @__PURE__ */ new Map(),\n          newOuts: /* @__PURE__ */ new Set()\n        };\n        nodeOuts.set(node, outs);\n        for (const key in node.inputs) {\n          let input = node.inputs[key];\n          while (input) {\n            if (input instanceof DynoValue) {\n              if (input instanceof DynoOutput) {\n                visit(input.dyno, input.key);\n              }\n              break;\n            }\n            input = input.dynoOut();\n          }\n        }\n        ordering.push(node);\n      }\n      if (outKey) {\n        if (!outName) {\n          outs.newOuts.add(outKey);\n        }\n        outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\n      }\n    }\n    for (const root of options.roots) {\n      visit(root);\n    }\n    for (const key in blockOutputs) {\n      let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];\n      while (value) {\n        if (value instanceof DynoValue) {\n          if (value instanceof DynoOutput) {\n            visit(value.dyno, value.key, outputs[key]);\n          }\n          break;\n        }\n        value = value.dynoOut();\n      }\n      blockOutputs[key] = value;\n    }\n    const steps = [];\n    for (const dyno2 of ordering) {\n      const inputs2 = {};\n      const outputs2 = {};\n      for (const key in dyno2.inputs) {\n        let value = dyno2.inputs[key];\n        while (value) {\n          if (value instanceof DynoValue) {\n            if (value instanceof DynoLiteral) {\n              inputs2[key] = value.getLiteral();\n            } else if (value instanceof DynoOutput) {\n              const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);\n              if (!source) {\n                throw new Error(\n                  `Source not found for ${value.dyno.constructor.name}.${value.key}`\n                );\n              }\n              inputs2[key] = source;\n            }\n            break;\n          }\n          value = value.dynoOut();\n        }\n      }\n      const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };\n      for (const [key, name] of outs.outNames.entries()) {\n        outputs2[key] = name;\n      }\n      const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });\n      steps.push(newSteps);\n    }\n    const literalOutputs = [];\n    for (const key in outputs) {\n      if (blockOutputs[key] instanceof DynoLiteral) {\n        literalOutputs.push(\n          `${outputs[key]} = ${blockOutputs[key].getLiteral()};`\n        );\n      }\n    }\n    if (literalOutputs.length > 0) {\n      steps.push(literalOutputs);\n    }\n    const statements = steps.flatMap((step2, index) => {\n      return index === 0 ? step2 : [\"\", ...step2];\n    });\n    return { statements };\n  }\n}\nfunction dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {\n  return new DynoBlock({ inTypes, outTypes, construct, update, globals });\n}\nfunction dyno$1({\n  inTypes,\n  outTypes,\n  inputs,\n  update,\n  globals,\n  statements,\n  generate\n}) {\n  return new Dyno({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  });\n}\nfunction dynoDeclare(name, type, count) {\n  const typeStr = typeof type === \"string\" ? type : type.type;\n  if (!typeStr) {\n    throw new Error(`Invalid DynoType: ${String(type)}`);\n  }\n  return `${typeStr} ${name}${count != null ? `[${count}]` : \"\"}`;\n}\nfunction unindentLines(s) {\n  var _a2;\n  let seenNonEmpty = false;\n  const lines = s.split(\"\\n\").map((line) => {\n    const trimmedLine = line.trimEnd();\n    if (seenNonEmpty) {\n      return trimmedLine;\n    }\n    if (trimmedLine.length > 0) {\n      seenNonEmpty = true;\n      return trimmedLine;\n    }\n    return null;\n  }).filter((line) => line != null);\n  while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n    lines.pop();\n  }\n  if (lines.length === 0) {\n    return [];\n  }\n  const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? void 0 : _a2[0];\n  if (!indent) {\n    return lines;\n  }\n  const regex = new RegExp(`^${indent}`);\n  return lines.map((line) => line.replace(regex, \"\"));\n}\nfunction unindent(s) {\n  return unindentLines(s).join(\"\\n\");\n}\nclass UnaryOp extends Dyno {\n  constructor({\n    a,\n    outKey,\n    outTypeFunc\n  }) {\n    const inTypes = { a: valType(a) };\n    const outType = outTypeFunc(valType(a));\n    const outTypes = { [outKey]: outType };\n    super({ inTypes, outTypes, inputs: { a } });\n    this.outKey = outKey;\n  }\n  dynoOut() {\n    return new DynoOutput(this, this.outKey);\n  }\n}\nclass BinaryOp extends Dyno {\n  constructor({\n    a,\n    b,\n    outKey,\n    outTypeFunc\n  }) {\n    const inTypes = { a: valType(a), b: valType(b) };\n    const outType = outTypeFunc(valType(a), valType(b));\n    const outTypes = { [outKey]: outType };\n    super({ inTypes, outTypes, inputs: { a, b } });\n    this.outKey = outKey;\n  }\n  dynoOut() {\n    return new DynoOutput(this, this.outKey);\n  }\n}\nclass TrinaryOp extends Dyno {\n  constructor({\n    a,\n    b,\n    c,\n    outKey,\n    outTypeFunc\n  }) {\n    const inTypes = { a: valType(a), b: valType(b), c: valType(c) };\n    const outType = outTypeFunc(valType(a), valType(b), valType(c));\n    const outTypes = { [outKey]: outType };\n    super({ inTypes, outTypes, inputs: { a, b, c } });\n    this.outKey = outKey;\n  }\n  dynoOut() {\n    return new DynoOutput(this, this.outKey);\n  }\n}\nconst Gsplat = { type: \"Gsplat\" };\nconst TPackedSplats = { type: \"PackedSplats\" };\nconst numPackedSplats = (packedSplats) => new NumPackedSplats({ packedSplats });\nconst readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });\nconst readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });\nconst splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\nconst combineGsplat = ({\n  gsplat,\n  flags,\n  index,\n  center,\n  scales,\n  quaternion,\n  rgba,\n  rgb,\n  opacity,\n  x,\n  y,\n  z,\n  r,\n  g,\n  b\n}) => {\n  return new CombineGsplat({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x,\n    y,\n    z,\n    r,\n    g,\n    b\n  });\n};\nconst gsplatNormal = (gsplat) => new GsplatNormal({ gsplat });\nconst transformGsplat = (gsplat, {\n  scale,\n  rotate,\n  translate,\n  recolor\n}) => {\n  return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\n};\nconst defineGsplat = unindent(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`);\nconst definePackedSplats = unindent(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n    vec4 rgbMinMaxLnScaleMinMax;\n  };\n`);\nclass NumPackedSplats extends UnaryOp {\n  constructor({\n    packedSplats\n  }) {\n    super({ a: packedSplats, outKey: \"numSplats\", outTypeFunc: () => \"int\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.numSplats} = ${inputs.a}.numSplats;`\n    ];\n  }\n}\nconst defineReadPackedSplat = unindent(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\nclass ReadPackedSplat extends Dyno {\n  constructor({\n    packedSplats,\n    index\n  }) {\n    super({\n      inTypes: { packedSplats: TPackedSplats, index: \"int\" },\n      outTypes: { gsplat: Gsplat },\n      inputs: { packedSplats, index },\n      globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n      statements: ({ inputs, outputs }) => {\n        const { gsplat } = outputs;\n        if (!gsplat) {\n          return [];\n        }\n        const { packedSplats: packedSplats2, index: index2 } = inputs;\n        let statements;\n        if (packedSplats2 && index2) {\n          statements = unindentLines(`\n            if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n              bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n              ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${gsplat}.flags = 0u;\n            }\n          `);\n        } else {\n          statements = [`${gsplat}.flags = 0u;`];\n        }\n        statements.push(`${gsplat}.index = ${index2 ?? \"0\"};`);\n        return statements;\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"gsplat\");\n  }\n}\nclass ReadPackedSplatRange extends Dyno {\n  constructor({\n    packedSplats,\n    index,\n    base,\n    count\n  }) {\n    super({\n      inTypes: {\n        packedSplats: TPackedSplats,\n        index: \"int\",\n        base: \"int\",\n        count: \"int\"\n      },\n      outTypes: { gsplat: Gsplat },\n      inputs: { packedSplats, index, base, count },\n      globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n      statements: ({ inputs, outputs }) => {\n        const { gsplat } = outputs;\n        if (!gsplat) {\n          return [];\n        }\n        const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n        let statements;\n        if (packedSplats2 && index2 && base2 && count2) {\n          statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n            if ((${index2} >= ${base2}) && (${index2} < (${base2} + ${count2}))) {\n              if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n                bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `);\n        } else {\n          statements = [`${gsplat}.flags = 0u;`];\n        }\n        statements.push(`${gsplat}.index = ${index2 ?? \"0\"};`);\n        return statements;\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"gsplat\");\n  }\n}\nclass SplitGsplat extends Dyno {\n  constructor({ gsplat }) {\n    super({\n      inTypes: { gsplat: Gsplat },\n      outTypes: {\n        flags: \"uint\",\n        active: \"bool\",\n        index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\"\n      },\n      inputs: { gsplat },\n      globals: () => [defineGsplat],\n      statements: ({ inputs, outputs }) => {\n        const { gsplat: gsplat2 } = inputs;\n        const {\n          flags,\n          active,\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba,\n          rgb,\n          opacity,\n          x,\n          y,\n          z,\n          r,\n          g,\n          b\n        } = outputs;\n        return [\n          !flags ? null : `${flags} = ${gsplat2 ? `${gsplat2}.flags` : \"0u\"};`,\n          !active ? null : `${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : \"0u\"});`,\n          !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : \"0\"};`,\n          !center ? null : `${center} = ${gsplat2 ? `${gsplat2}.center` : \"vec3(0.0, 0.0, 0.0)\"};`,\n          !scales ? null : `${scales} = ${gsplat2 ? `${gsplat2}.scales` : \"vec3(0.0, 0.0, 0.0)\"};`,\n          !quaternion ? null : `${quaternion} = ${gsplat2 ? `${gsplat2}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\n          !rgba ? null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\"};`,\n          !rgb ? null : `${rgb} = ${gsplat2 ? `${gsplat2}.rgba.rgb` : \"vec3(0.0, 0.0, 0.0)\"};`,\n          !opacity ? null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : \"0.0\"};`,\n          !x ? null : `${x} = ${gsplat2 ? `${gsplat2}.center.x` : \"0.0\"};`,\n          !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : \"0.0\"};`,\n          !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : \"0.0\"};`,\n          !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : \"0.0\"};`,\n          !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : \"0.0\"};`,\n          !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : \"0.0\"};`\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nclass CombineGsplat extends Dyno {\n  constructor({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x,\n    y,\n    z,\n    r,\n    g,\n    b\n  }) {\n    super({\n      inTypes: {\n        gsplat: Gsplat,\n        flags: \"uint\",\n        index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\"\n      },\n      outTypes: { gsplat: Gsplat },\n      inputs: {\n        gsplat,\n        flags,\n        index,\n        center,\n        scales,\n        quaternion,\n        rgba,\n        rgb,\n        opacity,\n        x,\n        y,\n        z,\n        r,\n        g,\n        b\n      },\n      globals: () => [defineGsplat],\n      statements: ({ inputs, outputs }) => {\n        const { gsplat: outGsplat } = outputs;\n        if (!outGsplat) {\n          return [];\n        }\n        const {\n          gsplat: gsplat2,\n          flags: flags2,\n          index: index2,\n          center: center2,\n          scales: scales2,\n          quaternion: quaternion2,\n          rgba: rgba2,\n          rgb: rgb2,\n          opacity: opacity2,\n          x: x2,\n          y: y2,\n          z: z2,\n          r: r2,\n          g: g2,\n          b: b22\n        } = inputs;\n        return [\n          `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? `${gsplat2}.flags` : \"0u\")};`,\n          `${outGsplat}.index = ${index2 ?? (gsplat2 ? `${gsplat2}.index` : \"0\")};`,\n          `${outGsplat}.center = ${center2 ?? (gsplat2 ? `${gsplat2}.center` : \"vec3(0.0, 0.0, 0.0)\")};`,\n          `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : \"vec3(0.0, 0.0, 0.0)\")};`,\n          `${outGsplat}.quaternion = ${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\")};`,\n          `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? `${gsplat2}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};`,\n          !rgb2 ? null : `${outGsplat}.rgba.rgb = ${rgb2};`,\n          !opacity2 ? null : `${outGsplat}.rgba.a = ${opacity2};`,\n          !x2 ? null : `${outGsplat}.center.x = ${x2};`,\n          !y2 ? null : `${outGsplat}.center.y = ${y2};`,\n          !z2 ? null : `${outGsplat}.center.z = ${z2};`,\n          !r2 ? null : `${outGsplat}.rgba.r = ${r2};`,\n          !g2 ? null : `${outGsplat}.rgba.g = ${g2};`,\n          !b22 ? null : `${outGsplat}.rgba.b = ${b22};`\n        ].filter(Boolean);\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"gsplat\");\n  }\n}\nconst defineGsplatNormal = unindent(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);\nclass GsplatNormal extends UnaryOp {\n  constructor({ gsplat }) {\n    super({ a: gsplat, outKey: \"normal\", outTypeFunc: () => \"vec3\" });\n    this.globals = () => [defineGsplat, defineGsplatNormal];\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.normal} = gsplatNormal(${inputs.a}.scales, ${inputs.a}.quaternion);`\n    ];\n  }\n}\nclass TransformGsplat extends Dyno {\n  constructor({\n    gsplat,\n    scale,\n    rotate,\n    translate,\n    recolor\n  }) {\n    super({\n      inTypes: {\n        gsplat: Gsplat,\n        scale: \"float\",\n        rotate: \"vec4\",\n        translate: \"vec3\",\n        recolor: \"vec4\"\n      },\n      outTypes: { gsplat: Gsplat },\n      inputs: { gsplat, scale, rotate, translate, recolor },\n      globals: () => [defineGsplat],\n      statements: ({ inputs, outputs, compile }) => {\n        const { gsplat: gsplat2 } = outputs;\n        if (!gsplat2 || !inputs.gsplat) {\n          return [];\n        }\n        const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;\n        const indent = compile.indent;\n        const statements = [\n          `${gsplat2} = ${inputs.gsplat};`,\n          `if (isGsplatActive(${gsplat2}.flags)) {`,\n          scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,\n          rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, ${gsplat2}.center);` : null,\n          translate2 ? `${indent}${gsplat2}.center += ${translate2};` : null,\n          scale2 ? `${indent}${gsplat2}.scales *= ${scale2};` : null,\n          rotate2 ? `${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, ${gsplat2}.quaternion);` : null,\n          recolor2 ? `${indent}${gsplat2}.rgba *= ${recolor2};` : null,\n          \"}\"\n        ].filter(Boolean);\n        return statements;\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"gsplat\");\n  }\n}\nconst outputPackedSplat = (gsplat, rgbMinMaxLnScaleMinMax) => new OutputPackedSplat({ gsplat, rgbMinMaxLnScaleMinMax });\nconst outputRgba8 = (rgba8) => new OutputRgba8({ rgba8 });\nclass OutputPackedSplat extends Dyno {\n  constructor({\n    gsplat,\n    rgbMinMaxLnScaleMinMax\n  }) {\n    super({\n      inTypes: { gsplat: Gsplat, rgbMinMaxLnScaleMinMax: \"vec4\" },\n      inputs: { gsplat, rgbMinMaxLnScaleMinMax },\n      globals: () => [defineGsplat],\n      statements: ({ inputs, outputs }) => {\n        const { output } = outputs;\n        if (!output) {\n          return [];\n        }\n        const { gsplat: gsplat2, rgbMinMaxLnScaleMinMax: rgbMinMaxLnScaleMinMax2 } = inputs;\n        if (gsplat2) {\n          return unindentLines(`\n            if (isGsplatActive(${gsplat2}.flags)) {\n              ${output} = packSplatEncoding(${gsplat2}.center, ${gsplat2}.scales, ${gsplat2}.quaternion, ${gsplat2}.rgba, ${rgbMinMaxLnScaleMinMax2});\n            } else {\n              ${output} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `);\n        }\n        return [`${output} = uvec4(0u, 0u, 0u, 0u);`];\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"output\");\n  }\n}\nclass OutputRgba8 extends Dyno {\n  constructor({ rgba8 }) {\n    super({\n      inTypes: { rgba8: \"vec4\" },\n      inputs: { rgba8 },\n      statements: ({ inputs, outputs }) => [\n        `target = ${inputs.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};`\n      ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"rgba8\");\n  }\n}\nconst uniform = (key, type, value) => new DynoUniform({ key, type, value });\nconst dynoBool = (value = false, key) => new DynoBool({ key, value });\nconst dynoUint = (value = 0, key) => new DynoUint({ key, value });\nconst dynoInt = (value = 0, key) => new DynoInt({ key, value });\nconst dynoFloat = (value = 0, key) => new DynoFloat({ key, value });\nconst dynoBvec2 = (value, key) => new DynoBvec2({ key, value });\nconst dynoUvec2 = (value, key) => new DynoUvec2({ key, value });\nconst dynoIvec2 = (value, key) => new DynoIvec2({ key, value });\nconst dynoVec2 = (value, key) => new DynoVec2({ key, value });\nconst dynoBvec3 = (value, key) => new DynoBvec3({ key, value });\nconst dynoUvec3 = (value, key) => new DynoUvec3({ key, value });\nconst dynoIvec3 = (value, key) => new DynoIvec3({ key, value });\nconst dynoVec3 = (value, key) => new DynoVec3({ key, value });\nconst dynoBvec4 = (value, key) => new DynoBvec4({ key, value });\nconst dynoUvec4 = (value, key) => new DynoUvec4({ key, value });\nconst dynoIvec4 = (value, key) => new DynoIvec4({ key, value });\nconst dynoVec4 = (value, key) => new DynoVec4({ key, value });\nconst dynoMat2 = (value, key) => new DynoMat2({ key, value });\nconst dynoMat2x2 = (value, key) => new DynoMat2x2({ key, value });\nconst dynoMat2x3 = (value, key) => new DynoMat2x3({ key, value });\nconst dynoMat2x4 = (value, key) => new DynoMat2x4({ key, value });\nconst dynoMat3 = (value, key) => new DynoMat3({ key, value });\nconst dynoMat3x2 = (value, key) => new DynoMat3x2({ key, value });\nconst dynoMat3x3 = (value, key) => new DynoMat3x3({ key, value });\nconst dynoMat3x4 = (value, key) => new DynoMat3x4({ key, value });\nconst dynoMat4 = (value, key) => new DynoMat4({ key, value });\nconst dynoMat4x2 = (value, key) => new DynoMat4x2({ key, value });\nconst dynoMat4x3 = (value, key) => new DynoMat4x3({ key, value });\nconst dynoMat4x4 = (value, key) => new DynoMat4x4({ key, value });\nconst dynoUsampler2D = (value, key) => new DynoUsampler2D({ key, value });\nconst dynoIsampler2D = (value, key) => new DynoIsampler2D({ key, value });\nconst dynoSampler2D = (value, key) => new DynoSampler2D({ key, value });\nconst dynoUsampler2DArray = (value, key) => new DynoUsampler2DArray({ key, value });\nconst dynoIsampler2DArray = (key, value) => new DynoIsampler2DArray({ key, value });\nconst dynoSampler2DArray = (value, key) => new DynoSampler2DArray({ key, value });\nconst dynoUsampler3D = (value, key) => new DynoUsampler3D({ key, value });\nconst dynoIsampler3D = (value, key) => new DynoIsampler3D({ key, value });\nconst dynoSampler3D = (value, key) => new DynoSampler3D({ key, value });\nconst dynoUsamplerCube = (value, key) => new DynoUsamplerCube({ key, value });\nconst dynoIsamplerCube = (value, key) => new DynoIsamplerCube({ key, value });\nconst dynoSamplerCube = (value, key) => new DynoSamplerCube({ key, value });\nconst dynoSampler2DShadow = (value, key) => new DynoSampler2DShadow({ key, value });\nconst dynoSampler2DArrayShadow = (value, key) => new DynoSampler2DArrayShadow({ key, value });\nconst dynoSamplerCubeShadow = (value, key) => new DynoSamplerCubeShadow({ key, value });\nclass DynoUniform extends Dyno {\n  constructor({\n    key,\n    type,\n    count,\n    value,\n    update,\n    globals\n  }) {\n    key = key ?? \"value\";\n    super({\n      outTypes: { [key]: type },\n      update: () => {\n        if (update) {\n          const value2 = update(this.value);\n          if (value2 !== void 0) {\n            this.value = value2;\n          }\n        }\n        this.uniform.value = this.value;\n      },\n      generate: ({ inputs, outputs }) => {\n        const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];\n        const uniforms = {};\n        const name = outputs[key];\n        if (name) {\n          allGlobals.push(`uniform ${dynoDeclare(name, type, count)};`);\n          uniforms[name] = this.uniform;\n        }\n        return { globals: allGlobals, uniforms };\n      }\n    });\n    this.type = type;\n    this.count = count;\n    this.value = value;\n    this.uniform = { value };\n    this.outKey = key;\n  }\n  dynoOut() {\n    return new DynoOutput(this, this.outKey);\n  }\n}\nclass DynoBool extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"bool\", value, update });\n  }\n}\nclass DynoUint extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"uint\", value, update });\n  }\n}\nclass DynoInt extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"int\", value, update });\n  }\n}\nclass DynoFloat extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"float\", value, update });\n  }\n}\nclass DynoBvec2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"bvec2\", value, update });\n  }\n}\nclass DynoUvec2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"uvec2\", value, update });\n  }\n}\nclass DynoIvec2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"ivec2\", value, update });\n  }\n}\nclass DynoVec2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"vec2\", value, update });\n  }\n}\nclass DynoBvec3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"bvec3\", value, update });\n  }\n}\nclass DynoUvec3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"uvec3\", value, update });\n  }\n}\nclass DynoIvec3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"ivec3\", value, update });\n  }\n}\nclass DynoVec3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"vec3\", value, update });\n  }\n}\nclass DynoBvec4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"bvec4\", value, update });\n  }\n}\nclass DynoUvec4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"uvec4\", value, update });\n  }\n}\nclass DynoIvec4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"ivec4\", value, update });\n  }\n}\nclass DynoVec4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"vec4\", value, update });\n  }\n}\nclass DynoMat2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat2\", value, update });\n  }\n}\nclass DynoMat2x2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat2x2\", value, update });\n  }\n}\nclass DynoMat2x3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat2x3\", value, update });\n  }\n}\nclass DynoMat2x4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat2x4\", value, update });\n  }\n}\nclass DynoMat3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat3\", value, update });\n  }\n}\nclass DynoMat3x2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat3x2\", value, update });\n  }\n}\nclass DynoMat3x3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat3x3\", value, update });\n  }\n}\nclass DynoMat3x4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat3x4\", value, update });\n  }\n}\nclass DynoMat4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4\", value, update });\n  }\n}\nclass DynoMat4x2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4x2\", value, update });\n  }\n}\nclass DynoMat4x3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4x3\", value, update });\n  }\n}\nclass DynoMat4x4 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4x4\", value, update });\n  }\n}\nclass DynoUsampler2D extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"usampler2D\", value, update });\n  }\n}\nclass DynoIsampler2D extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"isampler2D\", value, update });\n  }\n}\nclass DynoSampler2D extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"sampler2D\", value, update });\n  }\n}\nclass DynoUsampler2DArray extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"usampler2DArray\", value, update });\n  }\n}\nclass DynoIsampler2DArray extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"isampler2DArray\", value, update });\n  }\n}\nclass DynoSampler2DArray extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"sampler2DArray\", value, update });\n  }\n}\nclass DynoUsampler3D extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"usampler3D\", value, update });\n  }\n}\nclass DynoIsampler3D extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"isampler3D\", value, update });\n  }\n}\nclass DynoSampler3D extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"sampler3D\", value, update });\n  }\n}\nclass DynoUsamplerCube extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"usamplerCube\", value, update });\n  }\n}\nclass DynoIsamplerCube extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"isamplerCube\", value, update });\n  }\n}\nclass DynoSamplerCube extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"samplerCube\", value, update });\n  }\n}\nclass DynoSampler2DShadow extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"sampler2DShadow\", value, update });\n  }\n}\nclass DynoSampler2DArrayShadow extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"sampler2DArrayShadow\", value, update });\n  }\n}\nclass DynoSamplerCubeShadow extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, type: \"samplerCubeShadow\", value, update });\n  }\n}\nconst f32buffer = new Float32Array(1);\nconst u32buffer = new Uint32Array(f32buffer.buffer);\nfunction floatBitsToUint$1(f) {\n  f32buffer[0] = f;\n  return u32buffer[0];\n}\nfunction uintBitsToFloat$1(u) {\n  u32buffer[0] = u;\n  return f32buffer[0];\n}\nfunction toHalf(f) {\n  f32buffer[0] = f;\n  const bits2 = u32buffer[0];\n  const sign2 = bits2 >> 31 & 1;\n  const exp3 = bits2 >> 23 & 255;\n  const frac = bits2 & 8388607;\n  const halfSign = sign2 << 15;\n  if (exp3 === 255) {\n    if (frac !== 0) {\n      return halfSign | 32767;\n    }\n    return halfSign | 31744;\n  }\n  const newExp = exp3 - 127 + 15;\n  if (newExp >= 31) {\n    return halfSign | 31744;\n  }\n  if (newExp <= 0) {\n    if (newExp < -10) {\n      return halfSign;\n    }\n    const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n    return halfSign | subFrac;\n  }\n  const halfFrac = frac >> 13;\n  return halfSign | newExp << 10 | halfFrac;\n}\nfunction fromHalf(h) {\n  const sign2 = h >> 15 & 1;\n  const exp3 = h >> 10 & 31;\n  const frac = h & 1023;\n  let f32bits;\n  if (exp3 === 0) {\n    if (frac === 0) {\n      f32bits = sign2 << 31;\n    } else {\n      let mant = frac;\n      let e = -14;\n      while ((mant & 1024) === 0) {\n        mant <<= 1;\n        e--;\n      }\n      mant &= 1023;\n      const newExp = e + 127;\n      const newFrac = mant << 13;\n      f32bits = sign2 << 31 | newExp << 23 | newFrac;\n    }\n  } else if (exp3 === 31) {\n    if (frac === 0) {\n      f32bits = sign2 << 31 | 2139095040;\n    } else {\n      f32bits = sign2 << 31 | 2143289344;\n    }\n  } else {\n    const newExp = exp3 - 15 + 127;\n    const newFrac = frac << 13;\n    f32bits = sign2 << 31 | newExp << 23 | newFrac;\n  }\n  u32buffer[0] = f32bits;\n  return f32buffer[0];\n}\nfunction floatToUint8(v) {\n  return Math.max(0, Math.min(255, Math.round(v * 255)));\n}\nfunction floatToSint8(v) {\n  return Math.max(-127, Math.min(127, Math.round(v * 127)));\n}\nfunction Uint8ToFloat(v) {\n  return v / 255;\n}\nfunction Sint8ToFloat(v) {\n  return v / 127;\n}\nclass DataCache {\n  // Create a DataCache with a given function that fetches data not in the cache.\n  constructor({\n    asyncFetch,\n    maxItems = 5\n  }) {\n    this.asyncFetch = asyncFetch;\n    this.maxItems = maxItems;\n    this.items = [];\n  }\n  // Fetch data for the key, returning cached data if available.\n  async getFetch(key) {\n    const index = this.items.findIndex((item) => item.key === key);\n    if (index >= 0) {\n      const item = this.items.splice(index, 1)[0];\n      this.items.push(item);\n      return item.data;\n    }\n    const data = await this.asyncFetch(key);\n    this.items.push({ key, data });\n    while (this.items.length > this.maxItems) {\n      this.items.shift();\n    }\n    return data;\n  }\n}\nfunction mapObject(obj, fn) {\n  const entries = Object.entries(obj).map(([key, value]) => [\n    key,\n    fn(value, key)\n  ]);\n  return Object.fromEntries(entries);\n}\nfunction mapFilterObject(obj, fn) {\n  const entries = Object.entries(obj).map(([key, value]) => [key, fn(value, key)]).filter(([_, value]) => value !== void 0);\n  return Object.fromEntries(entries);\n}\nfunction getArrayBuffers(ctx) {\n  const buffers = [];\n  const seen = /* @__PURE__ */ new Set();\n  function traverse(obj) {\n    if (obj && typeof obj === \"object\" && !seen.has(obj)) {\n      seen.add(obj);\n      if (obj instanceof ArrayBuffer) {\n        buffers.push(obj);\n      } else if (ArrayBuffer.isView(obj)) {\n        buffers.push(obj.buffer);\n      } else if (Array.isArray(obj)) {\n        obj.forEach(traverse);\n      } else {\n        Object.values(obj).forEach(traverse);\n      }\n    }\n  }\n  traverse(ctx);\n  return buffers;\n}\nfunction newArray(n, initFunction) {\n  return new Array(n).fill(null).map((_, i) => initFunction(i));\n}\nclass FreeList {\n  constructor({\n    // Allocate a new item with the given args\n    allocate,\n    // Dispose of an item (optional, if GC is enough)\n    dispose,\n    // Check if an existing item in the list is valid for the given args,\n    // allowing you to store heterogeneous items in the list.\n    valid\n  }) {\n    this.items = [];\n    this.allocate = allocate;\n    this.dispose = dispose;\n    this.valid = valid;\n  }\n  // Allocate a new item from the free list, first checking if a existing item\n  // on the freelist is valid for the given args.\n  alloc(args) {\n    while (true) {\n      const item = this.items.pop();\n      if (!item) {\n        break;\n      }\n      if (this.valid(item, args)) {\n        return item;\n      }\n      if (this.dispose) {\n        this.dispose(item);\n      }\n    }\n    return this.allocate(args);\n  }\n  free(item) {\n    this.items.push(item);\n  }\n  disposeAll() {\n    let item;\n    item = this.items.pop();\n    while (item) {\n      if (this.dispose) {\n        this.dispose(item);\n      }\n      item = this.items.pop();\n    }\n  }\n}\nfunction setPackedSplat(packedSplats, index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {\n  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = floatToUint8((b - rgbMin) / rgbRange);\n  const uA = floatToUint8(opacity);\n  const uQuat = encodeQuatOctXy88R8(\n    new THREE.Quaternion(quatX, quatY, quatZ, quatW)\n  );\n  const uQuatX = uQuat & 255;\n  const uQuatY = uQuat >>> 8 & 255;\n  const uQuatZ = uQuat >>> 16 & 255;\n  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n  const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n    255,\n    Math.max(\n      1,\n      Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n  const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n    255,\n    Math.max(\n      1,\n      Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n    255,\n    Math.max(\n      1,\n      Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n  const uCenterX = toHalf(x);\n  const uCenterY = toHalf(y);\n  const uCenterZ = toHalf(z);\n  const i4 = index * 4;\n  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n  packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n}\nfunction setPackedSplatCenter(packedSplats, index, x, y, z) {\n  const uCenterX = toHalf(x);\n  const uCenterY = toHalf(y);\n  const uCenterZ = toHalf(z);\n  const i4 = index * 4;\n  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n  packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n}\nfunction setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {\n  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n  const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n    255,\n    Math.max(\n      1,\n      Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n  const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n    255,\n    Math.max(\n      1,\n      Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n    255,\n    Math.max(\n      1,\n      Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n  const i4 = index * 4;\n  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n}\nfunction setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n  const uQuat = encodeQuatOctXy88R8(\n    new THREE.Quaternion(quatX, quatY, quatZ, quatW)\n  );\n  const uQuatX = uQuat & 255;\n  const uQuatY = uQuat >>> 8 & 255;\n  const uQuatZ = uQuat >>> 16 & 255;\n  const i4 = index * 4;\n  packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n  packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n}\nfunction setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {\n  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = floatToUint8((b - rgbMin) / rgbRange);\n  const uA = floatToUint8(a);\n  const i4 = index * 4;\n  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n}\nfunction setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {\n  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = floatToUint8((b - rgbMin) / rgbRange);\n  const i4 = index * 4;\n  packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n}\nfunction setPackedSplatOpacity(packedSplats, index, opacity) {\n  const uA = floatToUint8(opacity);\n  const i4 = index * 4;\n  packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n}\nconst packedCenter = new THREE.Vector3();\nconst packedScales = new THREE.Vector3();\nconst packedQuaternion = new THREE.Quaternion();\nconst packedColor = new THREE.Color();\nconst packedFields = {\n  center: packedCenter,\n  scales: packedScales,\n  quaternion: packedQuaternion,\n  color: packedColor,\n  opacity: 0\n};\nfunction unpackSplat(packedSplats, index, encoding) {\n  const result = packedFields;\n  const i4 = index * 4;\n  const word0 = packedSplats[i4];\n  const word1 = packedSplats[i4 + 1];\n  const word2 = packedSplats[i4 + 2];\n  const word3 = packedSplats[i4 + 3];\n  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = rgbMax - rgbMin;\n  result.color.set(\n    rgbMin + (word0 & 255) / 255 * rgbRange,\n    rgbMin + (word0 >>> 8 & 255) / 255 * rgbRange,\n    rgbMin + (word0 >>> 16 & 255) / 255 * rgbRange\n  );\n  result.opacity = (word0 >>> 24 & 255) / 255;\n  result.center.set(\n    fromHalf(word1 & 65535),\n    fromHalf(word1 >>> 16 & 65535),\n    fromHalf(word2 & 65535)\n  );\n  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n  const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n  const lnScaleScale = (lnScaleMax - lnScaleMin) / 254;\n  const uScalesX = word3 & 255;\n  result.scales.x = uScalesX === 0 ? 0 : Math.exp(lnScaleMin + (uScalesX - 1) * lnScaleScale);\n  const uScalesY = word3 >>> 8 & 255;\n  result.scales.y = uScalesY === 0 ? 0 : Math.exp(lnScaleMin + (uScalesY - 1) * lnScaleScale);\n  const uScalesZ = word3 >>> 16 & 255;\n  result.scales.z = uScalesZ === 0 ? 0 : Math.exp(lnScaleMin + (uScalesZ - 1) * lnScaleScale);\n  const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;\n  decodeQuatOctXy88R8(uQuat, result.quaternion);\n  return result;\n}\nfunction getTextureSize(numSplats) {\n  const width = SPLAT_TEX_WIDTH;\n  const height = Math.max(\n    SPLAT_TEX_MIN_HEIGHT,\n    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n  );\n  const depth = Math.ceil(numSplats / (width * height));\n  const maxSplats = width * height * depth;\n  return { width, height, depth, maxSplats };\n}\nfunction computeMaxSplats(numSplats) {\n  const width = SPLAT_TEX_WIDTH;\n  const height = Math.max(\n    SPLAT_TEX_MIN_HEIGHT,\n    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n  );\n  const depth = Math.ceil(numSplats / (width * height));\n  return width * height * depth;\n}\nfunction isMobile() {\n  if (navigator.maxTouchPoints > 0) {\n    return true;\n  }\n  return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(\n    navigator.userAgent\n  );\n}\nfunction isAndroid() {\n  return /Android/.test(navigator.userAgent);\n}\nfunction isOculus() {\n  return /Oculus/.test(navigator.userAgent);\n}\nfunction flipPixels(pixels, width, height) {\n  const tempLine = new Uint8Array(width * 4);\n  for (let y = 0; y < height / 2; y++) {\n    const topOffset = y * width * 4;\n    const bottomOffset = (height - 1 - y) * width * 4;\n    tempLine.set(pixels.subarray(topOffset, topOffset + width * 4));\n    pixels.set(\n      pixels.subarray(bottomOffset, bottomOffset + width * 4),\n      topOffset\n    );\n    pixels.set(tempLine, bottomOffset);\n  }\n  return pixels;\n}\nfunction pixelsToPngUrl(pixels, width, height) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new Error(\"Can't get 2d context\");\n  }\n  const imageData = ctx.createImageData(width, height);\n  imageData.data.set(pixels);\n  ctx.putImageData(imageData, 0, 0);\n  return canvas.toDataURL(\"image/png\");\n}\nfunction cloneClock(clock) {\n  const newClock = new THREE.Clock(clock.autoStart);\n  newClock.startTime = clock.startTime;\n  newClock.oldTime = clock.oldTime;\n  newClock.elapsedTime = clock.elapsedTime;\n  newClock.running = clock.running;\n  return newClock;\n}\nfunction omitUndefined(obj) {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([_, value]) => value !== void 0)\n  );\n}\nconst IDENT_VERTEX_SHADER = unindent(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\nfunction averagePositions(positions) {\n  const sum = new THREE.Vector3();\n  for (const position of positions) {\n    sum.add(position);\n  }\n  return sum.divideScalar(positions.length);\n}\nfunction averageQuaternions(quaternions) {\n  if (quaternions.length === 0) {\n    return new THREE.Quaternion();\n  }\n  const sum = quaternions[0].clone();\n  for (let i = 1; i < quaternions.length; i++) {\n    if (quaternions[i].dot(quaternions[0]) < 0) {\n      sum.x -= quaternions[i].x;\n      sum.y -= quaternions[i].y;\n      sum.z -= quaternions[i].z;\n      sum.w -= quaternions[i].w;\n    } else {\n      sum.x += quaternions[i].x;\n      sum.y += quaternions[i].y;\n      sum.z += quaternions[i].z;\n      sum.w += quaternions[i].w;\n    }\n  }\n  return sum.normalize();\n}\nfunction coinciDist(matrix1, matrix2) {\n  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\n  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\n  const direction1 = new THREE.Vector3(0, 0, -1).applyMatrix4(matrix1).sub(origin1).normalize();\n  const direction2 = new THREE.Vector3(0, 0, -1).applyMatrix4(matrix2).sub(origin2).normalize();\n  const distance2 = origin1.distanceTo(origin2);\n  const coincidence = direction1.dot(direction2);\n  return { distance: distance2, coincidence };\n}\nfunction withinDist({\n  matrix1,\n  matrix2,\n  maxDistance\n}) {\n  const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\n  const origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\n  return origin1.distanceTo(origin2) <= maxDistance;\n}\nfunction withinCoinciDist({\n  matrix1,\n  matrix2,\n  maxDistance,\n  minCoincidence\n}) {\n  const { distance: distance2, coincidence } = coinciDist(matrix1, matrix2);\n  return distance2 <= maxDistance && (minCoincidence == null || coincidence >= minCoincidence);\n}\nfunction coorientDist(matrix1, matrix2) {\n  const [origin1, rotate1] = [new THREE.Vector3(), new THREE.Quaternion()];\n  const [origin2, rotate2] = [new THREE.Vector3(), new THREE.Quaternion()];\n  matrix1.decompose(origin1, rotate1, new THREE.Vector3());\n  matrix2.decompose(origin2, rotate2, new THREE.Vector3());\n  const distance2 = origin1.distanceTo(origin2);\n  const coorient = Math.abs(rotate1.dot(rotate2));\n  return { distance: distance2, coorient };\n}\nfunction withinCoorientDist({\n  matrix1,\n  matrix2,\n  maxDistance,\n  minCoorient\n}) {\n  const { distance: distance2, coorient } = coorientDist(matrix1, matrix2);\n  return distance2 <= maxDistance && (minCoorient == null || coorient >= minCoorient);\n}\nfunction epsilonSign(value, epsilon = 1e-3) {\n  if (Math.abs(value) < epsilon) {\n    return 0;\n  }\n  return Math.sign(value);\n}\nfunction encodeQuatXyz888(q) {\n  const negQuat = q.w < 0;\n  const iQuatX = floatToSint8(negQuat ? -q.x : q.x);\n  const iQuatY = floatToSint8(negQuat ? -q.y : q.y);\n  const iQuatZ = floatToSint8(negQuat ? -q.z : q.z);\n  const uQuatX = iQuatX & 255;\n  const uQuatY = iQuatY & 255;\n  const uQuatZ = iQuatZ & 255;\n  return uQuatX | uQuatY << 8 | uQuatZ << 16;\n}\nfunction decodeQuatXyz888(encoded, out) {\n  const iQuatX = encoded << 24 >> 24;\n  const iQuatY = encoded << 16 >> 24;\n  const iQuatZ = encoded << 8 >> 24;\n  out.set(iQuatX / 127, iQuatY / 127, iQuatZ / 127, 0);\n  const dotSelf = out.x * out.x + out.y * out.y + out.z * out.z;\n  out.w = Math.sqrt(Math.max(0, 1 - dotSelf));\n  return out;\n}\nfunction encodeQuatOctXy88R8(q) {\n  const qnorm = q.clone().normalize();\n  if (qnorm.w < 0) {\n    qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n  }\n  const theta = 2 * Math.acos(qnorm.w);\n  const xyz_norm = Math.sqrt(\n    qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n  );\n  const axis = xyz_norm < 1e-6 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n  const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n  let p_x = axis.x / sum;\n  let p_y = axis.y / sum;\n  if (axis.z < 0) {\n    const tmp = p_x;\n    p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n    p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n  }\n  const u_f = p_x * 0.5 + 0.5;\n  const v_f = p_y * 0.5 + 0.5;\n  const quantU = Math.round(u_f * 255);\n  const quantV = Math.round(v_f * 255);\n  const angleInt = Math.round(theta * (255 / Math.PI));\n  return angleInt << 16 | quantV << 8 | quantU;\n}\nfunction decodeQuatOctXy88R8(encoded, out) {\n  const quantU = encoded & 255;\n  const quantV = encoded >>> 8 & 255;\n  const angleInt = encoded >>> 16 & 255;\n  const u_f = quantU / 255;\n  const v_f = quantV / 255;\n  let f_x = (u_f - 0.5) * 2;\n  let f_y = (v_f - 0.5) * 2;\n  const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\n  const t = Math.max(-f_z, 0);\n  f_x += f_x >= 0 ? -t : t;\n  f_y += f_y >= 0 ? -t : t;\n  const axis = new THREE.Vector3(f_x, f_y, f_z).normalize();\n  const theta = angleInt / 255 * Math.PI;\n  const halfTheta = theta * 0.5;\n  const s = Math.sin(halfTheta);\n  const w = Math.cos(halfTheta);\n  out.set(axis.x * s, axis.y * s, axis.z * s, w);\n  return out;\n}\nfunction encodeQuatEulerXyz888(q) {\n  const qNorm = q.clone().normalize();\n  const sinr_cosp = 2 * (qNorm.w * qNorm.x + qNorm.y * qNorm.z);\n  const cosr_cosp = 1 - 2 * (qNorm.x * qNorm.x + qNorm.y * qNorm.y);\n  const roll = Math.atan2(sinr_cosp, cosr_cosp);\n  const sinp = 2 * (qNorm.w * qNorm.y - qNorm.z * qNorm.x);\n  const pitch = Math.abs(sinp) >= 1 ? Math.sign(sinp) * (Math.PI / 2) : Math.asin(sinp);\n  const siny_cosp = 2 * (qNorm.w * qNorm.z + qNorm.x * qNorm.y);\n  const cosy_cosp = 1 - 2 * (qNorm.y * qNorm.y + qNorm.z * qNorm.z);\n  const yaw = Math.atan2(siny_cosp, cosy_cosp);\n  const normRoll = (roll + Math.PI) / (2 * Math.PI);\n  const normPitch = (pitch + Math.PI) / (2 * Math.PI);\n  const normYaw = (yaw + Math.PI) / (2 * Math.PI);\n  const rollQ = Math.round(normRoll * 255);\n  const pitchQ = Math.round(normPitch * 255);\n  const yawQ = Math.round(normYaw * 255);\n  return yawQ << 16 | pitchQ << 8 | rollQ;\n}\nfunction decodeQuatEulerXyz888(encoded, out) {\n  const rollQ = encoded & 255;\n  const pitchQ = encoded >>> 8 & 255;\n  const yawQ = encoded >>> 16 & 255;\n  const normRoll = rollQ / 255;\n  const normPitch = pitchQ / 255;\n  const normYaw = yawQ / 255;\n  const roll = normRoll * (2 * Math.PI) - Math.PI;\n  const pitch = normPitch * (2 * Math.PI) - Math.PI;\n  const yaw = normYaw * (2 * Math.PI) - Math.PI;\n  const cr = Math.cos(roll * 0.5);\n  const sr = Math.sin(roll * 0.5);\n  const cp = Math.cos(pitch * 0.5);\n  const sp = Math.sin(pitch * 0.5);\n  const cy = Math.cos(yaw * 0.5);\n  const sy = Math.sin(yaw * 0.5);\n  out.w = cr * cp * cy + sr * sp * sy;\n  out.x = sr * cp * cy - cr * sp * sy;\n  out.y = cr * sp * cy + sr * cp * sy;\n  out.z = cr * cp * sy - sr * sp * cy;\n  out.normalize();\n  return out;\n}\nfunction packSint8Bytes(b0, b1, b22, b3) {\n  const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n  const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n  const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));\n  const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n  return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n}\nfunction encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {\n  const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;\n  const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;\n  const sh1Mid = 0.5 * (sh1Min + sh1Max);\n  const sh1Scale = 126 / (sh1Max - sh1Min);\n  const base = index * 2;\n  for (let i = 0; i < 9; ++i) {\n    const s = (sh1Rgb[i] - sh1Mid) * sh1Scale;\n    const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;\n    const bitStart = i * 7;\n    const bitEnd = bitStart + 7;\n    const wordStart = Math.floor(bitStart / 32);\n    const bitOffset = bitStart - wordStart * 32;\n    const firstWord = value << bitOffset & 4294967295;\n    sh1Array[base + wordStart] |= firstWord;\n    if (bitEnd > wordStart * 32 + 32) {\n      const secondWord = value >>> 32 - bitOffset & 4294967295;\n      sh1Array[base + wordStart + 1] |= secondWord;\n    }\n  }\n}\nfunction encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {\n  const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;\n  const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;\n  const sh2Mid = 0.5 * (sh2Min + sh2Max);\n  const sh2Scale = 2 / (sh2Max - sh2Min);\n  sh2Array[index * 4 + 0] = packSint8Bytes(\n    (sh2Rgb[0] - sh2Mid) * sh2Scale,\n    (sh2Rgb[1] - sh2Mid) * sh2Scale,\n    (sh2Rgb[2] - sh2Mid) * sh2Scale,\n    (sh2Rgb[3] - sh2Mid) * sh2Scale\n  );\n  sh2Array[index * 4 + 1] = packSint8Bytes(\n    (sh2Rgb[4] - sh2Mid) * sh2Scale,\n    (sh2Rgb[5] - sh2Mid) * sh2Scale,\n    (sh2Rgb[6] - sh2Mid) * sh2Scale,\n    (sh2Rgb[7] - sh2Mid) * sh2Scale\n  );\n  sh2Array[index * 4 + 2] = packSint8Bytes(\n    (sh2Rgb[8] - sh2Mid) * sh2Scale,\n    (sh2Rgb[9] - sh2Mid) * sh2Scale,\n    (sh2Rgb[10] - sh2Mid) * sh2Scale,\n    (sh2Rgb[11] - sh2Mid) * sh2Scale\n  );\n  sh2Array[index * 4 + 3] = packSint8Bytes(\n    (sh2Rgb[12] - sh2Mid) * sh2Scale,\n    (sh2Rgb[13] - sh2Mid) * sh2Scale,\n    (sh2Rgb[14] - sh2Mid) * sh2Scale,\n    0\n  );\n}\nfunction encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\n  const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\n  const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\n  const sh3Mid = 0.5 * (sh3Min + sh3Max);\n  const sh3Scale = 62 / (sh3Max - sh3Min);\n  const base = index * 4;\n  for (let i = 0; i < 21; ++i) {\n    const s = (sh3Rgb[i] - sh3Mid) * sh3Scale;\n    const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;\n    const bitStart = i * 6;\n    const bitEnd = bitStart + 6;\n    const wordStart = Math.floor(bitStart / 32);\n    const bitOffset = bitStart - wordStart * 32;\n    const firstWord = value << bitOffset & 4294967295;\n    sh3Array[base + wordStart] |= firstWord;\n    if (bitEnd > wordStart * 32 + 32) {\n      const secondWord = value >>> 32 - bitOffset & 4294967295;\n      sh3Array[base + wordStart + 1] |= secondWord;\n    }\n  }\n}\nfunction decompressPartialGzip(fileBytes, numBytes) {\n  const chunks = [];\n  let totalBytes = 0;\n  let result = null;\n  const gunzip = new Gunzip((data, final) => {\n    chunks.push(data);\n    totalBytes += data.length;\n    if (final || totalBytes >= numBytes) {\n      const allBytes = new Uint8Array(totalBytes);\n      let offset2 = 0;\n      for (const chunk of chunks) {\n        allBytes.set(chunk, offset2);\n        offset2 += chunk.length;\n      }\n      result = allBytes.slice(0, numBytes);\n    }\n  });\n  const CHUNK_SIZE = 1024;\n  let offset = 0;\n  while (result == null && offset < fileBytes.length) {\n    const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n    gunzip.push(chunk, false);\n    offset += CHUNK_SIZE;\n  }\n  if (result == null) {\n    gunzip.push(new Uint8Array(), true);\n    if (result == null) {\n      throw new Error(\"Failed to decompress partial gzip\");\n    }\n  }\n  return result;\n}\nclass GunzipReader {\n  constructor({\n    fileBytes,\n    chunkBytes = 64 * 1024\n  }) {\n    this.fileBytes = fileBytes;\n    this.chunkBytes = chunkBytes;\n    this.offset = 0;\n    this.chunks = [];\n    this.totalBytes = 0;\n    this.gunzip = new Gunzip((chunk, _final) => {\n      this.chunks.push(chunk);\n      this.totalBytes += chunk.length;\n    });\n  }\n  read(numBytes) {\n    while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {\n      const end = Math.min(\n        this.offset + this.chunkBytes,\n        this.fileBytes.length\n      );\n      this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);\n      this.offset = end;\n    }\n    if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {\n      this.gunzip.push(new Uint8Array(0), true);\n    }\n    if (this.totalBytes < numBytes) {\n      throw new Error(\n        `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n      );\n    }\n    const allBytes = new Uint8Array(this.totalBytes);\n    let outOffset = 0;\n    for (const chunk of this.chunks) {\n      allBytes.set(chunk, outOffset);\n      outOffset += chunk.length;\n    }\n    const result = allBytes.subarray(0, numBytes);\n    this.chunks = [allBytes.subarray(numBytes)];\n    this.totalBytes -= numBytes;\n    return result;\n  }\n}\nconst utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  DataCache,\n  FreeList,\n  GunzipReader,\n  IDENT_VERTEX_SHADER,\n  Sint8ToFloat,\n  Uint8ToFloat,\n  averagePositions,\n  averageQuaternions,\n  cloneClock,\n  coinciDist,\n  computeMaxSplats,\n  coorientDist,\n  decodeQuatEulerXyz888,\n  decodeQuatOctXy88R8,\n  decodeQuatXyz888,\n  decompressPartialGzip,\n  encodeQuatEulerXyz888,\n  encodeQuatOctXy88R8,\n  encodeQuatXyz888,\n  encodeSh1Rgb,\n  encodeSh2Rgb,\n  encodeSh3Rgb,\n  epsilonSign,\n  flipPixels,\n  floatBitsToUint: floatBitsToUint$1,\n  floatToSint8,\n  floatToUint8,\n  fromHalf,\n  getArrayBuffers,\n  getTextureSize,\n  isAndroid,\n  isMobile,\n  isOculus,\n  mapFilterObject,\n  mapObject,\n  newArray,\n  omitUndefined,\n  pixelsToPngUrl,\n  setPackedSplat,\n  setPackedSplatCenter,\n  setPackedSplatOpacity,\n  setPackedSplatQuat,\n  setPackedSplatRgb,\n  setPackedSplatRgba,\n  setPackedSplatScales,\n  toHalf,\n  uintBitsToFloat: uintBitsToFloat$1,\n  unpackSplat,\n  withinCoinciDist,\n  withinCoorientDist,\n  withinDist\n}, Symbol.toStringTag, { value: \"Module\" }));\nclass DynoProgram {\n  constructor({\n    graph,\n    inputs,\n    outputs,\n    template\n  }) {\n    this.graph = graph;\n    this.template = template;\n    this.inputs = inputs ?? {};\n    this.outputs = outputs ?? {};\n    const compile = new Compilation({ indent: this.template.indent });\n    for (const key in this.outputs) {\n      if (this.outputs[key]) {\n        compile.declares.add(this.outputs[key]);\n      }\n    }\n    const statements = graph.compile({\n      inputs: this.inputs,\n      outputs: this.outputs,\n      compile\n    });\n    this.shader = template.generate({ globals: compile.globals, statements });\n    this.uniforms = compile.uniforms;\n    this.updaters = compile.updaters;\n  }\n  prepareMaterial() {\n    return getMaterial(this);\n  }\n  update() {\n    for (const updater of this.updaters) {\n      updater();\n    }\n  }\n}\nclass DynoProgramTemplate {\n  constructor(template) {\n    const globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\n    const statements = template.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n    if (!globals || !statements) {\n      throw new Error(\n        \"Template must contain {{ GLOBALS }} and {{ STATEMENTS }}\"\n      );\n    }\n    this.before = template.substring(0, globals.index);\n    this.between = template.substring(\n      globals.index + globals[0].length,\n      statements.index\n    );\n    this.after = template.substring(\n      statements.index + statements[0].length\n    );\n    this.indent = statements[1];\n  }\n  generate({\n    globals,\n    statements\n  }) {\n    return this.before + Array.from(globals).join(\"\\n\\n\") + this.between + statements.map((s) => this.indent + s).join(\"\\n\") + this.after;\n  }\n}\nconst programMaterial = /* @__PURE__ */ new Map();\nfunction getMaterial(program) {\n  let material = programMaterial.get(program);\n  if (material) {\n    return material;\n  }\n  material = new THREE.RawShaderMaterial({\n    glslVersion: THREE.GLSL3,\n    vertexShader: IDENT_VERTEX_SHADER,\n    fragmentShader: program.shader,\n    uniforms: program.uniforms\n  });\n  programMaterial.set(program, material);\n  return material;\n}\nfunction addOutputType(a, b, operation = \"add\") {\n  const error = () => {\n    throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n  };\n  if (a === b) return a;\n  if (a === \"int\") {\n    if (isIntType(b)) return b;\n    error();\n  }\n  if (b === \"int\") {\n    if (isIntType(a)) return a;\n    error();\n  }\n  if (a === \"uint\") {\n    if (isUintType(b)) return b;\n    error();\n  }\n  if (b === \"uint\") {\n    if (isUintType(a)) return a;\n    error();\n  }\n  if (a === \"float\") {\n    if (isAllFloatType(b)) return b;\n    error();\n  }\n  if (b === \"float\") {\n    if (isAllFloatType(a)) return a;\n    error();\n  }\n  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n}\nfunction subOutputType(a, b) {\n  return addOutputType(a, b, \"sub\");\n}\nfunction mulOutputType(a, b) {\n  const error = () => {\n    throw new Error(`Invalid mul types: ${a}, ${b}`);\n  };\n  const result = (value) => value;\n  if (a === \"int\") {\n    if (isIntType(b)) return result(b);\n    error();\n  }\n  if (b === \"int\") {\n    if (isIntType(a)) return result(a);\n    error();\n  }\n  if (a === \"uint\") {\n    if (isUintType(b)) return result(b);\n    error();\n  }\n  if (b === \"uint\") {\n    if (isUintType(a)) return result(a);\n    error();\n  }\n  if (a === \"float\") {\n    if (isAllFloatType(b)) return result(b);\n    error();\n  }\n  if (b === \"float\") {\n    if (isAllFloatType(a)) return result(a);\n    error();\n  }\n  if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n    if (a === b) return result(a);\n    error();\n  }\n  if (a === \"vec2\") {\n    if (b === \"vec2\" || isMat2(b)) return result(\"vec2\");\n    if (b === \"mat3x2\") return result(\"vec3\");\n    if (b === \"mat4x2\") return result(\"vec4\");\n    error();\n  }\n  if (a === \"vec3\") {\n    if (b === \"mat2x3\") return result(\"vec2\");\n    if (b === \"vec3\" || isMat3(b)) return result(\"vec3\");\n    if (b === \"mat4x3\") return result(\"vec4\");\n    error();\n  }\n  if (a === \"vec4\") {\n    if (b === \"mat2x4\") return result(\"vec2\");\n    if (b === \"mat3x4\") return result(\"vec3\");\n    if (b === \"vec4\" || isMat4(b)) return result(\"vec4\");\n    error();\n  }\n  if (b === \"vec2\") {\n    if (isMat2(a)) return result(\"vec2\");\n    if (a === \"mat2x3\") return result(\"vec3\");\n    if (a === \"mat2x4\") return result(\"vec4\");\n    error();\n  }\n  if (b === \"vec3\") {\n    if (a === \"mat3x2\") return result(\"vec2\");\n    if (isMat3(a)) return result(\"vec3\");\n    if (a === \"mat3x4\") return result(\"vec4\");\n    error();\n  }\n  if (b === \"vec4\") {\n    if (a === \"mat4x2\") return result(\"vec2\");\n    if (a === \"mat4x3\") return result(\"vec3\");\n    if (isMat4(a)) return result(\"vec4\");\n    error();\n  }\n  if (isMat2(a)) {\n    if (isMat2(b)) return result(\"mat2\");\n    if (b === \"mat3x2\") return result(\"mat3x2\");\n    if (b === \"mat4x2\") return result(\"mat4x2\");\n    error();\n  }\n  if (a === \"mat2x3\") {\n    if (isMat2(b)) return result(\"mat2x3\");\n    if (b === \"mat3x2\") return result(\"mat3\");\n    if (b === \"mat4x2\") return result(\"mat4x3\");\n    error();\n  }\n  if (a === \"mat2x4\") {\n    if (isMat2(b)) return result(\"mat2x4\");\n    if (b === \"mat3x2\") return result(\"mat3x4\");\n    if (b === \"mat4x2\") return result(\"mat4\");\n    error();\n  }\n  if (a === \"mat3x2\") {\n    if (b === \"mat2x3\") return result(\"mat2\");\n    if (isMat3(b)) return result(\"mat3x2\");\n    if (b === \"mat4x3\") return result(\"mat4x2\");\n    error();\n  }\n  if (isMat3(a)) {\n    if (b === \"mat2x3\") return result(\"mat2x3\");\n    if (isMat3(b)) return result(\"mat3\");\n    if (b === \"mat4x3\") return result(\"mat4x3\");\n    error();\n  }\n  if (a === \"mat3x4\") {\n    if (b === \"mat2x3\") return result(\"mat2x4\");\n    if (isMat3(b)) return result(\"mat3x4\");\n    if (b === \"mat4x3\") return result(\"mat4\");\n    error();\n  }\n  if (a === \"mat4x2\") {\n    if (b === \"mat2x4\") return result(\"mat2\");\n    if (b === \"mat3x4\") return result(\"mat3x2\");\n    if (isMat4(b)) return result(\"mat4x2\");\n    error();\n  }\n  if (a === \"mat4x3\") {\n    if (b === \"mat2x4\") return result(\"mat2x3\");\n    if (b === \"mat3x4\") return result(\"mat3\");\n    if (isMat4(b)) return result(\"mat4x3\");\n    error();\n  }\n  if (isMat4(a)) {\n    if (b === \"mat2x4\") return result(\"mat2x4\");\n    if (b === \"mat3x4\") return result(\"mat3x4\");\n    if (isMat4(b)) return result(\"mat4\");\n    error();\n  }\n  throw new Error(`Invalid mul types: ${a}, ${b}`);\n}\nfunction divOutputType(a, b) {\n  return addOutputType(a, b, \"div\");\n}\nfunction imodOutputType(a, b) {\n  if (a === b) return a;\n  if (a === \"int\") {\n    if (isIntType(b)) return b;\n  } else if (b === \"int\") {\n    if (isIntType(a)) return a;\n  } else if (a === \"uint\") {\n    if (isUintType(b)) return b;\n  } else if (b === \"uint\") {\n    if (isUintType(a)) return a;\n  }\n  throw new Error(`Invalid imod types: ${a}, ${b}`);\n}\nfunction modOutputType(a, b) {\n  if (a === b || b === \"float\") return a;\n  throw new Error(`Invalid mod types: ${a}, ${b}`);\n}\nfunction modfOutputType(a) {\n  return a;\n}\nfunction negOutputType(a) {\n  return a;\n}\nfunction absOutputType(a) {\n  return a;\n}\nfunction signOutputType(a) {\n  return a;\n}\nfunction floorOutputType(a) {\n  return a;\n}\nfunction ceilOutputType(a) {\n  return a;\n}\nfunction truncOutputType(a) {\n  return a;\n}\nfunction roundOutputType(a) {\n  return a;\n}\nfunction fractOutputType(a) {\n  return a;\n}\nfunction powOutputType(a) {\n  return a;\n}\nfunction expOutputType(a) {\n  return a;\n}\nfunction exp2OutputType(a) {\n  return a;\n}\nfunction logOutputType(a) {\n  return a;\n}\nfunction log2OutputType(a) {\n  return a;\n}\nfunction sqrOutputType(a) {\n  return a;\n}\nfunction sqrtOutputType(a) {\n  return a;\n}\nfunction inversesqrtOutputType(a) {\n  return a;\n}\nfunction minOutputType(a, b, operation = \"min\") {\n  if (a === b) return a;\n  if (b === \"float\") {\n    if (isFloatType(a)) return a;\n  } else if (b === \"int\") {\n    if (isIntType(a)) return a;\n  } else if (b === \"uint\") {\n    if (isUintType(a)) return a;\n  }\n  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n}\nfunction maxOutputType(a, b) {\n  return minOutputType(a, b, \"max\");\n}\nfunction clampOutputType(a, b, _c) {\n  if (b === \"float\") {\n    if (isFloatType(a)) return a;\n  } else if (b === \"int\") {\n    if (isIntType(a)) return a;\n  } else if (b === \"uint\") {\n    if (isUintType(a)) return a;\n  }\n  throw new Error(`Invalid clamp types: ${a}, ${b}`);\n}\nfunction mixOutputType(a, b, c) {\n  if (c === a) return a;\n  if (c === \"float\") return a;\n  if (c === \"bool\" && a === \"float\") return a;\n  if (c === \"bvec2\" && a === \"vec2\") return a;\n  if (c === \"bvec3\" && a === \"vec3\") return a;\n  if (c === \"bvec4\" && a === \"vec4\") return a;\n  throw new Error(`Invalid mix types: ${a}, ${b}, ${c}`);\n}\nfunction stepOutputType(a, b) {\n  if (a === b || b === \"float\") return b;\n  throw new Error(`Invalid step types: ${a}, ${b}`);\n}\nfunction smoothstepOutputType(a, b, c) {\n  if (a === b) {\n    if (a === c || a === \"float\") return c;\n  }\n  throw new Error(`Invalid smoothstep types: ${a}, ${b}, ${c}`);\n}\nfunction isNanOutputType(a, operation = \"isNan\") {\n  if (a === \"float\") return \"bool\";\n  if (a === \"vec2\") return \"bvec2\";\n  if (a === \"vec3\") return \"bvec3\";\n  if (a === \"vec4\") return \"bvec4\";\n  throw new Error(`Invalid ${operation} types: ${a}`);\n}\nfunction isInfOutputType(a) {\n  return isNanOutputType(a, \"isInf\");\n}\nconst add = (a, b) => new Add({ a, b });\nconst sub = (a, b) => new Sub({ a, b });\nconst mul = (a, b) => new Mul({ a, b });\nconst div = (a, b) => new Div({ a, b });\nconst imod = (a, b) => new IMod({ a, b });\nconst mod = (a, b) => new Mod({ a, b });\nconst modf = (a) => new Modf({ a }).outputs;\nconst neg = (a) => new Neg({ a });\nconst abs = (a) => new Abs({ a });\nconst sign = (a) => new Sign({ a });\nconst floor = (a) => new Floor({ a });\nconst ceil = (a) => new Ceil({ a });\nconst trunc = (a) => new Trunc({ a });\nconst round = (a) => new Round({ a });\nconst fract = (a) => new Fract({ a });\nconst pow = (a, b) => new Pow({ a, b });\nconst exp = (a) => new Exp({ a });\nconst exp2 = (a) => new Exp2({ a });\nconst log = (a) => new Log({ a });\nconst log2 = (a) => new Log2({ a });\nconst sqr = (a) => new Sqr({ a });\nconst sqrt = (a) => new Sqrt({ a });\nconst inversesqrt = (a) => new InverseSqrt({ a });\nconst min = (a, b) => new Min({ a, b });\nconst max = (a, b) => new Max({ a, b });\nconst clamp = (a, min2, max2) => new Clamp({ a, min: min2, max: max2 });\nconst mix = (a, b, t) => new Mix({ a, b, t });\nconst step = (edge, x) => new Step({ edge, x });\nconst smoothstep = (edge0, edge1, x) => new Smoothstep({ edge0, edge1, x });\nconst isNan = (a) => new IsNan({ a });\nconst isInf = (a) => new IsInf({ a });\nclass Add extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"sum\", outTypeFunc: addOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.sum} = ${inputs.a} + ${inputs.b};`];\n    };\n  }\n}\nclass Sub extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"difference\", outTypeFunc: subOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\n    };\n  }\n}\nclass Mul extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"product\", outTypeFunc: mulOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.product} = ${inputs.a} * ${inputs.b};`];\n    };\n  }\n}\nclass Div extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"quotient\", outTypeFunc: divOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.quotient} = ${inputs.a} / ${inputs.b};`];\n    };\n  }\n}\nclass IMod extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"remainder\", outTypeFunc: imodOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.remainder} = ${inputs.a} % ${inputs.b};`];\n    };\n  }\n}\nclass Mod extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"remainder\", outTypeFunc: modOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.remainder} = mod(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Modf extends Dyno {\n  constructor({ a }) {\n    const inTypes = { a: valType(a) };\n    const outType = modfOutputType(inTypes.a);\n    const outTypes = {\n      fract: outType,\n      integer: outType\n    };\n    super({ inTypes, outTypes, inputs: { a } });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.fract} = modf(${inputs.a}, ${outputs.integer});`];\n    };\n  }\n}\nclass Neg extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"neg\", outTypeFunc: negOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.neg} = -${inputs.a};`];\n    };\n  }\n}\nclass Abs extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"abs\", outTypeFunc: absOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.abs} = abs(${inputs.a});`];\n    };\n  }\n}\nclass Sign extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"sign\", outTypeFunc: signOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.sign} = sign(${inputs.a});`];\n    };\n  }\n}\nclass Floor extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"floor\", outTypeFunc: floorOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.floor} = floor(${inputs.a});`];\n    };\n  }\n}\nclass Ceil extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"ceil\", outTypeFunc: ceilOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.ceil} = ceil(${inputs.a});`];\n    };\n  }\n}\nclass Trunc extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"trunc\", outTypeFunc: truncOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.trunc} = trunc(${inputs.a});`];\n    };\n  }\n}\nclass Round extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"round\", outTypeFunc: roundOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.round} = round(${inputs.a});`];\n    };\n  }\n}\nclass Fract extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"fract\", outTypeFunc: fractOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.fract} = fract(${inputs.a});`];\n    };\n  }\n}\nclass Pow extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"power\", outTypeFunc: powOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.power} = pow(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Exp extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"exp\", outTypeFunc: expOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.exp} = exp(${inputs.a});`];\n    };\n  }\n}\nclass Exp2 extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"exp2\", outTypeFunc: exp2OutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.exp2} = exp2(${inputs.a});`];\n    };\n  }\n}\nclass Log extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"log\", outTypeFunc: logOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.log} = log(${inputs.a});`];\n    };\n  }\n}\nclass Log2 extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"log2\", outTypeFunc: log2OutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.log2} = log2(${inputs.a});`];\n    };\n  }\n}\nclass Sqr extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"sqr\", outTypeFunc: sqrOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.sqr} = ${inputs.a} * ${inputs.a};`];\n    };\n  }\n}\nclass Sqrt extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"sqrt\", outTypeFunc: sqrtOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.sqrt} = sqrt(${inputs.a});`];\n    };\n  }\n}\nclass InverseSqrt extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"inversesqrt\", outTypeFunc: inversesqrtOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.inversesqrt} = inversesqrt(${inputs.a});`];\n    };\n  }\n}\nclass Min extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"min\", outTypeFunc: minOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.min} = min(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Max extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"max\", outTypeFunc: maxOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.max} = max(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Clamp extends TrinaryOp {\n  constructor({\n    a,\n    min: min2,\n    max: max2\n  }) {\n    super({\n      a,\n      b: min2,\n      c: max2,\n      outKey: \"clamp\",\n      outTypeFunc: clampOutputType\n    });\n    this.statements = ({ inputs, outputs }) => {\n      const { a: a2, b: min3, c: max3 } = inputs;\n      return [`${outputs.clamp} = clamp(${a2}, ${min3}, ${max3});`];\n    };\n  }\n}\nclass Mix extends TrinaryOp {\n  constructor({ a, b, t }) {\n    super({ a, b, c: t, outKey: \"mix\", outTypeFunc: mixOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      const { a: a2, b: b22, c: t2 } = inputs;\n      return [`${outputs.mix} = mix(${a2}, ${b22}, ${t2});`];\n    };\n  }\n}\nclass Step extends BinaryOp {\n  constructor({ edge, x }) {\n    super({\n      a: edge,\n      b: x,\n      outKey: \"step\",\n      outTypeFunc: stepOutputType\n    });\n    this.statements = ({ inputs, outputs }) => {\n      const { a: edge2, b: x2 } = inputs;\n      return [`${outputs.step} = step(${edge2}, ${x2});`];\n    };\n  }\n}\nclass Smoothstep extends TrinaryOp {\n  constructor({\n    edge0,\n    edge1,\n    x\n  }) {\n    super({\n      a: edge0,\n      b: edge1,\n      c: x,\n      outKey: \"smoothstep\",\n      outTypeFunc: smoothstepOutputType\n    });\n    this.statements = ({ inputs, outputs }) => {\n      const { a: edge02, b: edge12, c: x2 } = inputs;\n      return [`${outputs.smoothstep} = smoothstep(${edge02}, ${edge12}, ${x2});`];\n    };\n  }\n}\nclass IsNan extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"isNan\", outTypeFunc: isNanOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.isNan} = isNan(${inputs.a});`];\n    };\n  }\n}\nclass IsInf extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"isInf\", outTypeFunc: isInfOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.isInf} = isInf(${inputs.a});`];\n    };\n  }\n}\nconst and = (a, b) => new And({ a, b });\nconst or = (a, b) => new Or({ a, b });\nconst xor = (a, b) => new Xor({ a, b });\nconst not = (a) => new Not({ a });\nconst lessThan = (a, b) => new LessThan({ a, b });\nconst lessThanEqual = (a, b) => new LessThanEqual({ a, b });\nconst greaterThan = (a, b) => new GreaterThan({ a, b });\nconst greaterThanEqual = (a, b) => new GreaterThanEqual({ a, b });\nconst equal = (a, b) => new Equal({ a, b });\nconst notEqual = (a, b) => new NotEqual({ a, b });\nconst any = (a) => new Any({ a });\nconst all = (a) => new All({ a });\nconst select = (cond, t, f) => new Select({ cond, t, f });\nconst compXor = (a) => new CompXor({ a });\nclass And extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: \"and\" });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.and === \"bool\") {\n        return [`${outputs.and} = ${inputs.a} && ${inputs.b};`];\n      }\n      return [`${outputs.and} = ${inputs.a} & ${inputs.b};`];\n    };\n  }\n}\nclass Or extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: \"or\" });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.or === \"bool\") {\n        return [`${outputs.or} = ${inputs.a} || ${inputs.b};`];\n      }\n      return [`${outputs.or} = ${inputs.a} | ${inputs.b};`];\n    };\n  }\n}\nclass Xor extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: (aType, bType) => aType, outKey: \"xor\" });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.xor === \"bool\") {\n        return [`${outputs.xor} = ${inputs.a} ^^ ${inputs.b};`];\n      }\n      return [`${outputs.xor} = ${inputs.a} ^ ${inputs.b};`];\n    };\n  }\n}\nclass Not extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => aType, outKey: \"not\" });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.not === \"bool\") {\n        return [`${outputs.not} = !${inputs.a};`];\n      }\n      return [`${outputs.not} = not(${inputs.a});`];\n    };\n  }\n}\nclass LessThan extends BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      outTypeFunc: (aType, bType) => compareOutputType(aType, \"lessThan\"),\n      outKey: \"lessThan\"\n    });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.lessThan === \"bool\") {\n        return [`${outputs.lessThan} = ${inputs.a} < ${inputs.b};`];\n      }\n      return [`${outputs.lessThan} = lessThan(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass LessThanEqual extends BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      outTypeFunc: (aType, bType) => compareOutputType(aType, \"lessThanEqual\"),\n      outKey: \"lessThanEqual\"\n    });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.lessThanEqual === \"bool\") {\n        return [`${outputs.lessThanEqual} = ${inputs.a} <= ${inputs.b};`];\n      }\n      return [\n        `${outputs.lessThanEqual} = lessThanEqual(${inputs.a}, ${inputs.b});`\n      ];\n    };\n  }\n}\nclass GreaterThan extends BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      outTypeFunc: (aType, bType) => compareOutputType(aType, \"greaterThan\"),\n      outKey: \"greaterThan\"\n    });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.greaterThan === \"bool\") {\n        return [`${outputs.greaterThan} = ${inputs.a} > ${inputs.b};`];\n      }\n      return [\n        `${outputs.greaterThan} = greaterThan(${inputs.a}, ${inputs.b});`\n      ];\n    };\n  }\n}\nclass GreaterThanEqual extends BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      outTypeFunc: (aType, bType) => compareOutputType(aType, \"greaterThanEqual\"),\n      outKey: \"greaterThanEqual\"\n    });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.greaterThanEqual === \"bool\") {\n        return [`${outputs.greaterThanEqual} = ${inputs.a} >= ${inputs.b};`];\n      }\n      return [\n        `${outputs.greaterThanEqual} = greaterThanEqual(${inputs.a}, ${inputs.b});`\n      ];\n    };\n  }\n}\nclass Equal extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: equalOutputType, outKey: \"equal\" });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.equal === \"bool\") {\n        return [`${outputs.equal} = ${inputs.a} == ${inputs.b};`];\n      }\n      return [`${outputs.equal} = equal(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass NotEqual extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: notEqualOutputType, outKey: \"notEqual\" });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.outTypes.notEqual === \"bool\") {\n        return [`${outputs.notEqual} = ${inputs.a} != ${inputs.b};`];\n      }\n      return [`${outputs.notEqual} = notEqual(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Any extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => \"bool\", outKey: \"any\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.any} = any(${inputs.a});`];\n    };\n  }\n}\nclass All extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => \"bool\", outKey: \"all\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.all} = all(${inputs.a});`];\n    };\n  }\n}\nclass Select extends TrinaryOp {\n  constructor({\n    cond,\n    t,\n    f\n  }) {\n    super({\n      a: cond,\n      b: t,\n      c: f,\n      outKey: \"select\",\n      outTypeFunc: (aType, bType, cType) => bType\n    });\n    this.statements = ({ inputs, outputs }) => {\n      const { a: cond2, b: t2, c: f2 } = inputs;\n      return [`${outputs.select} = (${cond2}) ? (${t2}) : (${f2});`];\n    };\n  }\n}\nfunction compareOutputType(type, operator) {\n  if (isScalarType(type)) {\n    return \"bool\";\n  }\n  if (type === \"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\n    return \"bvec2\";\n  }\n  if (type === \"ivec3\" || type === \"uvec3\" || type === \"vec3\") {\n    return \"bvec3\";\n  }\n  if (type === \"ivec4\" || type === \"uvec4\" || type === \"vec4\") {\n    return \"bvec4\";\n  }\n  throw new Error(`Invalid ${operator} type: ${type}`);\n}\nfunction equalOutputType(type, operator = \"equal\") {\n  if (isScalarType(type)) {\n    return \"bool\";\n  }\n  if (isBoolType(type)) {\n    return type;\n  }\n  if (type === \"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\n    return \"bvec2\";\n  }\n  if (type === \"ivec3\" || type === \"uvec3\" || type === \"vec3\") {\n    return \"bvec3\";\n  }\n  if (type === \"ivec4\" || type === \"uvec4\" || type === \"vec4\") {\n    return \"bvec4\";\n  }\n  throw new Error(`Invalid ${operator} type: ${type}`);\n}\nfunction notEqualOutputType(type) {\n  return equalOutputType(type, \"notEqual\");\n}\nfunction compXorOutputType(type) {\n  if (isBoolType(type)) {\n    return \"bool\";\n  }\n  if (isIntType(type)) {\n    return \"int\";\n  }\n  if (isUintType(type)) {\n    return \"uint\";\n  }\n  throw new Error(`Invalid compXor type: ${type}`);\n}\nclass CompXor extends UnaryOp {\n  constructor({ a }) {\n    const outType = compXorOutputType(valType(a));\n    super({ a, outTypeFunc: (aType) => outType, outKey: \"compXor\" });\n    this.statements = ({ inputs, outputs }) => {\n      if (isScalarType(this.outTypes.compXor)) {\n        return [`${outputs.compXor} = ${inputs.a};`];\n      }\n      const components = isVector2Type(outType) ? [\"x\", \"y\"] : isVector3Type(outType) ? [\"x\", \"y\", \"z\"] : [\"x\", \"y\", \"z\", \"w\"];\n      const operands = components.map((c) => `${inputs.a}.${c}`);\n      const operator = isBoolType(outType) ? \"^^\" : \"^\";\n      return [`${outputs.compXor} = ${operands.join(` ${operator} `)};`];\n    };\n  }\n}\nconst bool = (value) => new Bool({ value });\nconst int = (value) => new Int({ value });\nconst uint = (value) => new Uint({ value });\nconst float = (value) => new Float({ value });\nconst bvec2 = (value) => new BVec2({ value });\nconst bvec3 = (value) => new BVec3({ value });\nconst bvec4 = (value) => new BVec4({ value });\nconst ivec2 = (value) => new IVec2({ value });\nconst ivec3 = (value) => new IVec3({ value });\nconst ivec4 = (value) => new IVec4({ value });\nconst uvec2 = (value) => new UVec2({ value });\nconst uvec3 = (value) => new UVec3({ value });\nconst uvec4 = (value) => new UVec4({ value });\nconst vec2 = (value) => new Vec2({ value });\nconst vec3 = (value) => new Vec3({ value });\nconst vec4 = (value) => new Vec4({ value });\nconst mat2 = (value) => new Mat2({ value });\nconst mat3 = (value) => new Mat3({ value });\nconst mat4 = (value) => new Mat4({ value });\nconst floatBitsToInt = (value) => new FloatBitsToInt({ value });\nconst floatBitsToUint = (value) => new FloatBitsToUint({ value });\nconst intBitsToFloat = (value) => new IntBitsToFloat({ value });\nconst uintBitsToFloat = (value) => new UintBitsToFloat({ value });\nconst packSnorm2x16 = (value) => new PackSnorm2x16({ value });\nconst unpackSnorm2x16 = (value) => new UnpackSnorm2x16({ value });\nconst packUnorm2x16 = (value) => new PackUnorm2x16({ value });\nconst unpackUnorm2x16 = (value) => new UnpackUnorm2x16({ value });\nconst packHalf2x16 = (value) => new PackHalf2x16({ value });\nconst unpackHalf2x16 = (value) => new UnpackHalf2x16({ value });\nconst uintToRgba8 = (value) => new UintToRgba8({ value });\nclass SimpleCast extends UnaryOp {\n  constructor({\n    value,\n    outType,\n    outKey\n  }) {\n    super({ a: value, outTypeFunc: () => outType, outKey });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs[outKey]} = ${typeLiteral(outType)}(${inputs.a});`\n    ];\n  }\n}\nclass Bool extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"bool\", outKey: \"bool\" });\n  }\n}\nclass Int extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"int\", outKey: \"int\" });\n  }\n}\nclass Uint extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"uint\", outKey: \"uint\" });\n  }\n}\nclass Float extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"float\", outKey: \"float\" });\n  }\n}\nclass BVec2 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec2\", outKey: \"bvec2\" });\n  }\n}\nclass BVec3 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec3\", outKey: \"bvec3\" });\n  }\n}\nclass BVec4 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec4\", outKey: \"bvec4\" });\n  }\n}\nclass IVec2 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec2\", outKey: \"ivec2\" });\n  }\n}\nclass IVec3 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec3\", outKey: \"ivec3\" });\n  }\n}\nclass IVec4 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec4\", outKey: \"ivec4\" });\n  }\n}\nclass UVec2 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec2\", outKey: \"uvec2\" });\n  }\n}\nclass UVec3 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec3\", outKey: \"uvec3\" });\n  }\n}\nclass UVec4 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec4\", outKey: \"uvec4\" });\n  }\n}\nclass Vec2 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"vec2\", outKey: \"vec2\" });\n  }\n}\nclass Vec3 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"vec3\", outKey: \"vec3\" });\n  }\n}\nclass Vec4 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"vec4\", outKey: \"vec4\" });\n  }\n}\nclass Mat2 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"mat2\", outKey: \"mat2\" });\n  }\n}\nclass Mat3 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"mat3\", outKey: \"mat3\" });\n  }\n}\nclass Mat4 extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"mat4\", outKey: \"mat4\" });\n  }\n}\nclass FloatBitsToInt extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"int\", outTypeFunc: () => \"int\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.int} = floatBitsToInt(${inputs.a});`];\n    };\n  }\n}\nclass FloatBitsToUint extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.uint} = floatBitsToUint(${inputs.a});`];\n    };\n  }\n}\nclass IntBitsToFloat extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"float\", outTypeFunc: () => \"float\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.float} = intBitsToFloat(${inputs.a});`];\n    };\n  }\n}\nclass UintBitsToFloat extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"float\", outTypeFunc: () => \"float\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.float} = uintBitsToFloat(${inputs.a});`];\n    };\n  }\n}\nclass PackSnorm2x16 extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.uint} = packSnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackSnorm2x16 extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.vec2} = unpackSnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass PackUnorm2x16 extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.uint} = packUnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackUnorm2x16 extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.vec2} = unpackUnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass PackHalf2x16 extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.uint} = packHalf2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackHalf2x16 extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.vec2} = unpackHalf2x16(${inputs.a});`];\n    };\n  }\n}\nclass UintToRgba8 extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \"rgba8\", outTypeFunc: () => \"vec4\" });\n    this.statements = ({ inputs, outputs }) => {\n      return [\n        `uvec4 uRgba = uvec4(${inputs.a} & 0xffu, (${inputs.a} >> 8u) & 0xffu, (${inputs.a} >> 16u) & 0xffu, (${inputs.a} >> 24u) & 0xffu);`,\n        `${outputs.rgba8} = vec4(uRgba) / 255.0;`\n      ];\n    };\n  }\n}\nconst length = (a) => new Length({ a });\nconst distance = (a, b) => new Distance({ a, b });\nconst dot = (a, b) => new Dot({ a, b });\nconst cross = (a, b) => new Cross({ a, b });\nconst normalize = (a) => new Normalize({ a });\nconst faceforward = (a, b, c) => new FaceForward({ a, b, c });\nconst reflectVec = (incident, normal) => new ReflectVec({ incident, normal });\nconst refractVec = (incident, normal, eta) => new RefractVec({ incident, normal, eta });\nconst split = (vector) => new Split({ vector });\nconst combine = ({\n  vector,\n  vectorType,\n  x,\n  y,\n  z,\n  w,\n  r,\n  g,\n  b,\n  a\n}) => new Combine({ vector, vectorType, x, y, z, w, r, g, b, a });\nconst projectH = (a) => new ProjectH({ a });\nconst extendVec = (a, b) => new ExtendVec({ a, b });\nconst swizzle = (a, select2) => new Swizzle({ vector: a, select: select2 });\nconst compMult = (a, b) => new CompMult({ a, b });\nconst outer = (a, b) => new Outer({ a, b });\nconst transpose = (a) => new Transpose({ a });\nconst determinant = (a) => new Determinant({ a });\nconst inverse = (a) => new Inverse({ a });\nclass Length extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => \"float\", outKey: \"length\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.length} = length(${inputs.a});`\n    ];\n  }\n}\nclass Distance extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"distance\", outTypeFunc: (aType, bType) => \"float\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.distance} = distance(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Dot extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"dot\", outTypeFunc: (aType, bType) => \"float\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.dot} = dot(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Cross extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"cross\", outTypeFunc: (aType, bType) => \"vec3\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.cross} = cross(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Normalize extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => aType, outKey: \"normalize\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.normalize} = normalize(${inputs.a});`\n    ];\n  }\n}\nfunction projectHOutputType(type) {\n  if (type === \"vec3\") {\n    return \"vec2\";\n  }\n  if (type === \"vec4\") {\n    return \"vec3\";\n  }\n  throw new Error(\"Invalid type\");\n}\nclass ProjectH extends UnaryOp {\n  constructor({ a }) {\n    super({\n      a,\n      outTypeFunc: (aType) => projectHOutputType(aType),\n      outKey: \"projected\"\n    });\n    this.statements = ({ inputs, outputs }) => {\n      if (this.inTypes.a === \"vec3\") {\n        return [`${outputs.projected} = ${inputs.a}.xy / ${inputs.a}.z;`];\n      }\n      if (this.inTypes.a === \"vec4\") {\n        return [`${outputs.projected} = ${inputs.a}.xyz / ${inputs.a}.w;`];\n      }\n      throw new Error(\"Invalid type\");\n    };\n  }\n}\nfunction extendVecOutputType(type) {\n  if (type === \"float\") return \"vec2\";\n  if (type === \"vec2\") return \"vec3\";\n  if (type === \"vec3\") return \"vec4\";\n  throw new Error(\"Invalid type\");\n}\nclass ExtendVec extends BinaryOp {\n  constructor({ a, b }) {\n    const type = valType(a);\n    const outType = extendVecOutputType(type);\n    super({ a, b, outKey: \"extend\", outTypeFunc: () => outType });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.extend} = ${outType}(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass FaceForward extends TrinaryOp {\n  constructor({ a, b, c }) {\n    super({\n      a,\n      b,\n      c,\n      outKey: \"forward\",\n      outTypeFunc: (aType, bType, cType) => aType\n    });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.forward} = faceforward(${inputs.a}, ${inputs.b}, ${inputs.c});`\n    ];\n  }\n}\nclass ReflectVec extends BinaryOp {\n  constructor({\n    incident,\n    normal\n  }) {\n    super({\n      a: incident,\n      b: normal,\n      outKey: \"reflection\",\n      outTypeFunc: (aType, bType) => aType\n    });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.reflection} = reflect(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass RefractVec extends TrinaryOp {\n  constructor({\n    incident,\n    normal,\n    eta\n  }) {\n    super({\n      a: incident,\n      b: normal,\n      c: eta,\n      outKey: \"refraction\",\n      outTypeFunc: (aType, bType, cType) => aType\n    });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.refraction} = refract(${inputs.a}, ${inputs.b}, ${inputs.c});`\n    ];\n  }\n}\nclass CompMult extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"product\", outTypeFunc: (aType, bType) => aType });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.product} = matrixCompMult(${a}, ${b});`\n    ];\n  }\n}\nfunction outerOutputType(aType, bType) {\n  if (aType === \"vec2\") {\n    if (bType === \"vec2\") return \"mat2\";\n    if (bType === \"vec3\") return \"mat3x2\";\n    if (bType === \"vec4\") return \"mat4x2\";\n  }\n  if (aType === \"vec3\") {\n    if (bType === \"vec2\") return \"mat2x3\";\n    if (bType === \"vec3\") return \"mat3\";\n    if (bType === \"vec4\") return \"mat4x3\";\n  }\n  if (aType === \"vec4\") {\n    if (bType === \"vec2\") return \"mat2x4\";\n    if (bType === \"vec3\") return \"mat3x4\";\n    if (bType === \"vec4\") return \"mat4\";\n  }\n  throw new Error(`Invalid outer type: ${aType}, ${bType}`);\n}\nclass Outer extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"outer\", outTypeFunc: outerOutputType });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.outer} = outerProduct(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nfunction transposeOutputType(type) {\n  if (type === \"mat2\") return \"mat2\";\n  if (type === \"mat3\") return \"mat3\";\n  if (type === \"mat4\") return \"mat4\";\n  if (type === \"mat2x2\") return \"mat2x2\";\n  if (type === \"mat2x3\") return \"mat3x2\";\n  if (type === \"mat2x4\") return \"mat4x2\";\n  if (type === \"mat3x2\") return \"mat2x3\";\n  if (type === \"mat3x3\") return \"mat3x3\";\n  if (type === \"mat3x4\") return \"mat4x3\";\n  if (type === \"mat4x2\") return \"mat2x4\";\n  if (type === \"mat4x3\") return \"mat3x4\";\n  if (type === \"mat4x4\") return \"mat4x4\";\n  throw new Error(`Invalid transpose type: ${type}`);\n}\nclass Transpose extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"transpose\", outTypeFunc: transposeOutputType });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.transpose} = transpose(${inputs.a});`\n    ];\n  }\n}\nclass Determinant extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"det\", outTypeFunc: (aType) => \"float\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.det} = determinant(${inputs.a});`\n    ];\n  }\n}\nclass Inverse extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"inverse\", outTypeFunc: (aType) => aType });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.inverse} = inverse(${a});`\n    ];\n  }\n}\nfunction splitOutTypes(type) {\n  const result = (value) => value;\n  switch (type) {\n    case \"vec2\":\n      return result({ x: \"float\", y: \"float\", r: \"float\", g: \"float\" });\n    case \"vec3\":\n      return result({\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\"\n      });\n    case \"vec4\":\n      return result({\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        w: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\",\n        a: \"float\"\n      });\n    case \"ivec2\":\n      return result({ x: \"int\", y: \"int\", r: \"int\", g: \"int\" });\n    case \"ivec3\":\n      return result({\n        x: \"int\",\n        y: \"int\",\n        z: \"int\",\n        r: \"int\",\n        g: \"int\",\n        b: \"int\"\n      });\n    case \"ivec4\":\n      return result({\n        x: \"int\",\n        y: \"int\",\n        z: \"int\",\n        w: \"int\",\n        r: \"int\",\n        g: \"int\",\n        b: \"int\",\n        a: \"int\"\n      });\n    case \"uvec2\":\n      return result({ x: \"uint\", y: \"uint\", r: \"uint\", g: \"uint\" });\n    case \"uvec3\":\n      return result({\n        x: \"uint\",\n        y: \"uint\",\n        z: \"uint\",\n        r: \"uint\",\n        g: \"uint\",\n        b: \"uint\"\n      });\n    case \"uvec4\":\n      return result({\n        x: \"uint\",\n        y: \"uint\",\n        z: \"uint\",\n        w: \"uint\",\n        r: \"uint\",\n        g: \"uint\",\n        b: \"uint\",\n        a: \"uint\"\n      });\n    default:\n      throw new Error(`Invalid vector type: ${type}`);\n  }\n}\nclass Split extends Dyno {\n  constructor({ vector }) {\n    const type = valType(vector);\n    const inTypes = { vector: type };\n    const outTypes = splitOutTypes(inTypes.vector);\n    super({ inTypes, outTypes, inputs: { vector } });\n    this.statements = ({ inputs, outputs }) => {\n      const { x, y, z, w, r, g, b, a } = outputs;\n      const { vector: vector2 } = inputs;\n      return [\n        x ? `${x} = ${vector2}.x;` : null,\n        y ? `${y} = ${vector2}.y;` : null,\n        z ? `${z} = ${vector2}.z;` : null,\n        w ? `${w} = ${vector2}.w;` : null,\n        r ? `${r} = ${vector2}.r;` : null,\n        g ? `${g} = ${vector2}.g;` : null,\n        b ? `${b} = ${vector2}.b;` : null,\n        a ? `${a} = ${vector2}.a;` : null\n      ].filter(Boolean);\n    };\n  }\n}\nclass Combine extends Dyno {\n  constructor({\n    vector,\n    vectorType,\n    x,\n    y,\n    z,\n    w,\n    r,\n    g,\n    b,\n    a\n  }) {\n    if (!vector && !vectorType) {\n      throw new Error(\"Either vector or vectorType must be provided\");\n    }\n    const vType = vectorType ?? valType(vector);\n    const elType = vectorElementType(vType);\n    const dim = vectorDim(vType);\n    const inTypes = {\n      vector: vType,\n      x: elType,\n      y: elType,\n      r: elType,\n      g: elType\n    };\n    const inputs = { vector, x, y, r, g };\n    if (dim >= 3) {\n      Object.assign(inTypes, { z: elType, b: elType });\n      Object.assign(inputs, { z, b });\n    }\n    if (dim >= 4) {\n      Object.assign(inTypes, { w: elType, a: elType });\n      Object.assign(inputs, { w, a });\n    }\n    super({ inTypes, outTypes: { vector: vType }, inputs });\n    this.statements = ({ inputs: inputs2, outputs }) => {\n      const { vector: vector2 } = outputs;\n      const {\n        vector: input,\n        x: x2,\n        y: y2,\n        z: z2,\n        w: w2,\n        r: r2,\n        g: g2,\n        b: b22,\n        a: a2\n      } = inputs2;\n      const statements = [\n        `${vector2}.x = ${x2 ?? r2 ?? (input ? `${input}.x` : literalZero(elType))};`,\n        `${vector2}.y = ${y2 ?? g2 ?? (input ? `${input}.y` : literalZero(elType))};`\n      ];\n      if (dim >= 3)\n        statements.push(\n          `${vector2}.z = ${z2 ?? b22 ?? (input ? `${input}.z` : literalZero(elType))};`\n        );\n      if (dim >= 4)\n        statements.push(\n          `${vector2}.w = ${w2 ?? a2 ?? (input ? `${input}.w` : literalZero(elType))};`\n        );\n      return statements;\n    };\n  }\n  dynoOut() {\n    return new DynoOutput(\n      this,\n      \"vector\"\n    );\n  }\n}\nfunction swizzleOutputType(type, swizzle2) {\n  let result = null;\n  if (isFloatType(type)) {\n    result = swizzle2.length === 1 ? \"float\" : swizzle2.length === 2 ? \"vec2\" : swizzle2.length === 3 ? \"vec3\" : swizzle2.length === 4 ? \"vec4\" : null;\n  } else if (isIntType(type)) {\n    result = swizzle2.length === 1 ? \"int\" : swizzle2.length === 2 ? \"ivec2\" : swizzle2.length === 3 ? \"ivec3\" : swizzle2.length === 4 ? \"ivec4\" : null;\n  } else if (isUintType(type)) {\n    result = swizzle2.length === 1 ? \"uint\" : swizzle2.length === 2 ? \"uvec2\" : swizzle2.length === 3 ? \"uvec3\" : swizzle2.length === 4 ? \"uvec4\" : null;\n  }\n  if (result == null) {\n    throw new Error(`Invalid swizzle: ${swizzle2}`);\n  }\n  return result;\n}\nclass Swizzle extends UnaryOp {\n  constructor({ vector, select: select2 }) {\n    super({\n      a: vector,\n      outKey: \"swizzle\",\n      outTypeFunc: (aType) => swizzleOutputType(aType, select2)\n    });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.swizzle} = ${inputs.a}.${select2};`\n    ];\n  }\n}\nconst remapIndex = (index, from, to) => {\n  return new DynoRemapIndex({ index, from, to });\n};\nconst pcgMix = (value) => {\n  return new PcgMix({ value });\n};\nconst pcgNext = (state) => {\n  return new PcgNext({ state });\n};\nconst pcgHash = (state) => {\n  return new PcgHash({ state });\n};\nconst hash = (value) => {\n  return new Hash({ value });\n};\nconst hash2 = (value) => {\n  return new Hash2({ value });\n};\nconst hash3 = (value) => {\n  return new Hash3({ value });\n};\nconst hash4 = (value) => {\n  return new Hash4({ value });\n};\nconst hashFloat = (value) => {\n  return new HashFloat({ value });\n};\nconst hashVec2 = (value) => {\n  return new HashVec2({ value });\n};\nconst hashVec3 = (value) => {\n  return new HashVec3({ value });\n};\nconst hashVec4 = (value) => {\n  return new HashVec4({ value });\n};\nconst normalizedDepth = (z, zNear, zFar) => {\n  return new NormalizedDepth({ z, zNear, zFar }).outputs.depth;\n};\nclass DynoRemapIndex extends Dyno {\n  constructor({\n    from,\n    to,\n    index\n  }) {\n    super({\n      inTypes: { from: \"int\", to: \"int\", index: \"int\" },\n      outTypes: { index: \"int\" },\n      inputs: { from, to, index },\n      statements: ({ inputs, outputs }) => {\n        return [\n          `${outputs.index} = ${inputs.index} - ${inputs.from} + ${inputs.to};`\n        ];\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"index\");\n  }\n}\nclass PcgNext extends Dyno {\n  constructor({ state }) {\n    const type = valType(state);\n    super({\n      inTypes: { state: type },\n      outTypes: { state: \"uint\" },\n      inputs: { state },\n      globals: () => [\n        unindent(`\n          uint pcg_next(uint state) {\n            return state * 747796405u + 2891336453u;\n          }\n        `)\n      ],\n      statements: ({ inputs, outputs }) => {\n        const toUint = type === \"uint\" ? `${inputs.state}` : type === \"int\" ? `uint(${inputs.state})` : `floatBitsToUint(${inputs.state})`;\n        return [`${outputs.state} = pcg_next(${toUint});`];\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"state\");\n  }\n}\nclass PcgHash extends Dyno {\n  constructor({ state }) {\n    super({\n      inTypes: { state: \"uint\" },\n      outTypes: { hash: \"uint\" },\n      inputs: { state },\n      globals: () => [\n        unindent(`\n          uint pcg_hash(uint state) {\n            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n            return (hash >> 22u) ^ hash;\n          }\n        `)\n      ],\n      statements: ({ inputs, outputs }) => [\n        `${outputs.hash} = pcg_hash(${inputs.state});`\n      ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass PcgMix extends Dyno {\n  constructor({ value }) {\n    const type = valType(value);\n    const tempType = sameSizeUvec(type);\n    super({\n      inTypes: { value: type },\n      outTypes: { state: \"uint\" },\n      inputs: { value },\n      globals: () => [\n        unindent(`\n          uint pcg_mix(uint value) {\n            return value;\n          }\n          uint pcg_mix(uvec2 value) {\n            return value.x + 0x9e3779b9u * value.y;\n          }\n          uint pcg_mix(uvec3 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\n          }\n          uint pcg_mix(uvec4 value) {\n            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\n          }\n        `)\n      ],\n      statements: ({ inputs, outputs }) => {\n        const toUvec = isUintType(type) ? `${inputs.value}` : isIntType(type) ? `${tempType}(${inputs.value})` : `floatBitsToUint(${inputs.value})`;\n        return [\n          `${tempType} bits = ${toUvec};`,\n          `${outputs.state} = pcg_mix(bits);`\n        ];\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"state\");\n  }\n}\nclass Hash extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"uint\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        let state = new PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state }).outputs.state;\n        return new PcgHash({ state }).outputs;\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass Hash2 extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"uvec2\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        let state = new PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state }).outputs.state;\n        const x = new PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n        const y = new PcgHash({ state }).outputs.hash;\n        return { hash: combine({ vectorType: \"uvec2\", x, y }) };\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass Hash3 extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"uvec3\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        let state = new PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state }).outputs.state;\n        const x = new PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n        const y = new PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n        const z = new PcgHash({ state }).outputs.hash;\n        return { hash: combine({ vectorType: \"uvec3\", x, y, z }) };\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass Hash4 extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"uvec4\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        let state = new PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state }).outputs.state;\n        const x = new PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n        const y = new PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n        const z = new PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n        const w = new PcgHash({ state }).outputs.hash;\n        return { hash: combine({ vectorType: \"uvec4\", x, y, z, w }) };\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashFloat extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"float\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        const word = hash(value2);\n        return { hash: mul(float(word), dynoConst(\"float\", 1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec2 extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"vec2\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        const words = hash2(value2);\n        return { hash: mul(vec2(words), dynoConst(\"float\", 1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec3 extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"vec3\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        const words = hash3(value2);\n        return { hash: mul(vec3(words), dynoConst(\"float\", 1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec4 extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) },\n      outTypes: { hash: \"vec4\" },\n      inputs: { value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw new Error(\"value is required\");\n        }\n        const words = hash4(value2);\n        return { hash: mul(vec4(words), dynoConst(\"float\", 1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass NormalizedDepth extends Dyno {\n  constructor({\n    z,\n    zNear,\n    zFar\n  }) {\n    super({\n      inTypes: { z: \"float\", zNear: \"float\", zFar: \"float\" },\n      outTypes: { depth: \"float\" },\n      inputs: { z, zNear, zFar },\n      statements: ({ inputs, outputs }) => [\n        `float clamped = clamp(${inputs.z}, ${inputs.zNear}, ${inputs.zFar});`,\n        `${outputs.depth} = (log2(clamped + 1.0) - log2(${inputs.zNear} + 1.0)) / (log2(${inputs.zFar} + 1.0) - log2(${inputs.zNear} + 1.0));`\n      ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"depth\");\n  }\n}\nconst transformPos = (position, {\n  scale,\n  scales,\n  rotate,\n  translate\n}) => {\n  return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;\n};\nconst transformDir = (dir, {\n  scale,\n  scales,\n  rotate\n}) => {\n  return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\n};\nconst transformQuat = (quaternion, { rotate }) => {\n  return new TransformQuaternion({ quaternion, rotate }).outputs.quaternion;\n};\nclass TransformPosition extends Dyno {\n  constructor({\n    position,\n    scale,\n    scales,\n    rotate,\n    translate\n  }) {\n    super({\n      inTypes: {\n        position: \"vec3\",\n        scale: \"float\",\n        scales: \"vec3\",\n        rotate: \"vec4\",\n        translate: \"vec3\"\n      },\n      outTypes: { position: \"vec3\" },\n      inputs: { position, scale, scales, rotate, translate },\n      statements: ({ inputs, outputs }) => {\n        const { position: position2 } = outputs;\n        if (!position2) {\n          return [];\n        }\n        const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;\n        return [\n          `${position2} = ${inputs.position ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          !scale2 ? null : `${position2} *= ${scale2};`,\n          !scales2 ? null : `${position2} *= ${scales2};`,\n          !rotate2 ? null : `${position2} = quatVec(${rotate2}, ${position2});`,\n          !translate2 ? null : `${position2} += ${translate2};`\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nclass TransformDir extends Dyno {\n  constructor({\n    dir,\n    scale,\n    scales,\n    rotate\n  }) {\n    super({\n      inTypes: { dir: \"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\n      outTypes: { dir: \"vec3\" },\n      inputs: { dir, scale, scales, rotate },\n      statements: ({ inputs, outputs }) => {\n        const { dir: dir2 } = outputs;\n        if (!dir2) {\n          return [];\n        }\n        const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n        return [\n          `${dir2} = ${inputs.dir ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          !scale2 ? null : `${dir2} *= ${scale2};`,\n          !scales2 ? null : `${dir2} *= ${scales2};`,\n          !rotate2 ? null : `${dir2} = quatVec(${rotate2}, ${dir2});`\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nclass TransformQuaternion extends Dyno {\n  constructor({\n    quaternion,\n    rotate\n  }) {\n    super({\n      inTypes: { quaternion: \"vec4\", rotate: \"vec4\" },\n      outTypes: { quaternion: \"vec4\" },\n      inputs: { quaternion, rotate },\n      statements: ({ inputs, outputs }) => {\n        const { quaternion: quaternion2 } = outputs;\n        if (!quaternion2) {\n          return [];\n        }\n        return [\n          `${quaternion2} = ${inputs.quaternion ?? \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\n          !rotate ? null : `${quaternion2} = quatQuat(${inputs.rotate}, ${quaternion2});`\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nconst dynoIf = () => {\n  throw new Error(\"Not implemented\");\n};\nconst dynoSwitch = () => {\n  throw new Error(\"Not implemented\");\n};\nconst dynoFor = () => {\n  throw new Error(\"Not implemented\");\n};\nconst comment = () => {\n  throw new Error(\"Not implemented\");\n};\nconst arrayIndex = () => {\n  throw new Error(\"Not implemented\");\n};\nconst arrayLength = () => {\n  throw new Error(\"Not implemented\");\n};\nconst textureSize = (texture2, lod) => new TextureSize({ texture: texture2, lod });\nconst texture = (texture2, coord, bias) => new Texture({ texture: texture2, coord, bias });\nconst texelFetch = (texture2, coord, lod) => new TexelFetch({ texture: texture2, coord, lod });\nclass TextureSize extends Dyno {\n  constructor({ texture: texture2, lod }) {\n    const textureType = valType(texture2);\n    super({\n      inTypes: { texture: textureType, lod: \"int\" },\n      outTypes: { size: textureSizeType(textureType) },\n      inputs: { texture: texture2, lod },\n      statements: ({ inputs, outputs }) => [\n        `${outputs.size} = textureSize(${inputs.texture}, ${inputs.lod ?? \"0\"});`\n      ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"size\");\n  }\n}\nclass Texture extends Dyno {\n  constructor({\n    texture: texture2,\n    coord,\n    bias\n  }) {\n    const textureType = valType(texture2);\n    super({\n      inTypes: {\n        texture: textureType,\n        coord: textureCoordType(textureType),\n        bias: \"float\"\n      },\n      outTypes: { sample: textureReturnType(textureType) },\n      inputs: { texture: texture2, coord, bias },\n      statements: ({ inputs, outputs }) => [\n        `${outputs.sample} = texture(${inputs.texture}, ${inputs.coord}${inputs.bias ? `, ${inputs.bias}` : \"\"});`\n      ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"sample\");\n  }\n}\nclass TexelFetch extends Dyno {\n  constructor({\n    texture: texture2,\n    coord,\n    lod\n  }) {\n    const textureType = valType(texture2);\n    super({\n      inTypes: {\n        texture: textureType,\n        coord: textureSizeType(textureType),\n        lod: \"int\"\n      },\n      outTypes: { texel: textureReturnType(textureType) },\n      inputs: { texture: texture2, coord, lod },\n      statements: ({ inputs, outputs }) => [\n        `${outputs.texel} = texelFetch(${inputs.texture}, ${inputs.coord}, ${inputs.lod ?? \"0\"});`\n      ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"texel\");\n  }\n}\nfunction textureSizeType(textureType) {\n  switch (textureType) {\n    case \"sampler2D\":\n    case \"usampler2D\":\n    case \"isampler2D\":\n    case \"samplerCube\":\n    case \"usamplerCube\":\n    case \"isamplerCube\":\n    case \"sampler2DShadow\":\n    case \"samplerCubeShadow\":\n      return \"ivec2\";\n    case \"sampler3D\":\n    case \"usampler3D\":\n    case \"isampler3D\":\n    case \"sampler2DArray\":\n    case \"usampler2DArray\":\n    case \"isampler2DArray\":\n    case \"sampler2DArrayShadow\":\n      return \"ivec3\";\n    default:\n      throw new Error(`Invalid texture type: ${textureType}`);\n  }\n}\nfunction textureCoordType(textureType) {\n  switch (textureType) {\n    case \"sampler2D\":\n    case \"usampler2D\":\n    case \"isampler2D\":\n      return \"vec2\";\n    case \"sampler3D\":\n    case \"usampler3D\":\n    case \"isampler3D\":\n    case \"samplerCube\":\n    case \"usamplerCube\":\n    case \"isamplerCube\":\n    case \"sampler2DArray\":\n    case \"usampler2DArray\":\n    case \"isampler2DArray\":\n    case \"sampler2DShadow\":\n      return \"vec3\";\n    case \"samplerCubeShadow\":\n    case \"sampler2DArrayShadow\":\n      return \"vec4\";\n    default:\n      throw new Error(`Invalid texture type: ${textureType}`);\n  }\n}\nfunction textureReturnType(textureType) {\n  switch (textureType) {\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n    case \"sampler3D\":\n    case \"samplerCube\":\n    case \"sampler2DShadow\":\n      return \"vec4\";\n    case \"usampler2D\":\n    case \"usampler2DArray\":\n    case \"usampler3D\":\n    case \"usamplerCube\":\n      return \"uvec4\";\n    case \"isampler2D\":\n    case \"isampler2DArray\":\n    case \"isampler3D\":\n    case \"isamplerCube\":\n      return \"ivec4\";\n    case \"samplerCubeShadow\":\n    case \"sampler2DArrayShadow\":\n      return \"float\";\n    default:\n      throw new Error(`Invalid texture type: ${textureType}`);\n  }\n}\nconst radians = (degrees2) => new Radians({ degrees: degrees2 });\nconst degrees = (radians2) => new Degrees({ radians: radians2 });\nconst sin = (radians2) => new Sin({ radians: radians2 });\nconst cos = (radians2) => new Cos({ radians: radians2 });\nconst tan = (radians2) => new Tan({ radians: radians2 });\nconst asin = (sin2) => new Asin({ sin: sin2 });\nconst acos = (cos2) => new Acos({ cos: cos2 });\nconst atan = (tan2) => new Atan({ tan: tan2 });\nconst atan2 = (y, x) => new Atan2({ y, x });\nconst sinh = (x) => new Sinh({ x });\nconst cosh = (x) => new Cosh({ x });\nconst tanh = (x) => new Tanh({ x });\nconst asinh = (x) => new Asinh({ x });\nconst acosh = (x) => new Acosh({ x });\nconst atanh = (x) => new Atanh({ x });\nclass Radians extends UnaryOp {\n  constructor({ degrees: degrees2 }) {\n    super({ a: degrees2, outTypeFunc: (aType) => aType, outKey: \"radians\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.radians} = radians(${inputs.a});`\n    ];\n  }\n}\nclass Degrees extends UnaryOp {\n  constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"degrees\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.degrees} = degrees(${inputs.a});`\n    ];\n  }\n}\nclass Sin extends UnaryOp {\n  constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"sin\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.sin} = sin(${inputs.a});`\n    ];\n  }\n}\nclass Cos extends UnaryOp {\n  constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"cos\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.cos} = cos(${inputs.a});`\n    ];\n  }\n}\nclass Tan extends UnaryOp {\n  constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"tan\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.tan} = tan(${inputs.a});`\n    ];\n  }\n}\nclass Asin extends UnaryOp {\n  constructor({ sin: sin2 }) {\n    super({ a: sin2, outTypeFunc: (aType) => aType, outKey: \"asin\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.asin} = asin(${inputs.a});`\n    ];\n  }\n}\nclass Acos extends UnaryOp {\n  constructor({ cos: cos2 }) {\n    super({ a: cos2, outTypeFunc: (aType) => aType, outKey: \"acos\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.acos} = acos(${inputs.a});`\n    ];\n  }\n}\nclass Atan extends UnaryOp {\n  constructor({ tan: tan2 }) {\n    super({ a: tan2, outTypeFunc: (aType) => aType, outKey: \"atan\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.atan} = atan(${inputs.a});`\n    ];\n  }\n}\nclass Atan2 extends BinaryOp {\n  constructor({ y, x }) {\n    super({\n      a: y,\n      b: x,\n      outTypeFunc: (aType, bType) => aType,\n      outKey: \"atan2\"\n    });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.atan2} = atan2(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Sinh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"sinh\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.sinh} = sinh(${inputs.a});`\n    ];\n  }\n}\nclass Cosh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"cosh\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.cosh} = cosh(${inputs.a});`\n    ];\n  }\n}\nclass Tanh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"tanh\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.tanh} = tanh(${inputs.a});`\n    ];\n  }\n}\nclass Asinh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"asinh\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.asinh} = asinh(${inputs.a});`\n    ];\n  }\n}\nclass Acosh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"acosh\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.acosh} = acosh(${inputs.a});`\n    ];\n  }\n}\nclass Atanh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, outKey: \"atanh\" });\n    this.statements = ({ inputs, outputs }) => [\n      `${outputs.atanh} = atanh(${inputs.a});`\n    ];\n  }\n}\nconst dyno = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Abs,\n  Acos,\n  Acosh,\n  Add,\n  All,\n  And,\n  Any,\n  Asin,\n  Asinh,\n  Atan,\n  Atan2,\n  Atanh,\n  BVec2,\n  BVec3,\n  BVec4,\n  BinaryOp,\n  Bool,\n  Ceil,\n  Clamp,\n  Combine,\n  CombineGsplat,\n  CompMult,\n  CompXor,\n  Compilation,\n  Cos,\n  Cosh,\n  Cross,\n  Degrees,\n  Determinant,\n  Distance,\n  Div,\n  Dot,\n  Dyno,\n  DynoBlock,\n  DynoBool,\n  DynoBvec2,\n  DynoBvec3,\n  DynoBvec4,\n  DynoConst,\n  DynoFloat,\n  DynoInt,\n  DynoIsampler2D,\n  DynoIsampler2DArray,\n  DynoIsampler3D,\n  DynoIsamplerCube,\n  DynoIvec2,\n  DynoIvec3,\n  DynoIvec4,\n  DynoLiteral,\n  DynoMat2,\n  DynoMat2x2,\n  DynoMat2x3,\n  DynoMat2x4,\n  DynoMat3,\n  DynoMat3x2,\n  DynoMat3x3,\n  DynoMat3x4,\n  DynoMat4,\n  DynoMat4x2,\n  DynoMat4x3,\n  DynoMat4x4,\n  DynoOutput,\n  DynoProgram,\n  DynoProgramTemplate,\n  DynoRemapIndex,\n  DynoSampler2D,\n  DynoSampler2DArray,\n  DynoSampler2DArrayShadow,\n  DynoSampler2DShadow,\n  DynoSampler3D,\n  DynoSamplerCube,\n  DynoSamplerCubeShadow,\n  DynoUint,\n  DynoUniform,\n  DynoUsampler2D,\n  DynoUsampler2DArray,\n  DynoUsampler3D,\n  DynoUsamplerCube,\n  DynoUvec2,\n  DynoUvec3,\n  DynoUvec4,\n  DynoValue,\n  DynoVec2,\n  DynoVec3,\n  DynoVec4,\n  Equal,\n  Exp,\n  Exp2,\n  ExtendVec,\n  FaceForward,\n  Float,\n  FloatBitsToInt,\n  FloatBitsToUint,\n  Floor,\n  Fract,\n  GreaterThan,\n  GreaterThanEqual,\n  Gsplat,\n  GsplatNormal,\n  Hash,\n  Hash2,\n  Hash3,\n  Hash4,\n  HashFloat,\n  HashVec2,\n  HashVec3,\n  HashVec4,\n  IMod,\n  IVec2,\n  IVec3,\n  IVec4,\n  Int,\n  IntBitsToFloat,\n  Inverse,\n  InverseSqrt,\n  IsInf,\n  IsNan,\n  Length,\n  LessThan,\n  LessThanEqual,\n  Log,\n  Log2,\n  Mat2,\n  Mat3,\n  Mat4,\n  Max,\n  Min,\n  Mix,\n  Mod,\n  Modf,\n  Mul,\n  Neg,\n  Normalize,\n  NormalizedDepth,\n  Not,\n  NotEqual,\n  NumPackedSplats,\n  Or,\n  Outer,\n  OutputPackedSplat,\n  OutputRgba8,\n  PackHalf2x16,\n  PackSnorm2x16,\n  PackUnorm2x16,\n  PcgHash,\n  PcgMix,\n  PcgNext,\n  Pow,\n  ProjectH,\n  Radians,\n  ReadPackedSplat,\n  ReadPackedSplatRange,\n  ReflectVec,\n  RefractVec,\n  Round,\n  Select,\n  Sign,\n  SimpleCast,\n  Sin,\n  Sinh,\n  Smoothstep,\n  Split,\n  SplitGsplat,\n  Sqr,\n  Sqrt,\n  Step,\n  Sub,\n  Swizzle,\n  TPackedSplats,\n  Tan,\n  Tanh,\n  TexelFetch,\n  Texture,\n  TextureSize,\n  TransformDir,\n  TransformGsplat,\n  TransformPosition,\n  TransformQuaternion,\n  Transpose,\n  TrinaryOp,\n  Trunc,\n  UVec2,\n  UVec3,\n  UVec4,\n  Uint,\n  UintBitsToFloat,\n  UintToRgba8,\n  UnaryOp,\n  UnpackHalf2x16,\n  UnpackSnorm2x16,\n  UnpackUnorm2x16,\n  Vec2,\n  Vec3,\n  Vec4,\n  Xor,\n  abs,\n  acos,\n  acosh,\n  add,\n  all,\n  and,\n  any,\n  arrayIndex,\n  arrayLength,\n  asin,\n  asinh,\n  atan,\n  atan2,\n  atanh,\n  bool,\n  bvec2,\n  bvec3,\n  bvec4,\n  ceil,\n  clamp,\n  combine,\n  combineGsplat,\n  comment,\n  compMult,\n  compXor,\n  cos,\n  cosh,\n  cross,\n  defineGsplat,\n  defineGsplatNormal,\n  definePackedSplats,\n  degrees,\n  determinant,\n  distance,\n  div,\n  dot,\n  dyno: dyno$1,\n  dynoBlock,\n  dynoBool,\n  dynoBvec2,\n  dynoBvec3,\n  dynoBvec4,\n  dynoConst,\n  dynoDeclare,\n  dynoFloat,\n  dynoFor,\n  dynoIf,\n  dynoInt,\n  dynoIsampler2D,\n  dynoIsampler2DArray,\n  dynoIsampler3D,\n  dynoIsamplerCube,\n  dynoIvec2,\n  dynoIvec3,\n  dynoIvec4,\n  dynoLiteral,\n  dynoMat2,\n  dynoMat2x2,\n  dynoMat2x3,\n  dynoMat2x4,\n  dynoMat3,\n  dynoMat3x2,\n  dynoMat3x3,\n  dynoMat3x4,\n  dynoMat4,\n  dynoMat4x2,\n  dynoMat4x3,\n  dynoMat4x4,\n  dynoSampler2D,\n  dynoSampler2DArray,\n  dynoSampler2DArrayShadow,\n  dynoSampler2DShadow,\n  dynoSampler3D,\n  dynoSamplerCube,\n  dynoSamplerCubeShadow,\n  dynoSwitch,\n  dynoUint,\n  dynoUsampler2D,\n  dynoUsampler2DArray,\n  dynoUsampler3D,\n  dynoUsamplerCube,\n  dynoUvec2,\n  dynoUvec3,\n  dynoUvec4,\n  dynoVec2,\n  dynoVec3,\n  dynoVec4,\n  equal,\n  exp,\n  exp2,\n  extendVec,\n  faceforward,\n  float,\n  floatBitsToInt,\n  floatBitsToUint,\n  floor,\n  fract,\n  greaterThan,\n  greaterThanEqual,\n  gsplatNormal,\n  hash,\n  hash2,\n  hash3,\n  hash4,\n  hashFloat,\n  hashVec2,\n  hashVec3,\n  hashVec4,\n  imod,\n  int,\n  intBitsToFloat,\n  inverse,\n  inversesqrt,\n  isAllFloatType,\n  isBoolType,\n  isFloatType,\n  isInf,\n  isIntType,\n  isMat2,\n  isMat3,\n  isMat4,\n  isMatFloatType,\n  isNan,\n  isScalarType,\n  isUintType,\n  isVector2Type,\n  isVector3Type,\n  isVector4Type,\n  isVectorType,\n  ivec2,\n  ivec3,\n  ivec4,\n  length,\n  lessThan,\n  lessThanEqual,\n  literalNegOne,\n  literalOne,\n  literalZero,\n  log,\n  log2,\n  mat2,\n  mat3,\n  mat4,\n  max,\n  min,\n  mix,\n  mod,\n  modf,\n  mul,\n  neg,\n  normalize,\n  normalizedDepth,\n  not,\n  notEqual,\n  numPackedSplats,\n  numberAsFloat,\n  numberAsInt,\n  numberAsUint,\n  or,\n  outer,\n  outputPackedSplat,\n  outputRgba8,\n  packHalf2x16,\n  packSnorm2x16,\n  packUnorm2x16,\n  pcgHash,\n  pcgMix,\n  pcgNext,\n  pow,\n  projectH,\n  radians,\n  readPackedSplat,\n  readPackedSplatRange,\n  reflectVec,\n  refractVec,\n  remapIndex,\n  round,\n  sameSizeIvec,\n  sameSizeUvec,\n  sameSizeVec,\n  select,\n  sign,\n  sin,\n  sinh,\n  smoothstep,\n  split,\n  splitGsplat,\n  sqr,\n  sqrt,\n  step,\n  sub,\n  swizzle,\n  tan,\n  tanh,\n  texelFetch,\n  texture,\n  textureSize,\n  transformDir,\n  transformGsplat,\n  transformPos,\n  transformQuat,\n  transpose,\n  trunc,\n  typeLiteral,\n  uint,\n  uintBitsToFloat,\n  uintToRgba8,\n  uniform,\n  unindent,\n  unindentLines,\n  unpackHalf2x16,\n  unpackSnorm2x16,\n  unpackUnorm2x16,\n  uvec2,\n  uvec3,\n  uvec4,\n  valType,\n  vec2,\n  vec3,\n  vec4,\n  vectorDim,\n  vectorElementType,\n  xor\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar computeVec4_default = \"precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}\";\nconst _Readback = class _Readback {\n  constructor({ renderer } = {}) {\n    this.renderer = renderer;\n    this.capacity = 0;\n    this.count = 0;\n  }\n  dispose() {\n    if (this.target) {\n      this.target.dispose();\n      this.target = void 0;\n    }\n  }\n  // Ensure we have a buffer large enough for the readback of count indices.\n  // Pass in previous bufer of the desired type.\n  ensureBuffer(count, buffer) {\n    const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n    const bytes = roundedCount * 4;\n    if (buffer.byteLength >= bytes) {\n      return buffer;\n    }\n    const newBuffer = new ArrayBuffer(bytes);\n    if (buffer instanceof ArrayBuffer) {\n      return newBuffer;\n    }\n    const ctor = buffer.constructor;\n    return new ctor(newBuffer);\n  }\n  // Ensure our render target is large enough for the readback of capacity indices.\n  ensureCapacity(capacity) {\n    const { width, height, depth, maxSplats } = getTextureSize(capacity);\n    if (!this.target || maxSplats > this.capacity) {\n      this.dispose();\n      this.capacity = maxSplats;\n      this.target = new THREE.WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n        magFilter: THREE.NearestFilter,\n        minFilter: THREE.NearestFilter\n      });\n      this.target.texture.format = THREE.RGBAFormat;\n      this.target.texture.type = THREE.UnsignedByteType;\n      this.target.texture.internalFormat = \"RGBA8\";\n      this.target.scissorTest = true;\n    }\n  }\n  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n  // generating it if necessary and caching the result.\n  prepareProgramMaterial(reader) {\n    let program = _Readback.readbackProgram.get(reader);\n    if (!program) {\n      const graph = dynoBlock(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          reader.inputs.index = index;\n          const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\n          return { rgba8 };\n        }\n      );\n      if (!_Readback.programTemplate) {\n        _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);\n      }\n      program = new DynoProgram({\n        graph,\n        inputs: { index: \"index\" },\n        outputs: { rgba8: \"target\" },\n        template: _Readback.programTemplate\n      });\n      Object.assign(program.uniforms, {\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      });\n      _Readback.readbackProgram.set(reader, program);\n    }\n    const material = program.prepareMaterial();\n    _Readback.fullScreenQuad.material = material;\n    return { program, material };\n  }\n  saveRenderState(renderer) {\n    return {\n      xrEnabled: renderer.xr.enabled,\n      autoClear: renderer.autoClear\n    };\n  }\n  resetRenderState(renderer, state) {\n    renderer.setRenderTarget(null);\n    renderer.xr.enabled = state.xrEnabled;\n    renderer.autoClear = state.autoClear;\n  }\n  process({\n    count,\n    material\n  }) {\n    const renderer = this.renderer;\n    if (!renderer) {\n      throw new Error(\"No renderer\");\n    }\n    if (!this.target) {\n      throw new Error(\"No target\");\n    }\n    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n    material.uniforms.targetBase.value = 0;\n    material.uniforms.targetCount.value = count;\n    let baseIndex = 0;\n    while (baseIndex < count) {\n      const layer = Math.floor(baseIndex / layerSize);\n      const layerBase = layer * layerSize;\n      const layerYEnd = Math.min(\n        SPLAT_TEX_HEIGHT,\n        Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)\n      );\n      material.uniforms.targetLayer.value = layer;\n      this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n      renderer.setRenderTarget(this.target, layer);\n      renderer.xr.enabled = false;\n      renderer.autoClear = false;\n      _Readback.fullScreenQuad.render(renderer);\n      baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n    }\n    this.count = count;\n  }\n  async read({\n    readback\n  }) {\n    const renderer = this.renderer;\n    if (!renderer) {\n      throw new Error(\"No renderer\");\n    }\n    if (!this.target) {\n      throw new Error(\"No target\");\n    }\n    const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n    if (readback.byteLength < roundedCount * 4) {\n      throw new Error(\n        `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`\n      );\n    }\n    const readbackUint8 = new Uint8Array(\n      readback instanceof ArrayBuffer ? readback : readback.buffer\n    );\n    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n    let baseIndex = 0;\n    const promises = [];\n    while (baseIndex < this.count) {\n      const layer = Math.floor(baseIndex / layerSize);\n      const layerBase = layer * layerSize;\n      const layerYEnd = Math.min(\n        SPLAT_TEX_HEIGHT,\n        Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n      );\n      renderer.setRenderTarget(this.target, layer);\n      const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\n      const subReadback = readbackUint8.subarray(\n        layerBase * 4,\n        layerBase * 4 + readbackSize\n      );\n      const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(\n        this.target,\n        0,\n        0,\n        SPLAT_TEX_WIDTH,\n        layerYEnd,\n        subReadback\n      );\n      promises.push(promise);\n      baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n    }\n    return Promise.all(promises).then(() => readback);\n  }\n  // Perform render operation to run the Rgba8Readback program\n  // but don't perform the readback yet.\n  render({\n    reader,\n    count,\n    renderer\n  }) {\n    this.renderer = renderer || this.renderer;\n    if (!this.renderer) {\n      throw new Error(\"No renderer\");\n    }\n    this.ensureCapacity(count);\n    const { program, material } = this.prepareProgramMaterial(reader);\n    program.update();\n    const renderState = this.saveRenderState(this.renderer);\n    this.process({ count, material });\n    this.resetRenderState(this.renderer, renderState);\n  }\n  // Perform a readback of the render target, returning a buffer of the\n  // given type.\n  async readback({\n    readback\n  }) {\n    if (!this.renderer) {\n      throw new Error(\"No renderer\");\n    }\n    const renderState = this.saveRenderState(this.renderer);\n    const promise = this.read({ readback });\n    this.resetRenderState(this.renderer, renderState);\n    return promise;\n  }\n  // Perform a render and readback operation for the given Rgba8Readback,\n  // and readback buffer (call ensureBuffer first).\n  async renderReadback({\n    reader,\n    count,\n    renderer,\n    readback\n  }) {\n    this.renderer = renderer || this.renderer;\n    if (!this.renderer) {\n      throw new Error(\"No renderer\");\n    }\n    this.ensureCapacity(count);\n    const { program, material } = this.prepareProgramMaterial(reader);\n    program.update();\n    const renderState = this.saveRenderState(this.renderer);\n    this.process({ count, material });\n    const promise = this.read({ readback });\n    this.resetRenderState(this.renderer, renderState);\n    return promise;\n  }\n  getTexture() {\n    var _a2;\n    return (_a2 = this.target) == null ? void 0 : _a2.texture;\n  }\n};\n_Readback.programTemplate = null;\n_Readback.readbackProgram = /* @__PURE__ */ new Map();\n_Readback.fullScreenQuad = new FullScreenQuad(\n  new THREE.RawShaderMaterial({ visible: false })\n);\nlet Readback = _Readback;\nconst _RgbaArray = class _RgbaArray {\n  constructor(options = {}) {\n    this.capacity = 0;\n    this.count = 0;\n    this.array = null;\n    this.readback = null;\n    this.source = null;\n    this.needsUpdate = true;\n    this.dyno = new DynoUniform({\n      key: \"rgbaArray\",\n      type: TRgbaArray,\n      globals: () => [defineRgbaArray],\n      value: {\n        texture: _RgbaArray.getEmpty(),\n        count: 0\n      },\n      update: (value) => {\n        var _a2;\n        value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();\n        value.count = this.count;\n        return value;\n      }\n    });\n    if (options.array) {\n      this.array = options.array;\n      this.capacity = Math.floor(this.array.length / 4);\n      this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      this.count = Math.min(\n        this.capacity,\n        options.count ?? Number.POSITIVE_INFINITY\n      );\n    } else {\n      this.capacity = options.capacity ?? 0;\n      this.count = 0;\n    }\n  }\n  // Free up resources\n  dispose() {\n    if (this.readback) {\n      this.readback.dispose();\n      this.readback = null;\n    }\n    if (this.source) {\n      this.source.dispose();\n      this.source = null;\n    }\n  }\n  // Ensure that our array is large enough to hold capacity RGBA8 values.\n  ensureCapacity(capacity) {\n    var _a2;\n    if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n      this.capacity = getTextureSize(capacity).maxSplats;\n      const newArray2 = new Uint8Array(this.capacity * 4);\n      if (this.array) {\n        newArray2.set(this.array);\n      }\n      this.array = newArray2;\n    }\n    return this.array;\n  }\n  // Get the THREE.DataArrayTexture from either the readback or the source.\n  getTexture() {\n    var _a2;\n    let texture2 = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n    if (this.source || this.array) {\n      texture2 = this.maybeUpdateSource();\n    }\n    return texture2 ?? _RgbaArray.getEmpty();\n  }\n  // Create or get a THREE.DataArrayTexture from the data array.\n  maybeUpdateSource() {\n    if (!this.array) {\n      throw new Error(\"No array\");\n    }\n    if (this.needsUpdate || !this.source) {\n      this.needsUpdate = false;\n      if (this.source) {\n        const { width, height, depth } = this.source.image;\n        if (this.capacity !== width * height * depth) {\n          this.source.dispose();\n          this.source = null;\n        }\n      }\n      if (!this.source) {\n        const { width, height, depth } = getTextureSize(this.capacity);\n        this.source = new THREE.DataArrayTexture(\n          this.array,\n          width,\n          height,\n          depth\n        );\n        this.source.format = THREE.RGBAFormat;\n        this.source.type = THREE.UnsignedByteType;\n        this.source.internalFormat = \"RGBA8\";\n        this.source.needsUpdate = true;\n      } else if (this.array.buffer !== this.source.image.data.buffer) {\n        this.source.image.data = new Uint8Array(this.array.buffer);\n      }\n      this.source.needsUpdate = true;\n    }\n    return this.source;\n  }\n  // Generate the RGBA8 values from a Rgba8Readback dyno program.\n  render({\n    reader,\n    count,\n    renderer\n  }) {\n    if (!this.readback) {\n      this.readback = new Readback({ renderer });\n    }\n    this.readback.render({ reader, count, renderer });\n    this.capacity = this.readback.capacity;\n    this.count = this.readback.count;\n  }\n  // Extract the RGBA8 values from a PackedSplats collection.\n  fromPackedSplats({\n    packedSplats,\n    base,\n    count,\n    renderer\n  }) {\n    const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();\n    dynoSplats.packedSplats = packedSplats;\n    dynoBase.value = base;\n    dynoCount.value = count;\n    this.render({ reader, count, renderer });\n    return this;\n  }\n  // Read back the RGBA8 values from the readback buffer.\n  async read() {\n    if (!this.readback) {\n      throw new Error(\"No readback\");\n    }\n    if (!this.array || this.array.length < this.count * 4) {\n      this.array = new Uint8Array(this.capacity * 4);\n    }\n    const result = await this.readback.readback({ readback: this.array });\n    return result.subarray(0, this.count * 4);\n  }\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update with the result of this.getTexture() later.\n  static getEmpty() {\n    if (!_RgbaArray.emptySource) {\n      const emptyArray = new Uint8Array(1 * 4);\n      _RgbaArray.emptySource = new THREE.DataArrayTexture(emptyArray, 1, 1, 1);\n      _RgbaArray.emptySource.format = THREE.RGBAFormat;\n      _RgbaArray.emptySource.type = THREE.UnsignedByteType;\n      _RgbaArray.emptySource.internalFormat = \"RGBA8\";\n      _RgbaArray.emptySource.needsUpdate = true;\n    }\n    return _RgbaArray.emptySource;\n  }\n  // Create a dyno program that can extract RGBA8 values from a PackedSplats\n  static makeDynos() {\n    if (!_RgbaArray.dynos) {\n      const dynoSplats = new DynoPackedSplats();\n      const dynoBase = new DynoInt({ value: 0 });\n      const dynoCount = new DynoInt({ value: 0 });\n      const reader = dynoBlock(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          if (!index) {\n            throw new Error(\"index is undefined\");\n          }\n          index = add(index, dynoBase);\n          const gsplat = readPackedSplatRange(\n            dynoSplats,\n            index,\n            dynoBase,\n            dynoCount\n          );\n          return { rgba8: splitGsplat(gsplat).outputs.rgba };\n        }\n      );\n      _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n    }\n    return _RgbaArray.dynos;\n  }\n};\n_RgbaArray.emptySource = null;\n_RgbaArray.dynos = null;\nlet RgbaArray = _RgbaArray;\nconst TRgbaArray = { type: \"RgbaArray\" };\nconst defineRgbaArray = unindent(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);\nfunction readRgbaArray(rgba, index) {\n  const dyno2 = new Dyno({\n    inTypes: { rgba: TRgbaArray, index: \"int\" },\n    outTypes: { rgba: \"vec4\" },\n    inputs: { rgba, index },\n    globals: () => [defineRgbaArray],\n    statements: ({ inputs, outputs }) => unindentLines(`\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) {\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n  });\n  return dyno2.outputs.rgba;\n}\nvar SplatEditSdfType = /* @__PURE__ */ ((SplatEditSdfType2) => {\n  SplatEditSdfType2[\"ALL\"] = \"all\";\n  SplatEditSdfType2[\"PLANE\"] = \"plane\";\n  SplatEditSdfType2[\"SPHERE\"] = \"sphere\";\n  SplatEditSdfType2[\"BOX\"] = \"box\";\n  SplatEditSdfType2[\"ELLIPSOID\"] = \"ellipsoid\";\n  SplatEditSdfType2[\"CYLINDER\"] = \"cylinder\";\n  SplatEditSdfType2[\"CAPSULE\"] = \"capsule\";\n  SplatEditSdfType2[\"INFINITE_CONE\"] = \"infinite_cone\";\n  return SplatEditSdfType2;\n})(SplatEditSdfType || {});\nfunction sdfTypeToNumber(type) {\n  switch (type) {\n    case \"all\":\n      return 0;\n    case \"plane\":\n      return 1;\n    case \"sphere\":\n      return 2;\n    case \"box\":\n      return 3;\n    case \"ellipsoid\":\n      return 4;\n    case \"cylinder\":\n      return 5;\n    case \"capsule\":\n      return 6;\n    case \"infinite_cone\":\n      return 7;\n    default:\n      throw new Error(`Unknown SDF type: ${type}`);\n  }\n}\nvar SplatEditRgbaBlendMode = /* @__PURE__ */ ((SplatEditRgbaBlendMode2) => {\n  SplatEditRgbaBlendMode2[\"MULTIPLY\"] = \"multiply\";\n  SplatEditRgbaBlendMode2[\"SET_RGB\"] = \"set_rgb\";\n  SplatEditRgbaBlendMode2[\"ADD_RGBA\"] = \"add_rgba\";\n  return SplatEditRgbaBlendMode2;\n})(SplatEditRgbaBlendMode || {});\nfunction rgbaBlendModeToNumber(mode) {\n  switch (mode) {\n    case \"multiply\":\n      return 0;\n    case \"set_rgb\":\n      return 1;\n    case \"add_rgba\":\n      return 2;\n    default:\n      throw new Error(`Unknown blend mode: ${mode}`);\n  }\n}\nclass SplatEditSdf extends THREE.Object3D {\n  constructor(options = {}) {\n    super();\n    const { type, invert, opacity, color, displace, radius } = options;\n    this.type = type ?? \"sphere\";\n    this.invert = invert ?? false;\n    this.opacity = opacity ?? 1;\n    this.color = color ?? new THREE.Color(1, 1, 1);\n    this.displace = displace ?? new THREE.Vector3(0, 0, 0);\n    this.radius = radius ?? 0;\n  }\n}\nconst _SplatEdit = class _SplatEdit extends THREE.Object3D {\n  constructor(options = {}) {\n    const {\n      name,\n      rgbaBlendMode = \"multiply\",\n      sdfSmooth = 0,\n      softEdge = 0,\n      invert = false,\n      sdfs = null\n    } = options;\n    super();\n    this.rgbaBlendMode = rgbaBlendMode;\n    this.sdfSmooth = sdfSmooth;\n    this.softEdge = softEdge;\n    this.invert = invert;\n    this.sdfs = sdfs;\n    this.ordering = _SplatEdit.nextOrdering++;\n    this.name = name ?? `Edit ${this.ordering}`;\n  }\n  addSdf(sdf) {\n    if (this.sdfs == null) {\n      this.sdfs = [];\n    }\n    if (!this.sdfs.includes(sdf)) {\n      this.sdfs.push(sdf);\n    }\n  }\n  removeSdf(sdf) {\n    if (this.sdfs == null) {\n      return;\n    }\n    this.sdfs = this.sdfs.filter((s) => s !== sdf);\n  }\n};\n_SplatEdit.nextOrdering = 1;\nlet SplatEdit = _SplatEdit;\nclass SplatEdits {\n  constructor({ maxSdfs, maxEdits }) {\n    this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n    this.numSdfs = 0;\n    this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n    this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n    this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n    this.dynoSdfArray = new DynoUniform({\n      key: \"sdfArray\",\n      type: SdfArray,\n      globals: () => [defineSdfArray],\n      value: {\n        numSdfs: 0,\n        sdfTexture: this.sdfTexture\n      },\n      update: (uniform2) => {\n        uniform2.numSdfs = this.numSdfs;\n        uniform2.sdfTexture = this.sdfTexture;\n        return uniform2;\n      }\n    });\n    this.maxEdits = Math.max(16, maxEdits ?? 0);\n    this.numEdits = 0;\n    this.editData = new Uint32Array(this.maxEdits * 4);\n    this.editFloatData = new Float32Array(this.editData.buffer);\n    this.dynoNumEdits = new DynoInt({ value: 0 });\n    this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n  }\n  newSdfTexture(data, maxSdfs) {\n    const texture2 = new THREE.DataTexture(\n      data,\n      8,\n      maxSdfs,\n      THREE.RGBAIntegerFormat,\n      THREE.UnsignedIntType\n    );\n    texture2.internalFormat = \"RGBA32UI\";\n    texture2.needsUpdate = true;\n    return texture2;\n  }\n  newEdits(data, maxEdits) {\n    return new DynoUniform({\n      key: \"edits\",\n      type: \"uvec4\",\n      count: maxEdits,\n      globals: () => [defineEdit],\n      value: data\n    });\n  }\n  // Ensure our SDF texture and edits uniform array have enough capacity.\n  // Reallocate if not.\n  ensureCapacity({\n    maxSdfs,\n    maxEdits\n  }) {\n    let dynoUpdated = false;\n    if (maxSdfs > this.sdfTexture.image.height) {\n      this.sdfTexture.dispose();\n      this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n    }\n    if (maxEdits > (this.dynoEdits.count ?? 0)) {\n      this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\n      this.editData = new Uint32Array(this.maxEdits * 4);\n      this.editFloatData = new Float32Array(this.editData.buffer);\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n      dynoUpdated = true;\n    }\n    return dynoUpdated;\n  }\n  updateEditData(offset, value) {\n    const updated = this.editData[offset] !== value;\n    this.editData[offset] = value;\n    return updated;\n  }\n  updateEditFloatData(offset, value) {\n    tempFloat32[0] = value;\n    const updated = this.editFloatData[offset] !== tempFloat32[0];\n    if (updated) {\n      this.editFloatData[offset] = tempFloat32[0];\n    }\n    return updated;\n  }\n  encodeEdit(editIndex, {\n    sdfFirst,\n    sdfCount,\n    invert,\n    rgbaBlendMode,\n    softEdge,\n    sdfSmooth\n  }) {\n    const base = editIndex * 4;\n    let updated = false;\n    updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;\n    updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;\n    updated = this.updateEditFloatData(base + 2, softEdge) || updated;\n    updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\n    return updated;\n  }\n  updateSdfData(offset, value) {\n    const updated = this.sdfData[offset] !== value;\n    this.sdfData[offset] = value;\n    return updated;\n  }\n  updateSdfFloatData(offset, value) {\n    tempFloat32[0] = value;\n    const updated = this.sdfFloatData[offset] !== tempFloat32[0];\n    if (updated) {\n      this.sdfFloatData[offset] = tempFloat32[0];\n    }\n    return updated;\n  }\n  encodeSdf(sdfIndex, {\n    sdfType,\n    invert,\n    center,\n    quaternion,\n    scale,\n    sizes\n  }, values) {\n    const base = sdfIndex * (8 * 4);\n    const flags = sdfType | (invert ? 1 << 8 : 0);\n    let updated = false;\n    updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;\n    updated = this.updateSdfData(base + 3, flags) || updated;\n    updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;\n    updated = this.updateSdfData(base + 11, 0) || updated;\n    updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;\n    const nValues = Math.min(4, values.length);\n    for (let i = 0; i < nValues; ++i) {\n      const vBase = base + 16 + i * 4;\n      updated = this.updateSdfFloatData(vBase + 0, values[i].x) || updated;\n      updated = this.updateSdfFloatData(vBase + 1, values[i].y) || updated;\n      updated = this.updateSdfFloatData(vBase + 2, values[i].z) || updated;\n      updated = this.updateSdfFloatData(vBase + 3, values[i].w) || updated;\n    }\n    return updated;\n  }\n  // Update the SDFs and edits from an array of SplatEdits and their\n  // associated SplatEditSdfs, updating it for the dyno shader program.\n  update(edits) {\n    const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\n    const dynoUpdated = this.ensureCapacity({\n      maxEdits: edits.length,\n      maxSdfs: sdfCount\n    });\n    const values = [new THREE.Vector4(), new THREE.Vector4()];\n    const center = new THREE.Vector3();\n    const quaternion = new THREE.Quaternion();\n    const scale = new THREE.Vector3();\n    const sizes = new THREE.Vector4();\n    let sdfIndex = 0;\n    let updated = dynoUpdated;\n    if (edits.length !== this.dynoNumEdits.value) {\n      this.dynoNumEdits.value = edits.length;\n      this.numEdits = edits.length;\n      updated = true;\n    }\n    for (const [editIndex, { edit, sdfs }] of edits.entries()) {\n      updated = this.encodeEdit(editIndex, {\n        sdfFirst: sdfIndex,\n        sdfCount: sdfs.length,\n        invert: edit.invert,\n        rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\n        softEdge: edit.softEdge,\n        sdfSmooth: edit.sdfSmooth\n      }) || updated;\n      let sdfUpdated = false;\n      for (const sdf of sdfs) {\n        sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n        sdf.scale.setScalar(1);\n        sdf.updateMatrixWorld();\n        const worldToSdf = sdf.matrixWorld.clone().invert();\n        worldToSdf.decompose(center, quaternion, scale);\n        sdf.scale.set(sizes.x, sizes.y, sizes.z);\n        sdf.updateMatrixWorld();\n        values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n        values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n        sdfUpdated = this.encodeSdf(\n          sdfIndex,\n          {\n            sdfType: sdfTypeToNumber(sdf.type),\n            invert: sdf.invert,\n            center,\n            quaternion,\n            scale,\n            sizes\n          },\n          values\n        ) || sdfUpdated;\n        sdfIndex += 1;\n      }\n      this.numSdfs = sdfIndex;\n      if (sdfUpdated) {\n        this.sdfTexture.needsUpdate = true;\n      }\n      updated || (updated = sdfUpdated);\n    }\n    return { updated, dynoUpdated };\n  }\n  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n  modify(gsplat) {\n    return applyGsplatRgbaDisplaceEdits(\n      gsplat,\n      this.dynoSdfArray,\n      this.dynoNumEdits,\n      this.dynoEdits\n    );\n  }\n}\nconst SdfArray = { type: \"SdfArray\" };\nconst defineSdfArray = unindent(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`);\nconst defineEdit = unindent(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);\nfunction applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {\n  const dyno2 = new Dyno({\n    inTypes: {\n      gsplat: Gsplat,\n      sdfArray: SdfArray,\n      numEdits: \"int\",\n      rgbaDisplaceEdits: \"uvec4\"\n    },\n    outTypes: { gsplat: Gsplat },\n    globals: () => [defineSdfArray, defineEdit],\n    inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\n    statements: ({ inputs, outputs }) => {\n      const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n      const { gsplat: gsplat2 } = outputs;\n      return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${rgbaDisplaceEdits2}[editIndex], ${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,\n              ${gsplat2}.center, ${gsplat2}.rgba\n            );\n          }\n        }\n      `);\n    }\n  });\n  return dyno2.outputs.gsplat;\n}\nconst tempFloat32 = new Float32Array(1);\nclass SplatModifier {\n  constructor(modifier) {\n    this.modifier = modifier;\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  apply(generator) {\n    let modified = this.cache.get(generator);\n    if (!modified) {\n      modified = dynoBlock(\n        { index: \"int\" },\n        { gsplat: Gsplat },\n        ({ index }) => {\n          const { gsplat } = generator.apply({ index });\n          return this.modifier.apply({ gsplat });\n        }\n      );\n      this.cache.set(generator, modified);\n    }\n    return modified;\n  }\n}\nclass SplatTransformer {\n  // Create the dyno uniforms that parameterize the transform, setting them\n  // to initial values that are different from any valid transform.\n  constructor() {\n    this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n    this.rotate = new DynoVec4({\n      value: new THREE.Quaternion(\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    });\n    this.translate = new DynoVec3({\n      value: new THREE.Vector3(\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    });\n  }\n  // Apply the transform to a Vec3 position in a dyno program.\n  apply(position) {\n    return transformPos(position, {\n      scale: this.scale,\n      rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  applyDir(dir) {\n    return transformDir(dir, {\n      rotate: this.rotate\n    });\n  }\n  // Apply the transform to a Gsplat in a dyno program.\n  applyGsplat(gsplat) {\n    return transformGsplat(gsplat, {\n      scale: this.scale,\n      rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  // Update the uniforms to match the given transform matrix.\n  updateFromMatrix(transform) {\n    const scale = new THREE.Vector3();\n    const quaternion = new THREE.Quaternion();\n    const position = new THREE.Vector3();\n    transform.decompose(position, quaternion, scale);\n    const newScale = (scale.x + scale.y + scale.z) / 3;\n    let updated = false;\n    if (newScale !== this.scale.value) {\n      this.scale.value = newScale;\n      updated = true;\n    }\n    if (!position.equals(this.translate.value)) {\n      this.translate.value.copy(position);\n      updated = true;\n    }\n    if (!quaternion.equals(this.rotate.value)) {\n      this.rotate.value.copy(quaternion);\n      updated = true;\n    }\n    return updated;\n  }\n  // Update this transform to match the object's to-world transform.\n  update(object) {\n    object.updateMatrixWorld();\n    return this.updateFromMatrix(object.matrixWorld);\n  }\n}\nclass SplatGenerator extends THREE.Object3D {\n  constructor({\n    numSplats,\n    generator,\n    construct,\n    update\n  }) {\n    super();\n    this.numSplats = numSplats ?? 0;\n    this.generator = generator;\n    this.frameUpdate = update;\n    this.version = 0;\n    if (construct) {\n      const constructed = construct(this);\n      Object.assign(this, constructed);\n    }\n  }\n  updateVersion() {\n    this.version += 1;\n  }\n  set needsUpdate(value) {\n    if (value) {\n      this.updateVersion();\n    }\n  }\n}\nconst _SplatMesh = class _SplatMesh extends SplatGenerator {\n  constructor(options = {}) {\n    const transform = new SplatTransformer();\n    const viewToWorld = new SplatTransformer();\n    const worldToView = new SplatTransformer();\n    const viewToObject = new SplatTransformer();\n    const recolor = new DynoVec4({\n      value: new THREE.Vector4(\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n      )\n    });\n    const time = new DynoFloat({ value: 0 });\n    const deltaTime = new DynoFloat({ value: 0 });\n    const context = {\n      transform,\n      viewToWorld,\n      worldToView,\n      viewToObject,\n      recolor,\n      time,\n      deltaTime\n    };\n    super({\n      update: ({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits })\n    });\n    this.isInitialized = false;\n    this.recolor = new THREE.Color(1, 1, 1);\n    this.opacity = 1;\n    this.enableViewToObject = false;\n    this.enableViewToWorld = false;\n    this.enableWorldToView = false;\n    this.skinning = null;\n    this.edits = null;\n    this.rgbaDisplaceEdits = null;\n    this.splatRgba = null;\n    this.maxSh = 3;\n    this.packedSplats = options.packedSplats ?? new PackedSplats();\n    this.packedSplats.splatEncoding = options.splatEncoding ?? {\n      ...DEFAULT_SPLAT_ENCODING\n    };\n    this.numSplats = this.packedSplats.numSplats;\n    this.editable = options.editable ?? true;\n    this.onFrame = options.onFrame;\n    this.context = context;\n    this.objectModifier = options.objectModifier;\n    this.worldModifier = options.worldModifier;\n    this.updateGenerator();\n    if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {\n      this.initialized = this.asyncInitialize(options).then(async () => {\n        this.updateGenerator();\n        this.isInitialized = true;\n        if (options.onLoad) {\n          const maybePromise = options.onLoad(this);\n          if (maybePromise instanceof Promise) {\n            await maybePromise;\n          }\n        }\n        return this;\n      });\n    } else {\n      this.isInitialized = true;\n      this.initialized = Promise.resolve(this);\n      if (options.onLoad) {\n        const maybePromise = options.onLoad(this);\n        if (maybePromise instanceof Promise) {\n          this.initialized = maybePromise.then(() => this);\n        }\n      }\n    }\n  }\n  async asyncInitialize(options) {\n    const {\n      url,\n      fileBytes,\n      fileType,\n      fileName,\n      maxSplats,\n      constructSplats,\n      splatEncoding\n    } = options;\n    if (url || fileBytes || constructSplats) {\n      const packedSplatsOptions = {\n        url,\n        fileBytes,\n        fileType,\n        fileName,\n        maxSplats,\n        construct: constructSplats,\n        splatEncoding\n      };\n      this.packedSplats.reinitialize(packedSplatsOptions);\n    }\n    if (this.packedSplats) {\n      await this.packedSplats.initialized;\n      this.numSplats = this.packedSplats.numSplats;\n      this.updateGenerator();\n    }\n  }\n  static async staticInitialize() {\n    await __wbg_init();\n    _SplatMesh.isStaticInitialized = true;\n  }\n  // Creates a new Gsplat with the provided parameters (all values in \"float\" space,\n  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n  // doubling strategy to fit the new data, so it's fairly efficient to just\n  // pushSplat(...) each Gsplat you want to create in a loop.\n  pushSplat(center, scales, quaternion, opacity, color) {\n    this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\n  }\n  // This method iterates over all Gsplats in this instance's packedSplats,\n  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n  // Note that the objects passed in as center etc. are the same for every callback\n  // invocation: these objects are reused for efficiency. Changing these values has\n  // no effect as they are decoded/unpacked copies of the underlying data. To update\n  // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n  // quaternion, opacity, color).\n  forEachSplat(callback) {\n    this.packedSplats.forEachSplat(callback);\n  }\n  // Call this when you are finished with the SplatMesh and want to free\n  // any buffers it holds (via packedSplats).\n  dispose() {\n    this.packedSplats.dispose();\n  }\n  // Returns axis-aligned bounding box of the SplatMesh. If centers_only is true,\n  // only the centers of the splats are used to compute the bounding box.\n  // IMPORTANT: This should only be called after the SplatMesh is initialized.\n  getBoundingBox(centers_only = true) {\n    if (!this.initialized) {\n      throw new Error(\n        \"Cannot get bounding box before SplatMesh is initialized\"\n      );\n    }\n    const minVec = new THREE.Vector3(\n      Number.POSITIVE_INFINITY,\n      Number.POSITIVE_INFINITY,\n      Number.POSITIVE_INFINITY\n    );\n    const maxVec = new THREE.Vector3(\n      Number.NEGATIVE_INFINITY,\n      Number.NEGATIVE_INFINITY,\n      Number.NEGATIVE_INFINITY\n    );\n    const corners = new THREE.Vector3();\n    const signs = [-1, 1];\n    this.packedSplats.forEachSplat(\n      (_index, center, scales, quaternion, _opacity, _color) => {\n        if (centers_only) {\n          minVec.min(center);\n          maxVec.max(center);\n        } else {\n          for (const x of signs) {\n            for (const y of signs) {\n              for (const z of signs) {\n                corners.set(x * scales.x, y * scales.y, z * scales.z);\n                corners.applyQuaternion(quaternion);\n                corners.add(center);\n                minVec.min(corners);\n                maxVec.max(corners);\n              }\n            }\n          }\n        }\n      }\n    );\n    const box = new THREE.Box3(minVec, maxVec);\n    return box;\n  }\n  constructGenerator(context) {\n    const { transform, viewToObject, recolor } = context;\n    const generator = dynoBlock(\n      { index: \"int\" },\n      { gsplat: Gsplat },\n      ({ index }) => {\n        if (!index) {\n          throw new Error(\"index is undefined\");\n        }\n        let gsplat = readPackedSplat(this.packedSplats.dyno, index);\n        if (this.maxSh >= 1) {\n          const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();\n          if (sh1Texture) {\n            let rescaleSh = function(sNorm, minMax) {\n              const { x: min2, y: max2 } = split(minMax).outputs;\n              const mid = mul(add(min2, max2), dynoConst(\"float\", 0.5));\n              const scale = mul(sub(max2, min2), dynoConst(\"float\", 0.5));\n              return add(mid, mul(sNorm, scale));\n            };\n            const viewCenterInObject = viewToObject.translate;\n            const { center } = splitGsplat(gsplat).outputs;\n            const viewDir = normalize(sub(center, viewCenterInObject));\n            const sh1Snorm = evaluateSH1(gsplat, sh1Texture, viewDir);\n            let rgb = rescaleSh(sh1Snorm, this.packedSplats.dynoSh1MinMax);\n            if (this.maxSh >= 2 && sh2Texture) {\n              const sh2Snorm = evaluateSH2(gsplat, sh2Texture, viewDir);\n              rgb = add(\n                rgb,\n                rescaleSh(sh2Snorm, this.packedSplats.dynoSh2MinMax)\n              );\n            }\n            if (this.maxSh >= 3 && sh3Texture) {\n              const sh3Snorm = evaluateSH3(gsplat, sh3Texture, viewDir);\n              rgb = add(\n                rgb,\n                rescaleSh(sh3Snorm, this.packedSplats.dynoSh3MinMax)\n              );\n            }\n            let { rgba } = splitGsplat(gsplat).outputs;\n            rgba = add(rgba, extendVec(rgb, dynoConst(\"float\", 0)));\n            gsplat = combineGsplat({ gsplat, rgba });\n          }\n        }\n        if (this.splatRgba) {\n          const rgba = readRgbaArray(this.splatRgba.dyno, index);\n          gsplat = combineGsplat({ gsplat, rgba });\n        }\n        if (this.skinning) {\n          gsplat = this.skinning.modify(gsplat);\n        }\n        if (this.objectModifier) {\n          gsplat = this.objectModifier.apply({ gsplat }).gsplat;\n        }\n        gsplat = transform.applyGsplat(gsplat);\n        const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\n        gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\n        if (this.rgbaDisplaceEdits) {\n          gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n        }\n        if (this.worldModifier) {\n          gsplat = this.worldModifier.apply({ gsplat }).gsplat;\n        }\n        return { gsplat };\n      }\n    );\n    this.generator = generator;\n  }\n  // Call this whenever something changes in the Gsplat processing pipeline,\n  // for example changing maxSh or updating objectModifier or worldModifier.\n  // Compiled generators are cached for efficiency and re-use when the same\n  // pipeline structure emerges after successive changes.\n  updateGenerator() {\n    this.constructGenerator(this.context);\n  }\n  // This is called automatically by SparkRenderer and you should not have to\n  // call it. It updates parameters for the generated pipeline and calls\n  // updateGenerator() if the pipeline needs to change.\n  update({\n    time,\n    viewToWorld,\n    deltaTime,\n    globalEdits\n  }) {\n    var _a2;\n    this.numSplats = this.packedSplats.numSplats;\n    this.context.time.value = time;\n    this.context.deltaTime.value = deltaTime;\n    _SplatMesh.dynoTime.value = time;\n    const { transform, viewToObject, recolor } = this.context;\n    let updated = transform.update(this);\n    if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {\n      updated = true;\n    }\n    const worldToView = viewToWorld.clone().invert();\n    if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {\n      updated = true;\n    }\n    const objectToWorld = new THREE.Matrix4().compose(\n      transform.translate.value,\n      transform.rotate.value,\n      new THREE.Vector3().setScalar(transform.scale.value)\n    );\n    const worldToObject = objectToWorld.invert();\n    const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\n    if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {\n      updated = true;\n    }\n    const newRecolor = new THREE.Vector4(\n      this.recolor.r,\n      this.recolor.g,\n      this.recolor.b,\n      this.opacity\n    );\n    if (!newRecolor.equals(recolor.value)) {\n      recolor.value.copy(newRecolor);\n      updated = true;\n    }\n    const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n    if (this.editable && !this.edits) {\n      this.traverseVisible((node) => {\n        if (node instanceof SplatEdit) {\n          edits.push(node);\n        }\n      });\n    }\n    edits.sort((a, b) => a.ordering - b.ordering);\n    const editsSdfs = edits.map((edit) => {\n      if (edit.sdfs != null) {\n        return { edit, sdfs: edit.sdfs };\n      }\n      const sdfs = [];\n      edit.traverseVisible((node) => {\n        if (node instanceof SplatEditSdf) {\n          sdfs.push(node);\n        }\n      });\n      return { edit, sdfs };\n    });\n    if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\n      const edits2 = editsSdfs.length;\n      const sdfs = editsSdfs.reduce(\n        (total, edit) => total + edit.sdfs.length,\n        0\n      );\n      this.rgbaDisplaceEdits = new SplatEdits({\n        maxEdits: edits2,\n        maxSdfs: sdfs\n      });\n      this.updateGenerator();\n    }\n    if (this.rgbaDisplaceEdits) {\n      const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n      updated || (updated = editResult.updated);\n      if (editResult.dynoUpdated) {\n        this.updateGenerator();\n      }\n    }\n    if (updated) {\n      this.updateVersion();\n    }\n    (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });\n  }\n  // This method conforms to the standard THREE.Raycaster API, performing object-ray\n  // intersections using this method to populate the provided intersects[] array\n  // with each intersection point.\n  raycast(raycaster, intersects) {\n    var _a2, _b2;\n    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\n      return;\n    }\n    const { near, far, ray } = raycaster;\n    const worldToMesh = this.matrixWorld.clone().invert();\n    const worldToMeshRot = new THREE.Matrix3().setFromMatrix4(worldToMesh);\n    const origin = ray.origin.clone().applyMatrix4(worldToMesh);\n    const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\n    const scales = new THREE.Vector3();\n    worldToMesh.decompose(new THREE.Vector3(), new THREE.Quaternion(), scales);\n    (scales.x * scales.y * scales.z) ** (1 / 3);\n    const RAYCAST_ELLIPSOID = true;\n    const distances = raycast_splats(\n      origin.x,\n      origin.y,\n      origin.z,\n      direction.x,\n      direction.y,\n      direction.z,\n      near,\n      far,\n      this.packedSplats.numSplats,\n      this.packedSplats.packedArray,\n      RAYCAST_ELLIPSOID,\n      ((_a2 = this.packedSplats.splatEncoding) == null ? void 0 : _a2.lnScaleMin) ?? LN_SCALE_MIN,\n      ((_b2 = this.packedSplats.splatEncoding) == null ? void 0 : _b2.lnScaleMax) ?? LN_SCALE_MAX\n    );\n    for (const distance2 of distances) {\n      const point = ray.direction.clone().multiplyScalar(distance2).add(ray.origin);\n      intersects.push({\n        distance: distance2,\n        point,\n        object: this\n      });\n    }\n  }\n  ensureShTextures() {\n    if (!this.packedSplats.extra.sh1) {\n      return {};\n    }\n    let sh1Texture = this.packedSplats.extra.sh1Texture;\n    if (!sh1Texture) {\n      let sh1 = this.packedSplats.extra.sh1;\n      const { width, height, depth, maxSplats } = getTextureSize(\n        sh1.length / 2\n      );\n      if (sh1.length < maxSplats * 2) {\n        const newSh1 = new Uint32Array(maxSplats * 2);\n        newSh1.set(sh1);\n        this.packedSplats.extra.sh1 = newSh1;\n        sh1 = newSh1;\n      }\n      const texture2 = new THREE.DataArrayTexture(sh1, width, height, depth);\n      texture2.format = THREE.RGIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      texture2.internalFormat = \"RG32UI\";\n      texture2.needsUpdate = true;\n      sh1Texture = new DynoUsampler2DArray({\n        value: texture2,\n        key: \"sh1\"\n      });\n      this.packedSplats.extra.sh1Texture = sh1Texture;\n    }\n    if (!this.packedSplats.extra.sh2) {\n      return { sh1Texture };\n    }\n    let sh2Texture = this.packedSplats.extra.sh2Texture;\n    if (!sh2Texture) {\n      let sh2 = this.packedSplats.extra.sh2;\n      const { width, height, depth, maxSplats } = getTextureSize(\n        sh2.length / 4\n      );\n      if (sh2.length < maxSplats * 4) {\n        const newSh2 = new Uint32Array(maxSplats * 4);\n        newSh2.set(sh2);\n        this.packedSplats.extra.sh2 = newSh2;\n        sh2 = newSh2;\n      }\n      const texture2 = new THREE.DataArrayTexture(sh2, width, height, depth);\n      texture2.format = THREE.RGBAIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      texture2.internalFormat = \"RGBA32UI\";\n      texture2.needsUpdate = true;\n      sh2Texture = new DynoUsampler2DArray({\n        value: texture2,\n        key: \"sh2\"\n      });\n      this.packedSplats.extra.sh2Texture = sh2Texture;\n    }\n    if (!this.packedSplats.extra.sh3) {\n      return { sh1Texture, sh2Texture };\n    }\n    let sh3Texture = this.packedSplats.extra.sh3Texture;\n    if (!sh3Texture) {\n      let sh3 = this.packedSplats.extra.sh3;\n      const { width, height, depth, maxSplats } = getTextureSize(\n        sh3.length / 4\n      );\n      if (sh3.length < maxSplats * 4) {\n        const newSh3 = new Uint32Array(maxSplats * 4);\n        newSh3.set(sh3);\n        this.packedSplats.extra.sh3 = newSh3;\n        sh3 = newSh3;\n      }\n      const texture2 = new THREE.DataArrayTexture(sh3, width, height, depth);\n      texture2.format = THREE.RGBAIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      texture2.internalFormat = \"RGBA32UI\";\n      texture2.needsUpdate = true;\n      sh3Texture = new DynoUsampler2DArray({\n        value: texture2,\n        key: \"sh3\"\n      });\n      this.packedSplats.extra.sh3Texture = sh3Texture;\n    }\n    return { sh1Texture, sh2Texture, sh3Texture };\n  }\n};\n_SplatMesh.staticInitialized = _SplatMesh.staticInitialize();\n_SplatMesh.isStaticInitialized = false;\n_SplatMesh.dynoTime = new DynoFloat({ value: 0 });\nlet SplatMesh = _SplatMesh;\nconst defineEvaluateSH1 = unindent(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`);\nconst defineEvaluateSH2 = unindent(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`);\nconst defineEvaluateSH3 = unindent(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\nfunction evaluateSH1(gsplat, sh1, viewDir) {\n  return dyno$1({\n    inTypes: { gsplat: Gsplat, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat, sh1, viewDir },\n    globals: () => [defineGsplat, defineEvaluateSH1],\n    statements: ({ inputs, outputs }) => {\n      const statements = unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `);\n      return statements;\n    }\n  }).outputs.rgb;\n}\nfunction evaluateSH2(gsplat, sh2, viewDir) {\n  return dyno$1({\n    inTypes: { gsplat: Gsplat, sh2: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat, sh2, viewDir },\n    globals: () => [defineGsplat, defineEvaluateSH2],\n    statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nfunction evaluateSH3(gsplat, sh3, viewDir) {\n  return dyno$1({\n    inTypes: { gsplat: Gsplat, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat, sh3, viewDir },\n    globals: () => [defineGsplat, defineEvaluateSH3],\n    statements: ({ inputs, outputs }) => unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, ${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nconst _PlyReader = class _PlyReader {\n  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n  constructor({ fileBytes }) {\n    this.header = \"\";\n    this.littleEndian = true;\n    this.elements = {};\n    this.comments = [];\n    this.data = null;\n    this.numSplats = 0;\n    this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n  }\n  // Identify and parse the PLY text header (assumed to be <64KB in size).\n  // this.elements will contain all the elements in the file, typically\n  // \"vertex\" contains the Gsplat data.\n  async parseHeader() {\n    const bufferStream = new ReadableStream({\n      start: (controller) => {\n        controller.enqueue(this.fileBytes.slice(0, 65536));\n        controller.close();\n      }\n    });\n    const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n    this.header = \"\";\n    const headerTerminator = \"end_header\\n\";\n    while (true) {\n      const { value, done } = await decoder.read();\n      if (done) {\n        throw new Error(\"Failed to read header\");\n      }\n      this.header += value;\n      const endHeader = this.header.indexOf(headerTerminator);\n      if (endHeader >= 0) {\n        this.header = this.header.slice(0, endHeader + headerTerminator.length);\n        break;\n      }\n    }\n    const headerLen = new TextEncoder().encode(this.header).length;\n    this.data = new DataView(this.fileBytes.buffer, headerLen);\n    this.elements = {};\n    let curElement = null;\n    this.comments = [];\n    this.header.trim().split(\"\\n\").forEach((line, lineIndex) => {\n      const trimmedLine = line.trim();\n      if (lineIndex === 0) {\n        if (trimmedLine !== \"ply\") {\n          throw new Error(\"Invalid PLY header\");\n        }\n        return;\n      }\n      if (trimmedLine.length === 0) {\n        return;\n      }\n      const fields = trimmedLine.split(\" \");\n      switch (fields[0]) {\n        case \"format\":\n          if (fields[1] === \"binary_little_endian\") {\n            this.littleEndian = true;\n          } else if (fields[1] === \"binary_big_endian\") {\n            this.littleEndian = false;\n          } else {\n            throw new Error(`Unsupported PLY format: ${fields[1]}`);\n          }\n          if (fields[2] !== \"1.0\") {\n            throw new Error(`Unsupported PLY version: ${fields[2]}`);\n          }\n          break;\n        case \"end_header\":\n          break;\n        case \"comment\":\n          this.comments.push(trimmedLine.slice(\"comment \".length));\n          break;\n        case \"element\": {\n          const name = fields[1];\n          curElement = {\n            name,\n            count: Number.parseInt(fields[2]),\n            properties: {}\n          };\n          this.elements[name] = curElement;\n          break;\n        }\n        case \"property\":\n          if (curElement == null) {\n            throw new Error(\"Property must be inside an element\");\n          }\n          if (fields[1] === \"list\") {\n            curElement.properties[fields[4]] = {\n              isList: true,\n              type: fields[3],\n              countType: fields[2]\n            };\n          } else {\n            curElement.properties[fields[2]] = {\n              isList: false,\n              type: fields[1]\n            };\n          }\n          break;\n      }\n    });\n    if (this.elements.vertex) {\n      this.numSplats = this.elements.vertex.count;\n    }\n  }\n  parseData(elementCallback) {\n    let offset = 0;\n    const data = this.data;\n    if (data == null) {\n      throw new Error(\"No data to parse\");\n    }\n    for (const elementName in this.elements) {\n      const element = this.elements[elementName];\n      const { count, properties } = element;\n      const item = {};\n      const parsers = [];\n      for (const [propertyName, property] of Object.entries(properties)) {\n        if (!property.isList) {\n          item[propertyName] = 0;\n          parsers.push(() => {\n            item[propertyName] = PARSE_FIELD[property.type](\n              data,\n              offset,\n              this.littleEndian\n            );\n            offset += FIELD_BYTES[property.type];\n          });\n        } else {\n          item[propertyName] = [];\n          parsers.push(() => {\n            const list = item[propertyName];\n            list.length = PARSE_FIELD[property.countType](\n              data,\n              offset,\n              this.littleEndian\n            );\n            offset += FIELD_BYTES[property.countType];\n            for (let i = 0; i < list.length; i++) {\n              list[i] = PARSE_FIELD[property.type](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.type];\n            }\n          });\n        }\n      }\n      const callback = elementCallback(element) ?? (() => {\n      });\n      for (let index = 0; index < count; index++) {\n        for (const parser of parsers) {\n          parser();\n        }\n        callback(index, item);\n      }\n    }\n  }\n  // Parse all the Gsplat data in the PLY file in go, invoking the given\n  // callbacks for each Gsplat.\n  parseSplats(splatCallback, shCallback) {\n    if (this.elements.vertex == null) {\n      throw new Error(\"No vertex element found\");\n    }\n    let isSuperSplat = false;\n    const ssChunks = [];\n    let numSh = 0;\n    let sh1Props = [];\n    let sh2Props = [];\n    let sh3Props = [];\n    let sh1 = void 0;\n    let sh2 = void 0;\n    let sh3 = void 0;\n    function prepareSh() {\n      const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n      sh1Props = new Array(3).fill(null).flatMap(\n        (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${k + d * num_f_rest / 3}`)\n      );\n      sh2Props = new Array(5).fill(null).flatMap(\n        (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${3 + k + d * num_f_rest / 3}`)\n      );\n      sh3Props = new Array(7).fill(null).flatMap(\n        (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${8 + k + d * num_f_rest / 3}`)\n      );\n      sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n      sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n      sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n    }\n    function ssShCallback(index, item) {\n      if (!sh1) {\n        throw new Error(\"Missing sh1\");\n      }\n      for (const [i, key] of sh1Props.entries()) {\n        sh1[i] = item[key] * 8 / 255 - 4;\n      }\n      if (sh2) {\n        for (const [i, key] of sh2Props.entries()) {\n          sh2[i] = item[key] * 8 / 255 - 4;\n        }\n      }\n      if (sh3) {\n        for (const [i, key] of sh3Props.entries()) {\n          sh3[i] = item[key] * 8 / 255 - 4;\n        }\n      }\n      shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n    }\n    function initSuperSplat(element) {\n      const {\n        min_x,\n        min_y,\n        min_z,\n        max_x,\n        max_y,\n        max_z,\n        min_scale_x,\n        min_scale_y,\n        min_scale_z,\n        max_scale_x,\n        max_scale_y,\n        max_scale_z\n      } = element.properties;\n      if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\n        throw new Error(\"Missing PLY chunk properties\");\n      }\n      isSuperSplat = true;\n      return (index, item) => {\n        const {\n          min_x: min_x2,\n          min_y: min_y2,\n          min_z: min_z2,\n          max_x: max_x2,\n          max_y: max_y2,\n          max_z: max_z2,\n          min_scale_x: min_scale_x2,\n          min_scale_y: min_scale_y2,\n          min_scale_z: min_scale_z2,\n          max_scale_x: max_scale_x2,\n          max_scale_y: max_scale_y2,\n          max_scale_z: max_scale_z2,\n          min_r,\n          min_g,\n          min_b,\n          max_r,\n          max_g,\n          max_b\n        } = item;\n        ssChunks.push({\n          min_x: min_x2,\n          min_y: min_y2,\n          min_z: min_z2,\n          max_x: max_x2,\n          max_y: max_y2,\n          max_z: max_z2,\n          min_scale_x: min_scale_x2,\n          min_scale_y: min_scale_y2,\n          min_scale_z: min_scale_z2,\n          max_scale_x: max_scale_x2,\n          max_scale_y: max_scale_y2,\n          max_scale_z: max_scale_z2,\n          min_r,\n          min_g,\n          min_b,\n          max_r,\n          max_g,\n          max_b\n        });\n      };\n    }\n    function decodeSuperSplat(element) {\n      if (shCallback && element.name === \"sh\") {\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return ssShCallback;\n      }\n      if (element.name !== \"vertex\") {\n        return null;\n      }\n      const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n      if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n        throw new Error(\n          \"Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color\"\n        );\n      }\n      const SQRT2 = Math.sqrt(2);\n      return (index, item) => {\n        const chunk = ssChunks[index >>> 8];\n        if (chunk == null) {\n          throw new Error(\"Missing PLY chunk\");\n        }\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z,\n          min_r,\n          min_g,\n          min_b,\n          max_r,\n          max_g,\n          max_b\n        } = chunk;\n        const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n        const x = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n        const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n        const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n        const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n        const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n        const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n        const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n        const rOrder = packed_rotation2 >>> 30;\n        const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n        const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n        const quatZ = rOrder <= 2 ? r2 : rr;\n        const quatW = rOrder === 0 ? rr : r0;\n        const scaleX = Math.exp(\n          (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n        );\n        const scaleY = Math.exp(\n          (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n        );\n        const scaleZ = Math.exp(\n          (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n        );\n        const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n        const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\n        const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\n        const opacity = (packed_color2 & 255) / 255;\n        splatCallback(\n          index,\n          x,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      };\n    }\n    const elementCallback = (element) => {\n      if (element.name === \"chunk\") {\n        return initSuperSplat(element);\n      }\n      if (isSuperSplat) {\n        return decodeSuperSplat(element);\n      }\n      if (element.name !== \"vertex\") {\n        return null;\n      }\n      const {\n        x,\n        y,\n        z,\n        scale_0,\n        scale_1,\n        scale_2,\n        rot_0,\n        rot_1,\n        rot_2,\n        rot_3,\n        opacity,\n        f_dc_0,\n        f_dc_1,\n        f_dc_2,\n        red,\n        green,\n        blue,\n        alpha\n      } = element.properties;\n      if (!x || !y || !z) {\n        throw new Error(\"Missing PLY properties: x, y, z\");\n      }\n      const hasScales = scale_0 && scale_1 && scale_2;\n      const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n      const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n      const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n      const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n      const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n      numSh = getNumSh(element.properties);\n      prepareSh();\n      return (index, item) => {\n        const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n        const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n        const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n        const quatX = hasRots ? item.rot_1 : 0;\n        const quatY = hasRots ? item.rot_2 : 0;\n        const quatZ = hasRots ? item.rot_3 : 0;\n        const quatW = hasRots ? item.rot_0 : 1;\n        const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n        const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n        const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n        const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n        splatCallback(\n          index,\n          item.x,\n          item.y,\n          item.z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          op,\n          r,\n          g,\n          b\n        );\n        if (shCallback && sh1) {\n          if (sh1) {\n            for (const [i, key] of sh1Props.entries()) {\n              sh1[i] = item[key];\n            }\n          }\n          if (sh2) {\n            for (const [i, key] of sh2Props.entries()) {\n              sh2[i] = item[key];\n            }\n          }\n          if (sh3) {\n            for (const [i, key] of sh3Props.entries()) {\n              sh3[i] = item[key];\n            }\n          }\n          shCallback(index, sh1, sh2, sh3);\n        }\n      };\n    };\n    this.parseData(elementCallback);\n  }\n  // Inject RGBA values into original PLY file, which can be used to modify\n  // the color/opacity of the Gsplats and write out the modified PLY file.\n  injectRgba(rgba) {\n    let offset = 0;\n    const data = this.data;\n    if (data == null) {\n      throw new Error(\"No parsed data\");\n    }\n    if (rgba.length !== this.numSplats * 4) {\n      throw new Error(\"Invalid RGBA array length\");\n    }\n    for (const elementName in this.elements) {\n      const element = this.elements[elementName];\n      const { count, properties } = element;\n      const parsers = [];\n      let rgbaOffset = 0;\n      const isVertex = elementName === \"vertex\";\n      if (isVertex) {\n        for (const name of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\n          if (!properties[name] || properties[name].type !== \"float\") {\n            throw new Error(`Can't injectRgba due to property: ${name}`);\n          }\n        }\n      }\n      for (const [propertyName, property] of Object.entries(properties)) {\n        if (!property.isList) {\n          if (isVertex) {\n            if (propertyName === \"f_dc_0\" || propertyName === \"f_dc_1\" || propertyName === \"f_dc_2\") {\n              const component = Number.parseInt(\n                propertyName.slice(\"f_dc_\".length)\n              );\n              parsers.push(() => {\n                const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                SET_FIELD[property.type](\n                  data,\n                  offset,\n                  this.littleEndian,\n                  value\n                );\n              });\n            } else if (propertyName === \"opacity\") {\n              parsers.push(() => {\n                const value = Math.max(\n                  -100,\n                  Math.min(\n                    100,\n                    -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                  )\n                );\n                SET_FIELD[property.type](\n                  data,\n                  offset,\n                  this.littleEndian,\n                  value\n                );\n              });\n            }\n          }\n          parsers.push(() => {\n            offset += FIELD_BYTES[property.type];\n          });\n        } else {\n          parsers.push(() => {\n            const length2 = PARSE_FIELD[property.countType](\n              data,\n              offset,\n              this.littleEndian\n            );\n            offset += FIELD_BYTES[property.countType];\n            offset += length2 * FIELD_BYTES[property.type];\n          });\n        }\n      }\n      for (let index = 0; index < count; index++) {\n        for (const parser of parsers) {\n          parser();\n        }\n        if (isVertex) {\n          rgbaOffset += 4;\n        }\n      }\n    }\n  }\n};\n_PlyReader.defaultPointScale = 1e-3;\nlet PlyReader = _PlyReader;\nconst SH_C0$1 = 0.28209479177387814;\nconst PARSE_FIELD = {\n  char: (data, offset, littleEndian) => {\n    return data.getInt8(offset);\n  },\n  uchar: (data, offset, littleEndian) => {\n    return data.getUint8(offset);\n  },\n  short: (data, offset, littleEndian) => {\n    return data.getInt16(offset, littleEndian);\n  },\n  ushort: (data, offset, littleEndian) => {\n    return data.getUint16(offset, littleEndian);\n  },\n  int: (data, offset, littleEndian) => {\n    return data.getInt32(offset, littleEndian);\n  },\n  uint: (data, offset, littleEndian) => {\n    return data.getUint32(offset, littleEndian);\n  },\n  float: (data, offset, littleEndian) => {\n    return data.getFloat32(offset, littleEndian);\n  },\n  double: (data, offset, littleEndian) => {\n    return data.getFloat64(offset, littleEndian);\n  }\n};\nconst SET_FIELD = {\n  char: (data, offset, littleEndian, value) => {\n    data.setInt8(offset, value);\n  },\n  uchar: (data, offset, littleEndian, value) => {\n    data.setUint8(offset, value);\n  },\n  short: (data, offset, littleEndian, value) => {\n    data.setInt16(offset, value, littleEndian);\n  },\n  ushort: (data, offset, littleEndian, value) => {\n    data.setUint16(offset, value, littleEndian);\n  },\n  int: (data, offset, littleEndian, value) => {\n    data.setInt32(offset, value, littleEndian);\n  },\n  uint: (data, offset, littleEndian, value) => {\n    data.setUint32(offset, value, littleEndian);\n  },\n  float: (data, offset, littleEndian, value) => {\n    data.setFloat32(offset, value, littleEndian);\n  },\n  double: (data, offset, littleEndian, value) => {\n    data.setFloat64(offset, value, littleEndian);\n  }\n};\nconst FIELD_BYTES = {\n  char: 1,\n  uchar: 1,\n  short: 2,\n  ushort: 2,\n  int: 4,\n  uint: 4,\n  float: 4,\n  double: 8\n};\nconst FIELD_SCALE = {\n  char: 127,\n  uchar: 255,\n  short: 32767,\n  ushort: 65535,\n  int: 2147483647,\n  uint: 4294967295,\n  float: 1,\n  double: 1\n};\nconst NUM_F_REST_TO_NUM_SH = {\n  0: 0,\n  9: 1,\n  24: 2,\n  45: 3\n};\nconst NUM_SH_TO_NUM_F_REST = {\n  0: 0,\n  1: 9,\n  2: 24,\n  3: 45\n};\nfunction getNumSh(properties) {\n  let num_f_rest = 0;\n  while (properties[`f_rest_${num_f_rest}`]) {\n    num_f_rest += 1;\n  }\n  const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n  if (numSh == null) {\n    throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\n  }\n  return numSh;\n}\nconst jsContent = '(function() {\\n  \"use strict\";\\n  let wasm;\\n  const cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true }) : { decode: () => {\\n    throw Error(\"TextDecoder not available\");\\n  } };\\n  if (typeof TextDecoder !== \"undefined\") {\\n    cachedTextDecoder.decode();\\n  }\\n  let cachedUint8ArrayMemory0 = null;\\n  function getUint8ArrayMemory0() {\\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\\n    }\\n    return cachedUint8ArrayMemory0;\\n  }\\n  function getStringFromWasm0(ptr, len) {\\n    ptr = ptr >>> 0;\\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\\n  }\\n  function sort_splats(num_splats, readback, ordering) {\\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\\n    return ret >>> 0;\\n  }\\n  function sort32_splats(num_splats, readback, ordering) {\\n    const ret = wasm.sort32_splats(num_splats, readback, ordering);\\n    return ret >>> 0;\\n  }\\n  async function __wbg_load(module, imports) {\\n    if (typeof Response === \"function\" && module instanceof Response) {\\n      if (typeof WebAssembly.instantiateStreaming === \"function\") {\\n        try {\\n          return await WebAssembly.instantiateStreaming(module, imports);\\n        } catch (e) {\\n          if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\\n            console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\\\n\", e);\\n          } else {\\n            throw e;\\n          }\\n        }\\n      }\\n      const bytes = await module.arrayBuffer();\\n      return await WebAssembly.instantiate(bytes, imports);\\n    } else {\\n      const instance = await WebAssembly.instantiate(module, imports);\\n      if (instance instanceof WebAssembly.Instance) {\\n        return { instance, module };\\n      } else {\\n        return instance;\\n      }\\n    }\\n  }\\n  function __wbg_get_imports() {\\n    const imports = {};\\n    imports.wbg = {};\\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\\n      const ret = arg0.buffer;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\\n      const ret = arg0.length;\\n      return ret;\\n    };\\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\\n      const ret = new Uint16Array(arg0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\\n      const ret = new Uint32Array(arg0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\\n      const ret = new Float32Array(arg0 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\\n      arg0.set(arg1, arg2 >>> 0);\\n    };\\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\\n      arg0.set(arg1, arg2 >>> 0);\\n    };\\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\\n      arg0.set(arg1, arg2 >>> 0);\\n    };\\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    imports.wbg.__wbindgen_init_externref_table = function() {\\n      const table = wasm.__wbindgen_export_0;\\n      const offset = table.grow(4);\\n      table.set(0, void 0);\\n      table.set(offset + 0, void 0);\\n      table.set(offset + 1, null);\\n      table.set(offset + 2, true);\\n      table.set(offset + 3, false);\\n    };\\n    imports.wbg.__wbindgen_memory = function() {\\n      const ret = wasm.memory;\\n      return ret;\\n    };\\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\\n      throw new Error(getStringFromWasm0(arg0, arg1));\\n    };\\n    return imports;\\n  }\\n  function __wbg_finalize_init(instance, module) {\\n    wasm = instance.exports;\\n    __wbg_init.__wbindgen_wasm_module = module;\\n    cachedUint8ArrayMemory0 = null;\\n    wasm.__wbindgen_start();\\n    return wasm;\\n  }\\n  async function __wbg_init(module_or_path) {\\n    if (wasm !== void 0) return wasm;\\n    if (typeof module_or_path !== \"undefined\") {\\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\\n        ({ module_or_path } = module_or_path);\\n      } else {\\n        console.warn(\"using deprecated parameters for the initialization function; pass a single object instead\");\\n      }\\n    }\\n    if (typeof module_or_path === \"undefined\") {\\n      module_or_path = new URL(\"data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYG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ACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkb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QQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUE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ZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==\", self.location.href);\\n    }\\n    const imports = __wbg_get_imports();\\n    if (typeof module_or_path === \"string\" || typeof Request === \"function\" && module_or_path instanceof Request || typeof URL === \"function\" && module_or_path instanceof URL) {\\n      module_or_path = fetch(module_or_path);\\n    }\\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\\n    return __wbg_finalize_init(instance, module);\\n  }\\n  var ch2 = {};\\n  var wk = function(c, id, msg, transfer, cb) {\\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\\n      c + \\';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\\'\\n    ], { type: \"text/javascript\" }))));\\n    w.onmessage = function(e) {\\n      var d = e.data, ed = d.$e$;\\n      if (ed) {\\n        var err2 = new Error(ed[0]);\\n        err2[\"code\"] = ed[1];\\n        err2.stack = ed[2];\\n        cb(err2, null);\\n      } else\\n        cb(null, d);\\n    };\\n    w.postMessage(msg, transfer);\\n    return w;\\n  };\\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\\n  var fleb = new u8([\\n    0,\\n    0,\\n    0,\\n    0,\\n    0,\\n    0,\\n    0,\\n    0,\\n    1,\\n    1,\\n    1,\\n    1,\\n    2,\\n    2,\\n    2,\\n    2,\\n    3,\\n    3,\\n    3,\\n    3,\\n    4,\\n    4,\\n    4,\\n    4,\\n    5,\\n    5,\\n    5,\\n    5,\\n    0,\\n    /* unused */\\n    0,\\n    0,\\n    /* impossible */\\n    0\\n  ]);\\n  var fdeb = new u8([\\n    0,\\n    0,\\n    0,\\n    0,\\n    1,\\n    1,\\n    2,\\n    2,\\n    3,\\n    3,\\n    4,\\n    4,\\n    5,\\n    5,\\n    6,\\n    6,\\n    7,\\n    7,\\n    8,\\n    8,\\n    9,\\n    9,\\n    10,\\n    10,\\n    11,\\n    11,\\n    12,\\n    12,\\n    13,\\n    13,\\n    /* unused */\\n    0,\\n    0\\n  ]);\\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\\n  var freb = function(eb, start) {\\n    var b = new u16(31);\\n    for (var i2 = 0; i2 < 31; ++i2) {\\n      b[i2] = start += 1 << eb[i2 - 1];\\n    }\\n    var r = new i32(b[30]);\\n    for (var i2 = 1; i2 < 30; ++i2) {\\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\\n        r[j] = j - b[i2] << 5 | i2;\\n      }\\n    }\\n    return { b, r };\\n  };\\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\\n  fl[28] = 258, revfl[258] = 28;\\n  var _b = freb(fdeb, 0), fd = _b.b;\\n  var rev = new u16(32768);\\n  for (var i = 0; i < 32768; ++i) {\\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\\n  }\\n  var hMap = function(cd, mb, r) {\\n    var s = cd.length;\\n    var i2 = 0;\\n    var l = new u16(mb);\\n    for (; i2 < s; ++i2) {\\n      if (cd[i2])\\n        ++l[cd[i2] - 1];\\n    }\\n    var le = new u16(mb);\\n    for (i2 = 1; i2 < mb; ++i2) {\\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\\n    }\\n    var co;\\n    if (r) {\\n      co = new u16(1 << mb);\\n      var rvb = 15 - mb;\\n      for (i2 = 0; i2 < s; ++i2) {\\n        if (cd[i2]) {\\n          var sv = i2 << 4 | cd[i2];\\n          var r_1 = mb - cd[i2];\\n          var v = le[cd[i2] - 1]++ << r_1;\\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\\n            co[rev[v] >> rvb] = sv;\\n          }\\n        }\\n      }\\n    } else {\\n      co = new u16(s);\\n      for (i2 = 0; i2 < s; ++i2) {\\n        if (cd[i2]) {\\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\\n        }\\n      }\\n    }\\n    return co;\\n  };\\n  var flt = new u8(288);\\n  for (var i = 0; i < 144; ++i)\\n    flt[i] = 8;\\n  for (var i = 144; i < 256; ++i)\\n    flt[i] = 9;\\n  for (var i = 256; i < 280; ++i)\\n    flt[i] = 7;\\n  for (var i = 280; i < 288; ++i)\\n    flt[i] = 8;\\n  var fdt = new u8(32);\\n  for (var i = 0; i < 32; ++i)\\n    fdt[i] = 5;\\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\\n  var max = function(a) {\\n    var m = a[0];\\n    for (var i2 = 1; i2 < a.length; ++i2) {\\n      if (a[i2] > m)\\n        m = a[i2];\\n    }\\n    return m;\\n  };\\n  var bits = function(d, p, m) {\\n    var o = p / 8 | 0;\\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\\n  };\\n  var bits16 = function(d, p) {\\n    var o = p / 8 | 0;\\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\\n  };\\n  var shft = function(p) {\\n    return (p + 7) / 8 | 0;\\n  };\\n  var slc = function(v, s, e) {\\n    if (s == null || s < 0)\\n      s = 0;\\n    if (e == null || e > v.length)\\n      e = v.length;\\n    return new u8(v.subarray(s, e));\\n  };\\n  var ec = [\\n    \"unexpected EOF\",\\n    \"invalid block type\",\\n    \"invalid length/literal\",\\n    \"invalid distance\",\\n    \"stream finished\",\\n    \"no stream handler\",\\n    ,\\n    \"no callback\",\\n    \"invalid UTF-8 data\",\\n    \"extra field too long\",\\n    \"date not in range 1980-2099\",\\n    \"filename too long\",\\n    \"stream finishing\",\\n    \"invalid zip data\"\\n    // determined by unknown compression method\\n  ];\\n  var err = function(ind, msg, nt) {\\n    var e = new Error(msg || ec[ind]);\\n    e.code = ind;\\n    if (Error.captureStackTrace)\\n      Error.captureStackTrace(e, err);\\n    if (!nt)\\n      throw e;\\n    return e;\\n  };\\n  var inflt = function(dat, st, buf, dict) {\\n    var sl = dat.length, dl = dict ? dict.length : 0;\\n    if (!sl || st.f && !st.l)\\n      return buf || new u8(0);\\n    var noBuf = !buf;\\n    var resize = noBuf || st.i != 2;\\n    var noSt = st.i;\\n    if (noBuf)\\n      buf = new u8(sl * 3);\\n    var cbuf = function(l2) {\\n      var bl = buf.length;\\n      if (l2 > bl) {\\n        var nbuf = new u8(Math.max(bl * 2, l2));\\n        nbuf.set(buf);\\n        buf = nbuf;\\n      }\\n    };\\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\\n    var tbts = sl * 8;\\n    do {\\n      if (!lm) {\\n        final = bits(dat, pos, 1);\\n        var type = bits(dat, pos + 1, 3);\\n        pos += 3;\\n        if (!type) {\\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\\n          if (t > sl) {\\n            if (noSt)\\n              err(0);\\n            break;\\n          }\\n          if (resize)\\n            cbuf(bt + l);\\n          buf.set(dat.subarray(s, t), bt);\\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\\n          continue;\\n        } else if (type == 1)\\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\\n        else if (type == 2) {\\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\\n          pos += 14;\\n          var ldt = new u8(tl);\\n          var clt = new u8(19);\\n          for (var i2 = 0; i2 < hcLen; ++i2) {\\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\\n          }\\n          pos += hcLen * 3;\\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\\n          var clm = hMap(clt, clb, 1);\\n          for (var i2 = 0; i2 < tl; ) {\\n            var r = clm[bits(dat, pos, clbmsk)];\\n            pos += r & 15;\\n            var s = r >> 4;\\n            if (s < 16) {\\n              ldt[i2++] = s;\\n            } else {\\n              var c = 0, n = 0;\\n              if (s == 16)\\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\\n              else if (s == 17)\\n                n = 3 + bits(dat, pos, 7), pos += 3;\\n              else if (s == 18)\\n                n = 11 + bits(dat, pos, 127), pos += 7;\\n              while (n--)\\n                ldt[i2++] = c;\\n            }\\n          }\\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\\n          lbt = max(lt);\\n          dbt = max(dt);\\n          lm = hMap(lt, lbt, 1);\\n          dm = hMap(dt, dbt, 1);\\n        } else\\n          err(1);\\n        if (pos > tbts) {\\n          if (noSt)\\n            err(0);\\n          break;\\n        }\\n      }\\n      if (resize)\\n        cbuf(bt + 131072);\\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\\n      var lpos = pos;\\n      for (; ; lpos = pos) {\\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\\n        pos += c & 15;\\n        if (pos > tbts) {\\n          if (noSt)\\n            err(0);\\n          break;\\n        }\\n        if (!c)\\n          err(2);\\n        if (sym < 256)\\n          buf[bt++] = sym;\\n        else if (sym == 256) {\\n          lpos = pos, lm = null;\\n          break;\\n        } else {\\n          var add = sym - 254;\\n          if (sym > 264) {\\n            var i2 = sym - 257, b = fleb[i2];\\n            add = bits(dat, pos, (1 << b) - 1) + fl[i2];\\n            pos += b;\\n          }\\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\\n          if (!d)\\n            err(3);\\n          pos += d & 15;\\n          var dt = fd[dsym];\\n          if (dsym > 3) {\\n            var b = fdeb[dsym];\\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\\n          }\\n          if (pos > tbts) {\\n            if (noSt)\\n              err(0);\\n            break;\\n          }\\n          if (resize)\\n            cbuf(bt + 131072);\\n          var end = bt + add;\\n          if (bt < dt) {\\n            var shift = dl - dt, dend = Math.min(dt, end);\\n            if (shift + bt < 0)\\n              err(3);\\n            for (; bt < dend; ++bt)\\n              buf[bt] = dict[shift + bt];\\n          }\\n          for (; bt < end; ++bt)\\n            buf[bt] = buf[bt - dt];\\n        }\\n      }\\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\\n      if (lm)\\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\\n    } while (!final);\\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\\n  };\\n  var et = /* @__PURE__ */ new u8(0);\\n  var mrg = function(a, b) {\\n    var o = {};\\n    for (var k in a)\\n      o[k] = a[k];\\n    for (var k in b)\\n      o[k] = b[k];\\n    return o;\\n  };\\n  var wcln = function(fn, fnStr, td2) {\\n    var dt = fn();\\n    var st = fn.toString();\\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/\\\\s+/g, \"\").split(\",\");\\n    for (var i2 = 0; i2 < dt.length; ++i2) {\\n      var v = dt[i2], k = ks[i2];\\n      if (typeof v == \"function\") {\\n        fnStr += \";\" + k + \"=\";\\n        var st_1 = v.toString();\\n        if (v.prototype) {\\n          if (st_1.indexOf(\"[native code]\") != -1) {\\n            var spInd = st_1.indexOf(\" \", 8) + 1;\\n            fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\\n          } else {\\n            fnStr += st_1;\\n            for (var t in v.prototype)\\n              fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\\n          }\\n        } else\\n          fnStr += st_1;\\n      } else\\n        td2[k] = v;\\n    }\\n    return fnStr;\\n  };\\n  var ch = [];\\n  var cbfs = function(v) {\\n    var tl = [];\\n    for (var k in v) {\\n      if (v[k].buffer) {\\n        tl.push((v[k] = new v[k].constructor(v[k])).buffer);\\n      }\\n    }\\n    return tl;\\n  };\\n  var wrkr = function(fns, init, id, cb) {\\n    if (!ch[id]) {\\n      var fnStr = \"\", td_1 = {}, m = fns.length - 1;\\n      for (var i2 = 0; i2 < m; ++i2)\\n        fnStr = wcln(fns[i2], fnStr, td_1);\\n      ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\\n    }\\n    var td2 = mrg({}, ch[id].e);\\n    return wk(ch[id].c + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td2, cbfs(td2), cb);\\n  };\\n  var bInflt = function() {\\n    return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];\\n  };\\n  var pbf = function(msg) {\\n    return postMessage(msg, [msg.buffer]);\\n  };\\n  var gopt = function(o) {\\n    return o && {\\n      out: o.size && new u8(o.size),\\n      dictionary: o.dictionary\\n    };\\n  };\\n  var cbify = function(dat, opts, fns, init, id, cb) {\\n    var w = wrkr(fns, init, id, function(err2, dat2) {\\n      w.terminate();\\n      cb(err2, dat2);\\n    });\\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\\n    return function() {\\n      w.terminate();\\n    };\\n  };\\n  var b2 = function(d, b) {\\n    return d[b] | d[b + 1] << 8;\\n  };\\n  var b4 = function(d, b) {\\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\\n  };\\n  var b8 = function(d, b) {\\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\\n  };\\n  var gzs = function(d) {\\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\\n      err(6, \"invalid gzip data\");\\n    var flg = d[3];\\n    var st = 10;\\n    if (flg & 4)\\n      st += (d[10] | d[11] << 8) + 2;\\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\\n      ;\\n    return st + (flg & 2);\\n  };\\n  var Inflate = /* @__PURE__ */ function() {\\n    function Inflate2(opts, cb) {\\n      if (typeof opts == \"function\")\\n        cb = opts, opts = {};\\n      this.ondata = cb;\\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\\n      this.s = { i: 0, b: dict ? dict.length : 0 };\\n      this.o = new u8(32768);\\n      this.p = new u8(0);\\n      if (dict)\\n        this.o.set(dict);\\n    }\\n    Inflate2.prototype.e = function(c) {\\n      if (!this.ondata)\\n        err(5);\\n      if (this.d)\\n        err(4);\\n      if (!this.p.length)\\n        this.p = c;\\n      else if (c.length) {\\n        var n = new u8(this.p.length + c.length);\\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\\n      }\\n    };\\n    Inflate2.prototype.c = function(final) {\\n      this.s.i = +(this.d = final || false);\\n      var bts = this.s.b;\\n      var dt = inflt(this.p, this.s, this.o);\\n      this.ondata(slc(dt, bts, this.s.b), this.d);\\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\\n    };\\n    Inflate2.prototype.push = function(chunk, final) {\\n      this.e(chunk), this.c(final);\\n    };\\n    return Inflate2;\\n  }();\\n  function inflate(data, opts, cb) {\\n    if (!cb)\\n      cb = opts, opts = {};\\n    if (typeof cb != \"function\")\\n      err(7);\\n    return cbify(data, opts, [\\n      bInflt\\n    ], function(ev) {\\n      return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));\\n    }, 1, cb);\\n  }\\n  function inflateSync(data, opts) {\\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\\n  }\\n  var Gunzip = /* @__PURE__ */ function() {\\n    function Gunzip2(opts, cb) {\\n      this.v = 1;\\n      this.r = 0;\\n      Inflate.call(this, opts, cb);\\n    }\\n    Gunzip2.prototype.push = function(chunk, final) {\\n      Inflate.prototype.e.call(this, chunk);\\n      this.r += chunk.length;\\n      if (this.v) {\\n        var p = this.p.subarray(this.v - 1);\\n        var s = p.length > 3 ? gzs(p) : 4;\\n        if (s > p.length) {\\n          if (!final)\\n            return;\\n        } else if (this.v > 1 && this.onmember) {\\n          this.onmember(this.r - p.length);\\n        }\\n        this.p = p.subarray(s), this.v = 0;\\n      }\\n      Inflate.prototype.c.call(this, final);\\n      if (this.s.f && !this.s.l && !final) {\\n        this.v = shft(this.s.p) + 9;\\n        this.s = { i: 0 };\\n        this.o = new u8(0);\\n        this.push(new u8(0), final);\\n      }\\n    };\\n    return Gunzip2;\\n  }();\\n  var td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\\n  try {\\n    td.decode(et, { stream: true });\\n  } catch (e) {\\n  }\\n  var dutf8 = function(d) {\\n    for (var r = \"\", i2 = 0; ; ) {\\n      var c = d[i2++];\\n      var eb = (c > 127) + (c > 223) + (c > 239);\\n      if (i2 + eb > d.length)\\n        return { s: r, r: slc(d, i2 - 1) };\\n      if (!eb)\\n        r += String.fromCharCode(c);\\n      else if (eb == 3) {\\n        c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\\n      } else if (eb & 1)\\n        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);\\n      else\\n        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);\\n    }\\n  };\\n  function strFromU8(dat, latin1) {\\n    if (latin1) {\\n      var r = \"\";\\n      for (var i2 = 0; i2 < dat.length; i2 += 16384)\\n        r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));\\n      return r;\\n    } else if (td) {\\n      return td.decode(dat);\\n    } else {\\n      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;\\n      if (r.length)\\n        err(8);\\n      return s;\\n    }\\n  }\\n  var slzh = function(d, b) {\\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\\n  };\\n  var zh = function(d, b, z) {\\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\\n    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];\\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\\n  };\\n  var z64e = function(d, b) {\\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\\n      ;\\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\\n  };\\n  var mt = typeof queueMicrotask == \"function\" ? queueMicrotask : typeof setTimeout == \"function\" ? setTimeout : function(fn) {\\n    fn();\\n  };\\n  function unzip(data, opts, cb) {\\n    if (!cb)\\n      cb = opts, opts = {};\\n    if (typeof cb != \"function\")\\n      err(7);\\n    var term = [];\\n    var tAll = function() {\\n      for (var i3 = 0; i3 < term.length; ++i3)\\n        term[i3]();\\n    };\\n    var files = {};\\n    var cbd = function(a, b) {\\n      mt(function() {\\n        cb(a, b);\\n      });\\n    };\\n    mt(function() {\\n      cbd = cb;\\n    });\\n    var e = data.length - 22;\\n    for (; b4(data, e) != 101010256; --e) {\\n      if (!e || data.length - e > 65558) {\\n        cbd(err(13, 0, 1), null);\\n        return tAll;\\n      }\\n    }\\n    var lft = b2(data, e + 8);\\n    if (lft) {\\n      var c = lft;\\n      var o = b4(data, e + 16);\\n      var z = o == 4294967295 || c == 65535;\\n      if (z) {\\n        var ze = b4(data, e - 12);\\n        z = b4(data, ze) == 101075792;\\n        if (z) {\\n          c = lft = b4(data, ze + 32);\\n          o = b4(data, ze + 48);\\n        }\\n      }\\n      var fltr = opts && opts.filter;\\n      var _loop_3 = function(i3) {\\n        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\\n        o = no;\\n        var cbl = function(e2, d) {\\n          if (e2) {\\n            tAll();\\n            cbd(e2, null);\\n          } else {\\n            if (d)\\n              files[fn] = d;\\n            if (!--lft)\\n              cbd(null, files);\\n          }\\n        };\\n        if (!fltr || fltr({\\n          name: fn,\\n          size: sc,\\n          originalSize: su,\\n          compression: c_1\\n        })) {\\n          if (!c_1)\\n            cbl(null, slc(data, b, b + sc));\\n          else if (c_1 == 8) {\\n            var infl = data.subarray(b, b + sc);\\n            if (su < 524288 || sc > 0.8 * su) {\\n              try {\\n                cbl(null, inflateSync(infl, { out: new u8(su) }));\\n              } catch (e2) {\\n                cbl(e2, null);\\n              }\\n            } else\\n              term.push(inflate(infl, { size: su }, cbl));\\n          } else\\n            cbl(err(14, \"unknown compression type \" + c_1, 1), null);\\n        } else\\n          cbl(null, null);\\n      };\\n      for (var i2 = 0; i2 < c; ++i2) {\\n        _loop_3(i2);\\n      }\\n    } else\\n      cbd(null, {});\\n    return tAll;\\n  }\\n  function unzipSync(data, opts) {\\n    var files = {};\\n    var e = data.length - 22;\\n    for (; b4(data, e) != 101010256; --e) {\\n      if (!e || data.length - e > 65558)\\n        err(13);\\n    }\\n    var c = b2(data, e + 8);\\n    if (!c)\\n      return {};\\n    var o = b4(data, e + 16);\\n    var z = o == 4294967295 || c == 65535;\\n    if (z) {\\n      var ze = b4(data, e - 12);\\n      z = b4(data, ze) == 101075792;\\n      if (z) {\\n        c = b4(data, ze + 32);\\n        o = b4(data, ze + 48);\\n      }\\n    }\\n    var fltr = opts && opts.filter;\\n    for (var i2 = 0; i2 < c; ++i2) {\\n      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\\n      o = no;\\n      if (!fltr || fltr({\\n        name: fn,\\n        size: sc,\\n        originalSize: su,\\n        compression: c_2\\n      })) {\\n        if (!c_2)\\n          files[fn] = slc(data, b, b + sc);\\n        else if (c_2 == 8)\\n          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\\n        else\\n          err(14, \"unknown compression type \" + c_2);\\n      }\\n    }\\n    return files;\\n  }\\n  /**\\n   * @license\\n   * Copyright 2010-2024 Three.js Authors\\n   * SPDX-License-Identifier: MIT\\n   */\\n  const REVISION = \"172\";\\n  const NoColorSpace = \"\";\\n  const SRGBColorSpace = \"srgb\";\\n  const LinearSRGBColorSpace = \"srgb-linear\";\\n  const LinearTransfer = \"linear\";\\n  const SRGBTransfer = \"srgb\";\\n  function clamp(value, min, max2) {\\n    return Math.max(min, Math.min(max2, value));\\n  }\\n  function euclideanModulo(n, m) {\\n    return (n % m + m) % m;\\n  }\\n  function lerp(x2, y, t) {\\n    return (1 - t) * x2 + t * y;\\n  }\\n  class Matrix3 {\\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\\n      Matrix3.prototype.isMatrix3 = true;\\n      this.elements = [\\n        1,\\n        0,\\n        0,\\n        0,\\n        1,\\n        0,\\n        0,\\n        0,\\n        1\\n      ];\\n      if (n11 !== void 0) {\\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\\n      }\\n    }\\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\\n      const te = this.elements;\\n      te[0] = n11;\\n      te[1] = n21;\\n      te[2] = n31;\\n      te[3] = n12;\\n      te[4] = n22;\\n      te[5] = n32;\\n      te[6] = n13;\\n      te[7] = n23;\\n      te[8] = n33;\\n      return this;\\n    }\\n    identity() {\\n      this.set(\\n        1,\\n        0,\\n        0,\\n        0,\\n        1,\\n        0,\\n        0,\\n        0,\\n        1\\n      );\\n      return this;\\n    }\\n    copy(m) {\\n      const te = this.elements;\\n      const me = m.elements;\\n      te[0] = me[0];\\n      te[1] = me[1];\\n      te[2] = me[2];\\n      te[3] = me[3];\\n      te[4] = me[4];\\n      te[5] = me[5];\\n      te[6] = me[6];\\n      te[7] = me[7];\\n      te[8] = me[8];\\n      return this;\\n    }\\n    extractBasis(xAxis, yAxis, zAxis) {\\n      xAxis.setFromMatrix3Column(this, 0);\\n      yAxis.setFromMatrix3Column(this, 1);\\n      zAxis.setFromMatrix3Column(this, 2);\\n      return this;\\n    }\\n    setFromMatrix4(m) {\\n      const me = m.elements;\\n      this.set(\\n        me[0],\\n        me[4],\\n        me[8],\\n        me[1],\\n        me[5],\\n        me[9],\\n        me[2],\\n        me[6],\\n        me[10]\\n      );\\n      return this;\\n    }\\n    multiply(m) {\\n      return this.multiplyMatrices(this, m);\\n    }\\n    premultiply(m) {\\n      return this.multiplyMatrices(m, this);\\n    }\\n    multiplyMatrices(a, b) {\\n      const ae = a.elements;\\n      const be = b.elements;\\n      const te = this.elements;\\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\\n      const b11 = be[0], b12 = be[3], b13 = be[6];\\n      const b21 = be[1], b22 = be[4], b23 = be[7];\\n      const b31 = be[2], b32 = be[5], b33 = be[8];\\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\\n      return this;\\n    }\\n    multiplyScalar(s) {\\n      const te = this.elements;\\n      te[0] *= s;\\n      te[3] *= s;\\n      te[6] *= s;\\n      te[1] *= s;\\n      te[4] *= s;\\n      te[7] *= s;\\n      te[2] *= s;\\n      te[5] *= s;\\n      te[8] *= s;\\n      return this;\\n    }\\n    determinant() {\\n      const te = this.elements;\\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\\n    }\\n    invert() {\\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\\n      const detInv = 1 / det;\\n      te[0] = t11 * detInv;\\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\\n      te[3] = t12 * detInv;\\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\\n      te[6] = t13 * detInv;\\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\\n      return this;\\n    }\\n    transpose() {\\n      let tmp;\\n      const m = this.elements;\\n      tmp = m[1];\\n      m[1] = m[3];\\n      m[3] = tmp;\\n      tmp = m[2];\\n      m[2] = m[6];\\n      m[6] = tmp;\\n      tmp = m[5];\\n      m[5] = m[7];\\n      m[7] = tmp;\\n      return this;\\n    }\\n    getNormalMatrix(matrix4) {\\n      return this.setFromMatrix4(matrix4).invert().transpose();\\n    }\\n    transposeIntoArray(r) {\\n      const m = this.elements;\\n      r[0] = m[0];\\n      r[1] = m[3];\\n      r[2] = m[6];\\n      r[3] = m[1];\\n      r[4] = m[4];\\n      r[5] = m[7];\\n      r[6] = m[2];\\n      r[7] = m[5];\\n      r[8] = m[8];\\n      return this;\\n    }\\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\\n      const c = Math.cos(rotation);\\n      const s = Math.sin(rotation);\\n      this.set(\\n        sx * c,\\n        sx * s,\\n        -sx * (c * cx + s * cy) + cx + tx,\\n        -sy * s,\\n        sy * c,\\n        -sy * (-s * cx + c * cy) + cy + ty,\\n        0,\\n        0,\\n        1\\n      );\\n      return this;\\n    }\\n    //\\n    scale(sx, sy) {\\n      this.premultiply(_m3.makeScale(sx, sy));\\n      return this;\\n    }\\n    rotate(theta) {\\n      this.premultiply(_m3.makeRotation(-theta));\\n      return this;\\n    }\\n    translate(tx, ty) {\\n      this.premultiply(_m3.makeTranslation(tx, ty));\\n      return this;\\n    }\\n    // for 2D Transforms\\n    makeTranslation(x2, y) {\\n      if (x2.isVector2) {\\n        this.set(\\n          1,\\n          0,\\n          x2.x,\\n          0,\\n          1,\\n          x2.y,\\n          0,\\n          0,\\n          1\\n        );\\n      } else {\\n        this.set(\\n          1,\\n          0,\\n          x2,\\n          0,\\n          1,\\n          y,\\n          0,\\n          0,\\n          1\\n        );\\n      }\\n      return this;\\n    }\\n    makeRotation(theta) {\\n      const c = Math.cos(theta);\\n      const s = Math.sin(theta);\\n      this.set(\\n        c,\\n        -s,\\n        0,\\n        s,\\n        c,\\n        0,\\n        0,\\n        0,\\n        1\\n      );\\n      return this;\\n    }\\n    makeScale(x2, y) {\\n      this.set(\\n        x2,\\n        0,\\n        0,\\n        0,\\n        y,\\n        0,\\n        0,\\n        0,\\n        1\\n      );\\n      return this;\\n    }\\n    //\\n    equals(matrix) {\\n      const te = this.elements;\\n      const me = matrix.elements;\\n      for (let i2 = 0; i2 < 9; i2++) {\\n        if (te[i2] !== me[i2]) return false;\\n      }\\n      return true;\\n    }\\n    fromArray(array, offset = 0) {\\n      for (let i2 = 0; i2 < 9; i2++) {\\n        this.elements[i2] = array[i2 + offset];\\n      }\\n      return this;\\n    }\\n    toArray(array = [], offset = 0) {\\n      const te = this.elements;\\n      array[offset] = te[0];\\n      array[offset + 1] = te[1];\\n      array[offset + 2] = te[2];\\n      array[offset + 3] = te[3];\\n      array[offset + 4] = te[4];\\n      array[offset + 5] = te[5];\\n      array[offset + 6] = te[6];\\n      array[offset + 7] = te[7];\\n      array[offset + 8] = te[8];\\n      return array;\\n    }\\n    clone() {\\n      return new this.constructor().fromArray(this.elements);\\n    }\\n  }\\n  const _m3 = /* @__PURE__ */ new Matrix3();\\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\\n    0.4123908,\\n    0.3575843,\\n    0.1804808,\\n    0.212639,\\n    0.7151687,\\n    0.0721923,\\n    0.0193308,\\n    0.1191948,\\n    0.9505322\\n  );\\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\\n    3.2409699,\\n    -1.5373832,\\n    -0.4986108,\\n    -0.9692436,\\n    1.8759675,\\n    0.0415551,\\n    0.0556301,\\n    -0.203977,\\n    1.0569715\\n  );\\n  function createColorManagement() {\\n    const ColorManagement2 = {\\n      enabled: true,\\n      workingColorSpace: LinearSRGBColorSpace,\\n      /**\\n       * Implementations of supported color spaces.\\n       *\\n       * Required:\\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\\n       *\t- whitePoint: reference white [ x y ]\\n       *\t- transfer: transfer function (pre-defined)\\n       *\t- toXYZ: Matrix3 RGB to XYZ transform\\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\\n       *\t- luminanceCoefficients: RGB luminance coefficients\\n       *\\n       * Optional:\\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\\n       *\\n       * Reference:\\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\\n       */\\n      spaces: {},\\n      convert: function(color, sourceColorSpace, targetColorSpace) {\\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\\n          return color;\\n        }\\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\\n          color.r = SRGBToLinear(color.r);\\n          color.g = SRGBToLinear(color.g);\\n          color.b = SRGBToLinear(color.b);\\n        }\\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\\n        }\\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\\n          color.r = LinearToSRGB(color.r);\\n          color.g = LinearToSRGB(color.g);\\n          color.b = LinearToSRGB(color.b);\\n        }\\n        return color;\\n      },\\n      fromWorkingColorSpace: function(color, targetColorSpace) {\\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\\n      },\\n      toWorkingColorSpace: function(color, sourceColorSpace) {\\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\\n      },\\n      getPrimaries: function(colorSpace) {\\n        return this.spaces[colorSpace].primaries;\\n      },\\n      getTransfer: function(colorSpace) {\\n        if (colorSpace === NoColorSpace) return LinearTransfer;\\n        return this.spaces[colorSpace].transfer;\\n      },\\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\\n      },\\n      define: function(colorSpaces) {\\n        Object.assign(this.spaces, colorSpaces);\\n      },\\n      // Internal APIs\\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\\n      },\\n      _getDrawingBufferColorSpace: function(colorSpace) {\\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\\n      },\\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\\n      }\\n    };\\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\\n    const D65 = [0.3127, 0.329];\\n    ColorManagement2.define({\\n      [LinearSRGBColorSpace]: {\\n        primaries: REC709_PRIMARIES,\\n        whitePoint: D65,\\n        transfer: LinearTransfer,\\n        toXYZ: LINEAR_REC709_TO_XYZ,\\n        fromXYZ: XYZ_TO_LINEAR_REC709,\\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\\n      },\\n      [SRGBColorSpace]: {\\n        primaries: REC709_PRIMARIES,\\n        whitePoint: D65,\\n        transfer: SRGBTransfer,\\n        toXYZ: LINEAR_REC709_TO_XYZ,\\n        fromXYZ: XYZ_TO_LINEAR_REC709,\\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\\n      }\\n    });\\n    return ColorManagement2;\\n  }\\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\\n  function SRGBToLinear(c) {\\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\\n  }\\n  function LinearToSRGB(c) {\\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\\n  }\\n  class Quaternion {\\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\\n      this.isQuaternion = true;\\n      this._x = x2;\\n      this._y = y;\\n      this._z = z;\\n      this._w = w;\\n    }\\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\\n      if (t === 0) {\\n        dst[dstOffset + 0] = x0;\\n        dst[dstOffset + 1] = y0;\\n        dst[dstOffset + 2] = z0;\\n        dst[dstOffset + 3] = w0;\\n        return;\\n      }\\n      if (t === 1) {\\n        dst[dstOffset + 0] = x1;\\n        dst[dstOffset + 1] = y1;\\n        dst[dstOffset + 2] = z1;\\n        dst[dstOffset + 3] = w1;\\n        return;\\n      }\\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\\n        let s = 1 - t;\\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\\n        if (sqrSin > Number.EPSILON) {\\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\\n          s = Math.sin(s * len) / sin;\\n          t = Math.sin(t * len) / sin;\\n        }\\n        const tDir = t * dir;\\n        x0 = x0 * s + x1 * tDir;\\n        y0 = y0 * s + y1 * tDir;\\n        z0 = z0 * s + z1 * tDir;\\n        w0 = w0 * s + w1 * tDir;\\n        if (s === 1 - t) {\\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\\n          x0 *= f;\\n          y0 *= f;\\n          z0 *= f;\\n          w0 *= f;\\n        }\\n      }\\n      dst[dstOffset] = x0;\\n      dst[dstOffset + 1] = y0;\\n      dst[dstOffset + 2] = z0;\\n      dst[dstOffset + 3] = w0;\\n    }\\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\\n      const x0 = src0[srcOffset0];\\n      const y0 = src0[srcOffset0 + 1];\\n      const z0 = src0[srcOffset0 + 2];\\n      const w0 = src0[srcOffset0 + 3];\\n      const x1 = src1[srcOffset1];\\n      const y1 = src1[srcOffset1 + 1];\\n      const z1 = src1[srcOffset1 + 2];\\n      const w1 = src1[srcOffset1 + 3];\\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\\n      return dst;\\n    }\\n    get x() {\\n      return this._x;\\n    }\\n    set x(value) {\\n      this._x = value;\\n      this._onChangeCallback();\\n    }\\n    get y() {\\n      return this._y;\\n    }\\n    set y(value) {\\n      this._y = value;\\n      this._onChangeCallback();\\n    }\\n    get z() {\\n      return this._z;\\n    }\\n    set z(value) {\\n      this._z = value;\\n      this._onChangeCallback();\\n    }\\n    get w() {\\n      return this._w;\\n    }\\n    set w(value) {\\n      this._w = value;\\n      this._onChangeCallback();\\n    }\\n    set(x2, y, z, w) {\\n      this._x = x2;\\n      this._y = y;\\n      this._z = z;\\n      this._w = w;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    clone() {\\n      return new this.constructor(this._x, this._y, this._z, this._w);\\n    }\\n    copy(quaternion) {\\n      this._x = quaternion.x;\\n      this._y = quaternion.y;\\n      this._z = quaternion.z;\\n      this._w = quaternion.w;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    setFromEuler(euler, update = true) {\\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\\n      const cos = Math.cos;\\n      const sin = Math.sin;\\n      const c1 = cos(x2 / 2);\\n      const c2 = cos(y / 2);\\n      const c3 = cos(z / 2);\\n      const s1 = sin(x2 / 2);\\n      const s2 = sin(y / 2);\\n      const s3 = sin(z / 2);\\n      switch (order) {\\n        case \"XYZ\":\\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n          break;\\n        case \"YXZ\":\\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n          break;\\n        case \"ZXY\":\\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n          break;\\n        case \"ZYX\":\\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n          break;\\n        case \"YZX\":\\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n          break;\\n        case \"XZY\":\\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n          break;\\n        default:\\n          console.warn(\"THREE.Quaternion: .setFromEuler() encountered an unknown order: \" + order);\\n      }\\n      if (update === true) this._onChangeCallback();\\n      return this;\\n    }\\n    setFromAxisAngle(axis, angle) {\\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\\n      this._x = axis.x * s;\\n      this._y = axis.y * s;\\n      this._z = axis.z * s;\\n      this._w = Math.cos(halfAngle);\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    setFromRotationMatrix(m) {\\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\\n      if (trace > 0) {\\n        const s = 0.5 / Math.sqrt(trace + 1);\\n        this._w = 0.25 / s;\\n        this._x = (m32 - m23) * s;\\n        this._y = (m13 - m31) * s;\\n        this._z = (m21 - m12) * s;\\n      } else if (m11 > m22 && m11 > m33) {\\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\\n        this._w = (m32 - m23) / s;\\n        this._x = 0.25 * s;\\n        this._y = (m12 + m21) / s;\\n        this._z = (m13 + m31) / s;\\n      } else if (m22 > m33) {\\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\\n        this._w = (m13 - m31) / s;\\n        this._x = (m12 + m21) / s;\\n        this._y = 0.25 * s;\\n        this._z = (m23 + m32) / s;\\n      } else {\\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\\n        this._w = (m21 - m12) / s;\\n        this._x = (m13 + m31) / s;\\n        this._y = (m23 + m32) / s;\\n        this._z = 0.25 * s;\\n      }\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    setFromUnitVectors(vFrom, vTo) {\\n      let r = vFrom.dot(vTo) + 1;\\n      if (r < Number.EPSILON) {\\n        r = 0;\\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\\n          this._x = -vFrom.y;\\n          this._y = vFrom.x;\\n          this._z = 0;\\n          this._w = r;\\n        } else {\\n          this._x = 0;\\n          this._y = -vFrom.z;\\n          this._z = vFrom.y;\\n          this._w = r;\\n        }\\n      } else {\\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\\n        this._w = r;\\n      }\\n      return this.normalize();\\n    }\\n    angleTo(q) {\\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\\n    }\\n    rotateTowards(q, step) {\\n      const angle = this.angleTo(q);\\n      if (angle === 0) return this;\\n      const t = Math.min(1, step / angle);\\n      this.slerp(q, t);\\n      return this;\\n    }\\n    identity() {\\n      return this.set(0, 0, 0, 1);\\n    }\\n    invert() {\\n      return this.conjugate();\\n    }\\n    conjugate() {\\n      this._x *= -1;\\n      this._y *= -1;\\n      this._z *= -1;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    dot(v) {\\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\n    }\\n    lengthSq() {\\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\n    }\\n    length() {\\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\\n    }\\n    normalize() {\\n      let l = this.length();\\n      if (l === 0) {\\n        this._x = 0;\\n        this._y = 0;\\n        this._z = 0;\\n        this._w = 1;\\n      } else {\\n        l = 1 / l;\\n        this._x = this._x * l;\\n        this._y = this._y * l;\\n        this._z = this._z * l;\\n        this._w = this._w * l;\\n      }\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    multiply(q) {\\n      return this.multiplyQuaternions(this, q);\\n    }\\n    premultiply(q) {\\n      return this.multiplyQuaternions(q, this);\\n    }\\n    multiplyQuaternions(a, b) {\\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    slerp(qb, t) {\\n      if (t === 0) return this;\\n      if (t === 1) return this.copy(qb);\\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\\n      if (cosHalfTheta < 0) {\\n        this._w = -qb._w;\\n        this._x = -qb._x;\\n        this._y = -qb._y;\\n        this._z = -qb._z;\\n        cosHalfTheta = -cosHalfTheta;\\n      } else {\\n        this.copy(qb);\\n      }\\n      if (cosHalfTheta >= 1) {\\n        this._w = w;\\n        this._x = x2;\\n        this._y = y;\\n        this._z = z;\\n        return this;\\n      }\\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\\n      if (sqrSinHalfTheta <= Number.EPSILON) {\\n        const s = 1 - t;\\n        this._w = s * w + t * this._w;\\n        this._x = s * x2 + t * this._x;\\n        this._y = s * y + t * this._y;\\n        this._z = s * z + t * this._z;\\n        this.normalize();\\n        return this;\\n      }\\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\\n      this._w = w * ratioA + this._w * ratioB;\\n      this._x = x2 * ratioA + this._x * ratioB;\\n      this._y = y * ratioA + this._y * ratioB;\\n      this._z = z * ratioA + this._z * ratioB;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    slerpQuaternions(qa, qb, t) {\\n      return this.copy(qa).slerp(qb, t);\\n    }\\n    random() {\\n      const theta1 = 2 * Math.PI * Math.random();\\n      const theta2 = 2 * Math.PI * Math.random();\\n      const x0 = Math.random();\\n      const r1 = Math.sqrt(1 - x0);\\n      const r2 = Math.sqrt(x0);\\n      return this.set(\\n        r1 * Math.sin(theta1),\\n        r1 * Math.cos(theta1),\\n        r2 * Math.sin(theta2),\\n        r2 * Math.cos(theta2)\\n      );\\n    }\\n    equals(quaternion) {\\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\\n    }\\n    fromArray(array, offset = 0) {\\n      this._x = array[offset];\\n      this._y = array[offset + 1];\\n      this._z = array[offset + 2];\\n      this._w = array[offset + 3];\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    toArray(array = [], offset = 0) {\\n      array[offset] = this._x;\\n      array[offset + 1] = this._y;\\n      array[offset + 2] = this._z;\\n      array[offset + 3] = this._w;\\n      return array;\\n    }\\n    fromBufferAttribute(attribute, index) {\\n      this._x = attribute.getX(index);\\n      this._y = attribute.getY(index);\\n      this._z = attribute.getZ(index);\\n      this._w = attribute.getW(index);\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    toJSON() {\\n      return this.toArray();\\n    }\\n    _onChange(callback) {\\n      this._onChangeCallback = callback;\\n      return this;\\n    }\\n    _onChangeCallback() {\\n    }\\n    *[Symbol.iterator]() {\\n      yield this._x;\\n      yield this._y;\\n      yield this._z;\\n      yield this._w;\\n    }\\n  }\\n  class Vector3 {\\n    constructor(x2 = 0, y = 0, z = 0) {\\n      Vector3.prototype.isVector3 = true;\\n      this.x = x2;\\n      this.y = y;\\n      this.z = z;\\n    }\\n    set(x2, y, z) {\\n      if (z === void 0) z = this.z;\\n      this.x = x2;\\n      this.y = y;\\n      this.z = z;\\n      return this;\\n    }\\n    setScalar(scalar) {\\n      this.x = scalar;\\n      this.y = scalar;\\n      this.z = scalar;\\n      return this;\\n    }\\n    setX(x2) {\\n      this.x = x2;\\n      return this;\\n    }\\n    setY(y) {\\n      this.y = y;\\n      return this;\\n    }\\n    setZ(z) {\\n      this.z = z;\\n      return this;\\n    }\\n    setComponent(index, value) {\\n      switch (index) {\\n        case 0:\\n          this.x = value;\\n          break;\\n        case 1:\\n          this.y = value;\\n          break;\\n        case 2:\\n          this.z = value;\\n          break;\\n        default:\\n          throw new Error(\"index is out of range: \" + index);\\n      }\\n      return this;\\n    }\\n    getComponent(index) {\\n      switch (index) {\\n        case 0:\\n          return this.x;\\n        case 1:\\n          return this.y;\\n        case 2:\\n          return this.z;\\n        default:\\n          throw new Error(\"index is out of range: \" + index);\\n      }\\n    }\\n    clone() {\\n      return new this.constructor(this.x, this.y, this.z);\\n    }\\n    copy(v) {\\n      this.x = v.x;\\n      this.y = v.y;\\n      this.z = v.z;\\n      return this;\\n    }\\n    add(v) {\\n      this.x += v.x;\\n      this.y += v.y;\\n      this.z += v.z;\\n      return this;\\n    }\\n    addScalar(s) {\\n      this.x += s;\\n      this.y += s;\\n      this.z += s;\\n      return this;\\n    }\\n    addVectors(a, b) {\\n      this.x = a.x + b.x;\\n      this.y = a.y + b.y;\\n      this.z = a.z + b.z;\\n      return this;\\n    }\\n    addScaledVector(v, s) {\\n      this.x += v.x * s;\\n      this.y += v.y * s;\\n      this.z += v.z * s;\\n      return this;\\n    }\\n    sub(v) {\\n      this.x -= v.x;\\n      this.y -= v.y;\\n      this.z -= v.z;\\n      return this;\\n    }\\n    subScalar(s) {\\n      this.x -= s;\\n      this.y -= s;\\n      this.z -= s;\\n      return this;\\n    }\\n    subVectors(a, b) {\\n      this.x = a.x - b.x;\\n      this.y = a.y - b.y;\\n      this.z = a.z - b.z;\\n      return this;\\n    }\\n    multiply(v) {\\n      this.x *= v.x;\\n      this.y *= v.y;\\n      this.z *= v.z;\\n      return this;\\n    }\\n    multiplyScalar(scalar) {\\n      this.x *= scalar;\\n      this.y *= scalar;\\n      this.z *= scalar;\\n      return this;\\n    }\\n    multiplyVectors(a, b) {\\n      this.x = a.x * b.x;\\n      this.y = a.y * b.y;\\n      this.z = a.z * b.z;\\n      return this;\\n    }\\n    applyEuler(euler) {\\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\\n    }\\n    applyAxisAngle(axis, angle) {\\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\\n    }\\n    applyMatrix3(m) {\\n      const x2 = this.x, y = this.y, z = this.z;\\n      const e = m.elements;\\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\\n      return this;\\n    }\\n    applyNormalMatrix(m) {\\n      return this.applyMatrix3(m).normalize();\\n    }\\n    applyMatrix4(m) {\\n      const x2 = this.x, y = this.y, z = this.z;\\n      const e = m.elements;\\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\\n      return this;\\n    }\\n    applyQuaternion(q) {\\n      const vx = this.x, vy = this.y, vz = this.z;\\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\\n      const tx = 2 * (qy * vz - qz * vy);\\n      const ty = 2 * (qz * vx - qx * vz);\\n      const tz = 2 * (qx * vy - qy * vx);\\n      this.x = vx + qw * tx + qy * tz - qz * ty;\\n      this.y = vy + qw * ty + qz * tx - qx * tz;\\n      this.z = vz + qw * tz + qx * ty - qy * tx;\\n      return this;\\n    }\\n    project(camera) {\\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\\n    }\\n    unproject(camera) {\\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\\n    }\\n    transformDirection(m) {\\n      const x2 = this.x, y = this.y, z = this.z;\\n      const e = m.elements;\\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\\n      return this.normalize();\\n    }\\n    divide(v) {\\n      this.x /= v.x;\\n      this.y /= v.y;\\n      this.z /= v.z;\\n      return this;\\n    }\\n    divideScalar(scalar) {\\n      return this.multiplyScalar(1 / scalar);\\n    }\\n    min(v) {\\n      this.x = Math.min(this.x, v.x);\\n      this.y = Math.min(this.y, v.y);\\n      this.z = Math.min(this.z, v.z);\\n      return this;\\n    }\\n    max(v) {\\n      this.x = Math.max(this.x, v.x);\\n      this.y = Math.max(this.y, v.y);\\n      this.z = Math.max(this.z, v.z);\\n      return this;\\n    }\\n    clamp(min, max2) {\\n      this.x = clamp(this.x, min.x, max2.x);\\n      this.y = clamp(this.y, min.y, max2.y);\\n      this.z = clamp(this.z, min.z, max2.z);\\n      return this;\\n    }\\n    clampScalar(minVal, maxVal) {\\n      this.x = clamp(this.x, minVal, maxVal);\\n      this.y = clamp(this.y, minVal, maxVal);\\n      this.z = clamp(this.z, minVal, maxVal);\\n      return this;\\n    }\\n    clampLength(min, max2) {\\n      const length = this.length();\\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\\n    }\\n    floor() {\\n      this.x = Math.floor(this.x);\\n      this.y = Math.floor(this.y);\\n      this.z = Math.floor(this.z);\\n      return this;\\n    }\\n    ceil() {\\n      this.x = Math.ceil(this.x);\\n      this.y = Math.ceil(this.y);\\n      this.z = Math.ceil(this.z);\\n      return this;\\n    }\\n    round() {\\n      this.x = Math.round(this.x);\\n      this.y = Math.round(this.y);\\n      this.z = Math.round(this.z);\\n      return this;\\n    }\\n    roundToZero() {\\n      this.x = Math.trunc(this.x);\\n      this.y = Math.trunc(this.y);\\n      this.z = Math.trunc(this.z);\\n      return this;\\n    }\\n    negate() {\\n      this.x = -this.x;\\n      this.y = -this.y;\\n      this.z = -this.z;\\n      return this;\\n    }\\n    dot(v) {\\n      return this.x * v.x + this.y * v.y + this.z * v.z;\\n    }\\n    // TODO lengthSquared?\\n    lengthSq() {\\n      return this.x * this.x + this.y * this.y + this.z * this.z;\\n    }\\n    length() {\\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\\n    }\\n    manhattanLength() {\\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\\n    }\\n    normalize() {\\n      return this.divideScalar(this.length() || 1);\\n    }\\n    setLength(length) {\\n      return this.normalize().multiplyScalar(length);\\n    }\\n    lerp(v, alpha) {\\n      this.x += (v.x - this.x) * alpha;\\n      this.y += (v.y - this.y) * alpha;\\n      this.z += (v.z - this.z) * alpha;\\n      return this;\\n    }\\n    lerpVectors(v1, v2, alpha) {\\n      this.x = v1.x + (v2.x - v1.x) * alpha;\\n      this.y = v1.y + (v2.y - v1.y) * alpha;\\n      this.z = v1.z + (v2.z - v1.z) * alpha;\\n      return this;\\n    }\\n    cross(v) {\\n      return this.crossVectors(this, v);\\n    }\\n    crossVectors(a, b) {\\n      const ax = a.x, ay = a.y, az = a.z;\\n      const bx = b.x, by = b.y, bz = b.z;\\n      this.x = ay * bz - az * by;\\n      this.y = az * bx - ax * bz;\\n      this.z = ax * by - ay * bx;\\n      return this;\\n    }\\n    projectOnVector(v) {\\n      const denominator = v.lengthSq();\\n      if (denominator === 0) return this.set(0, 0, 0);\\n      const scalar = v.dot(this) / denominator;\\n      return this.copy(v).multiplyScalar(scalar);\\n    }\\n    projectOnPlane(planeNormal) {\\n      _vector$c.copy(this).projectOnVector(planeNormal);\\n      return this.sub(_vector$c);\\n    }\\n    reflect(normal) {\\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\\n    }\\n    angleTo(v) {\\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\\n      if (denominator === 0) return Math.PI / 2;\\n      const theta = this.dot(v) / denominator;\\n      return Math.acos(clamp(theta, -1, 1));\\n    }\\n    distanceTo(v) {\\n      return Math.sqrt(this.distanceToSquared(v));\\n    }\\n    distanceToSquared(v) {\\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\\n      return dx * dx + dy * dy + dz * dz;\\n    }\\n    manhattanDistanceTo(v) {\\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\\n    }\\n    setFromSpherical(s) {\\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\\n    }\\n    setFromSphericalCoords(radius, phi, theta) {\\n      const sinPhiRadius = Math.sin(phi) * radius;\\n      this.x = sinPhiRadius * Math.sin(theta);\\n      this.y = Math.cos(phi) * radius;\\n      this.z = sinPhiRadius * Math.cos(theta);\\n      return this;\\n    }\\n    setFromCylindrical(c) {\\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\\n    }\\n    setFromCylindricalCoords(radius, theta, y) {\\n      this.x = radius * Math.sin(theta);\\n      this.y = y;\\n      this.z = radius * Math.cos(theta);\\n      return this;\\n    }\\n    setFromMatrixPosition(m) {\\n      const e = m.elements;\\n      this.x = e[12];\\n      this.y = e[13];\\n      this.z = e[14];\\n      return this;\\n    }\\n    setFromMatrixScale(m) {\\n      const sx = this.setFromMatrixColumn(m, 0).length();\\n      const sy = this.setFromMatrixColumn(m, 1).length();\\n      const sz = this.setFromMatrixColumn(m, 2).length();\\n      this.x = sx;\\n      this.y = sy;\\n      this.z = sz;\\n      return this;\\n    }\\n    setFromMatrixColumn(m, index) {\\n      return this.fromArray(m.elements, index * 4);\\n    }\\n    setFromMatrix3Column(m, index) {\\n      return this.fromArray(m.elements, index * 3);\\n    }\\n    setFromEuler(e) {\\n      this.x = e._x;\\n      this.y = e._y;\\n      this.z = e._z;\\n      return this;\\n    }\\n    setFromColor(c) {\\n      this.x = c.r;\\n      this.y = c.g;\\n      this.z = c.b;\\n      return this;\\n    }\\n    equals(v) {\\n      return v.x === this.x && v.y === this.y && v.z === this.z;\\n    }\\n    fromArray(array, offset = 0) {\\n      this.x = array[offset];\\n      this.y = array[offset + 1];\\n      this.z = array[offset + 2];\\n      return this;\\n    }\\n    toArray(array = [], offset = 0) {\\n      array[offset] = this.x;\\n      array[offset + 1] = this.y;\\n      array[offset + 2] = this.z;\\n      return array;\\n    }\\n    fromBufferAttribute(attribute, index) {\\n      this.x = attribute.getX(index);\\n      this.y = attribute.getY(index);\\n      this.z = attribute.getZ(index);\\n      return this;\\n    }\\n    random() {\\n      this.x = Math.random();\\n      this.y = Math.random();\\n      this.z = Math.random();\\n      return this;\\n    }\\n    randomDirection() {\\n      const theta = Math.random() * Math.PI * 2;\\n      const u = Math.random() * 2 - 1;\\n      const c = Math.sqrt(1 - u * u);\\n      this.x = c * Math.cos(theta);\\n      this.y = u;\\n      this.z = c * Math.sin(theta);\\n      return this;\\n    }\\n    *[Symbol.iterator]() {\\n      yield this.x;\\n      yield this.y;\\n      yield this.z;\\n    }\\n  }\\n  const _vector$c = /* @__PURE__ */ new Vector3();\\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\\n  class Box3 {\\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\\n      this.isBox3 = true;\\n      this.min = min;\\n      this.max = max2;\\n    }\\n    set(min, max2) {\\n      this.min.copy(min);\\n      this.max.copy(max2);\\n      return this;\\n    }\\n    setFromArray(array) {\\n      this.makeEmpty();\\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\\n        this.expandByPoint(_vector$b.fromArray(array, i2));\\n      }\\n      return this;\\n    }\\n    setFromBufferAttribute(attribute) {\\n      this.makeEmpty();\\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\\n      }\\n      return this;\\n    }\\n    setFromPoints(points) {\\n      this.makeEmpty();\\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\\n        this.expandByPoint(points[i2]);\\n      }\\n      return this;\\n    }\\n    setFromCenterAndSize(center, size) {\\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\\n      this.min.copy(center).sub(halfSize);\\n      this.max.copy(center).add(halfSize);\\n      return this;\\n    }\\n    setFromObject(object, precise = false) {\\n      this.makeEmpty();\\n      return this.expandByObject(object, precise);\\n    }\\n    clone() {\\n      return new this.constructor().copy(this);\\n    }\\n    copy(box) {\\n      this.min.copy(box.min);\\n      this.max.copy(box.max);\\n      return this;\\n    }\\n    makeEmpty() {\\n      this.min.x = this.min.y = this.min.z = Infinity;\\n      this.max.x = this.max.y = this.max.z = -Infinity;\\n      return this;\\n    }\\n    isEmpty() {\\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\\n    }\\n    getCenter(target) {\\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\\n    }\\n    getSize(target) {\\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\\n    }\\n    expandByPoint(point) {\\n      this.min.min(point);\\n      this.max.max(point);\\n      return this;\\n    }\\n    expandByVector(vector) {\\n      this.min.sub(vector);\\n      this.max.add(vector);\\n      return this;\\n    }\\n    expandByScalar(scalar) {\\n      this.min.addScalar(-scalar);\\n      this.max.addScalar(scalar);\\n      return this;\\n    }\\n    expandByObject(object, precise = false) {\\n      object.updateWorldMatrix(false, false);\\n      const geometry = object.geometry;\\n      if (geometry !== void 0) {\\n        const positionAttribute = geometry.getAttribute(\"position\");\\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\\n            if (object.isMesh === true) {\\n              object.getVertexPosition(i2, _vector$b);\\n            } else {\\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\\n            }\\n            _vector$b.applyMatrix4(object.matrixWorld);\\n            this.expandByPoint(_vector$b);\\n          }\\n        } else {\\n          if (object.boundingBox !== void 0) {\\n            if (object.boundingBox === null) {\\n              object.computeBoundingBox();\\n            }\\n            _box$4.copy(object.boundingBox);\\n          } else {\\n            if (geometry.boundingBox === null) {\\n              geometry.computeBoundingBox();\\n            }\\n            _box$4.copy(geometry.boundingBox);\\n          }\\n          _box$4.applyMatrix4(object.matrixWorld);\\n          this.union(_box$4);\\n        }\\n      }\\n      const children = object.children;\\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\\n        this.expandByObject(children[i2], precise);\\n      }\\n      return this;\\n    }\\n    containsPoint(point) {\\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\\n    }\\n    containsBox(box) {\\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\\n    }\\n    getParameter(point, target) {\\n      return target.set(\\n        (point.x - this.min.x) / (this.max.x - this.min.x),\\n        (point.y - this.min.y) / (this.max.y - this.min.y),\\n        (point.z - this.min.z) / (this.max.z - this.min.z)\\n      );\\n    }\\n    intersectsBox(box) {\\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\\n    }\\n    intersectsSphere(sphere) {\\n      this.clampPoint(sphere.center, _vector$b);\\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\\n    }\\n    intersectsPlane(plane) {\\n      let min, max2;\\n      if (plane.normal.x > 0) {\\n        min = plane.normal.x * this.min.x;\\n        max2 = plane.normal.x * this.max.x;\\n      } else {\\n        min = plane.normal.x * this.max.x;\\n        max2 = plane.normal.x * this.min.x;\\n      }\\n      if (plane.normal.y > 0) {\\n        min += plane.normal.y * this.min.y;\\n        max2 += plane.normal.y * this.max.y;\\n      } else {\\n        min += plane.normal.y * this.max.y;\\n        max2 += plane.normal.y * this.min.y;\\n      }\\n      if (plane.normal.z > 0) {\\n        min += plane.normal.z * this.min.z;\\n        max2 += plane.normal.z * this.max.z;\\n      } else {\\n        min += plane.normal.z * this.max.z;\\n        max2 += plane.normal.z * this.min.z;\\n      }\\n      return min <= -plane.constant && max2 >= -plane.constant;\\n    }\\n    intersectsTriangle(triangle) {\\n      if (this.isEmpty()) {\\n        return false;\\n      }\\n      this.getCenter(_center);\\n      _extents.subVectors(this.max, _center);\\n      _v0$2.subVectors(triangle.a, _center);\\n      _v1$7.subVectors(triangle.b, _center);\\n      _v2$4.subVectors(triangle.c, _center);\\n      _f0.subVectors(_v1$7, _v0$2);\\n      _f1.subVectors(_v2$4, _v1$7);\\n      _f2.subVectors(_v0$2, _v2$4);\\n      let axes = [\\n        0,\\n        -_f0.z,\\n        _f0.y,\\n        0,\\n        -_f1.z,\\n        _f1.y,\\n        0,\\n        -_f2.z,\\n        _f2.y,\\n        _f0.z,\\n        0,\\n        -_f0.x,\\n        _f1.z,\\n        0,\\n        -_f1.x,\\n        _f2.z,\\n        0,\\n        -_f2.x,\\n        -_f0.y,\\n        _f0.x,\\n        0,\\n        -_f1.y,\\n        _f1.x,\\n        0,\\n        -_f2.y,\\n        _f2.x,\\n        0\\n      ];\\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\\n        return false;\\n      }\\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\\n        return false;\\n      }\\n      _triangleNormal.crossVectors(_f0, _f1);\\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\\n    }\\n    clampPoint(point, target) {\\n      return target.copy(point).clamp(this.min, this.max);\\n    }\\n    distanceToPoint(point) {\\n      return this.clampPoint(point, _vector$b).distanceTo(point);\\n    }\\n    getBoundingSphere(target) {\\n      if (this.isEmpty()) {\\n        target.makeEmpty();\\n      } else {\\n        this.getCenter(target.center);\\n        target.radius = this.getSize(_vector$b).length() * 0.5;\\n      }\\n      return target;\\n    }\\n    intersect(box) {\\n      this.min.max(box.min);\\n      this.max.min(box.max);\\n      if (this.isEmpty()) this.makeEmpty();\\n      return this;\\n    }\\n    union(box) {\\n      this.min.min(box.min);\\n      this.max.max(box.max);\\n      return this;\\n    }\\n    applyMatrix4(matrix) {\\n      if (this.isEmpty()) return this;\\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\\n      this.setFromPoints(_points);\\n      return this;\\n    }\\n    translate(offset) {\\n      this.min.add(offset);\\n      this.max.add(offset);\\n      return this;\\n    }\\n    equals(box) {\\n      return box.min.equals(this.min) && box.max.equals(this.max);\\n    }\\n  }\\n  const _points = [\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new Vector3()\\n  ];\\n  const _vector$b = /* @__PURE__ */ new Vector3();\\n  const _box$4 = /* @__PURE__ */ new Box3();\\n  const _v0$2 = /* @__PURE__ */ new Vector3();\\n  const _v1$7 = /* @__PURE__ */ new Vector3();\\n  const _v2$4 = /* @__PURE__ */ new Vector3();\\n  const _f0 = /* @__PURE__ */ new Vector3();\\n  const _f1 = /* @__PURE__ */ new Vector3();\\n  const _f2 = /* @__PURE__ */ new Vector3();\\n  const _center = /* @__PURE__ */ new Vector3();\\n  const _extents = /* @__PURE__ */ new Vector3();\\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\\n  const _testAxis = /* @__PURE__ */ new Vector3();\\n  function satForAxes(axes, v0, v1, v2, extents) {\\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\\n      _testAxis.fromArray(axes, i2);\\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\\n      const p0 = v0.dot(_testAxis);\\n      const p1 = v1.dot(_testAxis);\\n      const p2 = v2.dot(_testAxis);\\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n  const _colorKeywords = {\\n    \"aliceblue\": 15792383,\\n    \"antiquewhite\": 16444375,\\n    \"aqua\": 65535,\\n    \"aquamarine\": 8388564,\\n    \"azure\": 15794175,\\n    \"beige\": 16119260,\\n    \"bisque\": 16770244,\\n    \"black\": 0,\\n    \"blanchedalmond\": 16772045,\\n    \"blue\": 255,\\n    \"blueviolet\": 9055202,\\n    \"brown\": 10824234,\\n    \"burlywood\": 14596231,\\n    \"cadetblue\": 6266528,\\n    \"chartreuse\": 8388352,\\n    \"chocolate\": 13789470,\\n    \"coral\": 16744272,\\n    \"cornflowerblue\": 6591981,\\n    \"cornsilk\": 16775388,\\n    \"crimson\": 14423100,\\n    \"cyan\": 65535,\\n    \"darkblue\": 139,\\n    \"darkcyan\": 35723,\\n    \"darkgoldenrod\": 12092939,\\n    \"darkgray\": 11119017,\\n    \"darkgreen\": 25600,\\n    \"darkgrey\": 11119017,\\n    \"darkkhaki\": 12433259,\\n    \"darkmagenta\": 9109643,\\n    \"darkolivegreen\": 5597999,\\n    \"darkorange\": 16747520,\\n    \"darkorchid\": 10040012,\\n    \"darkred\": 9109504,\\n    \"darksalmon\": 15308410,\\n    \"darkseagreen\": 9419919,\\n    \"darkslateblue\": 4734347,\\n    \"darkslategray\": 3100495,\\n    \"darkslategrey\": 3100495,\\n    \"darkturquoise\": 52945,\\n    \"darkviolet\": 9699539,\\n    \"deeppink\": 16716947,\\n    \"deepskyblue\": 49151,\\n    \"dimgray\": 6908265,\\n    \"dimgrey\": 6908265,\\n    \"dodgerblue\": 2003199,\\n    \"firebrick\": 11674146,\\n    \"floralwhite\": 16775920,\\n    \"forestgreen\": 2263842,\\n    \"fuchsia\": 16711935,\\n    \"gainsboro\": 14474460,\\n    \"ghostwhite\": 16316671,\\n    \"gold\": 16766720,\\n    \"goldenrod\": 14329120,\\n    \"gray\": 8421504,\\n    \"green\": 32768,\\n    \"greenyellow\": 11403055,\\n    \"grey\": 8421504,\\n    \"honeydew\": 15794160,\\n    \"hotpink\": 16738740,\\n    \"indianred\": 13458524,\\n    \"indigo\": 4915330,\\n    \"ivory\": 16777200,\\n    \"khaki\": 15787660,\\n    \"lavender\": 15132410,\\n    \"lavenderblush\": 16773365,\\n    \"lawngreen\": 8190976,\\n    \"lemonchiffon\": 16775885,\\n    \"lightblue\": 11393254,\\n    \"lightcoral\": 15761536,\\n    \"lightcyan\": 14745599,\\n    \"lightgoldenrodyellow\": 16448210,\\n    \"lightgray\": 13882323,\\n    \"lightgreen\": 9498256,\\n    \"lightgrey\": 13882323,\\n    \"lightpink\": 16758465,\\n    \"lightsalmon\": 16752762,\\n    \"lightseagreen\": 2142890,\\n    \"lightskyblue\": 8900346,\\n    \"lightslategray\": 7833753,\\n    \"lightslategrey\": 7833753,\\n    \"lightsteelblue\": 11584734,\\n    \"lightyellow\": 16777184,\\n    \"lime\": 65280,\\n    \"limegreen\": 3329330,\\n    \"linen\": 16445670,\\n    \"magenta\": 16711935,\\n    \"maroon\": 8388608,\\n    \"mediumaquamarine\": 6737322,\\n    \"mediumblue\": 205,\\n    \"mediumorchid\": 12211667,\\n    \"mediumpurple\": 9662683,\\n    \"mediumseagreen\": 3978097,\\n    \"mediumslateblue\": 8087790,\\n    \"mediumspringgreen\": 64154,\\n    \"mediumturquoise\": 4772300,\\n    \"mediumvioletred\": 13047173,\\n    \"midnightblue\": 1644912,\\n    \"mintcream\": 16121850,\\n    \"mistyrose\": 16770273,\\n    \"moccasin\": 16770229,\\n    \"navajowhite\": 16768685,\\n    \"navy\": 128,\\n    \"oldlace\": 16643558,\\n    \"olive\": 8421376,\\n    \"olivedrab\": 7048739,\\n    \"orange\": 16753920,\\n    \"orangered\": 16729344,\\n    \"orchid\": 14315734,\\n    \"palegoldenrod\": 15657130,\\n    \"palegreen\": 10025880,\\n    \"paleturquoise\": 11529966,\\n    \"palevioletred\": 14381203,\\n    \"papayawhip\": 16773077,\\n    \"peachpuff\": 16767673,\\n    \"peru\": 13468991,\\n    \"pink\": 16761035,\\n    \"plum\": 14524637,\\n    \"powderblue\": 11591910,\\n    \"purple\": 8388736,\\n    \"rebeccapurple\": 6697881,\\n    \"red\": 16711680,\\n    \"rosybrown\": 12357519,\\n    \"royalblue\": 4286945,\\n    \"saddlebrown\": 9127187,\\n    \"salmon\": 16416882,\\n    \"sandybrown\": 16032864,\\n    \"seagreen\": 3050327,\\n    \"seashell\": 16774638,\\n    \"sienna\": 10506797,\\n    \"silver\": 12632256,\\n    \"skyblue\": 8900331,\\n    \"slateblue\": 6970061,\\n    \"slategray\": 7372944,\\n    \"slategrey\": 7372944,\\n    \"snow\": 16775930,\\n    \"springgreen\": 65407,\\n    \"steelblue\": 4620980,\\n    \"tan\": 13808780,\\n    \"teal\": 32896,\\n    \"thistle\": 14204888,\\n    \"tomato\": 16737095,\\n    \"turquoise\": 4251856,\\n    \"violet\": 15631086,\\n    \"wheat\": 16113331,\\n    \"white\": 16777215,\\n    \"whitesmoke\": 16119285,\\n    \"yellow\": 16776960,\\n    \"yellowgreen\": 10145074\\n  };\\n  const _hslA = { h: 0, s: 0, l: 0 };\\n  const _hslB = { h: 0, s: 0, l: 0 };\\n  function hue2rgb(p, q, t) {\\n    if (t < 0) t += 1;\\n    if (t > 1) t -= 1;\\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\\n    if (t < 1 / 2) return q;\\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\\n    return p;\\n  }\\n  class Color {\\n    constructor(r, g, b) {\\n      this.isColor = true;\\n      this.r = 1;\\n      this.g = 1;\\n      this.b = 1;\\n      return this.set(r, g, b);\\n    }\\n    set(r, g, b) {\\n      if (g === void 0 && b === void 0) {\\n        const value = r;\\n        if (value && value.isColor) {\\n          this.copy(value);\\n        } else if (typeof value === \"number\") {\\n          this.setHex(value);\\n        } else if (typeof value === \"string\") {\\n          this.setStyle(value);\\n        }\\n      } else {\\n        this.setRGB(r, g, b);\\n      }\\n      return this;\\n    }\\n    setScalar(scalar) {\\n      this.r = scalar;\\n      this.g = scalar;\\n      this.b = scalar;\\n      return this;\\n    }\\n    setHex(hex, colorSpace = SRGBColorSpace) {\\n      hex = Math.floor(hex);\\n      this.r = (hex >> 16 & 255) / 255;\\n      this.g = (hex >> 8 & 255) / 255;\\n      this.b = (hex & 255) / 255;\\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\\n      return this;\\n    }\\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\\n      this.r = r;\\n      this.g = g;\\n      this.b = b;\\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\\n      return this;\\n    }\\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\\n      h = euclideanModulo(h, 1);\\n      s = clamp(s, 0, 1);\\n      l = clamp(l, 0, 1);\\n      if (s === 0) {\\n        this.r = this.g = this.b = l;\\n      } else {\\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\\n        const q = 2 * l - p;\\n        this.r = hue2rgb(q, p, h + 1 / 3);\\n        this.g = hue2rgb(q, p, h);\\n        this.b = hue2rgb(q, p, h - 1 / 3);\\n      }\\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\\n      return this;\\n    }\\n    setStyle(style, colorSpace = SRGBColorSpace) {\\n      function handleAlpha(string) {\\n        if (string === void 0) return;\\n        if (parseFloat(string) < 1) {\\n          console.warn(\"THREE.Color: Alpha component of \" + style + \" will be ignored.\");\\n        }\\n      }\\n      let m;\\n      if (m = /^(\\\\w+)\\\\(([^\\\\)]*)\\\\)/.exec(style)) {\\n        let color;\\n        const name = m[1];\\n        const components = m[2];\\n        switch (name) {\\n          case \"rgb\":\\n          case \"rgba\":\\n            if (color = /^\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\\n              handleAlpha(color[4]);\\n              return this.setRGB(\\n                Math.min(255, parseInt(color[1], 10)) / 255,\\n                Math.min(255, parseInt(color[2], 10)) / 255,\\n                Math.min(255, parseInt(color[3], 10)) / 255,\\n                colorSpace\\n              );\\n            }\\n            if (color = /^\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\\n              handleAlpha(color[4]);\\n              return this.setRGB(\\n                Math.min(100, parseInt(color[1], 10)) / 100,\\n                Math.min(100, parseInt(color[2], 10)) / 100,\\n                Math.min(100, parseInt(color[3], 10)) / 100,\\n                colorSpace\\n              );\\n            }\\n            break;\\n          case \"hsl\":\\n          case \"hsla\":\\n            if (color = /^\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\\n              handleAlpha(color[4]);\\n              return this.setHSL(\\n                parseFloat(color[1]) / 360,\\n                parseFloat(color[2]) / 100,\\n                parseFloat(color[3]) / 100,\\n                colorSpace\\n              );\\n            }\\n            break;\\n          default:\\n            console.warn(\"THREE.Color: Unknown color model \" + style);\\n        }\\n      } else if (m = /^\\\\#([A-Fa-f\\\\d]+)$/.exec(style)) {\\n        const hex = m[1];\\n        const size = hex.length;\\n        if (size === 3) {\\n          return this.setRGB(\\n            parseInt(hex.charAt(0), 16) / 15,\\n            parseInt(hex.charAt(1), 16) / 15,\\n            parseInt(hex.charAt(2), 16) / 15,\\n            colorSpace\\n          );\\n        } else if (size === 6) {\\n          return this.setHex(parseInt(hex, 16), colorSpace);\\n        } else {\\n          console.warn(\"THREE.Color: Invalid hex color \" + style);\\n        }\\n      } else if (style && style.length > 0) {\\n        return this.setColorName(style, colorSpace);\\n      }\\n      return this;\\n    }\\n    setColorName(style, colorSpace = SRGBColorSpace) {\\n      const hex = _colorKeywords[style.toLowerCase()];\\n      if (hex !== void 0) {\\n        this.setHex(hex, colorSpace);\\n      } else {\\n        console.warn(\"THREE.Color: Unknown color \" + style);\\n      }\\n      return this;\\n    }\\n    clone() {\\n      return new this.constructor(this.r, this.g, this.b);\\n    }\\n    copy(color) {\\n      this.r = color.r;\\n      this.g = color.g;\\n      this.b = color.b;\\n      return this;\\n    }\\n    copySRGBToLinear(color) {\\n      this.r = SRGBToLinear(color.r);\\n      this.g = SRGBToLinear(color.g);\\n      this.b = SRGBToLinear(color.b);\\n      return this;\\n    }\\n    copyLinearToSRGB(color) {\\n      this.r = LinearToSRGB(color.r);\\n      this.g = LinearToSRGB(color.g);\\n      this.b = LinearToSRGB(color.b);\\n      return this;\\n    }\\n    convertSRGBToLinear() {\\n      this.copySRGBToLinear(this);\\n      return this;\\n    }\\n    convertLinearToSRGB() {\\n      this.copyLinearToSRGB(this);\\n      return this;\\n    }\\n    getHex(colorSpace = SRGBColorSpace) {\\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\\n    }\\n    getHexString(colorSpace = SRGBColorSpace) {\\n      return (\"000000\" + this.getHex(colorSpace).toString(16)).slice(-6);\\n    }\\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\\n      const r = _color.r, g = _color.g, b = _color.b;\\n      const max2 = Math.max(r, g, b);\\n      const min = Math.min(r, g, b);\\n      let hue, saturation;\\n      const lightness = (min + max2) / 2;\\n      if (min === max2) {\\n        hue = 0;\\n        saturation = 0;\\n      } else {\\n        const delta = max2 - min;\\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\\n        switch (max2) {\\n          case r:\\n            hue = (g - b) / delta + (g < b ? 6 : 0);\\n            break;\\n          case g:\\n            hue = (b - r) / delta + 2;\\n            break;\\n          case b:\\n            hue = (r - g) / delta + 4;\\n            break;\\n        }\\n        hue /= 6;\\n      }\\n      target.h = hue;\\n      target.s = saturation;\\n      target.l = lightness;\\n      return target;\\n    }\\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\\n      target.r = _color.r;\\n      target.g = _color.g;\\n      target.b = _color.b;\\n      return target;\\n    }\\n    getStyle(colorSpace = SRGBColorSpace) {\\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\\n      const r = _color.r, g = _color.g, b = _color.b;\\n      if (colorSpace !== SRGBColorSpace) {\\n        return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\\n      }\\n      return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\\n    }\\n    offsetHSL(h, s, l) {\\n      this.getHSL(_hslA);\\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\\n    }\\n    add(color) {\\n      this.r += color.r;\\n      this.g += color.g;\\n      this.b += color.b;\\n      return this;\\n    }\\n    addColors(color1, color2) {\\n      this.r = color1.r + color2.r;\\n      this.g = color1.g + color2.g;\\n      this.b = color1.b + color2.b;\\n      return this;\\n    }\\n    addScalar(s) {\\n      this.r += s;\\n      this.g += s;\\n      this.b += s;\\n      return this;\\n    }\\n    sub(color) {\\n      this.r = Math.max(0, this.r - color.r);\\n      this.g = Math.max(0, this.g - color.g);\\n      this.b = Math.max(0, this.b - color.b);\\n      return this;\\n    }\\n    multiply(color) {\\n      this.r *= color.r;\\n      this.g *= color.g;\\n      this.b *= color.b;\\n      return this;\\n    }\\n    multiplyScalar(s) {\\n      this.r *= s;\\n      this.g *= s;\\n      this.b *= s;\\n      return this;\\n    }\\n    lerp(color, alpha) {\\n      this.r += (color.r - this.r) * alpha;\\n      this.g += (color.g - this.g) * alpha;\\n      this.b += (color.b - this.b) * alpha;\\n      return this;\\n    }\\n    lerpColors(color1, color2, alpha) {\\n      this.r = color1.r + (color2.r - color1.r) * alpha;\\n      this.g = color1.g + (color2.g - color1.g) * alpha;\\n      this.b = color1.b + (color2.b - color1.b) * alpha;\\n      return this;\\n    }\\n    lerpHSL(color, alpha) {\\n      this.getHSL(_hslA);\\n      color.getHSL(_hslB);\\n      const h = lerp(_hslA.h, _hslB.h, alpha);\\n      const s = lerp(_hslA.s, _hslB.s, alpha);\\n      const l = lerp(_hslA.l, _hslB.l, alpha);\\n      this.setHSL(h, s, l);\\n      return this;\\n    }\\n    setFromVector3(v) {\\n      this.r = v.x;\\n      this.g = v.y;\\n      this.b = v.z;\\n      return this;\\n    }\\n    applyMatrix3(m) {\\n      const r = this.r, g = this.g, b = this.b;\\n      const e = m.elements;\\n      this.r = e[0] * r + e[3] * g + e[6] * b;\\n      this.g = e[1] * r + e[4] * g + e[7] * b;\\n      this.b = e[2] * r + e[5] * g + e[8] * b;\\n      return this;\\n    }\\n    equals(c) {\\n      return c.r === this.r && c.g === this.g && c.b === this.b;\\n    }\\n    fromArray(array, offset = 0) {\\n      this.r = array[offset];\\n      this.g = array[offset + 1];\\n      this.b = array[offset + 2];\\n      return this;\\n    }\\n    toArray(array = [], offset = 0) {\\n      array[offset] = this.r;\\n      array[offset + 1] = this.g;\\n      array[offset + 2] = this.b;\\n      return array;\\n    }\\n    fromBufferAttribute(attribute, index) {\\n      this.r = attribute.getX(index);\\n      this.g = attribute.getY(index);\\n      this.b = attribute.getZ(index);\\n      return this;\\n    }\\n    toJSON() {\\n      return this.getHex();\\n    }\\n    *[Symbol.iterator]() {\\n      yield this.r;\\n      yield this.g;\\n      yield this.b;\\n    }\\n  }\\n  const _color = /* @__PURE__ */ new Color();\\n  Color.NAMES = _colorKeywords;\\n  if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", { detail: {\\n      revision: REVISION\\n    } }));\\n  }\\n  if (typeof window !== \"undefined\") {\\n    if (window.__THREE__) {\\n      console.warn(\"WARNING: Multiple instances of Three.js being imported.\");\\n    } else {\\n      window.__THREE__ = REVISION;\\n    }\\n  }\\n  const LN_SCALE_MIN = -12;\\n  const LN_SCALE_MAX = 9;\\n  const LN_SCALE_ZERO = -30;\\n  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\\n  const SPLAT_TEX_WIDTH_BITS = 11;\\n  const SPLAT_TEX_HEIGHT_BITS = 11;\\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\\n  const SPLAT_TEX_MIN_HEIGHT = 1;\\n  function unindentLines(s) {\\n    var _a2;\\n    let seenNonEmpty = false;\\n    const lines = s.split(\"\\\\n\").map((line) => {\\n      const trimmedLine = line.trimEnd();\\n      if (seenNonEmpty) {\\n        return trimmedLine;\\n      }\\n      if (trimmedLine.length > 0) {\\n        seenNonEmpty = true;\\n        return trimmedLine;\\n      }\\n      return null;\\n    }).filter((line) => line != null);\\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\\n      lines.pop();\\n    }\\n    if (lines.length === 0) {\\n      return [];\\n    }\\n    const indent = (_a2 = lines[0].match(/^\\\\s*/)) == null ? void 0 : _a2[0];\\n    if (!indent) {\\n      return lines;\\n    }\\n    const regex = new RegExp(`^${indent}`);\\n    return lines.map((line) => line.replace(regex, \"\"));\\n  }\\n  function unindent(s) {\\n    return unindentLines(s).join(\"\\\\n\");\\n  }\\n  const f32buffer = new Float32Array(1);\\n  const u32buffer = new Uint32Array(f32buffer.buffer);\\n  function toHalf(f) {\\n    f32buffer[0] = f;\\n    const bits2 = u32buffer[0];\\n    const sign = bits2 >> 31 & 1;\\n    const exp = bits2 >> 23 & 255;\\n    const frac = bits2 & 8388607;\\n    const halfSign = sign << 15;\\n    if (exp === 255) {\\n      if (frac !== 0) {\\n        return halfSign | 32767;\\n      }\\n      return halfSign | 31744;\\n    }\\n    const newExp = exp - 127 + 15;\\n    if (newExp >= 31) {\\n      return halfSign | 31744;\\n    }\\n    if (newExp <= 0) {\\n      if (newExp < -10) {\\n        return halfSign;\\n      }\\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\\n      return halfSign | subFrac;\\n    }\\n    const halfFrac = frac >> 13;\\n    return halfSign | newExp << 10 | halfFrac;\\n  }\\n  function fromHalf(h) {\\n    const sign = h >> 15 & 1;\\n    const exp = h >> 10 & 31;\\n    const frac = h & 1023;\\n    let f32bits;\\n    if (exp === 0) {\\n      if (frac === 0) {\\n        f32bits = sign << 31;\\n      } else {\\n        let mant = frac;\\n        let e = -14;\\n        while ((mant & 1024) === 0) {\\n          mant <<= 1;\\n          e--;\\n        }\\n        mant &= 1023;\\n        const newExp = e + 127;\\n        const newFrac = mant << 13;\\n        f32bits = sign << 31 | newExp << 23 | newFrac;\\n      }\\n    } else if (exp === 31) {\\n      if (frac === 0) {\\n        f32bits = sign << 31 | 2139095040;\\n      } else {\\n        f32bits = sign << 31 | 2143289344;\\n      }\\n    } else {\\n      const newExp = exp - 15 + 127;\\n      const newFrac = frac << 13;\\n      f32bits = sign << 31 | newExp << 23 | newFrac;\\n    }\\n    u32buffer[0] = f32bits;\\n    return f32buffer[0];\\n  }\\n  function floatToUint8(v) {\\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\\n  }\\n  function getArrayBuffers(ctx) {\\n    const buffers = [];\\n    const seen = /* @__PURE__ */ new Set();\\n    function traverse(obj) {\\n      if (obj && typeof obj === \"object\" && !seen.has(obj)) {\\n        seen.add(obj);\\n        if (obj instanceof ArrayBuffer) {\\n          buffers.push(obj);\\n        } else if (ArrayBuffer.isView(obj)) {\\n          buffers.push(obj.buffer);\\n        } else if (Array.isArray(obj)) {\\n          obj.forEach(traverse);\\n        } else {\\n          Object.values(obj).forEach(traverse);\\n        }\\n      }\\n    }\\n    traverse(ctx);\\n    return buffers;\\n  }\\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b, encoding) {\\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    const rgbRange = rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\\n    const uA = floatToUint8(opacity);\\n    const uQuat = encodeQuatOctXy88R8(\\n      new Quaternion(quatX, quatY, quatZ, quatW)\\n    );\\n    const uQuatX = uQuat & 255;\\n    const uQuatY = uQuat >>> 8 & 255;\\n    const uQuatZ = uQuat >>> 16 & 255;\\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const uCenterX = toHalf(x2);\\n    const uCenterY = toHalf(y);\\n    const uCenterZ = toHalf(z);\\n    const i4 = index * 4;\\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\\n  }\\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\\n    const uCenterX = toHalf(x2);\\n    const uCenterY = toHalf(y);\\n    const uCenterZ = toHalf(z);\\n    const i4 = index * 4;\\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\\n  }\\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ, encoding) {\\n    const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\\n    const lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\\n    const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\\n    const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const i4 = index * 4;\\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\\n  }\\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\\n    const uQuat = encodeQuatOctXy88R8(\\n      new Quaternion(quatX, quatY, quatZ, quatW)\\n    );\\n    const uQuatX = uQuat & 255;\\n    const uQuatY = uQuat >>> 8 & 255;\\n    const uQuatZ = uQuat >>> 16 & 255;\\n    const i4 = index * 4;\\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\\n  }\\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {\\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    const rgbRange = rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\\n    const uA = floatToUint8(a);\\n    const i4 = index * 4;\\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\\n  }\\n  function setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {\\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n    const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    const rgbRange = rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    const uB = floatToUint8((b - rgbMin) / rgbRange);\\n    const i4 = index * 4;\\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\\n  }\\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\\n    const uA = floatToUint8(opacity);\\n    const i4 = index * 4;\\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\\n  }\\n  new Vector3();\\n  new Vector3();\\n  new Color();\\n  function getTextureSize(numSplats) {\\n    const width = SPLAT_TEX_WIDTH;\\n    const height = Math.max(\\n      SPLAT_TEX_MIN_HEIGHT,\\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\\n    );\\n    const depth = Math.ceil(numSplats / (width * height));\\n    const maxSplats = width * height * depth;\\n    return { width, height, depth, maxSplats };\\n  }\\n  function computeMaxSplats(numSplats) {\\n    const width = SPLAT_TEX_WIDTH;\\n    const height = Math.max(\\n      SPLAT_TEX_MIN_HEIGHT,\\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\\n    );\\n    const depth = Math.ceil(numSplats / (width * height));\\n    return width * height * depth;\\n  }\\n  unindent(`\\n  precision highp float;\\n\\n  in vec3 position;\\n\\n  void main() {\\n    gl_Position = vec4(position.xy, 0.0, 1.0);\\n  }\\n`);\\n  function encodeQuatOctXy88R8(q) {\\n    const qnorm = q.clone().normalize();\\n    if (qnorm.w < 0) {\\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\\n    }\\n    const theta = 2 * Math.acos(qnorm.w);\\n    const xyz_norm = Math.sqrt(\\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\\n    );\\n    const axis = xyz_norm < 1e-6 ? new Vector3(1, 0, 0) : new Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\\n    let p_x = axis.x / sum;\\n    let p_y = axis.y / sum;\\n    if (axis.z < 0) {\\n      const tmp = p_x;\\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\\n    }\\n    const u_f = p_x * 0.5 + 0.5;\\n    const v_f = p_y * 0.5 + 0.5;\\n    const quantU = Math.round(u_f * 255);\\n    const quantV = Math.round(v_f * 255);\\n    const angleInt = Math.round(theta * (255 / Math.PI));\\n    return angleInt << 16 | quantV << 8 | quantU;\\n  }\\n  function packSint8Bytes(b0, b1, b22, b3) {\\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\\n    const clampedB2 = Math.max(-127, Math.min(127, b22 * 127));\\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\\n  }\\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {\\n    const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;\\n    const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;\\n    const sh1Mid = 0.5 * (sh1Min + sh1Max);\\n    const sh1Scale = 126 / (sh1Max - sh1Min);\\n    const base = index * 2;\\n    for (let i2 = 0; i2 < 9; ++i2) {\\n      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;\\n      const value = Math.round(Math.max(-63, Math.min(63, s))) & 127;\\n      const bitStart = i2 * 7;\\n      const bitEnd = bitStart + 7;\\n      const wordStart = Math.floor(bitStart / 32);\\n      const bitOffset = bitStart - wordStart * 32;\\n      const firstWord = value << bitOffset & 4294967295;\\n      sh1Array[base + wordStart] |= firstWord;\\n      if (bitEnd > wordStart * 32 + 32) {\\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\\n        sh1Array[base + wordStart + 1] |= secondWord;\\n      }\\n    }\\n  }\\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {\\n    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? -1;\\n    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? 1;\\n    const sh2Mid = 0.5 * (sh2Min + sh2Max);\\n    const sh2Scale = 2 / (sh2Max - sh2Min);\\n    sh2Array[index * 4 + 0] = packSint8Bytes(\\n      (sh2Rgb[0] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[1] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[2] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[3] - sh2Mid) * sh2Scale\\n    );\\n    sh2Array[index * 4 + 1] = packSint8Bytes(\\n      (sh2Rgb[4] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[5] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[6] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[7] - sh2Mid) * sh2Scale\\n    );\\n    sh2Array[index * 4 + 2] = packSint8Bytes(\\n      (sh2Rgb[8] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[9] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[10] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[11] - sh2Mid) * sh2Scale\\n    );\\n    sh2Array[index * 4 + 3] = packSint8Bytes(\\n      (sh2Rgb[12] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[13] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[14] - sh2Mid) * sh2Scale,\\n      0\\n    );\\n  }\\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\\n    const sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\\n    const sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\\n    const sh3Mid = 0.5 * (sh3Min + sh3Max);\\n    const sh3Scale = 62 / (sh3Max - sh3Min);\\n    const base = index * 4;\\n    for (let i2 = 0; i2 < 21; ++i2) {\\n      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;\\n      const value = Math.round(Math.max(-31, Math.min(31, s))) & 63;\\n      const bitStart = i2 * 6;\\n      const bitEnd = bitStart + 6;\\n      const wordStart = Math.floor(bitStart / 32);\\n      const bitOffset = bitStart - wordStart * 32;\\n      const firstWord = value << bitOffset & 4294967295;\\n      sh3Array[base + wordStart] |= firstWord;\\n      if (bitEnd > wordStart * 32 + 32) {\\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\\n        sh3Array[base + wordStart + 1] |= secondWord;\\n      }\\n    }\\n  }\\n  function decompressPartialGzip(fileBytes, numBytes) {\\n    const chunks = [];\\n    let totalBytes = 0;\\n    let result = null;\\n    const gunzip = new Gunzip((data, final) => {\\n      chunks.push(data);\\n      totalBytes += data.length;\\n      if (final || totalBytes >= numBytes) {\\n        const allBytes = new Uint8Array(totalBytes);\\n        let offset2 = 0;\\n        for (const chunk of chunks) {\\n          allBytes.set(chunk, offset2);\\n          offset2 += chunk.length;\\n        }\\n        result = allBytes.slice(0, numBytes);\\n      }\\n    });\\n    const CHUNK_SIZE = 1024;\\n    let offset = 0;\\n    while (result == null && offset < fileBytes.length) {\\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\\n      gunzip.push(chunk, false);\\n      offset += CHUNK_SIZE;\\n    }\\n    if (result == null) {\\n      gunzip.push(new Uint8Array(), true);\\n      if (result == null) {\\n        throw new Error(\"Failed to decompress partial gzip\");\\n      }\\n    }\\n    return result;\\n  }\\n  class GunzipReader {\\n    constructor({\\n      fileBytes,\\n      chunkBytes = 64 * 1024\\n    }) {\\n      this.fileBytes = fileBytes;\\n      this.chunkBytes = chunkBytes;\\n      this.offset = 0;\\n      this.chunks = [];\\n      this.totalBytes = 0;\\n      this.gunzip = new Gunzip((chunk, _final) => {\\n        this.chunks.push(chunk);\\n        this.totalBytes += chunk.length;\\n      });\\n    }\\n    read(numBytes) {\\n      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {\\n        const end = Math.min(\\n          this.offset + this.chunkBytes,\\n          this.fileBytes.length\\n        );\\n        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);\\n        this.offset = end;\\n      }\\n      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {\\n        this.gunzip.push(new Uint8Array(0), true);\\n      }\\n      if (this.totalBytes < numBytes) {\\n        throw new Error(\\n          `Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\\n        );\\n      }\\n      const allBytes = new Uint8Array(this.totalBytes);\\n      let outOffset = 0;\\n      for (const chunk of this.chunks) {\\n        allBytes.set(chunk, outOffset);\\n        outOffset += chunk.length;\\n      }\\n      const result = allBytes.subarray(0, numBytes);\\n      this.chunks = [allBytes.subarray(numBytes)];\\n      this.totalBytes -= numBytes;\\n      return result;\\n    }\\n  }\\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\\n    const numSplats = Math.floor(fileBytes.length / 32);\\n    if (numSplats * 32 !== fileBytes.length) {\\n      throw new Error(\"Invalid .splat file size\");\\n    }\\n    initNumSplats(numSplats);\\n    const f32 = new Float32Array(fileBytes.buffer);\\n    for (let i2 = 0; i2 < numSplats; ++i2) {\\n      const i322 = i2 * 32;\\n      const i8 = i2 * 8;\\n      const x2 = f32[i8 + 0];\\n      const y = f32[i8 + 1];\\n      const z = f32[i8 + 2];\\n      const scaleX = f32[i8 + 3];\\n      const scaleY = f32[i8 + 4];\\n      const scaleZ = f32[i8 + 5];\\n      const r = fileBytes[i322 + 24] / 255;\\n      const g = fileBytes[i322 + 25] / 255;\\n      const b = fileBytes[i322 + 26] / 255;\\n      const opacity = fileBytes[i322 + 27] / 255;\\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\\n      splatCallback(\\n        i2,\\n        x2,\\n        y,\\n        z,\\n        scaleX,\\n        scaleY,\\n        scaleZ,\\n        quatX,\\n        quatY,\\n        quatZ,\\n        quatW,\\n        opacity,\\n        r,\\n        g,\\n        b\\n      );\\n    }\\n  }\\n  function unpackAntiSplat(fileBytes, splatEncoding) {\\n    let numSplats = 0;\\n    let maxSplats = 0;\\n    let packedArray = new Uint32Array(0);\\n    decodeAntiSplat(\\n      fileBytes,\\n      (cbNumSplats) => {\\n        numSplats = cbNumSplats;\\n        maxSplats = computeMaxSplats(numSplats);\\n        packedArray = new Uint32Array(maxSplats * 4);\\n      },\\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n        setPackedSplat(\\n          packedArray,\\n          index,\\n          x2,\\n          y,\\n          z,\\n          scaleX,\\n          scaleY,\\n          scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n          quatW,\\n          opacity,\\n          r,\\n          g,\\n          b,\\n          splatEncoding\\n        );\\n      }\\n    );\\n    return { packedArray, numSplats };\\n  }\\n  const KSPLAT_COMPRESSION = {\\n    0: {\\n      bytesPerCenter: 12,\\n      bytesPerScale: 12,\\n      bytesPerRotation: 16,\\n      bytesPerColor: 4,\\n      bytesPerSphericalHarmonicsComponent: 4,\\n      scaleOffsetBytes: 12,\\n      rotationOffsetBytes: 24,\\n      colorOffsetBytes: 40,\\n      sphericalHarmonicsOffsetBytes: 44,\\n      scaleRange: 1\\n    },\\n    1: {\\n      bytesPerCenter: 6,\\n      bytesPerScale: 6,\\n      bytesPerRotation: 8,\\n      bytesPerColor: 4,\\n      bytesPerSphericalHarmonicsComponent: 2,\\n      scaleOffsetBytes: 6,\\n      rotationOffsetBytes: 12,\\n      colorOffsetBytes: 20,\\n      sphericalHarmonicsOffsetBytes: 24,\\n      scaleRange: 32767\\n    },\\n    2: {\\n      bytesPerCenter: 6,\\n      bytesPerScale: 6,\\n      bytesPerRotation: 8,\\n      bytesPerColor: 4,\\n      bytesPerSphericalHarmonicsComponent: 1,\\n      scaleOffsetBytes: 6,\\n      rotationOffsetBytes: 12,\\n      colorOffsetBytes: 20,\\n      sphericalHarmonicsOffsetBytes: 24,\\n      scaleRange: 32767\\n    }\\n  };\\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\\n    0: 0,\\n    1: 9,\\n    2: 24,\\n    3: 45\\n  };\\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\\n    var _a2;\\n    const HEADER_BYTES = 4096;\\n    const SECTION_BYTES = 1024;\\n    let headerOffset = 0;\\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\\n    headerOffset += HEADER_BYTES;\\n    const versionMajor = header.getUint8(0);\\n    const versionMinor = header.getUint8(1);\\n    if (versionMajor !== 0 || versionMinor < 1) {\\n      throw new Error(\\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\\n      );\\n    }\\n    const maxSectionCount = header.getUint32(4, true);\\n    header.getUint32(16, true);\\n    const compressionLevel = header.getUint16(20, true);\\n    if (compressionLevel < 0 || compressionLevel > 2) {\\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\\n    }\\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\\n    for (let section = 0; section < maxSectionCount; ++section) {\\n      let getSh = function(splatOffset, component) {\\n        if (compressionLevel === 0) {\\n          return data.getFloat32(\\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\\n            true\\n          );\\n        }\\n        if (compressionLevel === 1) {\\n          return fromHalf(\\n            data.getUint16(\\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\\n              true\\n            )\\n          );\\n        }\\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\\n      };\\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\\n      headerOffset += SECTION_BYTES;\\n      const sectionSplatCount = section2.getUint32(0, true);\\n      const sectionMaxSplatCount = section2.getUint32(4, true);\\n      const bucketSize = section2.getUint32(8, true);\\n      const bucketCount = section2.getUint32(12, true);\\n      const bucketBlockSize = section2.getFloat32(16, true);\\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\\n      const fullBucketCount = section2.getUint32(32, true);\\n      const fullBucketSplats = fullBucketCount * bucketSize;\\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\\n      const {\\n        bytesPerCenter,\\n        bytesPerScale,\\n        bytesPerRotation,\\n        bytesPerColor,\\n        bytesPerSphericalHarmonicsComponent,\\n        scaleOffsetBytes,\\n        rotationOffsetBytes,\\n        colorOffsetBytes,\\n        sphericalHarmonicsOffsetBytes\\n      } = KSPLAT_COMPRESSION[compressionLevel];\\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\\n      const sh2Index = [\\n        9,\\n        14,\\n        19,\\n        10,\\n        15,\\n        20,\\n        11,\\n        16,\\n        21,\\n        12,\\n        17,\\n        22,\\n        13,\\n        18,\\n        23\\n      ];\\n      const sh3Index = [\\n        24,\\n        31,\\n        38,\\n        25,\\n        32,\\n        39,\\n        26,\\n        33,\\n        40,\\n        27,\\n        34,\\n        41,\\n        28,\\n        35,\\n        42,\\n        29,\\n        36,\\n        43,\\n        30,\\n        37,\\n        44\\n      ];\\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\\n      const data = new DataView(\\n        fileBytes.buffer,\\n        dataBase,\\n        splatDataStorageSizeBytes\\n      );\\n      const bucketArray = new Float32Array(\\n        fileBytes.buffer,\\n        bucketsBase,\\n        bucketCount * 3\\n      );\\n      const partiallyFilledBucketLengths = new Uint32Array(\\n        fileBytes.buffer,\\n        sectionBase,\\n        partiallyFilledBucketCount\\n      );\\n      let partialBucketIndex = fullBucketCount;\\n      let partialBucketBase = fullBucketSplats;\\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\\n        const splatOffset = i2 * bytesPerSplat;\\n        let bucketIndex;\\n        if (i2 < fullBucketSplats) {\\n          bucketIndex = Math.floor(i2 / bucketSize);\\n        } else {\\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\\n          if (i2 >= partialBucketBase + bucketLength) {\\n            partialBucketIndex += 1;\\n            partialBucketBase += bucketLength;\\n          }\\n          bucketIndex = partialBucketIndex;\\n        }\\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\\n        );\\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\\n        );\\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\\n        );\\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\\n        );\\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\\n        splatCallback(\\n          i2,\\n          x2,\\n          y,\\n          z,\\n          scaleX,\\n          scaleY,\\n          scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n          quatW,\\n          opacity,\\n          r,\\n          g,\\n          b\\n        );\\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\\n          for (const [i22, key] of sh1Index.entries()) {\\n            sh1[i22] = getSh(splatOffset, key);\\n          }\\n          if (sh2) {\\n            for (const [i22, key] of sh2Index.entries()) {\\n              sh2[i22] = getSh(splatOffset, key);\\n            }\\n          }\\n          if (sh3) {\\n            for (const [i22, key] of sh3Index.entries()) {\\n              sh3[i22] = getSh(splatOffset, key);\\n            }\\n          }\\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\\n        }\\n      }\\n      sectionBase += storageSizeBytes;\\n    }\\n  }\\n  function unpackKsplat(fileBytes, splatEncoding) {\\n    var _a2;\\n    const HEADER_BYTES = 4096;\\n    const SECTION_BYTES = 1024;\\n    let headerOffset = 0;\\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\\n    headerOffset += HEADER_BYTES;\\n    const versionMajor = header.getUint8(0);\\n    const versionMinor = header.getUint8(1);\\n    if (versionMajor !== 0 || versionMinor < 1) {\\n      throw new Error(\\n        `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\\n      );\\n    }\\n    const maxSectionCount = header.getUint32(4, true);\\n    const splatCount = header.getUint32(16, true);\\n    const compressionLevel = header.getUint16(20, true);\\n    if (compressionLevel < 0 || compressionLevel > 2) {\\n      throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\\n    }\\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\\n    const numSplats = splatCount;\\n    const maxSplats = computeMaxSplats(numSplats);\\n    const packedArray = new Uint32Array(maxSplats * 4);\\n    const extra = {};\\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\\n    for (let section = 0; section < maxSectionCount; ++section) {\\n      let getSh = function(splatOffset, component) {\\n        if (compressionLevel === 0) {\\n          return data.getFloat32(\\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\\n            true\\n          );\\n        }\\n        if (compressionLevel === 1) {\\n          return fromHalf(\\n            data.getUint16(\\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\\n              true\\n            )\\n          );\\n        }\\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\\n      };\\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\\n      headerOffset += SECTION_BYTES;\\n      const sectionSplatCount = section2.getUint32(0, true);\\n      const sectionMaxSplatCount = section2.getUint32(4, true);\\n      const bucketSize = section2.getUint32(8, true);\\n      const bucketCount = section2.getUint32(12, true);\\n      const bucketBlockSize = section2.getFloat32(16, true);\\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\\n      const fullBucketCount = section2.getUint32(32, true);\\n      const fullBucketSplats = fullBucketCount * bucketSize;\\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\\n      const {\\n        bytesPerCenter,\\n        bytesPerScale,\\n        bytesPerRotation,\\n        bytesPerColor,\\n        bytesPerSphericalHarmonicsComponent,\\n        scaleOffsetBytes,\\n        rotationOffsetBytes,\\n        colorOffsetBytes,\\n        sphericalHarmonicsOffsetBytes\\n      } = KSPLAT_COMPRESSION[compressionLevel];\\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\\n      const sh2Index = [\\n        9,\\n        14,\\n        19,\\n        10,\\n        15,\\n        20,\\n        11,\\n        16,\\n        21,\\n        12,\\n        17,\\n        22,\\n        13,\\n        18,\\n        23\\n      ];\\n      const sh3Index = [\\n        24,\\n        31,\\n        38,\\n        25,\\n        32,\\n        39,\\n        26,\\n        33,\\n        40,\\n        27,\\n        34,\\n        41,\\n        28,\\n        35,\\n        42,\\n        29,\\n        36,\\n        43,\\n        30,\\n        37,\\n        44\\n      ];\\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\\n      const data = new DataView(\\n        fileBytes.buffer,\\n        dataBase,\\n        splatDataStorageSizeBytes\\n      );\\n      const bucketArray = new Float32Array(\\n        fileBytes.buffer,\\n        bucketsBase,\\n        bucketCount * 3\\n      );\\n      const partiallyFilledBucketLengths = new Uint32Array(\\n        fileBytes.buffer,\\n        sectionBase,\\n        partiallyFilledBucketCount\\n      );\\n      let partialBucketIndex = fullBucketCount;\\n      let partialBucketBase = fullBucketSplats;\\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\\n        const splatOffset = i2 * bytesPerSplat;\\n        let bucketIndex;\\n        if (i2 < fullBucketSplats) {\\n          bucketIndex = Math.floor(i2 / bucketSize);\\n        } else {\\n          const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\\n          if (i2 >= partialBucketBase + bucketLength) {\\n            partialBucketIndex += 1;\\n            partialBucketBase += bucketLength;\\n          }\\n          bucketIndex = partialBucketIndex;\\n        }\\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\\n        );\\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\\n        );\\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\\n        );\\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\\n        );\\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\\n        setPackedSplat(\\n          packedArray,\\n          i2,\\n          x2,\\n          y,\\n          z,\\n          scaleX,\\n          scaleY,\\n          scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n          quatW,\\n          opacity,\\n          r,\\n          g,\\n          b,\\n          splatEncoding\\n        );\\n        if (sphericalHarmonicsDegree >= 1) {\\n          if (sh1) {\\n            if (!extra.sh1) {\\n              extra.sh1 = new Uint32Array(numSplats * 2);\\n            }\\n            for (const [i22, key] of sh1Index.entries()) {\\n              sh1[i22] = getSh(splatOffset, key);\\n            }\\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\\n          }\\n          if (sh2) {\\n            if (!extra.sh2) {\\n              extra.sh2 = new Uint32Array(numSplats * 4);\\n            }\\n            for (const [i22, key] of sh2Index.entries()) {\\n              sh2[i22] = getSh(splatOffset, key);\\n            }\\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\\n          }\\n          if (sh3) {\\n            if (!extra.sh3) {\\n              extra.sh3 = new Uint32Array(numSplats * 4);\\n            }\\n            for (const [i22, key] of sh3Index.entries()) {\\n              sh3[i22] = getSh(splatOffset, key);\\n            }\\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\\n          }\\n        }\\n      }\\n      sectionBase += storageSizeBytes;\\n    }\\n    return { packedArray, numSplats, extra };\\n  }\\n  const _PlyReader = class _PlyReader {\\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\\n    constructor({ fileBytes }) {\\n      this.header = \"\";\\n      this.littleEndian = true;\\n      this.elements = {};\\n      this.comments = [];\\n      this.data = null;\\n      this.numSplats = 0;\\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\\n    }\\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\\n    // this.elements will contain all the elements in the file, typically\\n    // \"vertex\" contains the Gsplat data.\\n    async parseHeader() {\\n      const bufferStream = new ReadableStream({\\n        start: (controller) => {\\n          controller.enqueue(this.fileBytes.slice(0, 65536));\\n          controller.close();\\n        }\\n      });\\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\\n      this.header = \"\";\\n      const headerTerminator = \"end_header\\\\n\";\\n      while (true) {\\n        const { value, done } = await decoder.read();\\n        if (done) {\\n          throw new Error(\"Failed to read header\");\\n        }\\n        this.header += value;\\n        const endHeader = this.header.indexOf(headerTerminator);\\n        if (endHeader >= 0) {\\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\\n          break;\\n        }\\n      }\\n      const headerLen = new TextEncoder().encode(this.header).length;\\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\\n      this.elements = {};\\n      let curElement = null;\\n      this.comments = [];\\n      this.header.trim().split(\"\\\\n\").forEach((line, lineIndex) => {\\n        const trimmedLine = line.trim();\\n        if (lineIndex === 0) {\\n          if (trimmedLine !== \"ply\") {\\n            throw new Error(\"Invalid PLY header\");\\n          }\\n          return;\\n        }\\n        if (trimmedLine.length === 0) {\\n          return;\\n        }\\n        const fields = trimmedLine.split(\" \");\\n        switch (fields[0]) {\\n          case \"format\":\\n            if (fields[1] === \"binary_little_endian\") {\\n              this.littleEndian = true;\\n            } else if (fields[1] === \"binary_big_endian\") {\\n              this.littleEndian = false;\\n            } else {\\n              throw new Error(`Unsupported PLY format: ${fields[1]}`);\\n            }\\n            if (fields[2] !== \"1.0\") {\\n              throw new Error(`Unsupported PLY version: ${fields[2]}`);\\n            }\\n            break;\\n          case \"end_header\":\\n            break;\\n          case \"comment\":\\n            this.comments.push(trimmedLine.slice(\"comment \".length));\\n            break;\\n          case \"element\": {\\n            const name = fields[1];\\n            curElement = {\\n              name,\\n              count: Number.parseInt(fields[2]),\\n              properties: {}\\n            };\\n            this.elements[name] = curElement;\\n            break;\\n          }\\n          case \"property\":\\n            if (curElement == null) {\\n              throw new Error(\"Property must be inside an element\");\\n            }\\n            if (fields[1] === \"list\") {\\n              curElement.properties[fields[4]] = {\\n                isList: true,\\n                type: fields[3],\\n                countType: fields[2]\\n              };\\n            } else {\\n              curElement.properties[fields[2]] = {\\n                isList: false,\\n                type: fields[1]\\n              };\\n            }\\n            break;\\n        }\\n      });\\n      if (this.elements.vertex) {\\n        this.numSplats = this.elements.vertex.count;\\n      }\\n    }\\n    parseData(elementCallback) {\\n      let offset = 0;\\n      const data = this.data;\\n      if (data == null) {\\n        throw new Error(\"No data to parse\");\\n      }\\n      for (const elementName in this.elements) {\\n        const element = this.elements[elementName];\\n        const { count, properties } = element;\\n        const item = {};\\n        const parsers = [];\\n        for (const [propertyName, property] of Object.entries(properties)) {\\n          if (!property.isList) {\\n            item[propertyName] = 0;\\n            parsers.push(() => {\\n              item[propertyName] = PARSE_FIELD[property.type](\\n                data,\\n                offset,\\n                this.littleEndian\\n              );\\n              offset += FIELD_BYTES[property.type];\\n            });\\n          } else {\\n            item[propertyName] = [];\\n            parsers.push(() => {\\n              const list = item[propertyName];\\n              list.length = PARSE_FIELD[property.countType](\\n                data,\\n                offset,\\n                this.littleEndian\\n              );\\n              offset += FIELD_BYTES[property.countType];\\n              for (let i2 = 0; i2 < list.length; i2++) {\\n                list[i2] = PARSE_FIELD[property.type](\\n                  data,\\n                  offset,\\n                  this.littleEndian\\n                );\\n                offset += FIELD_BYTES[property.type];\\n              }\\n            });\\n          }\\n        }\\n        const callback = elementCallback(element) ?? (() => {\\n        });\\n        for (let index = 0; index < count; index++) {\\n          for (const parser of parsers) {\\n            parser();\\n          }\\n          callback(index, item);\\n        }\\n      }\\n    }\\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\\n    // callbacks for each Gsplat.\\n    parseSplats(splatCallback, shCallback) {\\n      if (this.elements.vertex == null) {\\n        throw new Error(\"No vertex element found\");\\n      }\\n      let isSuperSplat = false;\\n      const ssChunks = [];\\n      let numSh = 0;\\n      let sh1Props = [];\\n      let sh2Props = [];\\n      let sh3Props = [];\\n      let sh1 = void 0;\\n      let sh2 = void 0;\\n      let sh3 = void 0;\\n      function prepareSh() {\\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\\n        sh1Props = new Array(3).fill(null).flatMap(\\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${k + d * num_f_rest / 3}`)\\n        );\\n        sh2Props = new Array(5).fill(null).flatMap(\\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${3 + k + d * num_f_rest / 3}`)\\n        );\\n        sh3Props = new Array(7).fill(null).flatMap(\\n          (_, k) => [0, 1, 2].map((_2, d) => `f_rest_${8 + k + d * num_f_rest / 3}`)\\n        );\\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\\n      }\\n      function ssShCallback(index, item) {\\n        if (!sh1) {\\n          throw new Error(\"Missing sh1\");\\n        }\\n        for (const [i2, key] of sh1Props.entries()) {\\n          sh1[i2] = item[key] * 8 / 255 - 4;\\n        }\\n        if (sh2) {\\n          for (const [i2, key] of sh2Props.entries()) {\\n            sh2[i2] = item[key] * 8 / 255 - 4;\\n          }\\n        }\\n        if (sh3) {\\n          for (const [i2, key] of sh3Props.entries()) {\\n            sh3[i2] = item[key] * 8 / 255 - 4;\\n          }\\n        }\\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\\n      }\\n      function initSuperSplat(element) {\\n        const {\\n          min_x,\\n          min_y,\\n          min_z,\\n          max_x,\\n          max_y,\\n          max_z,\\n          min_scale_x,\\n          min_scale_y,\\n          min_scale_z,\\n          max_scale_x,\\n          max_scale_y,\\n          max_scale_z\\n        } = element.properties;\\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z) {\\n          throw new Error(\"Missing PLY chunk properties\");\\n        }\\n        isSuperSplat = true;\\n        return (index, item) => {\\n          const {\\n            min_x: min_x2,\\n            min_y: min_y2,\\n            min_z: min_z2,\\n            max_x: max_x2,\\n            max_y: max_y2,\\n            max_z: max_z2,\\n            min_scale_x: min_scale_x2,\\n            min_scale_y: min_scale_y2,\\n            min_scale_z: min_scale_z2,\\n            max_scale_x: max_scale_x2,\\n            max_scale_y: max_scale_y2,\\n            max_scale_z: max_scale_z2,\\n            min_r,\\n            min_g,\\n            min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n          } = item;\\n          ssChunks.push({\\n            min_x: min_x2,\\n            min_y: min_y2,\\n            min_z: min_z2,\\n            max_x: max_x2,\\n            max_y: max_y2,\\n            max_z: max_z2,\\n            min_scale_x: min_scale_x2,\\n            min_scale_y: min_scale_y2,\\n            min_scale_z: min_scale_z2,\\n            max_scale_x: max_scale_x2,\\n            max_scale_y: max_scale_y2,\\n            max_scale_z: max_scale_z2,\\n            min_r,\\n            min_g,\\n            min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n          });\\n        };\\n      }\\n      function decodeSuperSplat(element) {\\n        if (shCallback && element.name === \"sh\") {\\n          numSh = getNumSh(element.properties);\\n          prepareSh();\\n          return ssShCallback;\\n        }\\n        if (element.name !== \"vertex\") {\\n          return null;\\n        }\\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\\n          throw new Error(\\n            \"Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color\"\\n          );\\n        }\\n        const SQRT2 = Math.sqrt(2);\\n        return (index, item) => {\\n          const chunk = ssChunks[index >>> 8];\\n          if (chunk == null) {\\n            throw new Error(\"Missing PLY chunk\");\\n          }\\n          const {\\n            min_x,\\n            min_y,\\n            min_z,\\n            max_x,\\n            max_y,\\n            max_z,\\n            min_scale_x,\\n            min_scale_y,\\n            min_scale_z,\\n            max_scale_x,\\n            max_scale_y,\\n            max_scale_z,\\n            min_r,\\n            min_g,\\n            min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n          } = chunk;\\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\\n          const rOrder = packed_rotation2 >>> 30;\\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\\n          const quatZ = rOrder <= 2 ? r2 : rr;\\n          const quatW = rOrder === 0 ? rr : r0;\\n          const scaleX = Math.exp(\\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\\n          );\\n          const scaleY = Math.exp(\\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\\n          );\\n          const scaleZ = Math.exp(\\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\\n          );\\n          const r = (packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g ?? 0);\\n          const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\\n          const opacity = (packed_color2 & 255) / 255;\\n          splatCallback(\\n            index,\\n            x2,\\n            y,\\n            z,\\n            scaleX,\\n            scaleY,\\n            scaleZ,\\n            quatX,\\n            quatY,\\n            quatZ,\\n            quatW,\\n            opacity,\\n            r,\\n            g,\\n            b\\n          );\\n        };\\n      }\\n      const elementCallback = (element) => {\\n        if (element.name === \"chunk\") {\\n          return initSuperSplat(element);\\n        }\\n        if (isSuperSplat) {\\n          return decodeSuperSplat(element);\\n        }\\n        if (element.name !== \"vertex\") {\\n          return null;\\n        }\\n        const {\\n          x: x2,\\n          y,\\n          z,\\n          scale_0,\\n          scale_1,\\n          scale_2,\\n          rot_0,\\n          rot_1,\\n          rot_2,\\n          rot_3,\\n          opacity,\\n          f_dc_0,\\n          f_dc_1,\\n          f_dc_2,\\n          red,\\n          green,\\n          blue,\\n          alpha\\n        } = element.properties;\\n        if (!x2 || !y || !z) {\\n          throw new Error(\"Missing PLY properties: x, y, z\");\\n        }\\n        const hasScales = scale_0 && scale_1 && scale_2;\\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\\n        numSh = getNumSh(element.properties);\\n        prepareSh();\\n        return (index, item) => {\\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\\n          const quatX = hasRots ? item.rot_1 : 0;\\n          const quatY = hasRots ? item.rot_2 : 0;\\n          const quatZ = hasRots ? item.rot_3 : 0;\\n          const quatW = hasRots ? item.rot_0 : 1;\\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\\n          splatCallback(\\n            index,\\n            item.x,\\n            item.y,\\n            item.z,\\n            scaleX,\\n            scaleY,\\n            scaleZ,\\n            quatX,\\n            quatY,\\n            quatZ,\\n            quatW,\\n            op,\\n            r,\\n            g,\\n            b\\n          );\\n          if (shCallback && sh1) {\\n            if (sh1) {\\n              for (const [i2, key] of sh1Props.entries()) {\\n                sh1[i2] = item[key];\\n              }\\n            }\\n            if (sh2) {\\n              for (const [i2, key] of sh2Props.entries()) {\\n                sh2[i2] = item[key];\\n              }\\n            }\\n            if (sh3) {\\n              for (const [i2, key] of sh3Props.entries()) {\\n                sh3[i2] = item[key];\\n              }\\n            }\\n            shCallback(index, sh1, sh2, sh3);\\n          }\\n        };\\n      };\\n      this.parseData(elementCallback);\\n    }\\n    // Inject RGBA values into original PLY file, which can be used to modify\\n    // the color/opacity of the Gsplats and write out the modified PLY file.\\n    injectRgba(rgba) {\\n      let offset = 0;\\n      const data = this.data;\\n      if (data == null) {\\n        throw new Error(\"No parsed data\");\\n      }\\n      if (rgba.length !== this.numSplats * 4) {\\n        throw new Error(\"Invalid RGBA array length\");\\n      }\\n      for (const elementName in this.elements) {\\n        const element = this.elements[elementName];\\n        const { count, properties } = element;\\n        const parsers = [];\\n        let rgbaOffset = 0;\\n        const isVertex = elementName === \"vertex\";\\n        if (isVertex) {\\n          for (const name of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\\n            if (!properties[name] || properties[name].type !== \"float\") {\\n              throw new Error(`Can\\'t injectRgba due to property: ${name}`);\\n            }\\n          }\\n        }\\n        for (const [propertyName, property] of Object.entries(properties)) {\\n          if (!property.isList) {\\n            if (isVertex) {\\n              if (propertyName === \"f_dc_0\" || propertyName === \"f_dc_1\" || propertyName === \"f_dc_2\") {\\n                const component = Number.parseInt(\\n                  propertyName.slice(\"f_dc_\".length)\\n                );\\n                parsers.push(() => {\\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\\n                  SET_FIELD[property.type](\\n                    data,\\n                    offset,\\n                    this.littleEndian,\\n                    value\\n                  );\\n                });\\n              } else if (propertyName === \"opacity\") {\\n                parsers.push(() => {\\n                  const value = Math.max(\\n                    -100,\\n                    Math.min(\\n                      100,\\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\\n                    )\\n                  );\\n                  SET_FIELD[property.type](\\n                    data,\\n                    offset,\\n                    this.littleEndian,\\n                    value\\n                  );\\n                });\\n              }\\n            }\\n            parsers.push(() => {\\n              offset += FIELD_BYTES[property.type];\\n            });\\n          } else {\\n            parsers.push(() => {\\n              const length = PARSE_FIELD[property.countType](\\n                data,\\n                offset,\\n                this.littleEndian\\n              );\\n              offset += FIELD_BYTES[property.countType];\\n              offset += length * FIELD_BYTES[property.type];\\n            });\\n          }\\n        }\\n        for (let index = 0; index < count; index++) {\\n          for (const parser of parsers) {\\n            parser();\\n          }\\n          if (isVertex) {\\n            rgbaOffset += 4;\\n          }\\n        }\\n      }\\n    }\\n  };\\n  _PlyReader.defaultPointScale = 1e-3;\\n  let PlyReader = _PlyReader;\\n  const SH_C0$1 = 0.28209479177387814;\\n  const PARSE_FIELD = {\\n    char: (data, offset, littleEndian) => {\\n      return data.getInt8(offset);\\n    },\\n    uchar: (data, offset, littleEndian) => {\\n      return data.getUint8(offset);\\n    },\\n    short: (data, offset, littleEndian) => {\\n      return data.getInt16(offset, littleEndian);\\n    },\\n    ushort: (data, offset, littleEndian) => {\\n      return data.getUint16(offset, littleEndian);\\n    },\\n    int: (data, offset, littleEndian) => {\\n      return data.getInt32(offset, littleEndian);\\n    },\\n    uint: (data, offset, littleEndian) => {\\n      return data.getUint32(offset, littleEndian);\\n    },\\n    float: (data, offset, littleEndian) => {\\n      return data.getFloat32(offset, littleEndian);\\n    },\\n    double: (data, offset, littleEndian) => {\\n      return data.getFloat64(offset, littleEndian);\\n    }\\n  };\\n  const SET_FIELD = {\\n    char: (data, offset, littleEndian, value) => {\\n      data.setInt8(offset, value);\\n    },\\n    uchar: (data, offset, littleEndian, value) => {\\n      data.setUint8(offset, value);\\n    },\\n    short: (data, offset, littleEndian, value) => {\\n      data.setInt16(offset, value, littleEndian);\\n    },\\n    ushort: (data, offset, littleEndian, value) => {\\n      data.setUint16(offset, value, littleEndian);\\n    },\\n    int: (data, offset, littleEndian, value) => {\\n      data.setInt32(offset, value, littleEndian);\\n    },\\n    uint: (data, offset, littleEndian, value) => {\\n      data.setUint32(offset, value, littleEndian);\\n    },\\n    float: (data, offset, littleEndian, value) => {\\n      data.setFloat32(offset, value, littleEndian);\\n    },\\n    double: (data, offset, littleEndian, value) => {\\n      data.setFloat64(offset, value, littleEndian);\\n    }\\n  };\\n  const FIELD_BYTES = {\\n    char: 1,\\n    uchar: 1,\\n    short: 2,\\n    ushort: 2,\\n    int: 4,\\n    uint: 4,\\n    float: 4,\\n    double: 8\\n  };\\n  const FIELD_SCALE = {\\n    char: 127,\\n    uchar: 255,\\n    short: 32767,\\n    ushort: 65535,\\n    int: 2147483647,\\n    uint: 4294967295,\\n    float: 1,\\n    double: 1\\n  };\\n  const NUM_F_REST_TO_NUM_SH = {\\n    0: 0,\\n    9: 1,\\n    24: 2,\\n    45: 3\\n  };\\n  const NUM_SH_TO_NUM_F_REST = {\\n    0: 0,\\n    1: 9,\\n    2: 24,\\n    3: 45\\n  };\\n  function getNumSh(properties) {\\n    let num_f_rest = 0;\\n    while (properties[`f_rest_${num_f_rest}`]) {\\n      num_f_rest += 1;\\n    }\\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\\n    if (numSh == null) {\\n      throw new Error(`Unsupported number of SH coefficients: ${num_f_rest}`);\\n    }\\n    return numSh;\\n  }\\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\\n    SplatFileType2[\"PLY\"] = \"ply\";\\n    SplatFileType2[\"SPZ\"] = \"spz\";\\n    SplatFileType2[\"SPLAT\"] = \"splat\";\\n    SplatFileType2[\"KSPLAT\"] = \"ksplat\";\\n    SplatFileType2[\"PCSOGS\"] = \"pcsogs\";\\n    SplatFileType2[\"PCSOGSZIP\"] = \"pcsogszip\";\\n    return SplatFileType2;\\n  })(SplatFileType || {});\\n  function getSplatFileType(fileBytes) {\\n    const view = new DataView(fileBytes.buffer);\\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\\n      return \"ply\";\\n    }\\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\\n      const header = decompressPartialGzip(fileBytes, 4);\\n      const gView = new DataView(header.buffer);\\n      if (gView.getUint32(0, true) === 1347635022) {\\n        return \"spz\";\\n      }\\n      return void 0;\\n    }\\n    if (view.getUint32(0, true) === 67324752) {\\n      if (tryPcSogsZip(fileBytes)) {\\n        return \"pcsogszip\";\\n      }\\n      return void 0;\\n    }\\n    return void 0;\\n  }\\n  function getFileExtension(pathOrUrl) {\\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\\n    const lastSlash = Math.max(\\n      noTrailing.lastIndexOf(\"/\"),\\n      noTrailing.lastIndexOf(\"\\\\\\\\\")\\n    );\\n    const filename = noTrailing.slice(lastSlash + 1);\\n    const lastDot = filename.lastIndexOf(\".\");\\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\\n      return \"\";\\n    }\\n    return filename.slice(lastDot + 1).toLowerCase();\\n  }\\n  function getSplatFileTypeFromPath(pathOrUrl) {\\n    const extension = getFileExtension(pathOrUrl);\\n    if (extension === \"ply\") {\\n      return \"ply\";\\n    }\\n    if (extension === \"spz\") {\\n      return \"spz\";\\n    }\\n    if (extension === \"splat\") {\\n      return \"splat\";\\n    }\\n    if (extension === \"ksplat\") {\\n      return \"ksplat\";\\n    }\\n    return void 0;\\n  }\\n  function tryPcSogs(input) {\\n    try {\\n      let text;\\n      if (typeof input === \"string\") {\\n        text = input;\\n      } else {\\n        const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\\n        if (fileBytes.length > 65536) {\\n          return void 0;\\n        }\\n        text = new TextDecoder().decode(fileBytes);\\n      }\\n      const json = JSON.parse(text);\\n      if (!json || typeof json !== \"object\" || Array.isArray(json)) {\\n        return void 0;\\n      }\\n      for (const key of [\"means\", \"scales\", \"quats\", \"sh0\"]) {\\n        if (!json[key] || typeof json[key] !== \"object\" || Array.isArray(json[key])) {\\n          return void 0;\\n        }\\n        if (!json[key].shape || !json[key].files) {\\n          return void 0;\\n        }\\n        if (key !== \"quats\" && (!json[key].mins || !json[key].maxs)) {\\n          return void 0;\\n        }\\n      }\\n      return json;\\n    } catch {\\n      return void 0;\\n    }\\n  }\\n  function tryPcSogsZip(input) {\\n    try {\\n      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\\n      let metaFilename = null;\\n      const unzipped = unzipSync(fileBytes, {\\n        filter: ({ name }) => {\\n          const filename = name.split(/[\\\\\\\\/]/).pop();\\n          if (filename === \"meta.json\") {\\n            metaFilename = name;\\n            return true;\\n          }\\n          return false;\\n        }\\n      });\\n      if (!metaFilename) {\\n        return void 0;\\n      }\\n      const json = tryPcSogs(unzipped[metaFilename]);\\n      if (!json) {\\n        return void 0;\\n      }\\n      return { name: metaFilename, json };\\n    } catch {\\n      return void 0;\\n    }\\n  }\\n  class SplatData {\\n    constructor({ maxSplats = 1 } = {}) {\\n      this.numSplats = 0;\\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\\n      this.centers = new Float32Array(this.maxSplats * 3);\\n      this.scales = new Float32Array(this.maxSplats * 3);\\n      this.quaternions = new Float32Array(this.maxSplats * 4);\\n      this.opacities = new Float32Array(this.maxSplats);\\n      this.colors = new Float32Array(this.maxSplats * 3);\\n    }\\n    pushSplat() {\\n      const index = this.numSplats;\\n      this.ensureIndex(index);\\n      this.numSplats += 1;\\n      return index;\\n    }\\n    unpushSplat(index) {\\n      if (index === this.numSplats - 1) {\\n        this.numSplats -= 1;\\n      } else {\\n        throw new Error(\"Cannot unpush splat from non-last position\");\\n      }\\n    }\\n    ensureCapacity(numSplats) {\\n      if (numSplats > this.maxSplats) {\\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\\n        const newCenters = new Float32Array(targetSplats * 3);\\n        const newScales = new Float32Array(targetSplats * 3);\\n        const newQuaternions = new Float32Array(targetSplats * 4);\\n        const newOpacities = new Float32Array(targetSplats);\\n        const newColors = new Float32Array(targetSplats * 3);\\n        newCenters.set(this.centers);\\n        newScales.set(this.scales);\\n        newQuaternions.set(this.quaternions);\\n        newOpacities.set(this.opacities);\\n        newColors.set(this.colors);\\n        this.centers = newCenters;\\n        this.scales = newScales;\\n        this.quaternions = newQuaternions;\\n        this.opacities = newOpacities;\\n        this.colors = newColors;\\n        if (this.sh1) {\\n          const newSh1 = new Float32Array(targetSplats * 9);\\n          newSh1.set(this.sh1);\\n          this.sh1 = newSh1;\\n        }\\n        if (this.sh2) {\\n          const newSh2 = new Float32Array(targetSplats * 15);\\n          newSh2.set(this.sh2);\\n          this.sh2 = newSh2;\\n        }\\n        if (this.sh3) {\\n          const newSh3 = new Float32Array(targetSplats * 21);\\n          newSh3.set(this.sh3);\\n          this.sh3 = newSh3;\\n        }\\n        this.maxSplats = targetSplats;\\n      }\\n    }\\n    ensureIndex(index) {\\n      this.ensureCapacity(index + 1);\\n    }\\n    setCenter(index, x2, y, z) {\\n      this.centers[index * 3] = x2;\\n      this.centers[index * 3 + 1] = y;\\n      this.centers[index * 3 + 2] = z;\\n    }\\n    setScale(index, scaleX, scaleY, scaleZ) {\\n      this.scales[index * 3] = scaleX;\\n      this.scales[index * 3 + 1] = scaleY;\\n      this.scales[index * 3 + 2] = scaleZ;\\n    }\\n    setQuaternion(index, x2, y, z, w) {\\n      this.quaternions[index * 4] = x2;\\n      this.quaternions[index * 4 + 1] = y;\\n      this.quaternions[index * 4 + 2] = z;\\n      this.quaternions[index * 4 + 3] = w;\\n    }\\n    setOpacity(index, opacity) {\\n      this.opacities[index] = opacity;\\n    }\\n    setColor(index, r, g, b) {\\n      this.colors[index * 3] = r;\\n      this.colors[index * 3 + 1] = g;\\n      this.colors[index * 3 + 2] = b;\\n    }\\n    setSh1(index, sh1) {\\n      if (!this.sh1) {\\n        this.sh1 = new Float32Array(this.maxSplats * 9);\\n      }\\n      for (let j = 0; j < 9; ++j) {\\n        this.sh1[index * 9 + j] = sh1[j];\\n      }\\n    }\\n    setSh2(index, sh2) {\\n      if (!this.sh2) {\\n        this.sh2 = new Float32Array(this.maxSplats * 15);\\n      }\\n      for (let j = 0; j < 15; ++j) {\\n        this.sh2[index * 15 + j] = sh2[j];\\n      }\\n    }\\n    setSh3(index, sh3) {\\n      if (!this.sh3) {\\n        this.sh3 = new Float32Array(this.maxSplats * 21);\\n      }\\n      for (let j = 0; j < 21; ++j) {\\n        this.sh3[index * 21 + j] = sh3[j];\\n      }\\n    }\\n  }\\n  async function unpackPcSogs(json, extraFiles, splatEncoding) {\\n    if (json.quats.encoding !== \"quaternion_packed\") {\\n      throw new Error(\"Unsupported quaternion encoding\");\\n    }\\n    const numSplats = json.means.shape[0];\\n    const maxSplats = computeMaxSplats(numSplats);\\n    const packedArray = new Uint32Array(maxSplats * 4);\\n    const extra = {};\\n    const meansPromise = Promise.all([\\n      decodeImageRgba(extraFiles[json.means.files[0]]),\\n      decodeImageRgba(extraFiles[json.means.files[1]])\\n    ]).then((means) => {\\n      for (let i2 = 0; i2 < numSplats; ++i2) {\\n        const i4 = i2 * 4;\\n        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / 65535;\\n        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / 65535;\\n        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / 65535;\\n        let x2 = json.means.mins[0] + (json.means.maxs[0] - json.means.mins[0]) * fx;\\n        let y = json.means.mins[1] + (json.means.maxs[1] - json.means.mins[1]) * fy;\\n        let z = json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\\n        x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\\n        y = Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\\n        z = Math.sign(z) * (Math.exp(Math.abs(z)) - 1);\\n        setPackedSplatCenter(packedArray, i2, x2, y, z);\\n      }\\n    });\\n    const scalesPromise = decodeImageRgba(extraFiles[json.scales.files[0]]).then(\\n      (scales) => {\\n        for (let i2 = 0; i2 < numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          const fx = scales[i4 + 0] / 255;\\n          const fy = scales[i4 + 1] / 255;\\n          const fz = scales[i4 + 2] / 255;\\n          const x2 = json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * fx;\\n          const y = json.scales.mins[1] + (json.scales.maxs[1] - json.scales.mins[1]) * fy;\\n          const z = json.scales.mins[2] + (json.scales.maxs[2] - json.scales.mins[2]) * fz;\\n          setPackedSplatScales(\\n            packedArray,\\n            i2,\\n            Math.exp(x2),\\n            Math.exp(y),\\n            Math.exp(z),\\n            splatEncoding\\n          );\\n        }\\n      }\\n    );\\n    const quatsPromise = decodeImageRgba(extraFiles[json.quats.files[0]]).then(\\n      (quats) => {\\n        const SQRT2 = Math.sqrt(2);\\n        for (let i2 = 0; i2 < numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          const r0 = (quats[i4 + 0] / 255 - 0.5) * SQRT2;\\n          const r1 = (quats[i4 + 1] / 255 - 0.5) * SQRT2;\\n          const r2 = (quats[i4 + 2] / 255 - 0.5) * SQRT2;\\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\\n          const rOrder = quats[i4 + 3] - 252;\\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\\n          const quatZ = rOrder <= 2 ? r2 : rr;\\n          const quatW = rOrder === 0 ? rr : r0;\\n          setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\\n        }\\n      }\\n    );\\n    const sh0Promise = decodeImageRgba(extraFiles[json.sh0.files[0]]).then(\\n      (sh0) => {\\n        const SH_C02 = 0.28209479177387814;\\n        for (let i2 = 0; i2 < numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          const f0 = sh0[i4 + 0] / 255;\\n          const f1 = sh0[i4 + 1] / 255;\\n          const f2 = sh0[i4 + 2] / 255;\\n          const f3 = sh0[i4 + 3] / 255;\\n          const dc0 = json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * f0;\\n          const dc1 = json.sh0.mins[1] + (json.sh0.maxs[1] - json.sh0.mins[1]) * f1;\\n          const dc2 = json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * f2;\\n          const opa = json.sh0.mins[3] + (json.sh0.maxs[3] - json.sh0.mins[3]) * f3;\\n          const r = SH_C02 * dc0 + 0.5;\\n          const g = SH_C02 * dc1 + 0.5;\\n          const b = SH_C02 * dc2 + 0.5;\\n          const a = 1 / (1 + Math.exp(-opa));\\n          setPackedSplatRgba(packedArray, i2, r, g, b, a, splatEncoding);\\n        }\\n      }\\n    );\\n    const promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];\\n    if (json.shN) {\\n      const useSH3 = json.shN.shape[1] >= 48 - 3;\\n      const useSH2 = json.shN.shape[1] >= 27 - 3;\\n      const useSH1 = json.shN.shape[1] >= 12 - 3;\\n      if (useSH1) extra.sh1 = new Uint32Array(numSplats * 2);\\n      if (useSH2) extra.sh2 = new Uint32Array(numSplats * 4);\\n      if (useSH3) extra.sh3 = new Uint32Array(numSplats * 4);\\n      const sh1 = new Float32Array(9);\\n      const sh2 = new Float32Array(15);\\n      const sh3 = new Float32Array(21);\\n      const shN = json.shN;\\n      const shNPromise = Promise.all([\\n        decodeImage(extraFiles[json.shN.files[0]]),\\n        decodeImage(extraFiles[json.shN.files[1]])\\n      ]).then(([centroids, labels]) => {\\n        for (let i2 = 0; i2 < numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 + 1] << 8);\\n          const col = (label & 63) * 15;\\n          const row = label >>> 6;\\n          const offset = row * centroids.width + col;\\n          for (let d = 0; d < 3; ++d) {\\n            if (useSH1) {\\n              for (let k = 0; k < 3; ++k) {\\n                sh1[k * 3 + d] = shN.mins + (shN.maxs - shN.mins) * centroids.rgba[(offset + k) * 4 + d] / 255;\\n              }\\n            }\\n            if (useSH2) {\\n              for (let k = 0; k < 5; ++k) {\\n                sh2[k * 3 + d] = shN.mins + (shN.maxs - shN.mins) * centroids.rgba[(offset + 3 + k) * 4 + d] / 255;\\n              }\\n            }\\n            if (useSH3) {\\n              for (let k = 0; k < 7; ++k) {\\n                sh3[k * 3 + d] = shN.mins + (shN.maxs - shN.mins) * centroids.rgba[(offset + 8 + k) * 4 + d] / 255;\\n              }\\n            }\\n          }\\n          if (useSH1)\\n            encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\\n          if (useSH2)\\n            encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\\n          if (useSH3)\\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\\n        }\\n      });\\n      promises.push(shNPromise);\\n    }\\n    await Promise.all(promises);\\n    return { packedArray, numSplats, extra };\\n  }\\n  let offscreenGlContext = null;\\n  async function decodeImage(fileBytes) {\\n    if (!offscreenGlContext) {\\n      const canvas = new OffscreenCanvas(1, 1);\\n      offscreenGlContext = canvas.getContext(\"webgl2\");\\n      if (!offscreenGlContext) {\\n        throw new Error(\"Failed to create WebGL2 context\");\\n      }\\n    }\\n    const imageBlob = new Blob([fileBytes]);\\n    const bitmap = await createImageBitmap(imageBlob, {\\n      premultiplyAlpha: \"none\"\\n    });\\n    const gl = offscreenGlContext;\\n    const texture = gl.createTexture();\\n    gl.bindTexture(gl.TEXTURE_2D, texture);\\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n    const framebuffer = gl.createFramebuffer();\\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\\n    gl.framebufferTexture2D(\\n      gl.FRAMEBUFFER,\\n      gl.COLOR_ATTACHMENT0,\\n      gl.TEXTURE_2D,\\n      texture,\\n      0\\n    );\\n    const data = new Uint8Array(bitmap.width * bitmap.height * 4);\\n    gl.readPixels(\\n      0,\\n      0,\\n      bitmap.width,\\n      bitmap.height,\\n      gl.RGBA,\\n      gl.UNSIGNED_BYTE,\\n      data\\n    );\\n    gl.deleteTexture(texture);\\n    gl.deleteFramebuffer(framebuffer);\\n    return { rgba: data, width: bitmap.width, height: bitmap.height };\\n  }\\n  async function decodeImageRgba(fileBytes) {\\n    const { rgba } = await decodeImage(fileBytes);\\n    return rgba;\\n  }\\n  async function unpackPcSogsZip(fileBytes, splatEncoding) {\\n    var _a2;\\n    const nameJson = tryPcSogsZip(fileBytes);\\n    if (!nameJson) {\\n      throw new Error(\"Invalid PC SOGS zip file\");\\n    }\\n    const { name, json } = nameJson;\\n    const lastSlash = name.lastIndexOf(\"/\");\\n    const lastBackslash = name.lastIndexOf(\"\\\\\\\\\");\\n    const prefix = name.slice(0, Math.max(lastSlash, lastBackslash) + 1);\\n    const fileMap = /* @__PURE__ */ new Map();\\n    const refFiles = [\\n      ...json.means.files,\\n      ...json.scales.files,\\n      ...json.quats.files,\\n      ...json.sh0.files,\\n      ...((_a2 = json.shN) == null ? void 0 : _a2.files) ?? []\\n    ];\\n    for (const file of refFiles) {\\n      fileMap.set(prefix + file, file);\\n    }\\n    const unzipped = await new Promise(\\n      (resolve, reject) => {\\n        unzip(\\n          fileBytes,\\n          {\\n            filter: ({ name: name2 }) => {\\n              return fileMap.has(name2);\\n            }\\n          },\\n          (err2, files) => {\\n            if (err2) {\\n              reject(err2);\\n            } else {\\n              resolve(files);\\n            }\\n          }\\n        );\\n      }\\n    );\\n    const extraFiles = {};\\n    for (const [full, name2] of fileMap.entries()) {\\n      extraFiles[name2] = unzipped[full];\\n    }\\n    return await unpackPcSogs(json, extraFiles, splatEncoding);\\n  }\\n  class SpzReader {\\n    constructor({ fileBytes }) {\\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\\n      const header = new DataView(this.reader.read(16).buffer);\\n      if (header.getUint32(0, true) !== 1347635022) {\\n        throw new Error(\"Invalid SPZ file\");\\n      }\\n      this.version = header.getUint32(4, true);\\n      if (this.version < 1 || this.version > 2) {\\n        throw new Error(`Unsupported SPZ version: ${this.version}`);\\n      }\\n      this.numSplats = header.getUint32(8, true);\\n      this.shDegree = header.getUint8(12);\\n      this.fractionalBits = header.getUint8(13);\\n      this.flags = header.getUint8(14);\\n      this.flagAntiAlias = (this.flags & 1) !== 0;\\n      this.reserved = header.getUint8(15);\\n      this.parsed = false;\\n    }\\n    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\\n      if (this.parsed) {\\n        throw new Error(\"SPZ file already parsed\");\\n      }\\n      this.parsed = true;\\n      if (this.version === 1) {\\n        const centerBytes = this.reader.read(this.numSplats * 3 * 2);\\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const x2 = fromHalf(centerUint16[i3]);\\n          const y = fromHalf(centerUint16[i3 + 1]);\\n          const z = fromHalf(centerUint16[i3 + 2]);\\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\\n        }\\n      } else if (this.version === 2) {\\n        const fixed = 1 << this.fractionalBits;\\n        const centerBytes = this.reader.read(this.numSplats * 3 * 3);\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          const i9 = i2 * 9;\\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\\n        }\\n      } else {\\n        throw new Error(\"Unreachable\");\\n      }\\n      {\\n        const bytes = this.reader.read(this.numSplats);\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\\n        }\\n      }\\n      {\\n        const rgbBytes = this.reader.read(this.numSplats * 3);\\n        const scale = SH_C0 / 0.15;\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\\n        }\\n      }\\n      {\\n        const scalesBytes = this.reader.read(this.numSplats * 3);\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\\n        }\\n      }\\n      {\\n        const quatBytes = this.reader.read(this.numSplats * 3);\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const quatX = quatBytes[i3] / 127.5 - 1;\\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\\n          const quatW = Math.sqrt(\\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\\n          );\\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\\n        }\\n      }\\n      if (shCallback && this.shDegree >= 1) {\\n        const sh1 = new Float32Array(3 * 3);\\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\\n        const shBytes = this.reader.read(\\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\\n        );\\n        let offset = 0;\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          for (let j = 0; j < 9; ++j) {\\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\\n          }\\n          offset += 9;\\n          if (sh2) {\\n            for (let j = 0; j < 15; ++j) {\\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\\n            }\\n            offset += 15;\\n          }\\n          if (sh3) {\\n            for (let j = 0; j < 21; ++j) {\\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\\n            }\\n            offset += 21;\\n          }\\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\\n        }\\n      }\\n    }\\n  }\\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\\n  const SH_C0 = 0.28209479177387814;\\n  const SPZ_MAGIC = 1347635022;\\n  const SPZ_VERSION = 2;\\n  const FLAG_ANTIALIASED = 1;\\n  class SpzWriter {\\n    constructor({\\n      numSplats,\\n      shDegree,\\n      fractionalBits = 12,\\n      flagAntiAlias = true\\n    }) {\\n      this.clippedCount = 0;\\n      const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\\n      const bufferSize = 16 + numSplats * splatSize;\\n      this.buffer = new ArrayBuffer(bufferSize);\\n      this.view = new DataView(this.buffer);\\n      this.view.setUint32(0, SPZ_MAGIC, true);\\n      this.view.setUint32(4, SPZ_VERSION, true);\\n      this.view.setUint32(8, numSplats, true);\\n      this.view.setUint8(12, shDegree);\\n      this.view.setUint8(13, fractionalBits);\\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\\n      this.view.setUint8(15, 0);\\n      this.numSplats = numSplats;\\n      this.shDegree = shDegree;\\n      this.fractionalBits = fractionalBits;\\n      this.fraction = 1 << fractionalBits;\\n      this.flagAntiAlias = flagAntiAlias;\\n    }\\n    setCenter(index, x2, y, z) {\\n      const xRounded = Math.round(x2 * this.fraction);\\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\\n      const yRounded = Math.round(y * this.fraction);\\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\\n      const zRounded = Math.round(z * this.fraction);\\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\\n      if (clipped) {\\n        this.clippedCount += 1;\\n      }\\n      const i9 = index * 9;\\n      const base = 16 + i9;\\n      this.view.setUint8(base, xInt & 255);\\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\\n      this.view.setUint8(base + 3, yInt & 255);\\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\\n      this.view.setUint8(base + 6, zInt & 255);\\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\\n    }\\n    setAlpha(index, alpha) {\\n      const base = 16 + this.numSplats * 9 + index;\\n      this.view.setUint8(\\n        base,\\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\\n      );\\n    }\\n    static scaleRgb(r) {\\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\\n      return Math.max(0, Math.min(255, Math.round(v)));\\n    }\\n    setRgb(index, r, g, b) {\\n      const base = 16 + this.numSplats * 10 + index * 3;\\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\\n    }\\n    setScale(index, scaleX, scaleY, scaleZ) {\\n      const base = 16 + this.numSplats * 13 + index * 3;\\n      this.view.setUint8(\\n        base,\\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\\n      );\\n      this.view.setUint8(\\n        base + 1,\\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\\n      );\\n      this.view.setUint8(\\n        base + 2,\\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\\n      );\\n    }\\n    setQuat(index, quatX, quatY, quatZ, quatW) {\\n      const base = 16 + this.numSplats * 16 + index * 3;\\n      const quatNeg = quatW < 0;\\n      this.view.setUint8(\\n        base,\\n        Math.max(\\n          0,\\n          Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))\\n        )\\n      );\\n      this.view.setUint8(\\n        base + 1,\\n        Math.max(\\n          0,\\n          Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))\\n        )\\n      );\\n      this.view.setUint8(\\n        base + 2,\\n        Math.max(\\n          0,\\n          Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))\\n        )\\n      );\\n    }\\n    static quantizeSh(sh, bits2) {\\n      const value = Math.round(sh * 128) + 128;\\n      const bucketSize = 1 << 8 - bits2;\\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\\n      return Math.max(0, Math.min(255, quantized));\\n    }\\n    setSh(index, sh1, sh2, sh3) {\\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\\n      const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;\\n      for (let j = 0; j < 9; ++j) {\\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\\n      }\\n      if (sh2) {\\n        const base2 = base1 + 9;\\n        for (let j = 0; j < 15; ++j) {\\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\\n        }\\n        if (sh3) {\\n          const base3 = base2 + 15;\\n          for (let j = 0; j < 21; ++j) {\\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\\n          }\\n        }\\n      }\\n    }\\n    async finalize() {\\n      const input = new Uint8Array(this.buffer);\\n      const stream = new ReadableStream({\\n        async start(controller) {\\n          controller.enqueue(input);\\n          controller.close();\\n        }\\n      });\\n      const compressed = stream.pipeThrough(new CompressionStream(\"gzip\"));\\n      const response = new Response(compressed);\\n      const buffer = await response.arrayBuffer();\\n      console.log(\\n        \"Compressed\",\\n        input.length,\\n        \"bytes to\",\\n        buffer.byteLength,\\n        \"bytes\"\\n      );\\n      return new Uint8Array(buffer);\\n    }\\n  }\\n  async function transcodeSpz(input) {\\n    var _a2, _b2, _c;\\n    const splats = new SplatData();\\n    const {\\n      inputs,\\n      clipXyz,\\n      maxSh,\\n      fractionalBits = 12,\\n      opacityThreshold\\n    } = input;\\n    for (const input2 of inputs) {\\n      let transformPos = function(pos) {\\n        pos.multiplyScalar(scale);\\n        pos.applyQuaternion(quaternion);\\n        pos.add(translate);\\n        return pos;\\n      }, transformScales = function(scales) {\\n        scales.multiplyScalar(scale);\\n        return scales;\\n      }, transformQuaternion = function(quat) {\\n        quat.premultiply(quaternion);\\n        return quat;\\n      }, withinClip = function(p) {\\n        return !clip || clip.containsPoint(p);\\n      }, withinOpacity = function(opacity) {\\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\\n      };\\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\\n      const quaternion = new Quaternion().fromArray(\\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\\n      );\\n      const translate = new Vector3().fromArray(\\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\\n      );\\n      const clip = clipXyz ? new Box3(\\n        new Vector3().fromArray(clipXyz.min),\\n        new Vector3().fromArray(clipXyz.max)\\n      ) : void 0;\\n      let fileType = input2.fileType;\\n      if (!fileType) {\\n        fileType = getSplatFileType(input2.fileBytes);\\n        if (!fileType && input2.pathOrUrl) {\\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\\n        }\\n      }\\n      switch (fileType) {\\n        case SplatFileType.PLY: {\\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\\n          await ply.parseHeader();\\n          let lastIndex = null;\\n          ply.parseSplats(\\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n              const center = transformPos(new Vector3(x2, y, z));\\n              if (withinClip(center) && withinOpacity(opacity)) {\\n                lastIndex = splats.pushSplat();\\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\\n                const scales = transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\\n                const quaternion2 = transformQuaternion(\\n                  new Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                splats.setQuaternion(\\n                  lastIndex,\\n                  quaternion2.x,\\n                  quaternion2.y,\\n                  quaternion2.z,\\n                  quaternion2.w\\n                );\\n                splats.setOpacity(lastIndex, opacity);\\n                splats.setColor(lastIndex, r, g, b);\\n              } else {\\n                lastIndex = null;\\n              }\\n            },\\n            (index, sh1, sh2, sh3) => {\\n              if (sh1 && lastIndex !== null) {\\n                splats.setSh1(lastIndex, sh1);\\n              }\\n              if (sh2 && lastIndex !== null) {\\n                splats.setSh2(lastIndex, sh2);\\n              }\\n              if (sh3 && lastIndex !== null) {\\n                splats.setSh3(lastIndex, sh3);\\n              }\\n            }\\n          );\\n          break;\\n        }\\n        case SplatFileType.SPZ: {\\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\\n          const mapping = new Int32Array(spz2.numSplats);\\n          mapping.fill(-1);\\n          const centers = new Float32Array(spz2.numSplats * 3);\\n          const center = new Vector3();\\n          spz2.parseSplats(\\n            (index, x2, y, z) => {\\n              const center2 = transformPos(new Vector3(x2, y, z));\\n              centers[index * 3] = center2.x;\\n              centers[index * 3 + 1] = center2.y;\\n              centers[index * 3 + 2] = center2.z;\\n            },\\n            (index, alpha) => {\\n              center.fromArray(centers, index * 3);\\n              if (withinClip(center) && withinOpacity(alpha)) {\\n                mapping[index] = splats.pushSplat();\\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\\n                splats.setOpacity(mapping[index], alpha);\\n              }\\n            },\\n            (index, r, g, b) => {\\n              if (mapping[index] >= 0) {\\n                splats.setColor(mapping[index], r, g, b);\\n              }\\n            },\\n            (index, scaleX, scaleY, scaleZ) => {\\n              if (mapping[index] >= 0) {\\n                const scales = transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\\n              }\\n            },\\n            (index, quatX, quatY, quatZ, quatW) => {\\n              if (mapping[index] >= 0) {\\n                const quaternion2 = transformQuaternion(\\n                  new Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                splats.setQuaternion(\\n                  mapping[index],\\n                  quaternion2.x,\\n                  quaternion2.y,\\n                  quaternion2.z,\\n                  quaternion2.w\\n                );\\n              }\\n            },\\n            (index, sh1, sh2, sh3) => {\\n              if (mapping[index] >= 0) {\\n                splats.setSh1(mapping[index], sh1);\\n                if (sh2) {\\n                  splats.setSh2(mapping[index], sh2);\\n                }\\n                if (sh3) {\\n                  splats.setSh3(mapping[index], sh3);\\n                }\\n              }\\n            }\\n          );\\n          break;\\n        }\\n        case SplatFileType.SPLAT:\\n          decodeAntiSplat(\\n            input2.fileBytes,\\n            (numSplats) => {\\n            },\\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n              const center = transformPos(new Vector3(x2, y, z));\\n              if (withinClip(center) && withinOpacity(opacity)) {\\n                const index2 = splats.pushSplat();\\n                splats.setCenter(index2, center.x, center.y, center.z);\\n                const scales = transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n                splats.setScale(index2, scales.x, scales.y, scales.z);\\n                const quaternion2 = transformQuaternion(\\n                  new Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                splats.setQuaternion(\\n                  index2,\\n                  quaternion2.x,\\n                  quaternion2.y,\\n                  quaternion2.z,\\n                  quaternion2.w\\n                );\\n                splats.setOpacity(index2, opacity);\\n                splats.setColor(index2, r, g, b);\\n              }\\n            }\\n          );\\n          break;\\n        case SplatFileType.KSPLAT: {\\n          let lastIndex = null;\\n          decodeKsplat(\\n            input2.fileBytes,\\n            (numSplats) => {\\n            },\\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n              const center = transformPos(new Vector3(x2, y, z));\\n              if (withinClip(center) && withinOpacity(opacity)) {\\n                lastIndex = splats.pushSplat();\\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\\n                const scales = transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\\n                const quaternion2 = transformQuaternion(\\n                  new Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                splats.setQuaternion(\\n                  lastIndex,\\n                  quaternion2.x,\\n                  quaternion2.y,\\n                  quaternion2.z,\\n                  quaternion2.w\\n                );\\n                splats.setOpacity(lastIndex, opacity);\\n                splats.setColor(lastIndex, r, g, b);\\n              } else {\\n                lastIndex = null;\\n              }\\n            },\\n            (index, sh1, sh2, sh3) => {\\n              if (lastIndex !== null) {\\n                splats.setSh1(lastIndex, sh1);\\n                if (sh2) {\\n                  splats.setSh2(lastIndex, sh2);\\n                }\\n                if (sh3) {\\n                  splats.setSh3(lastIndex, sh3);\\n                }\\n              }\\n            }\\n          );\\n          break;\\n        }\\n        default:\\n          throw new Error(`transcodeSpz not implemented for ${fileType}`);\\n      }\\n    }\\n    const shDegree = Math.min(\\n      maxSh ?? 3,\\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\\n    );\\n    const spz = new SpzWriter({\\n      numSplats: splats.numSplats,\\n      shDegree,\\n      fractionalBits,\\n      flagAntiAlias: true\\n    });\\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\\n      const i3 = i2 * 3;\\n      const i4 = i2 * 4;\\n      spz.setCenter(\\n        i2,\\n        splats.centers[i3],\\n        splats.centers[i3 + 1],\\n        splats.centers[i3 + 2]\\n      );\\n      spz.setScale(\\n        i2,\\n        splats.scales[i3],\\n        splats.scales[i3 + 1],\\n        splats.scales[i3 + 2]\\n      );\\n      spz.setQuat(\\n        i2,\\n        splats.quaternions[i4],\\n        splats.quaternions[i4 + 1],\\n        splats.quaternions[i4 + 2],\\n        splats.quaternions[i4 + 3]\\n      );\\n      spz.setAlpha(i2, splats.opacities[i2]);\\n      spz.setRgb(\\n        i2,\\n        splats.colors[i3],\\n        splats.colors[i3 + 1],\\n        splats.colors[i3 + 2]\\n      );\\n      if (splats.sh1 && shDegree >= 1) {\\n        spz.setSh(\\n          i2,\\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\\n        );\\n      }\\n    }\\n    const spzBytes = await spz.finalize();\\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\\n  }\\n  async function onMessage(event) {\\n    const { name, args, id } = event.data;\\n    let result = void 0;\\n    let error = void 0;\\n    try {\\n      switch (name) {\\n        case \"unpackPly\": {\\n          const { packedArray, fileBytes, splatEncoding } = args;\\n          const decoded = await unpackPly({\\n            packedArray,\\n            fileBytes,\\n            splatEncoding\\n          });\\n          result = {\\n            id,\\n            numSplats: decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n          };\\n          break;\\n        }\\n        case \"decodeSpz\": {\\n          const { fileBytes, splatEncoding } = args;\\n          const decoded = unpackSpz(fileBytes, splatEncoding);\\n          result = {\\n            id,\\n            numSplats: decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n          };\\n          break;\\n        }\\n        case \"decodeAntiSplat\": {\\n          const { fileBytes, splatEncoding } = args;\\n          const decoded = unpackAntiSplat(fileBytes, splatEncoding);\\n          result = {\\n            id,\\n            numSplats: decoded.numSplats,\\n            packedArray: decoded.packedArray\\n          };\\n          break;\\n        }\\n        case \"decodeKsplat\": {\\n          const { fileBytes, splatEncoding } = args;\\n          const decoded = unpackKsplat(fileBytes, splatEncoding);\\n          result = {\\n            id,\\n            numSplats: decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n          };\\n          break;\\n        }\\n        case \"decodePcSogs\": {\\n          const { fileBytes, extraFiles, splatEncoding } = args;\\n          const json = JSON.parse(\\n            new TextDecoder().decode(fileBytes)\\n          );\\n          const decoded = await unpackPcSogs(json, extraFiles, splatEncoding);\\n          result = {\\n            id,\\n            numSplats: decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n          };\\n          break;\\n        }\\n        case \"decodePcSogsZip\": {\\n          const { fileBytes, splatEncoding } = args;\\n          const decoded = await unpackPcSogsZip(fileBytes, splatEncoding);\\n          result = {\\n            id,\\n            numSplats: decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n          };\\n          break;\\n        }\\n        case \"sortSplats\": {\\n          const { totalSplats, readback, ordering } = args;\\n          result = {\\n            id,\\n            readback,\\n            ...sortSplats({ totalSplats, readback, ordering })\\n          };\\n          break;\\n        }\\n        case \"sortDoubleSplats\": {\\n          const { numSplats, readback, ordering } = args;\\n          {\\n            result = {\\n              id,\\n              readback,\\n              ordering,\\n              activeSplats: sort_splats(numSplats, readback, ordering)\\n            };\\n          }\\n          break;\\n        }\\n        case \"sort32Splats\": {\\n          const { numSplats, readback, ordering } = args;\\n          {\\n            result = {\\n              id,\\n              readback,\\n              ordering,\\n              activeSplats: sort32_splats(numSplats, readback, ordering)\\n            };\\n          }\\n          break;\\n        }\\n        case \"transcodeSpz\": {\\n          const input = args;\\n          const spzBytes = await transcodeSpz(input);\\n          result = {\\n            id,\\n            fileBytes: spzBytes,\\n            input\\n          };\\n          break;\\n        }\\n        default: {\\n          throw new Error(`Unknown name: ${name}`);\\n        }\\n      }\\n    } catch (e) {\\n      error = e;\\n      console.error(error);\\n    }\\n    self.postMessage(\\n      { id, result, error },\\n      { transfer: getArrayBuffers(result) }\\n    );\\n  }\\n  async function unpackPly({\\n    packedArray,\\n    fileBytes,\\n    splatEncoding\\n  }) {\\n    const ply = new PlyReader({ fileBytes });\\n    await ply.parseHeader();\\n    const numSplats = ply.numSplats;\\n    const extra = {};\\n    ply.parseSplats(\\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n        setPackedSplat(\\n          packedArray,\\n          index,\\n          x2,\\n          y,\\n          z,\\n          scaleX,\\n          scaleY,\\n          scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n          quatW,\\n          opacity,\\n          r,\\n          g,\\n          b,\\n          splatEncoding\\n        );\\n      },\\n      (index, sh1, sh2, sh3) => {\\n        if (sh1) {\\n          if (!extra.sh1) {\\n            extra.sh1 = new Uint32Array(numSplats * 2);\\n          }\\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\\n        }\\n        if (sh2) {\\n          if (!extra.sh2) {\\n            extra.sh2 = new Uint32Array(numSplats * 4);\\n          }\\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\\n        }\\n        if (sh3) {\\n          if (!extra.sh3) {\\n            extra.sh3 = new Uint32Array(numSplats * 4);\\n          }\\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\\n        }\\n      }\\n    );\\n    return { packedArray, numSplats, extra };\\n  }\\n  function unpackSpz(fileBytes, splatEncoding) {\\n    const spz = new SpzReader({ fileBytes });\\n    const numSplats = spz.numSplats;\\n    const maxSplats = computeMaxSplats(numSplats);\\n    const packedArray = new Uint32Array(maxSplats * 4);\\n    const extra = {};\\n    spz.parseSplats(\\n      (index, x2, y, z) => {\\n        setPackedSplatCenter(packedArray, index, x2, y, z);\\n      },\\n      (index, alpha) => {\\n        setPackedSplatOpacity(packedArray, index, alpha);\\n      },\\n      (index, r, g, b) => {\\n        setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);\\n      },\\n      (index, scaleX, scaleY, scaleZ) => {\\n        setPackedSplatScales(\\n          packedArray,\\n          index,\\n          scaleX,\\n          scaleY,\\n          scaleZ,\\n          splatEncoding\\n        );\\n      },\\n      (index, quatX, quatY, quatZ, quatW) => {\\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\\n      },\\n      (index, sh1, sh2, sh3) => {\\n        if (sh1) {\\n          if (!extra.sh1) {\\n            extra.sh1 = new Uint32Array(numSplats * 2);\\n          }\\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\\n        }\\n        if (sh2) {\\n          if (!extra.sh2) {\\n            extra.sh2 = new Uint32Array(numSplats * 4);\\n          }\\n          encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\\n        }\\n        if (sh3) {\\n          if (!extra.sh3) {\\n            extra.sh3 = new Uint32Array(numSplats * 4);\\n          }\\n          encodeSh3Rgb(extra.sh3, index, sh3, splatEncoding);\\n        }\\n      }\\n    );\\n    return { packedArray, numSplats, extra };\\n  }\\n  const DEPTH_INFINITY_F16 = 31744;\\n  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;\\n  let depthArray16 = null;\\n  function sortSplats({\\n    totalSplats,\\n    readback,\\n    ordering\\n  }) {\\n    if (!depthArray16) {\\n      depthArray16 = new Uint32Array(DEPTH_SIZE_16);\\n    }\\n    depthArray16.fill(0);\\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\\n    const layerSize = readbackUint32[0].length;\\n    const numLayers = Math.ceil(totalSplats / layerSize);\\n    let layerBase = 0;\\n    for (let layer = 0; layer < numLayers; ++layer) {\\n      const readbackLayer = readbackUint32[layer];\\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\\n        const pri = readbackLayer[i2] & 32767;\\n        if (pri < DEPTH_INFINITY_F16) {\\n          depthArray16[pri] += 1;\\n        }\\n      }\\n      layerBase += layerSplats;\\n    }\\n    let activeSplats = 0;\\n    for (let j = 0; j < DEPTH_SIZE_16; ++j) {\\n      const nextIndex = activeSplats + depthArray16[j];\\n      depthArray16[j] = activeSplats;\\n      activeSplats = nextIndex;\\n    }\\n    layerBase = 0;\\n    for (let layer = 0; layer < numLayers; ++layer) {\\n      const readbackLayer = readbackUint32[layer];\\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\\n        const pri = readbackLayer[i2] & 32767;\\n        if (pri < DEPTH_INFINITY_F16) {\\n          ordering[depthArray16[pri]] = layerBase + i2;\\n          depthArray16[pri] += 1;\\n        }\\n      }\\n      layerBase += layerSplats;\\n    }\\n    if (depthArray16[DEPTH_SIZE_16 - 1] !== activeSplats) {\\n      throw new Error(\\n        `Expected ${activeSplats} active splats but got ${depthArray16[DEPTH_SIZE_16 - 1]}`\\n      );\\n    }\\n    return { activeSplats, ordering };\\n  }\\n  const messageBuffer = [];\\n  function bufferMessage(event) {\\n    messageBuffer.push(event);\\n  }\\n  async function initialize() {\\n    self.addEventListener(\"message\", bufferMessage);\\n    await __wbg_init();\\n    self.removeEventListener(\"message\", bufferMessage);\\n    self.addEventListener(\"message\", onMessage);\\n    for (const event of messageBuffer) {\\n      onMessage(event);\\n    }\\n    messageBuffer.length = 0;\\n  }\\n  initialize().catch(console.error);\\n})();\\n//# sourceMappingURL=worker-C1ojSBY1.js.map\\n';\nconst blob = typeof self !== \"undefined\" && self.Blob && new Blob([jsContent], { type: \"text/javascript;charset=utf-8\" });\nfunction WorkerWrapper(options) {\n  let objURL;\n  try {\n    objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);\n    if (!objURL) throw \"\";\n    const worker = new Worker(objURL, {\n      name: options == null ? void 0 : options.name\n    });\n    worker.addEventListener(\"error\", () => {\n      (self.URL || self.webkitURL).revokeObjectURL(objURL);\n    });\n    return worker;\n  } catch (e) {\n    return new Worker(\n      \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(jsContent),\n      {\n        name: options == null ? void 0 : options.name\n      }\n    );\n  } finally {\n    objURL && (self.URL || self.webkitURL).revokeObjectURL(objURL);\n  }\n}\nclass SplatWorker {\n  constructor() {\n    this.messages = {};\n    this.messageIdNext = 0;\n    this.worker = new WorkerWrapper();\n    this.worker.onmessage = (event) => this.onMessage(event);\n  }\n  makeMessageId() {\n    return ++this.messageIdNext;\n  }\n  makeMessagePromiseId() {\n    const id = this.makeMessageId();\n    const promise = new Promise((resolve, reject) => {\n      this.messages[id] = { resolve, reject };\n    });\n    return { id, promise };\n  }\n  onMessage(event) {\n    const { id, result, error } = event.data;\n    const handler = this.messages[id];\n    if (handler) {\n      delete this.messages[id];\n      if (error) {\n        handler.reject(error);\n      } else {\n        handler.resolve(result);\n      }\n    }\n  }\n  // Invoke an RPC on the worker with the given name and arguments.\n  // The normal usage of a worker is to run one activity at a time,\n  // but this function allows for concurrent calls, tagging each request\n  // with a unique message Id and awaiting a response to that same Id.\n  // The method will automatically transfer any ArrayBuffers in the\n  // arguments to the worker. If you'd like to transfer a copy of a\n  // buffer then you must clone it before passing to this function.\n  async call(name, args) {\n    const { id, promise } = this.makeMessagePromiseId();\n    this.worker.postMessage(\n      { name, args, id },\n      { transfer: getArrayBuffers(args) }\n    );\n    return promise;\n  }\n}\nlet maxWorkers = 4;\nlet numWorkers = 0;\nconst freeWorkers = [];\nconst workerQueue = [];\nasync function allocWorker() {\n  const worker = freeWorkers.shift();\n  if (worker) {\n    return worker;\n  }\n  if (numWorkers < maxWorkers) {\n    const worker2 = new SplatWorker();\n    numWorkers += 1;\n    return worker2;\n  }\n  return new Promise((resolve) => {\n    workerQueue.push(resolve);\n  });\n}\nfunction freeWorker(worker) {\n  if (numWorkers > maxWorkers) {\n    numWorkers -= 1;\n    return;\n  }\n  const waiter = workerQueue.shift();\n  if (waiter) {\n    waiter(worker);\n    return;\n  }\n  freeWorkers.push(worker);\n}\nasync function withWorker(callback) {\n  const worker = await allocWorker();\n  try {\n    return await callback(worker);\n  } finally {\n    freeWorker(worker);\n  }\n}\nclass SplatLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.fileLoader = new FileLoader(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const resolvedURL = this.manager.resolveURL(\n      (this.path ?? \"\") + (url ?? \"\")\n    );\n    const headers = new Headers(this.requestHeader);\n    const credentials = this.withCredentials ? \"include\" : \"same-origin\";\n    const request = new Request(resolvedURL, { headers, credentials });\n    let fileType = this.fileType;\n    this.manager.itemStart(resolvedURL);\n    fetchWithProgress(request, onProgress).then(async (input) => {\n      var _a2;\n      const progresses = [\n        new ProgressEvent(\"progress\", {\n          lengthComputable: true,\n          loaded: input.byteLength,\n          total: input.byteLength\n        })\n      ];\n      function updateProgresses() {\n        if (onProgress) {\n          const lengthComputable = progresses.every((p) => {\n            return p.lengthComputable || p.loaded === 0 && p.total === 0;\n          });\n          const loaded = progresses.reduce((sum, p) => sum + p.loaded, 0);\n          const total = progresses.reduce((sum, p) => sum + p.total, 0);\n          onProgress(\n            new ProgressEvent(\"progress\", {\n              lengthComputable,\n              loaded,\n              total\n            })\n          );\n        }\n      }\n      const extraFiles = {};\n      const promises = [];\n      const pcSogsJson = tryPcSogs(input);\n      if (fileType === \"pcsogs\") {\n        if (pcSogsJson === void 0) {\n          throw new Error(\"Invalid PC SOGS file\");\n        }\n      }\n      if (pcSogsJson !== void 0) {\n        fileType = \"pcsogs\";\n        for (const key of [\"means\", \"scales\", \"quats\", \"sh0\", \"shN\"]) {\n          const prop = pcSogsJson[key];\n          if (prop) {\n            for (const file of prop.files) {\n              const fileUrl = new URL(file, resolvedURL).toString();\n              const progressIndex = progresses.length;\n              progresses.push(new ProgressEvent(\"progress\"));\n              this.manager.itemStart(fileUrl);\n              const request2 = new Request(fileUrl, { headers, credentials });\n              const promise = fetchWithProgress(request2, (progress) => {\n                progresses[progressIndex] = progress;\n                updateProgresses();\n              }).then((data) => {\n                extraFiles[file] = data;\n              }).catch((error) => {\n                this.manager.itemError(fileUrl);\n                throw error;\n              }).finally(() => {\n                this.manager.itemEnd(fileUrl);\n              });\n              promises.push(promise);\n            }\n          }\n        }\n      }\n      await Promise.all(promises);\n      if (onLoad) {\n        const splatEncoding = ((_a2 = this.packedSplats) == null ? void 0 : _a2.splatEncoding) ?? DEFAULT_SPLAT_ENCODING;\n        const decoded = await unpackSplats({\n          input,\n          extraFiles,\n          fileType,\n          pathOrUrl: resolvedURL,\n          splatEncoding\n        });\n        if (this.packedSplats) {\n          this.packedSplats.initialize(decoded);\n          onLoad(this.packedSplats);\n        } else {\n          onLoad(new PackedSplats(decoded));\n        }\n      }\n    }).catch((error) => {\n      this.manager.itemError(resolvedURL);\n      onError == null ? void 0 : onError(error);\n    }).finally(() => {\n      this.manager.itemEnd(resolvedURL);\n    });\n  }\n  async loadAsync(url, onProgress) {\n    return new Promise((resolve, reject) => {\n      this.load(\n        url,\n        (decoded) => {\n          resolve(decoded);\n        },\n        onProgress,\n        reject\n      );\n    });\n  }\n  parse(packedSplats) {\n    return new SplatMesh({ packedSplats });\n  }\n}\nasync function fetchWithProgress(request, onProgress) {\n  const response = await fetch(request);\n  if (!response.ok) {\n    throw new Error(\n      `${response.status} \"${response.statusText}\" fetching URL: ${request.url}`\n    );\n  }\n  if (!response.body) {\n    throw new Error(`Response body is null for URL: ${request.url}`);\n  }\n  const reader = response.body.getReader();\n  const contentLength = Number.parseInt(\n    response.headers.get(\"Content-Length\") || \"0\"\n  );\n  const total = Number.isNaN(contentLength) ? 0 : contentLength;\n  let loaded = 0;\n  const chunks = [];\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    chunks.push(value);\n    loaded += value.length;\n    if (onProgress) {\n      onProgress(\n        new ProgressEvent(\"progress\", {\n          lengthComputable: total !== 0,\n          loaded,\n          total\n        })\n      );\n    }\n  }\n  const bytes = new Uint8Array(loaded);\n  let offset = 0;\n  for (const chunk of chunks) {\n    bytes.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return bytes.buffer;\n}\nvar SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n  SplatFileType2[\"PLY\"] = \"ply\";\n  SplatFileType2[\"SPZ\"] = \"spz\";\n  SplatFileType2[\"SPLAT\"] = \"splat\";\n  SplatFileType2[\"KSPLAT\"] = \"ksplat\";\n  SplatFileType2[\"PCSOGS\"] = \"pcsogs\";\n  SplatFileType2[\"PCSOGSZIP\"] = \"pcsogszip\";\n  return SplatFileType2;\n})(SplatFileType || {});\nfunction getSplatFileType(fileBytes) {\n  const view = new DataView(fileBytes.buffer);\n  if ((view.getUint32(0, true) & 16777215) === 7957616) {\n    return \"ply\";\n  }\n  if ((view.getUint32(0, true) & 16777215) === 559903) {\n    const header = decompressPartialGzip(fileBytes, 4);\n    const gView = new DataView(header.buffer);\n    if (gView.getUint32(0, true) === 1347635022) {\n      return \"spz\";\n    }\n    return void 0;\n  }\n  if (view.getUint32(0, true) === 67324752) {\n    if (tryPcSogsZip(fileBytes)) {\n      return \"pcsogszip\";\n    }\n    return void 0;\n  }\n  return void 0;\n}\nfunction getFileExtension(pathOrUrl) {\n  const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n  const lastSlash = Math.max(\n    noTrailing.lastIndexOf(\"/\"),\n    noTrailing.lastIndexOf(\"\\\\\")\n  );\n  const filename = noTrailing.slice(lastSlash + 1);\n  const lastDot = filename.lastIndexOf(\".\");\n  if (lastDot <= 0 || lastDot === filename.length - 1) {\n    return \"\";\n  }\n  return filename.slice(lastDot + 1).toLowerCase();\n}\nfunction getSplatFileTypeFromPath(pathOrUrl) {\n  const extension = getFileExtension(pathOrUrl);\n  if (extension === \"ply\") {\n    return \"ply\";\n  }\n  if (extension === \"spz\") {\n    return \"spz\";\n  }\n  if (extension === \"splat\") {\n    return \"splat\";\n  }\n  if (extension === \"ksplat\") {\n    return \"ksplat\";\n  }\n  return void 0;\n}\nfunction isPcSogs(input) {\n  return tryPcSogs(input) !== void 0;\n}\nfunction tryPcSogs(input) {\n  try {\n    let text;\n    if (typeof input === \"string\") {\n      text = input;\n    } else {\n      const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n      if (fileBytes.length > 65536) {\n        return void 0;\n      }\n      text = new TextDecoder().decode(fileBytes);\n    }\n    const json = JSON.parse(text);\n    if (!json || typeof json !== \"object\" || Array.isArray(json)) {\n      return void 0;\n    }\n    for (const key of [\"means\", \"scales\", \"quats\", \"sh0\"]) {\n      if (!json[key] || typeof json[key] !== \"object\" || Array.isArray(json[key])) {\n        return void 0;\n      }\n      if (!json[key].shape || !json[key].files) {\n        return void 0;\n      }\n      if (key !== \"quats\" && (!json[key].mins || !json[key].maxs)) {\n        return void 0;\n      }\n    }\n    return json;\n  } catch {\n    return void 0;\n  }\n}\nfunction tryPcSogsZip(input) {\n  try {\n    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let metaFilename = null;\n    const unzipped = unzipSync(fileBytes, {\n      filter: ({ name }) => {\n        const filename = name.split(/[\\\\/]/).pop();\n        if (filename === \"meta.json\") {\n          metaFilename = name;\n          return true;\n        }\n        return false;\n      }\n    });\n    if (!metaFilename) {\n      return void 0;\n    }\n    const json = tryPcSogs(unzipped[metaFilename]);\n    if (!json) {\n      return void 0;\n    }\n    return { name: metaFilename, json };\n  } catch {\n    return void 0;\n  }\n}\nasync function unpackSplats({\n  input,\n  extraFiles,\n  fileType,\n  pathOrUrl,\n  splatEncoding\n}) {\n  const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n  let splatFileType = fileType;\n  if (!fileType) {\n    splatFileType = getSplatFileType(fileBytes);\n    if (!splatFileType && pathOrUrl) {\n      splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n    }\n  }\n  switch (splatFileType) {\n    case \"ply\": {\n      const ply = new PlyReader({ fileBytes });\n      await ply.parseHeader();\n      const numSplats = ply.numSplats;\n      const maxSplats = getTextureSize(numSplats).maxSplats;\n      const args = {\n        fileBytes,\n        packedArray: new Uint32Array(maxSplats * 4),\n        splatEncoding\n      };\n      return await withWorker(async (worker) => {\n        const { packedArray, numSplats: numSplats2, extra } = await worker.call(\n          \"unpackPly\",\n          args\n        );\n        return { packedArray, numSplats: numSplats2, extra };\n      });\n    }\n    case \"spz\": {\n      return await withWorker(async (worker) => {\n        const { packedArray, numSplats, extra } = await worker.call(\n          \"decodeSpz\",\n          {\n            fileBytes,\n            splatEncoding\n          }\n        );\n        return { packedArray, numSplats, extra };\n      });\n    }\n    case \"splat\": {\n      return await withWorker(async (worker) => {\n        const { packedArray, numSplats } = await worker.call(\n          \"decodeAntiSplat\",\n          {\n            fileBytes,\n            splatEncoding\n          }\n        );\n        return { packedArray, numSplats };\n      });\n    }\n    case \"ksplat\": {\n      return await withWorker(async (worker) => {\n        const { packedArray, numSplats, extra } = await worker.call(\n          \"decodeKsplat\",\n          { fileBytes, splatEncoding }\n        );\n        return { packedArray, numSplats, extra };\n      });\n    }\n    case \"pcsogs\": {\n      return await withWorker(async (worker) => {\n        const { packedArray, numSplats, extra } = await worker.call(\n          \"decodePcSogs\",\n          { fileBytes, extraFiles, splatEncoding }\n        );\n        return { packedArray, numSplats, extra };\n      });\n    }\n    case \"pcsogszip\": {\n      return await withWorker(async (worker) => {\n        const { packedArray, numSplats, extra } = await worker.call(\n          \"decodePcSogsZip\",\n          { fileBytes, splatEncoding }\n        );\n        return { packedArray, numSplats, extra };\n      });\n    }\n    default: {\n      throw new Error(`Unknown splat file type: ${splatFileType}`);\n    }\n  }\n}\nclass SplatData {\n  constructor({ maxSplats = 1 } = {}) {\n    this.numSplats = 0;\n    this.maxSplats = getTextureSize(maxSplats).maxSplats;\n    this.centers = new Float32Array(this.maxSplats * 3);\n    this.scales = new Float32Array(this.maxSplats * 3);\n    this.quaternions = new Float32Array(this.maxSplats * 4);\n    this.opacities = new Float32Array(this.maxSplats);\n    this.colors = new Float32Array(this.maxSplats * 3);\n  }\n  pushSplat() {\n    const index = this.numSplats;\n    this.ensureIndex(index);\n    this.numSplats += 1;\n    return index;\n  }\n  unpushSplat(index) {\n    if (index === this.numSplats - 1) {\n      this.numSplats -= 1;\n    } else {\n      throw new Error(\"Cannot unpush splat from non-last position\");\n    }\n  }\n  ensureCapacity(numSplats) {\n    if (numSplats > this.maxSplats) {\n      const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n      const newCenters = new Float32Array(targetSplats * 3);\n      const newScales = new Float32Array(targetSplats * 3);\n      const newQuaternions = new Float32Array(targetSplats * 4);\n      const newOpacities = new Float32Array(targetSplats);\n      const newColors = new Float32Array(targetSplats * 3);\n      newCenters.set(this.centers);\n      newScales.set(this.scales);\n      newQuaternions.set(this.quaternions);\n      newOpacities.set(this.opacities);\n      newColors.set(this.colors);\n      this.centers = newCenters;\n      this.scales = newScales;\n      this.quaternions = newQuaternions;\n      this.opacities = newOpacities;\n      this.colors = newColors;\n      if (this.sh1) {\n        const newSh1 = new Float32Array(targetSplats * 9);\n        newSh1.set(this.sh1);\n        this.sh1 = newSh1;\n      }\n      if (this.sh2) {\n        const newSh2 = new Float32Array(targetSplats * 15);\n        newSh2.set(this.sh2);\n        this.sh2 = newSh2;\n      }\n      if (this.sh3) {\n        const newSh3 = new Float32Array(targetSplats * 21);\n        newSh3.set(this.sh3);\n        this.sh3 = newSh3;\n      }\n      this.maxSplats = targetSplats;\n    }\n  }\n  ensureIndex(index) {\n    this.ensureCapacity(index + 1);\n  }\n  setCenter(index, x, y, z) {\n    this.centers[index * 3] = x;\n    this.centers[index * 3 + 1] = y;\n    this.centers[index * 3 + 2] = z;\n  }\n  setScale(index, scaleX, scaleY, scaleZ) {\n    this.scales[index * 3] = scaleX;\n    this.scales[index * 3 + 1] = scaleY;\n    this.scales[index * 3 + 2] = scaleZ;\n  }\n  setQuaternion(index, x, y, z, w) {\n    this.quaternions[index * 4] = x;\n    this.quaternions[index * 4 + 1] = y;\n    this.quaternions[index * 4 + 2] = z;\n    this.quaternions[index * 4 + 3] = w;\n  }\n  setOpacity(index, opacity) {\n    this.opacities[index] = opacity;\n  }\n  setColor(index, r, g, b) {\n    this.colors[index * 3] = r;\n    this.colors[index * 3 + 1] = g;\n    this.colors[index * 3 + 2] = b;\n  }\n  setSh1(index, sh1) {\n    if (!this.sh1) {\n      this.sh1 = new Float32Array(this.maxSplats * 9);\n    }\n    for (let j = 0; j < 9; ++j) {\n      this.sh1[index * 9 + j] = sh1[j];\n    }\n  }\n  setSh2(index, sh2) {\n    if (!this.sh2) {\n      this.sh2 = new Float32Array(this.maxSplats * 15);\n    }\n    for (let j = 0; j < 15; ++j) {\n      this.sh2[index * 15 + j] = sh2[j];\n    }\n  }\n  setSh3(index, sh3) {\n    if (!this.sh3) {\n      this.sh3 = new Float32Array(this.maxSplats * 21);\n    }\n    for (let j = 0; j < 21; ++j) {\n      this.sh3[index * 21 + j] = sh3[j];\n    }\n  }\n}\nvar computeUvec4_default = \"precision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp usampler3D;\\nprecision highp isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if ((index >= 0) && (index < targetCount)) {\\n        produceSplat(index);\\n    } else {\\n        target = uvec4(0u, 0u, 0u, 0u);\\n    }\\n}\";\nconst DEFAULT_SPLAT_ENCODING = {\n  rgbMin: 0,\n  rgbMax: 1,\n  lnScaleMin: LN_SCALE_MIN,\n  lnScaleMax: LN_SCALE_MAX,\n  sh1Min: -1,\n  sh1Max: 1,\n  sh2Min: -1,\n  sh2Max: 1,\n  sh3Min: -1,\n  sh3Max: 1\n};\nconst _PackedSplats = class _PackedSplats {\n  constructor(options = {}) {\n    this.maxSplats = 0;\n    this.numSplats = 0;\n    this.packedArray = null;\n    this.isInitialized = false;\n    this.target = null;\n    this.source = null;\n    this.needsUpdate = true;\n    this.extra = {};\n    this.dyno = new DynoPackedSplats({ packedSplats: this });\n    this.dynoRgbMinMaxLnScaleMinMax = new DynoVec4({\n      key: \"rgbMinMaxLnScaleMinMax\",\n      value: new THREE.Vector4(0, 1, LN_SCALE_MIN, LN_SCALE_MAX),\n      update: (value) => {\n        var _a2, _b2, _c, _d;\n        value.set(\n          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,\n          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? 1,\n          ((_c = this.splatEncoding) == null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,\n          ((_d = this.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX\n        );\n        return value;\n      }\n    });\n    this.dynoSh1MinMax = new DynoVec2({\n      key: \"sh1MinMax\",\n      value: new THREE.Vector2(-1, 1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh1Min) ?? -1,\n          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh1Max) ?? 1\n        );\n        return value;\n      }\n    });\n    this.dynoSh2MinMax = new DynoVec2({\n      key: \"sh2MinMax\",\n      value: new THREE.Vector2(-1, 1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh2Min) ?? -1,\n          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh2Max) ?? 1\n        );\n        return value;\n      }\n    });\n    this.dynoSh3MinMax = new DynoVec2({\n      key: \"sh3MinMax\",\n      value: new THREE.Vector2(-1, 1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n          ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh3Min) ?? -1,\n          ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh3Max) ?? 1\n        );\n        return value;\n      }\n    });\n    this.initialized = Promise.resolve(this);\n    this.reinitialize(options);\n  }\n  reinitialize(options) {\n    this.isInitialized = false;\n    this.extra = {};\n    this.splatEncoding = options.splatEncoding;\n    if (options.url || options.fileBytes || options.construct) {\n      this.initialized = this.asyncInitialize(options).then(() => {\n        this.isInitialized = true;\n        return this;\n      });\n    } else {\n      this.initialize(options);\n      this.isInitialized = true;\n      this.initialized = Promise.resolve(this);\n    }\n  }\n  initialize(options) {\n    if (options.packedArray) {\n      this.packedArray = options.packedArray;\n      this.maxSplats = Math.floor(this.packedArray.length / 4);\n      this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      this.numSplats = Math.min(\n        this.maxSplats,\n        options.numSplats ?? Number.POSITIVE_INFINITY\n      );\n    } else {\n      this.maxSplats = options.maxSplats ?? 0;\n      this.numSplats = 0;\n    }\n    this.extra = options.extra ?? {};\n  }\n  async asyncInitialize(options) {\n    const { url, fileBytes, construct } = options;\n    if (url) {\n      const loader = new SplatLoader();\n      loader.packedSplats = this;\n      await loader.loadAsync(url);\n    } else if (fileBytes) {\n      const unpacked = await unpackSplats({\n        input: fileBytes,\n        fileType: options.fileType,\n        pathOrUrl: options.fileName ?? url,\n        splatEncoding: options.splatEncoding ?? DEFAULT_SPLAT_ENCODING\n      });\n      this.initialize(unpacked);\n    }\n    if (construct) {\n      const maybePromise = construct(this);\n      if (maybePromise instanceof Promise) {\n        await maybePromise;\n      }\n    }\n  }\n  // Call this when you are finished with the PackedSplats and want to free\n  // any buffers it holds.\n  dispose() {\n    if (this.target) {\n      this.target.dispose();\n      this.target = null;\n    }\n    if (this.source) {\n      this.source.dispose();\n      this.source = null;\n    }\n  }\n  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,\n  // resize exponentially and copy over the original data.\n  //\n  // Typically you don't need to call this, because calling this.setSplat(index, ...)\n  // and this.pushSplat(...) will automatically call ensureSplats() so we have\n  // enough splats.\n  ensureSplats(numSplats) {\n    const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (\n      // Grow exponentially to avoid frequent reallocations\n      Math.max(numSplats, 2 * this.maxSplats)\n    );\n    const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\n    if (!this.packedArray || targetSize > currentSize) {\n      this.maxSplats = getTextureSize(targetSize).maxSplats;\n      const newArray2 = new Uint32Array(this.maxSplats * 4);\n      if (this.packedArray) {\n        newArray2.set(this.packedArray);\n      }\n      this.packedArray = newArray2;\n    }\n    return this.packedArray;\n  }\n  // Ensure the extra array for the given level is large enough to hold numSplats\n  ensureSplatsSh(level, numSplats) {\n    let wordsPerSplat;\n    let key;\n    if (level === 0) {\n      return this.ensureSplats(numSplats);\n    }\n    if (level === 1) {\n      wordsPerSplat = 2;\n      key = \"sh1\";\n    } else if (level === 2) {\n      wordsPerSplat = 4;\n      key = \"sh2\";\n    } else if (level === 3) {\n      wordsPerSplat = 4;\n      key = \"sh3\";\n    } else {\n      throw new Error(`Invalid level: ${level}`);\n    }\n    let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n    const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\n    if (!this.extra[key] || targetSize > maxSplats) {\n      maxSplats = getTextureSize(targetSize).maxSplats;\n      const newArray2 = new Uint32Array(maxSplats * wordsPerSplat);\n      if (this.extra[key]) {\n        newArray2.set(this.extra[key]);\n      }\n      this.extra[key] = newArray2;\n    }\n    return this.extra[key];\n  }\n  // Unpack the 16-byte Gsplat data at index into the Three.js components\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number 0..1, color: THREE.Color 0..1.\n  getSplat(index) {\n    if (!this.packedArray || index >= this.numSplats) {\n      throw new Error(\"Invalid index\");\n    }\n    return unpackSplat(this.packedArray, index, this.splatEncoding);\n  }\n  // Set all PackedSplat components at index with the provided Gsplat attributes\n  // (can be the same objects returned by getSplat). Ensures there is capacity\n  // for at least index+1 Gsplats.\n  setSplat(index, center, scales, quaternion, opacity, color) {\n    const packedSplats = this.ensureSplats(index + 1);\n    setPackedSplat(\n      packedSplats,\n      index,\n      center.x,\n      center.y,\n      center.z,\n      scales.x,\n      scales.y,\n      scales.z,\n      quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      quaternion.w,\n      opacity,\n      color.r,\n      color.g,\n      color.b\n    );\n    this.numSplats = Math.max(this.numSplats, index + 1);\n  }\n  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n  // construction where you just want to iterate and create a collection of Gsplats.\n  pushSplat(center, scales, quaternion, opacity, color) {\n    const packedSplats = this.ensureSplats(this.numSplats + 1);\n    setPackedSplat(\n      packedSplats,\n      this.numSplats,\n      center.x,\n      center.y,\n      center.z,\n      scales.x,\n      scales.y,\n      scales.z,\n      quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      quaternion.w,\n      opacity,\n      color.r,\n      color.g,\n      color.b\n    );\n    ++this.numSplats;\n  }\n  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n  // and invoke the callback function with the Gsplat attributes.\n  forEachSplat(callback) {\n    if (!this.packedArray || !this.numSplats) {\n      return;\n    }\n    for (let i = 0; i < this.numSplats; ++i) {\n      const unpacked = unpackSplat(this.packedArray, i, this.splatEncoding);\n      callback(\n        i,\n        unpacked.center,\n        unpacked.scales,\n        unpacked.quaternion,\n        unpacked.opacity,\n        unpacked.color\n      );\n    }\n  }\n  // Ensures our PackedSplats.target render target has enough space to generate\n  // maxSplats total Gsplats, and reallocate if not large enough.\n  ensureGenerate(maxSplats) {\n    if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\n      return false;\n    }\n    this.dispose();\n    const textureSize2 = getTextureSize(maxSplats ?? 1);\n    const { width, height, depth } = textureSize2;\n    this.maxSplats = textureSize2.maxSplats;\n    this.target = new THREE.WebGLArrayRenderTarget(width, height, depth, {\n      depthBuffer: false,\n      stencilBuffer: false,\n      generateMipmaps: false,\n      magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    });\n    this.target.texture.format = THREE.RGBAIntegerFormat;\n    this.target.texture.type = THREE.UnsignedIntType;\n    this.target.texture.internalFormat = \"RGBA32UI\";\n    this.target.scissorTest = true;\n    return true;\n  }\n  // Given an array of splatCounts (.numSplats for each\n  // SplatGenerator/SplatMesh in the scene), compute a\n  // \"mapping layout\" in the composite array of generated outputs.\n  generateMapping(splatCounts) {\n    let maxSplats = 0;\n    const mapping = splatCounts.map((numSplats) => {\n      const base = maxSplats;\n      const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      maxSplats += rounded;\n      return { base, count: numSplats };\n    });\n    return { maxSplats, mapping };\n  }\n  // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n  // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n  getTexture() {\n    if (this.target) {\n      return this.target.texture;\n    }\n    if (this.source || this.packedArray) {\n      const source = this.maybeUpdateSource();\n      return source;\n    }\n    return _PackedSplats.getEmpty();\n  }\n  // Check if source texture needs to be created/updated\n  maybeUpdateSource() {\n    if (!this.packedArray) {\n      throw new Error(\"No packed splats\");\n    }\n    if (this.needsUpdate || !this.source) {\n      this.needsUpdate = false;\n      if (this.source) {\n        const { width, height, depth } = this.source.image;\n        if (this.maxSplats !== width * height * depth) {\n          this.source.dispose();\n          this.source = null;\n        }\n      }\n      if (!this.source) {\n        const { width, height, depth } = getTextureSize(this.maxSplats);\n        this.source = new THREE.DataArrayTexture(\n          this.packedArray,\n          width,\n          height,\n          depth\n        );\n        this.source.format = THREE.RGBAIntegerFormat;\n        this.source.type = THREE.UnsignedIntType;\n        this.source.internalFormat = \"RGBA32UI\";\n        this.source.needsUpdate = true;\n      } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\n        this.source.image.data = new Uint8Array(this.packedArray.buffer);\n      }\n      this.source.needsUpdate = true;\n    }\n    return this.source;\n  }\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update with the result of this.getTexture() later.\n  static getEmpty() {\n    if (!_PackedSplats.emptySource) {\n      const { width, height, depth, maxSplats } = getTextureSize(1);\n      const emptyArray = new Uint32Array(maxSplats * 4);\n      _PackedSplats.emptySource = new THREE.DataArrayTexture(\n        emptyArray,\n        width,\n        height,\n        depth\n      );\n      _PackedSplats.emptySource.format = THREE.RGBAIntegerFormat;\n      _PackedSplats.emptySource.type = THREE.UnsignedIntType;\n      _PackedSplats.emptySource.internalFormat = \"RGBA32UI\";\n      _PackedSplats.emptySource.needsUpdate = true;\n    }\n    return _PackedSplats.emptySource;\n  }\n  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n  // generating it if necessary and caching the result.\n  prepareProgramMaterial(generator) {\n    let program = _PackedSplats.generatorProgram.get(generator);\n    if (!program) {\n      const graph = dynoBlock(\n        { index: \"int\" },\n        { output: \"uvec4\" },\n        ({ index }) => {\n          generator.inputs.index = index;\n          const gsplat = generator.outputs.gsplat;\n          const output = outputPackedSplat(\n            gsplat,\n            this.dynoRgbMinMaxLnScaleMinMax\n          );\n          return { output };\n        }\n      );\n      if (!_PackedSplats.programTemplate) {\n        _PackedSplats.programTemplate = new DynoProgramTemplate(\n          computeUvec4_default\n        );\n      }\n      program = new DynoProgram({\n        graph,\n        inputs: { index: \"index\" },\n        outputs: { output: \"target\" },\n        template: _PackedSplats.programTemplate\n      });\n      Object.assign(program.uniforms, {\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      });\n      _PackedSplats.generatorProgram.set(generator, program);\n    }\n    const material = program.prepareMaterial();\n    _PackedSplats.fullScreenQuad.material = material;\n    return { program, material };\n  }\n  saveRenderState(renderer) {\n    return {\n      xrEnabled: renderer.xr.enabled,\n      autoClear: renderer.autoClear\n    };\n  }\n  resetRenderState(renderer, state) {\n    renderer.setRenderTarget(null);\n    renderer.xr.enabled = state.xrEnabled;\n    renderer.autoClear = state.autoClear;\n  }\n  // Executes a dyno program specified by generator which is any DynoBlock that\n  // maps { index: \"int\" } to { gsplat: Gsplat }. This is called in\n  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n  // SplatGenerator instances whose version is newer than what was generated\n  // for it last time.\n  generate({\n    generator,\n    base,\n    count,\n    renderer\n  }) {\n    if (!this.target) {\n      throw new Error(\"Target must be initialized with ensureSplats\");\n    }\n    if (base + count > this.maxSplats) {\n      throw new Error(\"Base + count exceeds maxSplats\");\n    }\n    const { program, material } = this.prepareProgramMaterial(generator);\n    program.update();\n    const renderState = this.saveRenderState(renderer);\n    const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n    const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n    material.uniforms.targetBase.value = base;\n    material.uniforms.targetCount.value = count;\n    while (base < nextBase) {\n      const layer = Math.floor(base / layerSize);\n      material.uniforms.targetLayer.value = layer;\n      const layerBase = layer * layerSize;\n      const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\n      const layerYEnd = Math.min(\n        SPLAT_TEX_HEIGHT,\n        Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)\n      );\n      this.target.scissor.set(\n        0,\n        layerYStart,\n        SPLAT_TEX_WIDTH,\n        layerYEnd - layerYStart\n      );\n      renderer.setRenderTarget(this.target, layer);\n      renderer.xr.enabled = false;\n      renderer.autoClear = false;\n      _PackedSplats.fullScreenQuad.render(renderer);\n      base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\n    }\n    this.resetRenderState(renderer, renderState);\n    return { nextBase };\n  }\n};\n_PackedSplats.emptySource = null;\n_PackedSplats.programTemplate = null;\n_PackedSplats.generatorProgram = /* @__PURE__ */ new Map();\n_PackedSplats.fullScreenQuad = new FullScreenQuad(\n  new THREE.RawShaderMaterial({ visible: false })\n);\nlet PackedSplats = _PackedSplats;\nclass DynoPackedSplats extends DynoUniform {\n  constructor({ packedSplats } = {}) {\n    super({\n      key: \"packedSplats\",\n      type: TPackedSplats,\n      globals: () => [definePackedSplats],\n      value: {\n        texture: PackedSplats.getEmpty(),\n        numSplats: 0,\n        rgbMinMaxLnScaleMinMax: new THREE.Vector4(\n          0,\n          1,\n          LN_SCALE_MIN,\n          LN_SCALE_MAX\n        )\n      },\n      update: (value) => {\n        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;\n        value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();\n        value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n        value.rgbMinMaxLnScaleMinMax.set(\n          ((_d = (_c = this.packedSplats) == null ? void 0 : _c.splatEncoding) == null ? void 0 : _d.rgbMin) ?? 0,\n          ((_f = (_e = this.packedSplats) == null ? void 0 : _e.splatEncoding) == null ? void 0 : _f.rgbMax) ?? 1,\n          ((_h = (_g = this.packedSplats) == null ? void 0 : _g.splatEncoding) == null ? void 0 : _h.lnScaleMin) ?? LN_SCALE_MIN,\n          ((_j = (_i = this.packedSplats) == null ? void 0 : _i.splatEncoding) == null ? void 0 : _j.lnScaleMax) ?? LN_SCALE_MAX\n        );\n        return value;\n      }\n    });\n    this.packedSplats = packedSplats;\n  }\n}\nclass SplatGeometry extends THREE.InstancedBufferGeometry {\n  constructor(ordering, activeSplats) {\n    super();\n    this.ordering = ordering;\n    this.setAttribute(\"position\", new THREE.BufferAttribute(QUAD_VERTICES, 3));\n    this.setIndex(new THREE.BufferAttribute(QUAD_INDICES, 1));\n    this._maxInstanceCount = ordering.length;\n    this.instanceCount = activeSplats;\n    this.attribute = new THREE.InstancedBufferAttribute(ordering, 1, false, 1);\n    this.attribute.setUsage(THREE.DynamicDrawUsage);\n    this.setAttribute(\"splatIndex\", this.attribute);\n  }\n  update(ordering, activeSplats) {\n    this.ordering = ordering;\n    this.attribute.array = ordering;\n    this.instanceCount = activeSplats;\n    this.attribute.addUpdateRange(0, activeSplats);\n    this.attribute.needsUpdate = true;\n  }\n}\nconst QUAD_VERTICES = new Float32Array([\n  -1,\n  -1,\n  0,\n  1,\n  -1,\n  0,\n  1,\n  1,\n  0,\n  -1,\n  1,\n  0\n]);\nconst QUAD_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3]);\nconst _SparkViewpoint = class _SparkViewpoint {\n  constructor(options) {\n    this.lastTime = null;\n    this.encodeLinear = false;\n    this.superXY = 1;\n    this.display = null;\n    this.sorting = null;\n    this.pending = null;\n    this.sortingCheck = false;\n    this.readback16 = new Uint16Array(0);\n    this.readback32 = new Uint32Array(0);\n    this.spark = options.spark;\n    this.camera = options.camera;\n    this.viewToWorld = options.viewToWorld ?? new THREE.Matrix4();\n    if (options.target) {\n      const { width, height, doubleBuffer } = options.target;\n      const superXY = Math.max(1, Math.min(4, options.target.superXY ?? 1));\n      this.superXY = superXY;\n      if (width * superXY > 8192 || height * superXY > 8192) {\n        throw new Error(\"Target size too large\");\n      }\n      this.target = new THREE.WebGLRenderTarget(\n        width * superXY,\n        height * superXY,\n        {\n          format: THREE.RGBAFormat,\n          type: THREE.UnsignedByteType,\n          colorSpace: THREE.SRGBColorSpace\n        }\n      );\n      if (doubleBuffer) {\n        this.back = new THREE.WebGLRenderTarget(\n          width * superXY,\n          height * superXY,\n          {\n            format: THREE.RGBAFormat,\n            type: THREE.UnsignedByteType,\n            colorSpace: THREE.SRGBColorSpace\n          }\n        );\n      }\n      this.encodeLinear = true;\n    }\n    this.onTextureUpdated = options.onTextureUpdated;\n    this.sortRadial = options.sortRadial ?? true;\n    this.sortDistance = options.sortDistance;\n    this.sortCoorient = options.sortCoorient;\n    this.depthBias = options.depthBias;\n    this.sort360 = options.sort360;\n    this.sort32 = options.sort32;\n    this.stochastic = options.stochastic ?? false;\n    this.orderingFreelist = new FreeList({\n      allocate: (maxSplats) => new Uint32Array(maxSplats),\n      valid: (ordering, maxSplats) => ordering.length === maxSplats\n    });\n    this.autoUpdate = false;\n    this.setAutoUpdate(options.autoUpdate ?? false);\n  }\n  // Call this when you are done with the SparkViewpoint and want to\n  // free up its resources (GPU targets, pixel buffers, etc.)\n  dispose() {\n    var _a2;\n    this.setAutoUpdate(false);\n    if (this.target) {\n      this.target.dispose();\n      this.target = void 0;\n    }\n    if (this.back) {\n      this.back.dispose();\n      this.back = void 0;\n    }\n    if (this.display) {\n      this.spark.releaseAccumulator(this.display.accumulator);\n      this.display.geometry.dispose();\n      this.display = null;\n    }\n    if ((_a2 = this.pending) == null ? void 0 : _a2.accumulator) {\n      this.spark.releaseAccumulator(this.pending.accumulator);\n      this.pending = null;\n    }\n  }\n  // Use this function to change whether this viewpoint will auto-update\n  // its sort order whenever the attached SparkRenderer updates the Gsplats.\n  // Turn this on or off depending on whether you expect to do renders from\n  // this viewpoint most frames.\n  setAutoUpdate(autoUpdate) {\n    if (!this.autoUpdate && autoUpdate) {\n      this.spark.autoViewpoints.push(this);\n    } else if (this.autoUpdate && !autoUpdate) {\n      this.spark.autoViewpoints = this.spark.autoViewpoints.filter(\n        (v) => v !== this\n      );\n    }\n    this.autoUpdate = autoUpdate;\n  }\n  // See below async prepareRenderPixels() for explanation of parameters.\n  // Awaiting this method updates the Gsplats in the scene and performs a sort of the\n  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()\n  // call in the same tick.\n  async prepare({\n    scene,\n    camera,\n    viewToWorld,\n    update,\n    forceOrigin\n  }) {\n    var _a2;\n    if (viewToWorld) {\n      this.viewToWorld = viewToWorld;\n    } else {\n      this.camera = camera ?? this.camera;\n      if (this.camera) {\n        this.camera.updateMatrixWorld();\n        this.viewToWorld = this.camera.matrixWorld.clone();\n      }\n    }\n    while (update ?? true) {\n      const originToWorld = forceOrigin ? this.viewToWorld : void 0;\n      const updated = this.spark.updateInternal({ scene, originToWorld });\n      if (updated) {\n        break;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 10));\n    }\n    const accumulator = this.spark.active;\n    if (accumulator !== ((_a2 = this.display) == null ? void 0 : _a2.accumulator)) {\n      this.spark.active.refCount += 1;\n    }\n    await this.sortUpdate({ accumulator, viewToWorld: this.viewToWorld });\n  }\n  // Render out the viewpoint to the view target RGBA buffer.\n  // Swaps buffers if doubleBuffer: true was set.\n  // Calls onTextureUpdated(texture) with the resulting texture.\n  renderTarget({\n    scene,\n    camera\n  }) {\n    var _a2;\n    const target = this.back ?? this.target;\n    if (!target) {\n      throw new Error(\"Must initialize SparkViewpoint with target\");\n    }\n    camera = camera ?? this.camera;\n    if (!camera) {\n      throw new Error(\"Must provide camera\");\n    }\n    if (camera instanceof THREE.PerspectiveCamera) {\n      const newCam = new THREE.PerspectiveCamera().copy(camera, false);\n      newCam.aspect = target.width / target.height;\n      newCam.updateProjectionMatrix();\n      camera = newCam;\n    }\n    this.viewToWorld = camera.matrixWorld.clone();\n    try {\n      this.spark.renderer.setRenderTarget(target);\n      this.spark.prepareViewpoint(this);\n      this.spark.renderer.render(scene, camera);\n    } finally {\n      this.spark.prepareViewpoint(this.spark.defaultView);\n      this.spark.renderer.setRenderTarget(null);\n    }\n    if (target !== this.target) {\n      [this.target, this.back] = [this.back, this.target];\n    }\n    (_a2 = this.onTextureUpdated) == null ? void 0 : _a2.call(this, target.texture);\n  }\n  // Read back the previously rendered target image as a Uint8Array of packed\n  // RGBA values (in that order). If superXY was set greater than 1 then\n  // downsampling is performed in the target pixel array with simple averaging\n  // to derive the returned pixel values. Subsequent calls to this.readTarget()\n  // will reuse the same buffers to minimize memory allocations.\n  async readTarget() {\n    if (!this.target) {\n      throw new Error(\"Must initialize SparkViewpoint with target\");\n    }\n    const { width, height } = this.target;\n    const byteSize = width * height * 4;\n    if (!this.superPixels || this.superPixels.length < byteSize) {\n      this.superPixels = new Uint8Array(byteSize);\n    }\n    await this.spark.renderer.readRenderTargetPixelsAsync(\n      this.target,\n      0,\n      0,\n      width,\n      height,\n      this.superPixels\n    );\n    const { superXY } = this;\n    if (superXY === 1) {\n      return this.superPixels;\n    }\n    const subWidth = width / superXY;\n    const subHeight = height / superXY;\n    const subSize = subWidth * subHeight * 4;\n    if (!this.pixels || this.pixels.length < subSize) {\n      this.pixels = new Uint8Array(subSize);\n    }\n    const { superPixels, pixels } = this;\n    const super2 = superXY * superXY;\n    for (let y = 0; y < subHeight; y++) {\n      const row = y * subWidth;\n      for (let x = 0; x < subWidth; x++) {\n        const superCol = x * superXY;\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        for (let sy = 0; sy < superXY; sy++) {\n          const superRow = (y * superXY + sy) * this.target.width;\n          for (let sx = 0; sx < superXY; sx++) {\n            const superIndex = (superRow + superCol + sx) * 4;\n            r += superPixels[superIndex];\n            g += superPixels[superIndex + 1];\n            b += superPixels[superIndex + 2];\n            a += superPixels[superIndex + 3];\n          }\n        }\n        const pixelIndex = (row + x) * 4;\n        pixels[pixelIndex] = r / super2;\n        pixels[pixelIndex + 1] = g / super2;\n        pixels[pixelIndex + 2] = b / super2;\n        pixels[pixelIndex + 3] = a / super2;\n      }\n    }\n    return pixels;\n  }\n  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene\n  // and any camera/viewToWorld viewpoint overrides. By default update is true,\n  // which triggers its SparkRenderer to check and potentially update the Gsplats.\n  // Setting update to false disables this and sorts the Gsplats as they are.\n  // Setting forceOrigin (default: false) to true forces the view update to\n  // recalculate the splats with this view origin, potentially altering any\n  // view-dependent effects. If you expect view-dependent effects to play a role\n  // in the rendering quality, enable this.\n  //\n  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),\n  // this.renderTarget(...), and finally returns the result this.readTarget(),\n  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially\n  // downsampled if the superXY parameter was used). These steps can also be called\n  // manually, for example if you need to alter the scene before and after\n  // this.renderTarget(...) to hide UI elements from being rendered.\n  async prepareRenderPixels({\n    scene,\n    camera,\n    viewToWorld,\n    update,\n    forceOrigin\n  }) {\n    await this.prepare({ scene, camera, viewToWorld, update, forceOrigin });\n    this.renderTarget({ scene, camera });\n    return this.readTarget();\n  }\n  // This is called automatically by SparkRenderer, there is no need to call it!\n  // The method cannot be private because then SparkRenderer would\n  // not be able to call it.\n  autoPoll({ accumulator }) {\n    var _a2, _b2, _c, _d;\n    if (this.camera) {\n      this.camera.updateMatrixWorld();\n      this.viewToWorld = this.camera.matrixWorld.clone();\n    }\n    let needsSort = false;\n    let displayed = false;\n    if (!this.display) {\n      needsSort = true;\n    } else if (accumulator) {\n      needsSort = true;\n      const { mappingVersion } = this.display.accumulator;\n      if (accumulator.mappingVersion === mappingVersion) {\n        this.spark.releaseAccumulator(this.display.accumulator);\n        this.display.accumulator = accumulator;\n        displayed = true;\n      }\n    }\n    const latestView = ((_a2 = this.sorting) == null ? void 0 : _a2.viewToWorld) ?? ((_b2 = this.display) == null ? void 0 : _b2.viewToWorld);\n    if (latestView && !withinCoorientDist({\n      matrix1: this.viewToWorld,\n      matrix2: latestView,\n      // By default update sort each 1 cm\n      maxDistance: this.sortDistance ?? 0.01,\n      // By default for radial sort, update for intermittent movement so that\n      // we bring back splats culled by being behind the camera.\n      // For depth sort, small rotations can change sort order a lot, so\n      // update sort for even small rotations.\n      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999\n    })) {\n      needsSort = true;\n    }\n    if (!needsSort) {\n      return;\n    }\n    if (accumulator) {\n      accumulator.refCount += 1;\n    }\n    if (accumulator && ((_c = this.pending) == null ? void 0 : _c.accumulator) && this.pending.accumulator !== ((_d = this.display) == null ? void 0 : _d.accumulator)) {\n      this.spark.releaseAccumulator(this.pending.accumulator);\n    }\n    this.pending = { accumulator, viewToWorld: this.viewToWorld, displayed };\n    this.driveSort();\n  }\n  async driveSort() {\n    var _a2;\n    while (true) {\n      if (this.sorting || !this.pending) {\n        return;\n      }\n      const { viewToWorld, displayed } = this.pending;\n      let accumulator = this.pending.accumulator ?? ((_a2 = this.display) == null ? void 0 : _a2.accumulator);\n      if (!accumulator) {\n        accumulator = this.spark.active;\n        accumulator.refCount += 1;\n      }\n      this.pending = null;\n      if (!accumulator) {\n        throw new Error(\"No accumulator to sort\");\n      }\n      this.sorting = { viewToWorld };\n      await this.sortUpdate({ accumulator, viewToWorld, displayed });\n      this.sorting = null;\n    }\n  }\n  async sortUpdate({\n    accumulator,\n    viewToWorld,\n    displayed = false\n  }) {\n    if (this.sortingCheck) {\n      throw new Error(\"Only one sort at a time\");\n    }\n    this.sortingCheck = true;\n    accumulator = accumulator ?? this.spark.active;\n    const { numSplats, maxSplats } = accumulator.splats;\n    let activeSplats = 0;\n    let ordering = this.orderingFreelist.alloc(maxSplats);\n    if (this.stochastic) {\n      activeSplats = numSplats;\n      for (let i = 0; i < numSplats; ++i) {\n        ordering[i] = i;\n      }\n    } else if (numSplats > 0) {\n      const {\n        reader,\n        doubleSortReader,\n        sort32Reader,\n        dynoSortRadial,\n        dynoOrigin,\n        dynoDirection,\n        dynoDepthBias,\n        dynoSort360,\n        dynoSplats\n      } = _SparkViewpoint.makeSorter();\n      const sort32 = this.sort32 ?? false;\n      let readback;\n      if (sort32) {\n        this.readback32 = reader.ensureBuffer(maxSplats, this.readback32);\n        readback = this.readback32;\n      } else {\n        const halfMaxSplats = Math.ceil(maxSplats / 2);\n        this.readback16 = reader.ensureBuffer(halfMaxSplats, this.readback16);\n        readback = this.readback16;\n      }\n      const worldToOrigin = accumulator.toWorld.clone().invert();\n      const viewToOrigin = viewToWorld.clone().premultiply(worldToOrigin);\n      dynoSortRadial.value = this.sort360 ? true : this.sortRadial;\n      dynoOrigin.value.set(0, 0, 0).applyMatrix4(viewToOrigin);\n      dynoDirection.value.set(0, 0, -1).applyMatrix4(viewToOrigin).sub(dynoOrigin.value).normalize();\n      dynoDepthBias.value = this.depthBias ?? 1;\n      dynoSort360.value = this.sort360 ?? false;\n      dynoSplats.packedSplats = accumulator.splats;\n      const sortReader = sort32 ? sort32Reader : doubleSortReader;\n      const count = sort32 ? numSplats : Math.ceil(numSplats / 2);\n      await reader.renderReadback({\n        renderer: this.spark.renderer,\n        reader: sortReader,\n        count,\n        readback\n      });\n      const result = await withWorker(async (worker) => {\n        const rpcName = sort32 ? \"sort32Splats\" : \"sortDoubleSplats\";\n        return worker.call(rpcName, {\n          maxSplats,\n          numSplats,\n          readback,\n          ordering\n        });\n      });\n      if (sort32) {\n        this.readback32 = result.readback;\n      } else {\n        this.readback16 = result.readback;\n      }\n      ordering = result.ordering;\n      activeSplats = result.activeSplats;\n    }\n    this.updateDisplay({\n      accumulator,\n      viewToWorld,\n      ordering,\n      activeSplats,\n      displayed\n    });\n    this.sortingCheck = false;\n  }\n  updateDisplay({\n    accumulator,\n    viewToWorld,\n    ordering,\n    activeSplats,\n    displayed = false\n  }) {\n    if (!this.display) {\n      this.display = {\n        accumulator,\n        viewToWorld,\n        geometry: new SplatGeometry(ordering, activeSplats)\n      };\n    } else {\n      if (!displayed && accumulator !== this.display.accumulator) {\n        this.spark.releaseAccumulator(this.display.accumulator);\n        this.display.accumulator = accumulator;\n      }\n      this.display.viewToWorld = viewToWorld;\n      const oldOrdering = this.display.geometry.ordering;\n      if (oldOrdering.length === ordering.length) {\n        this.display.geometry.update(ordering, activeSplats);\n      } else {\n        this.display.geometry.dispose();\n        this.display.geometry = new SplatGeometry(ordering, activeSplats);\n      }\n      this.orderingFreelist.free(oldOrdering);\n    }\n    if (this.spark.viewpoint === this) {\n      this.spark.prepareViewpoint(this);\n    }\n  }\n  static makeSorter() {\n    if (!_SparkViewpoint.dynos) {\n      const dynoSortRadial = new DynoBool({ value: true });\n      const dynoOrigin = new DynoVec3({ value: new THREE.Vector3() });\n      const dynoDirection = new DynoVec3({ value: new THREE.Vector3() });\n      const dynoDepthBias = new DynoFloat({ value: 1 });\n      const dynoSort360 = new DynoBool({ value: false });\n      const dynoSplats = new DynoPackedSplats();\n      const reader = new Readback();\n      const doubleSortReader = dynoBlock(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          if (!index) {\n            throw new Error(\"No index\");\n          }\n          const sortParams = {\n            sortRadial: dynoSortRadial,\n            sortOrigin: dynoOrigin,\n            sortDirection: dynoDirection,\n            sortDepthBias: dynoDepthBias,\n            sort360: dynoSort360\n          };\n          const index2 = mul(index, dynoConst(\"int\", 2));\n          const gsplat0 = readPackedSplat(dynoSplats, index2);\n          const metric0 = computeSortMetric({ gsplat: gsplat0, ...sortParams });\n          const gsplat1 = readPackedSplat(\n            dynoSplats,\n            add(index2, dynoConst(\"int\", 1))\n          );\n          const metric1 = computeSortMetric({ gsplat: gsplat1, ...sortParams });\n          const combined = combine({\n            vectorType: \"vec2\",\n            x: metric0,\n            y: metric1\n          });\n          const rgba8 = uintToRgba8(packHalf2x16(combined));\n          return { rgba8 };\n        }\n      );\n      const sort32Reader = dynoBlock(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          if (!index) {\n            throw new Error(\"No index\");\n          }\n          const sortParams = {\n            sortRadial: dynoSortRadial,\n            sortOrigin: dynoOrigin,\n            sortDirection: dynoDirection,\n            sortDepthBias: dynoDepthBias,\n            sort360: dynoSort360\n          };\n          const gsplat = readPackedSplat(dynoSplats, index);\n          const metric = computeSortMetric({ gsplat, ...sortParams });\n          const rgba8 = uintToRgba8(floatBitsToUint(metric));\n          return { rgba8 };\n        }\n      );\n      _SparkViewpoint.dynos = {\n        dynoSortRadial,\n        dynoOrigin,\n        dynoDirection,\n        dynoDepthBias,\n        dynoSort360,\n        dynoSplats,\n        reader,\n        doubleSortReader,\n        sort32Reader\n      };\n    }\n    return _SparkViewpoint.dynos;\n  }\n};\n_SparkViewpoint.EMPTY_TEXTURE = new THREE.Texture();\n_SparkViewpoint.dynos = null;\nlet SparkViewpoint = _SparkViewpoint;\nconst defineComputeSortMetric = unindent(`\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\n    if (!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) {\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : biasedDepth;\n  }\n`);\nfunction computeSortMetric({\n  gsplat,\n  sortRadial,\n  sortOrigin,\n  sortDirection,\n  sortDepthBias,\n  sort360\n}) {\n  return dyno$1({\n    inTypes: {\n      gsplat: Gsplat,\n      sortRadial: \"bool\",\n      sortOrigin: \"vec3\",\n      sortDirection: \"vec3\",\n      sortDepthBias: \"float\",\n      sort360: \"bool\"\n    },\n    outTypes: { metric: \"float\" },\n    globals: () => [defineGsplat, defineComputeSortMetric],\n    inputs: {\n      gsplat,\n      sortRadial,\n      sortOrigin,\n      sortDirection,\n      sortDepthBias,\n      sort360\n    },\n    statements: ({ inputs, outputs }) => {\n      const {\n        gsplat: gsplat2,\n        sortRadial: sortRadial2,\n        sortOrigin: sortOrigin2,\n        sortDirection: sortDirection2,\n        sortDepthBias: sortDepthBias2,\n        sort360: sort3602\n      } = inputs;\n      return unindentLines(`\n        ${outputs.metric} = computeSort(${gsplat2}, ${sortRadial2}, ${sortOrigin2}, ${sortDirection2}, ${sortDepthBias2}, ${sort3602});\n      `);\n    }\n  }).outputs.metric;\n}\nclass SplatAccumulator {\n  constructor() {\n    this.splats = new PackedSplats();\n    this.toWorld = new THREE.Matrix4();\n    this.mapping = [];\n    this.refCount = 0;\n    this.splatsVersion = -1;\n    this.mappingVersion = -1;\n  }\n  ensureGenerate(maxSplats) {\n    if (this.splats.ensureGenerate(maxSplats)) {\n      this.mapping = [];\n    }\n  }\n  // Generate all Gsplats from an array of generators\n  generateSplats({\n    renderer,\n    modifier,\n    generators: generators2,\n    forceUpdate,\n    originToWorld\n  }) {\n    const mapping = this.mapping.reduce((map, record) => {\n      map.set(record.node, record);\n      return map;\n    }, /* @__PURE__ */ new Map());\n    let updated = 0;\n    let numSplats = 0;\n    for (const { node, generator, version, base, count } of generators2) {\n      const current = mapping.get(node);\n      if (forceUpdate || generator !== (current == null ? void 0 : current.generator) || version !== (current == null ? void 0 : current.version) || base !== (current == null ? void 0 : current.base) || count !== (current == null ? void 0 : current.count)) {\n        if (generator && count > 0) {\n          const modGenerator = modifier.apply(generator);\n          try {\n            this.splats.generate({\n              generator: modGenerator,\n              base,\n              count,\n              renderer\n            });\n          } catch (error) {\n            node.generator = void 0;\n            node.generatorError = error;\n          }\n          updated += 1;\n        }\n      }\n      numSplats = Math.max(numSplats, base + count);\n    }\n    this.splats.numSplats = numSplats;\n    this.toWorld = originToWorld;\n    this.mapping = generators2;\n    return updated !== 0;\n  }\n  // Check if this accumulator has exactly the same generator mapping as\n  // the previous one. If so, we can reuse the Gsplat sort order.\n  hasCorrespondence(other) {\n    if (this.mapping.length !== other.mapping.length) {\n      return false;\n    }\n    return this.mapping.every(({ node, base, count }, i) => {\n      const {\n        node: otherNode,\n        base: otherBase,\n        count: otherCount\n      } = other.mapping[i];\n      return node === otherNode && base === otherBase && count === otherCount;\n    });\n  }\n}\nvar splatDefines_default = \"const float LN_SCALE_MIN = -12.0;\\nconst float LN_SCALE_MAX = 9.0;\\n\\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\\n\\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\\n\\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\\n\\nconst uint F16_INF = 0x7c00u;\\nconst float PI = 3.1415926535897932384626433832795;\\n\\nconst float INFINITY = 1.0 / 0.0;\\nconst float NEG_INFINITY = -INFINITY;\\n\\nfloat sqr(float x) {\\n    return x * x;\\n}\\n\\nfloat pow4(float x) {\\n    float x2 = x * x;\\n    return x2 * x2;\\n}\\n\\nfloat pow8(float x) {\\n    float x4 = pow4(x);\\n    return x4 * x4;\\n}\\n\\nvec3 srgbToLinear(vec3 rgb) {\\n    return pow(rgb, vec3(2.2));\\n}\\n\\nvec3 linearToSrgb(vec3 rgb) {\\n    return pow(rgb, vec3(1.0 / 2.2));\\n}\\n\\nuint encodeQuatOctXy88R8(vec4 q) {\\n    \\n    if (q.w < 0.0) {\\n        q = -q;\\n    }\\n    \\n    float theta = 2.0 * acos(q.w);\\n    float halfTheta = theta * 0.5;\\n    float s = sin(halfTheta);\\n    \\n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\\n    \\n    \\n    \\n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\\n    vec2 p = vec2(axis.x, axis.y) / sum;\\n    \\n    if (axis.z < 0.0) {\\n        float oldPx = p.x;\\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\\n    }\\n    \\n    float u_f = p.x * 0.5 + 0.5;\\n    float v_f = p.y * 0.5 + 0.5;\\n    \\n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\\n    \\n    \\n    \\n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\\n    \\n    \\n    return (angleInt << 16u) | (quantV << 8u) | quantU;\\n}\\n\\nvec4 decodeQuatOctXy88R8(uint encoded) {\\n    \\n    uint quantU = encoded & uint(0xFFu);               \\n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \\n    uint angleInt = encoded >> 16u;                      \\n\\n    \\n    float u_f = float(quantU) / 255.0;\\n    float v_f = float(quantV) / 255.0;\\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\\n\\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\\n    float t = max(-axis.z, 0.0);\\n    axis.x += (axis.x >= 0.0) ? -t : t;\\n    axis.y += (axis.y >= 0.0) ? -t : t;\\n    axis = normalize(axis);\\n    \\n    \\n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\\n    float halfTheta = theta * 0.5;\\n    float s = sin(halfTheta);\\n    float w = cos(halfTheta);\\n    \\n    return vec4(axis * s, w);\\n}\\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\nuvec4 packSplatEncoding(\\n    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax\\n) {\\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\\n    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);\\n    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));\\n\\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\\n    \\n    \\n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\\n\\n    \\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\\n    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);\\n    uvec3 uScales = uvec3(\\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,\\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u\\n    );\\n\\n    \\n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\\n    uint word1 = packHalf2x16(center.xy);\\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\\n    return uvec4(word0, word1, word2, word3);\\n}\\n\\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\\n    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\\n}\\n\\nvoid unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {\\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\\n\\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\\n    float rgbMin = rgbMinMaxLnScaleMinMax.x;\\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\\n    rgba = (vec4(uRgba) / 255.0);\\n    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;\\n\\n    center = vec4(\\n        unpackHalf2x16(word1),\\n        unpackHalf2x16(word2 & 0xffffu)\\n    ).xyz;\\n\\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\\n    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\\n    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;\\n    scales = vec3(\\n        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),\\n        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),\\n        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)\\n    );\\n\\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\\n    quaternion = decodeQuatOctXy88R8(uQuat);\\n    \\n    \\n}\\n\\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\\n}\\n\\nvec3 quatVec(vec4 q, vec3 v) {\\n    \\n    vec3 t = 2.0 * cross(q.xyz, v);\\n    return v + q.w * t + cross(q.xyz, t);\\n}\\n\\nvec4 quatQuat(vec4 q1, vec4 q2) {\\n    return vec4(\\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\\n    );\\n}\\n\\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\\n    \\n    return mat3(\\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\\n    );\\n}\\n\\nvec4 slerp(vec4 q1, vec4 q2, float t) {\\n    \\n    float cosHalfTheta = dot(q1, q2);\\n\\n    \\n    if (abs(cosHalfTheta) >= 0.999) {\\n        return q1;\\n    }\\n    \\n    \\n    \\n    if (cosHalfTheta < 0.0) {\\n        q2 = -q2;\\n        cosHalfTheta = -cosHalfTheta;\\n    }\\n\\n    \\n    float halfTheta = acos(cosHalfTheta);\\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\\n\\n    \\n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\\n\\n    \\n    return q1 * ratioA + q2 * ratioB;\\n}\\n\\nivec3 splatTexCoord(int index) {\\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\\n    return ivec3(x, y, z);\\n}\";\nvar splatFragment_default = \"precision highp float;\\nprecision highp int;\\n\\n#include <splatDefines>\\n\\nuniform float near;\\nuniform float far;\\nuniform bool encodeLinear;\\nuniform float time;\\nuniform bool debugFlag;\\nuniform float maxStdDev;\\nuniform float minAlpha;\\nuniform bool stochastic;\\nuniform bool disableFalloff;\\nuniform float falloff;\\n\\nuniform bool splatTexEnable;\\nuniform sampler3D splatTexture;\\nuniform mat2 splatTexMul;\\nuniform vec2 splatTexAdd;\\nuniform float splatTexNear;\\nuniform float splatTexFar;\\nuniform float splatTexMid;\\n\\nout vec4 fragColor;\\n\\nin vec4 vRgba;\\nin vec2 vSplatUv;\\nin vec3 vNdc;\\nflat in uint vSplatIndex;\\n\\nvoid main() {\\n    vec4 rgba = vRgba;\\n\\n    float z = dot(vSplatUv, vSplatUv);\\n    if (!splatTexEnable) {\\n        if (z > (maxStdDev * maxStdDev)) {\\n            discard;\\n        }\\n    } else {\\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\\n        float ndcZ = vNdc.z;\\n        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));\\n        float clampedFar = max(splatTexFar, splatTexNear);\\n        float clampedDepth = clamp(depth, splatTexNear, clampedFar);\\n        float logDepth = log2(clampedDepth + 1.0);\\n        float logNear = log2(splatTexNear + 1.0);\\n        float logFar = log2(clampedFar + 1.0);\\n\\n        float texZ;\\n        if (splatTexMid > 0.0) {\\n            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);\\n            float logMid = log2(clampedMid + 1.0);\\n            texZ = (clampedDepth <= clampedMid) ?\\n                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :\\n                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);\\n        } else {\\n            texZ = (logDepth - logNear) / (logFar - logNear);\\n        }\\n\\n        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\\n        rgba *= modulate;\\n    }\\n\\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\\n\\n    if (rgba.a < minAlpha) {\\n        discard;\\n    }\\n    if (encodeLinear) {\\n        rgba.rgb = srgbToLinear(rgba.rgb);\\n    }\\n\\n    if (stochastic) {\\n        const bool STEADY = false;\\n        uint uTime = STEADY ? 0u : floatBitsToUint(time);\\n        uvec2 coord = uvec2(gl_FragCoord.xy);\\n        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);\\n        state = state * 747796405u + 2891336453u;\\n        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\\n        hash = (hash >> 22u) ^ hash;\\n        float rand = float(hash) / 4294967296.0;\\n        if (rand < rgba.a) {\\n            fragColor = vec4(rgba.rgb, 1.0);\\n        } else {\\n            discard;\\n        }\\n    } else {\\n        #ifdef PREMULTIPLIED_ALPHA\\n            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);\\n        #else\\n            fragColor = rgba;\\n        #endif\\n    }\\n}\";\nvar splatVertex_default = \"precision highp float;\\nprecision highp int;\\nprecision highp usampler2DArray;\\n\\n#include <splatDefines>\\n\\nattribute uint splatIndex;\\n\\nout vec4 vRgba;\\nout vec2 vSplatUv;\\nout vec3 vNdc;\\nflat out uint vSplatIndex;\\n\\nuniform vec2 renderSize;\\nuniform uint numSplats;\\nuniform vec4 renderToViewQuat;\\nuniform vec3 renderToViewPos;\\nuniform float maxStdDev;\\nuniform float maxPixelRadius;\\nuniform float time;\\nuniform float deltaTime;\\nuniform bool debugFlag;\\nuniform float minAlpha;\\nuniform bool stochastic;\\nuniform bool enable2DGS;\\nuniform float blurAmount;\\nuniform float preBlurAmount;\\nuniform float focalDistance;\\nuniform float apertureAngle;\\nuniform float clipXY;\\nuniform float focalAdjustment;\\n\\nuniform usampler2DArray packedSplats;\\nuniform vec4 rgbMinMaxLnScaleMinMax;\\n\\nvoid main() {\\n    \\n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n\\n    if (uint(gl_InstanceID) >= numSplats) {\\n        return;\\n    }\\n\\n    ivec3 texCoord;\\n    if (stochastic) {\\n        texCoord = ivec3(\\n            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,\\n            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\\n            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)\\n        );\\n    } else {\\n        if (splatIndex == 0xffffffffu) {\\n            \\n            return;\\n        }\\n        texCoord = ivec3(\\n            splatIndex & SPLAT_TEX_WIDTH_MASK,\\n            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\\n            splatIndex >> SPLAT_TEX_LAYER_BITS\\n        );\\n    }\\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\\n\\n    vec3 center, scales;\\n    vec4 quaternion, rgba;\\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);\\n\\n    if (rgba.a < minAlpha) {\\n        return;\\n    }\\n    bvec3 zeroScales = equal(scales, vec3(0.0));\\n    if (all(zeroScales)) {\\n        return;\\n    }\\n\\n    \\n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\\n\\n    \\n    if (viewCenter.z >= 0.0) {\\n        return;\\n    }\\n\\n    \\n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\\n\\n    \\n    if (abs(clipCenter.z) >= clipCenter.w) {\\n        return;\\n    }\\n\\n    \\n    float clip = clipXY * clipCenter.w;\\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\\n        return;\\n    }\\n\\n    \\n    vSplatIndex = splatIndex;\\n\\n    \\n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\\n\\n    if (enable2DGS && any(zeroScales)) {\\n        vRgba = rgba;\\n        vSplatUv = position.xy * maxStdDev;\\n\\n        vec3 offset;\\n        if (zeroScales.z) {\\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\\n        } else if (zeroScales.y) {\\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\\n        } else {\\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\\n        }\\n\\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\\n        vNdc = gl_Position.xyz / gl_Position.w;\\n        return;\\n    }\\n\\n    \\n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\\n\\n    \\n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\\n    mat3 cov3D = RS * transpose(RS);\\n\\n    \\n    vec2 scaledRenderSize = renderSize * focalAdjustment;\\n    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\\n    float invZ = 1.0 / viewCenter.z;\\n    vec2 J1 = focal * invZ;\\n    vec2 J2 = -(J1 * viewCenter.xy) * invZ;\\n    mat3 J = mat3(\\n        J1.x, 0.0, J2.x,\\n        0.0, J1.y, J2.y,\\n        0.0, 0.0, 0.0\\n    );\\n\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    mat3 cov2D = transpose(J) * cov3D * J;\\n    float a = cov2D[0][0];\\n    float d = cov2D[1][1];\\n    float b = cov2D[0][1];\\n\\n    \\n    a += preBlurAmount;\\n    d += preBlurAmount;\\n\\n    float fullBlurAmount = blurAmount;\\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\\n        float focusRadius = maxPixelRadius;\\n        if (viewCenter.z < 0.0) {\\n            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);\\n            float apertureRadius = focal.x * tan(0.5 * apertureAngle);\\n            focusRadius = focusBlur * apertureRadius;\\n        }\\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));\\n    }\\n\\n    \\n    float detOrig = a * d - b * b;\\n    a += fullBlurAmount;\\n    d += fullBlurAmount;\\n    float det = a * d - b * b;\\n\\n    \\n    float blurAdjust = sqrt(max(0.0, detOrig / det));\\n    rgba.a *= blurAdjust;\\n    if (rgba.a < minAlpha) {\\n        return;\\n    }\\n\\n    \\n    float eigenAvg = 0.5 * (a + d);\\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\\n    float eigen1 = eigenAvg + eigenDelta;\\n    float eigen2 = eigenAvg - eigenDelta;\\n\\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\\n\\n    float scale1 = position.x * min(maxPixelRadius, maxStdDev * sqrt(eigen1));\\n    float scale2 = position.y * min(maxPixelRadius, maxStdDev * sqrt(eigen2));\\n\\n    \\n    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;\\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;\\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\\n\\n    vRgba = rgba;\\n    vSplatUv = position.xy * maxStdDev;\\n    vNdc = ndc;\\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\\n}\";\nlet shaders = null;\nfunction getShaders() {\n  if (!shaders) {\n    THREE.ShaderChunk.splatDefines = splatDefines_default;\n    shaders = {\n      splatVertex: splatVertex_default,\n      splatFragment: splatFragment_default\n    };\n  }\n  return shaders;\n}\nconst MAX_ACCUMULATORS = 5;\nlet hasSplatMesh = false;\nlet hasSparkRenderer = false;\nlet sparkRendererInstance;\nfunction containsSplatMesh(object3D) {\n  let hasSplatMesh2 = false;\n  if (object3D instanceof SplatMesh) {\n    return true;\n  }\n  object3D.traverse((child) => {\n    hasSplatMesh2 = hasSplatMesh2 || child instanceof SplatMesh;\n  });\n  return hasSplatMesh2;\n}\nconst sceneAdd = THREE.Scene.prototype.add;\nTHREE.Scene.prototype.add = function(object) {\n  hasSplatMesh = hasSplatMesh || containsSplatMesh(object);\n  hasSparkRenderer = hasSparkRenderer || object instanceof SparkRenderer;\n  sceneAdd.call(this, object);\n  return this;\n};\nconst sceneOnBeforeRender = THREE.Scene.prototype.onBeforeRender;\nTHREE.Scene.prototype.onBeforeRender = function(renderer) {\n  if (!hasSplatMesh) {\n    return;\n  }\n  if (!hasSparkRenderer) {\n    const spark = sparkRendererInstance || new SparkRenderer({ renderer });\n    this.add(spark);\n  }\n  THREE.Scene.prototype.onBeforeRender = sceneOnBeforeRender;\n  THREE.Scene.prototype.add = sceneAdd;\n};\nconst _SparkRenderer = class _SparkRenderer extends THREE.Mesh {\n  constructor(options) {\n    const uniforms = _SparkRenderer.makeUniforms();\n    const shaders2 = getShaders();\n    const premultipliedAlpha = options.premultipliedAlpha ?? true;\n    const material = new THREE.ShaderMaterial({\n      glslVersion: THREE.GLSL3,\n      vertexShader: shaders2.splatVertex,\n      fragmentShader: shaders2.splatFragment,\n      uniforms,\n      premultipliedAlpha,\n      transparent: true,\n      depthTest: true,\n      depthWrite: false,\n      side: THREE.DoubleSide\n    });\n    super(EMPTY_GEOMETRY, material);\n    this.splatTexture = null;\n    this.autoViewpoints = [];\n    this.rotateToAccumulator = new DynoVec4({ value: new THREE.Quaternion() });\n    this.translateToAccumulator = new DynoVec3({ value: new THREE.Vector3() });\n    this.lastFrame = -1;\n    this.lastUpdateTime = null;\n    this.defaultCameras = [];\n    this.lastStochastic = null;\n    this.pendingUpdate = null;\n    this.envViewpoint = null;\n    this.frustumCulled = false;\n    this.renderer = options.renderer;\n    this.material = material;\n    this.uniforms = uniforms;\n    const modifier = dynoBlock(\n      { gsplat: Gsplat },\n      { gsplat: Gsplat },\n      ({ gsplat }) => {\n        if (!gsplat) {\n          throw new Error(\"gsplat not defined\");\n        }\n        gsplat = transformGsplat(gsplat, {\n          rotate: this.rotateToAccumulator,\n          translate: this.translateToAccumulator\n        });\n        return { gsplat };\n      }\n    );\n    this.modifier = new SplatModifier(modifier);\n    this.premultipliedAlpha = premultipliedAlpha;\n    this.autoUpdate = options.autoUpdate ?? true;\n    this.preUpdate = options.preUpdate ?? false;\n    this.needsUpdate = false;\n    this.originDistance = options.originDistance ?? 1;\n    this.maxStdDev = options.maxStdDev ?? Math.sqrt(8);\n    this.maxPixelRadius = options.maxPixelRadius ?? 512;\n    this.minAlpha = options.minAlpha ?? 0.5 * (1 / 255);\n    this.enable2DGS = options.enable2DGS ?? false;\n    this.preBlurAmount = options.preBlurAmount ?? 0;\n    this.blurAmount = options.blurAmount ?? 0.3;\n    this.focalDistance = options.focalDistance ?? 0;\n    this.apertureAngle = options.apertureAngle ?? 0;\n    this.falloff = options.falloff ?? 1;\n    this.clipXY = options.clipXY ?? 1.4;\n    this.focalAdjustment = options.focalAdjustment ?? 1;\n    this.splatEncoding = options.splatEncoding ?? { ...DEFAULT_SPLAT_ENCODING };\n    this.active = new SplatAccumulator();\n    this.accumulatorCount = 1;\n    this.freeAccumulators = [];\n    for (let count = 0; count < 1; ++count) {\n      this.freeAccumulators.push(new SplatAccumulator());\n      this.accumulatorCount += 1;\n    }\n    this.defaultView = new SparkViewpoint({\n      ...options.view,\n      autoUpdate: true,\n      spark: this\n    });\n    this.viewpoint = this.defaultView;\n    this.prepareViewpoint(this.viewpoint);\n    this.clock = options.clock ? cloneClock(options.clock) : new THREE.Clock();\n    sparkRendererInstance = this;\n  }\n  static makeUniforms() {\n    const uniforms = {\n      // Size of render viewport in pixels\n      renderSize: { value: new THREE.Vector2() },\n      // Near and far plane distances\n      near: { value: 0.1 },\n      far: { value: 1e3 },\n      // Total number of Gsplats in packedSplats to render\n      numSplats: { value: 0 },\n      // SplatAccumulator to view transformation quaternion\n      renderToViewQuat: { value: new THREE.Quaternion() },\n      // SplatAccumulator to view transformation translation\n      renderToViewPos: { value: new THREE.Vector3() },\n      // Maximum distance (in stddevs) from Gsplat center to render\n      maxStdDev: { value: 1 },\n      // Maximum pixel radius for splat rendering\n      maxPixelRadius: { value: 512 },\n      // Minimum alpha value for splat rendering\n      minAlpha: { value: 0.5 * (1 / 255) },\n      // Enable stochastic splat rendering\n      stochastic: { value: false },\n      // Enable interpreting 0-thickness Gsplats as 2DGS\n      enable2DGS: { value: false },\n      // Add to projected 2D splat covariance diagonal (thickens and brightens)\n      preBlurAmount: { value: 0 },\n      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)\n      blurAmount: { value: 0.3 },\n      // Depth-of-field distance to focal plane\n      focalDistance: { value: 0 },\n      // Full-width angle of aperture opening (in radians)\n      apertureAngle: { value: 0 },\n      // Modulate Gaussian kernal falloff. 0 means \"no falloff, flat shading\",\n      // 1 is normal e^-x^2 falloff.\n      falloff: { value: 1 },\n      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds\n      clipXY: { value: 1.4 },\n      // Debug renderSize scale factor\n      focalAdjustment: { value: 1 },\n      // Enable splat texture rendering\n      splatTexEnable: { value: false },\n      // Splat texture to render\n      splatTexture: { type: \"t\", value: _SparkRenderer.EMPTY_SPLAT_TEXTURE },\n      // Splat texture UV transform (multiply)\n      splatTexMul: { value: new THREE.Matrix2() },\n      // Splat texture UV transform (add)\n      splatTexAdd: { value: new THREE.Vector2() },\n      // Splat texture near plane distance\n      splatTexNear: { value: 0.1 },\n      // Splat texture far plane distance\n      splatTexFar: { value: 1e3 },\n      // Splat texture mid plane distance, or 0.0 to disable\n      splatTexMid: { value: 0 },\n      // Gsplat collection to render\n      packedSplats: { type: \"t\", value: PackedSplats.getEmpty() },\n      // Splat encoding ranges\n      rgbMinMaxLnScaleMinMax: { value: new THREE.Vector4() },\n      // Time in seconds for time-based effects\n      time: { value: 0 },\n      // Delta time in seconds since last frame\n      deltaTime: { value: 0 },\n      // Whether to encode Gsplat with linear RGB (for environment mapping)\n      encodeLinear: { value: false },\n      // Debug flag that alternates each frame\n      debugFlag: { value: false }\n    };\n    return uniforms;\n  }\n  canAllocAccumulator() {\n    return this.freeAccumulators.length > 0 || this.accumulatorCount < MAX_ACCUMULATORS;\n  }\n  maybeAllocAccumulator() {\n    let accumulator = this.freeAccumulators.pop();\n    if (accumulator === void 0) {\n      if (this.accumulatorCount >= MAX_ACCUMULATORS) {\n        return null;\n      }\n      accumulator = new SplatAccumulator();\n      this.accumulatorCount += 1;\n    }\n    accumulator.refCount = 1;\n    return accumulator;\n  }\n  releaseAccumulator(accumulator) {\n    accumulator.refCount -= 1;\n    if (accumulator.refCount === 0) {\n      this.freeAccumulators.push(accumulator);\n    }\n  }\n  newViewpoint(options) {\n    return new SparkViewpoint({ ...options, spark: this });\n  }\n  onBeforeRender(renderer, scene, camera) {\n    var _a2, _b2;\n    const time = this.time ?? this.clock.getElapsedTime();\n    const deltaTime = time - (this.viewpoint.lastTime ?? time);\n    this.viewpoint.lastTime = time;\n    const frame = renderer.info.render.frame;\n    const isNewFrame = frame !== this.lastFrame;\n    this.lastFrame = frame;\n    const viewpoint = this.viewpoint;\n    if (viewpoint === this.defaultView) {\n      if (isNewFrame) {\n        if (!renderer.xr.isPresenting) {\n          this.defaultView.viewToWorld = camera.matrixWorld.clone();\n          this.defaultCameras = [this.defaultView.viewToWorld];\n        } else {\n          const cameras = renderer.xr.getCamera().cameras;\n          this.defaultCameras = cameras.map((camera2) => camera2.matrixWorld);\n          this.defaultView.viewToWorld = averageOriginToWorlds(this.defaultCameras) ?? new THREE.Matrix4();\n        }\n      }\n      if (this.autoUpdate) {\n        this.update({ scene, viewToWorld: this.defaultView.viewToWorld });\n      }\n    }\n    if (isNewFrame) {\n      if (this.material.premultipliedAlpha !== this.premultipliedAlpha) {\n        this.material.premultipliedAlpha = this.premultipliedAlpha;\n        this.material.needsUpdate = true;\n      }\n      this.uniforms.time.value = time;\n      this.uniforms.deltaTime.value = deltaTime;\n      this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1;\n      if (viewpoint.display && viewpoint.stochastic) {\n        this.geometry.instanceCount = this.uniforms.numSplats.value;\n      }\n    }\n    if (viewpoint.target) {\n      this.uniforms.renderSize.value.set(\n        viewpoint.target.width,\n        viewpoint.target.height\n      );\n    } else {\n      const renderSize = renderer.getDrawingBufferSize(\n        this.uniforms.renderSize.value\n      );\n      if (renderSize.x === 1 && renderSize.y === 1) {\n        const baseLayer = (_a2 = renderer.xr.getSession()) == null ? void 0 : _a2.renderState.baseLayer;\n        if (baseLayer) {\n          renderSize.x = baseLayer.framebufferWidth;\n          renderSize.y = baseLayer.framebufferHeight;\n        }\n      }\n    }\n    const typedCamera = camera;\n    this.uniforms.near.value = typedCamera.near;\n    this.uniforms.far.value = typedCamera.far;\n    this.uniforms.encodeLinear.value = viewpoint.encodeLinear;\n    this.uniforms.maxStdDev.value = this.maxStdDev;\n    this.uniforms.maxPixelRadius.value = this.maxPixelRadius;\n    this.uniforms.minAlpha.value = this.minAlpha;\n    this.uniforms.stochastic.value = viewpoint.stochastic;\n    this.uniforms.enable2DGS.value = this.enable2DGS;\n    this.uniforms.preBlurAmount.value = this.preBlurAmount;\n    this.uniforms.blurAmount.value = this.blurAmount;\n    this.uniforms.focalDistance.value = this.focalDistance;\n    this.uniforms.apertureAngle.value = this.apertureAngle;\n    this.uniforms.falloff.value = this.falloff;\n    this.uniforms.clipXY.value = this.clipXY;\n    this.uniforms.focalAdjustment.value = this.focalAdjustment;\n    if (this.lastStochastic !== !viewpoint.stochastic) {\n      this.lastStochastic = !viewpoint.stochastic;\n      this.material.transparent = !viewpoint.stochastic;\n      this.material.depthWrite = viewpoint.stochastic;\n      this.material.needsUpdate = true;\n    }\n    if (this.splatTexture) {\n      const { enable, texture: texture2, multiply, add: add2, near, far, mid } = this.splatTexture;\n      if (enable && texture2) {\n        this.uniforms.splatTexEnable.value = true;\n        this.uniforms.splatTexture.value = texture2;\n        if (multiply) {\n          this.uniforms.splatTexMul.value.fromArray(multiply.elements);\n        } else {\n          this.uniforms.splatTexMul.value.set(\n            0.5 / this.maxStdDev,\n            0,\n            0,\n            0.5 / this.maxStdDev\n          );\n        }\n        this.uniforms.splatTexAdd.value.set((add2 == null ? void 0 : add2.x) ?? 0.5, (add2 == null ? void 0 : add2.y) ?? 0.5);\n        this.uniforms.splatTexNear.value = near ?? this.uniforms.near.value;\n        this.uniforms.splatTexFar.value = far ?? this.uniforms.far.value;\n        this.uniforms.splatTexMid.value = mid ?? 0;\n      } else {\n        this.uniforms.splatTexEnable.value = false;\n        this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;\n      }\n    } else {\n      this.uniforms.splatTexEnable.value = false;\n      this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;\n    }\n    const accumToWorld = ((_b2 = viewpoint.display) == null ? void 0 : _b2.accumulator.toWorld) ?? new THREE.Matrix4();\n    const worldToCamera = camera.matrixWorld.clone().invert();\n    const originToCamera = accumToWorld.clone().premultiply(worldToCamera);\n    originToCamera.decompose(\n      this.uniforms.renderToViewPos.value,\n      this.uniforms.renderToViewQuat.value,\n      new THREE.Vector3()\n    );\n  }\n  // Update the uniforms for the given viewpoint.\n  // Note that the client expects to be able to call render() at any point\n  // to update the canvas, so we must switch the viewpoint back to\n  // defaultView when we're finished.\n  prepareViewpoint(viewpoint) {\n    var _a2, _b2, _c, _d;\n    this.viewpoint = viewpoint ?? this.viewpoint;\n    if (this.viewpoint.display) {\n      const { accumulator, geometry } = this.viewpoint.display;\n      this.uniforms.numSplats.value = accumulator.splats.numSplats;\n      this.uniforms.packedSplats.value = accumulator.splats.getTexture();\n      this.uniforms.rgbMinMaxLnScaleMinMax.value.set(\n        ((_a2 = accumulator.splats.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,\n        ((_b2 = accumulator.splats.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? 1,\n        ((_c = accumulator.splats.splatEncoding) == null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,\n        ((_d = accumulator.splats.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX\n      );\n      this.geometry = geometry;\n      this.material.transparent = !this.viewpoint.stochastic;\n      this.material.depthWrite = this.viewpoint.stochastic;\n      this.material.needsUpdate = true;\n    } else {\n      this.uniforms.numSplats.value = 0;\n      this.uniforms.packedSplats.value = PackedSplats.getEmpty();\n      this.geometry = EMPTY_GEOMETRY;\n    }\n  }\n  // If spark.autoUpdate is false then you must manually call\n  // spark.update({ scene }) to have the scene Gsplats be re-generated.\n  update({\n    scene,\n    viewToWorld\n  }) {\n    const originToWorld = this.matrixWorld.clone();\n    if (this.preUpdate) {\n      this.updateInternal({ scene, originToWorld, viewToWorld });\n    } else {\n      this.pendingUpdate = {\n        scene,\n        originToWorld\n      };\n      setTimeout(() => {\n        if (this.pendingUpdate) {\n          const { scene: scene2, originToWorld: originToWorld2 } = this.pendingUpdate;\n          this.pendingUpdate = null;\n          this.updateInternal({ scene: scene2, originToWorld: originToWorld2, viewToWorld });\n        }\n      }, 1);\n    }\n  }\n  updateInternal({\n    scene,\n    originToWorld,\n    viewToWorld\n  }) {\n    var _a2;\n    if (!this.canAllocAccumulator()) {\n      return false;\n    }\n    if (!originToWorld) {\n      originToWorld = this.active.toWorld;\n    }\n    viewToWorld = viewToWorld ?? originToWorld.clone();\n    const time = this.time ?? this.clock.getElapsedTime();\n    const deltaTime = time - (this.lastUpdateTime ?? time);\n    this.lastUpdateTime = time;\n    const activeMapping = this.active.mapping.reduce((map, record) => {\n      map.set(record.node, record);\n      return map;\n    }, /* @__PURE__ */ new Map());\n    const { generators: generators2, visibleGenerators, globalEdits } = this.compileScene(scene);\n    for (const object of generators2) {\n      (_a2 = object.frameUpdate) == null ? void 0 : _a2.call(object, {\n        object,\n        time,\n        deltaTime,\n        viewToWorld,\n        globalEdits\n      });\n    }\n    const visibleGenHash = new Set(visibleGenerators.map((g) => g.uuid));\n    for (const object of generators2) {\n      const current = activeMapping.get(object);\n      const isVisible = object.generator && visibleGenHash.has(object.uuid);\n      const numSplats = isVisible ? object.numSplats : 0;\n      if (this.needsUpdate || object.generator !== (current == null ? void 0 : current.generator) || numSplats !== (current == null ? void 0 : current.count)) {\n        object.updateVersion();\n      }\n    }\n    const originUpdate = !withinCoorientDist({\n      matrix1: originToWorld,\n      matrix2: this.active.toWorld,\n      maxDistance: this.originDistance\n    });\n    const needsUpdate = this.needsUpdate || originUpdate || generators2.length !== activeMapping.size || generators2.some((g) => {\n      var _a3;\n      return g.version !== ((_a3 = activeMapping.get(g)) == null ? void 0 : _a3.version);\n    });\n    this.needsUpdate = false;\n    let accumulator = null;\n    if (needsUpdate) {\n      accumulator = this.maybeAllocAccumulator();\n      if (!accumulator) {\n        throw new Error(\"Unreachable\");\n      }\n      const originChanged = !withinCoorientDist({\n        matrix1: originToWorld,\n        matrix2: this.active.toWorld,\n        maxDistance: 1e-5,\n        minCoorient: 0.99999\n      });\n      const sorted = visibleGenerators.map((g, gIndex) => {\n        const lastGen = activeMapping.get(g);\n        return !lastGen ? [Number.POSITIVE_INFINITY, g.version, g] : (\n          // Sort by version deltas then by previous ordering in the mapping,\n          // attempting to keep unchanging generators near the front\n          // to improve our chances of avoiding a re-generation.\n          [g.version - lastGen.version, lastGen.base, g]\n        );\n      }).sort((a, b) => {\n        if (a[0] !== b[0]) {\n          return a[0] - b[0];\n        }\n        return a[1] - b[1];\n      });\n      const genOrder = sorted.map(([_version, _seq, g]) => g);\n      const splatCounts = genOrder.map((g) => g.numSplats);\n      const { maxSplats, mapping } = accumulator.splats.generateMapping(splatCounts);\n      const newGenerators = genOrder.map((node, gIndex) => {\n        const { base, count } = mapping[gIndex];\n        return {\n          node,\n          generator: node.generator,\n          version: node.version,\n          base,\n          count\n        };\n      });\n      originToWorld.clone().invert().decompose(\n        this.translateToAccumulator.value,\n        this.rotateToAccumulator.value,\n        new THREE.Vector3()\n      );\n      accumulator.ensureGenerate(maxSplats);\n      accumulator.splats.splatEncoding = { ...this.splatEncoding };\n      accumulator.generateSplats({\n        renderer: this.renderer,\n        modifier: this.modifier,\n        generators: newGenerators,\n        forceUpdate: originChanged,\n        originToWorld\n      });\n      accumulator.splatsVersion = this.active.splatsVersion + 1;\n      const hasCorrespondence = accumulator.hasCorrespondence(this.active);\n      accumulator.mappingVersion = this.active.mappingVersion + (hasCorrespondence ? 0 : 1);\n      this.releaseAccumulator(this.active);\n      this.active = accumulator;\n      this.prepareViewpoint();\n    }\n    setTimeout(() => {\n      for (const view of this.autoViewpoints) {\n        view.autoPoll({ accumulator: accumulator ?? void 0 });\n      }\n    }, 1);\n    return true;\n  }\n  compileScene(scene) {\n    const generators2 = [];\n    scene.traverse((node) => {\n      if (node instanceof SplatGenerator) {\n        generators2.push(node);\n      }\n    });\n    const visibleGenerators = [];\n    scene.traverseVisible((node) => {\n      if (node instanceof SplatGenerator) {\n        visibleGenerators.push(node);\n      }\n    });\n    const globalEdits = /* @__PURE__ */ new Set();\n    scene.traverseVisible((node) => {\n      if (node instanceof SplatEdit) {\n        let ancestor = node.parent;\n        while (ancestor != null && !(ancestor instanceof SplatMesh)) {\n          ancestor = ancestor.parent;\n        }\n        if (ancestor == null) {\n          globalEdits.add(node);\n        }\n      }\n    });\n    return {\n      generators: generators2,\n      visibleGenerators,\n      globalEdits: Array.from(globalEdits)\n    };\n  }\n  // Renders out the scene to an environment map that can be used for\n  // Image-based lighting or similar applications. First optionally updates Gsplats,\n  // sorts them with respect to the provided worldCenter, renders 6 cube faces,\n  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture\n  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.\n  async renderEnvMap({\n    renderer,\n    scene,\n    worldCenter,\n    size = 256,\n    near = 0.1,\n    far = 1e3,\n    hideObjects = [],\n    update = false\n  }) {\n    var _a2, _b2;\n    if (!this.envViewpoint) {\n      this.envViewpoint = this.newViewpoint({ sort360: true });\n    }\n    if (!_SparkRenderer.cubeRender || _SparkRenderer.cubeRender.target.width !== size || _SparkRenderer.cubeRender.near !== near || _SparkRenderer.cubeRender.far !== far) {\n      if (_SparkRenderer.cubeRender) {\n        _SparkRenderer.cubeRender.target.dispose();\n      }\n      const target2 = new THREE.WebGLCubeRenderTarget(size, {\n        format: THREE.RGBAFormat,\n        generateMipmaps: true,\n        minFilter: THREE.LinearMipMapLinearFilter\n      });\n      const camera2 = new THREE.CubeCamera(near, far, target2);\n      _SparkRenderer.cubeRender = { target: target2, camera: camera2, near, far };\n    }\n    if (!_SparkRenderer.pmrem) {\n      _SparkRenderer.pmrem = new THREE.PMREMGenerator(renderer ?? this.renderer);\n    }\n    const viewToWorld = new THREE.Matrix4().setPosition(worldCenter);\n    await ((_a2 = this.envViewpoint) == null ? void 0 : _a2.prepare({ scene, viewToWorld, update }));\n    const { target, camera } = _SparkRenderer.cubeRender;\n    camera.position.copy(worldCenter);\n    const objectVisibility = /* @__PURE__ */ new Map();\n    for (const object of hideObjects) {\n      objectVisibility.set(object, object.visible);\n      object.visible = false;\n    }\n    this.prepareViewpoint(this.envViewpoint);\n    camera.update(renderer ?? this.renderer, scene);\n    this.prepareViewpoint(this.defaultView);\n    for (const [object, visible] of objectVisibility.entries()) {\n      object.visible = visible;\n    }\n    return (_b2 = _SparkRenderer.pmrem) == null ? void 0 : _b2.fromCubemap(target.texture).texture;\n  }\n  // Utility function to recursively set the envMap property for any\n  // THREE.MeshStandardMaterial within the subtree of root.\n  recurseSetEnvMap(root, envMap) {\n    root.traverse((node) => {\n      if (node instanceof THREE.Mesh) {\n        if (Array.isArray(node.material)) {\n          for (const material of node.material) {\n            if (material instanceof THREE.MeshStandardMaterial) {\n              material.envMap = envMap;\n            }\n          }\n        } else {\n          if (node.material instanceof THREE.MeshStandardMaterial) {\n            node.material.envMap = envMap;\n          }\n        }\n      }\n    });\n  }\n  // Utility function that helps extract the Gsplat RGBA values from a\n  // SplatGenerator, including the result of any real-time RGBA SDF edits applied\n  // to a SplatMesh. This effectively \"bakes\" any computed RGBA values, which can\n  // now be used as a pipeline input via SplatMesh.splatRgba to inject these\n  // baked values into the Gsplat data.\n  getRgba({\n    generator,\n    rgba\n  }) {\n    const mapping = this.active.mapping.find(({ node }) => node === generator);\n    if (!mapping) {\n      throw new Error(\"Generator not found\");\n    }\n    rgba = rgba ?? new RgbaArray();\n    rgba.fromPackedSplats({\n      packedSplats: this.active.splats,\n      base: mapping.base,\n      count: mapping.count,\n      renderer: this.renderer\n    });\n    return rgba;\n  }\n  // Utility function that builds on getRgba({ generator }) and additionally\n  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA\n  // in that byte order.\n  async readRgba({\n    generator,\n    rgba\n  }) {\n    rgba = this.getRgba({ generator, rgba });\n    return rgba.read();\n  }\n};\n_SparkRenderer.cubeRender = null;\n_SparkRenderer.pmrem = null;\n_SparkRenderer.EMPTY_SPLAT_TEXTURE = new THREE.Data3DTexture();\nlet SparkRenderer = _SparkRenderer;\nconst EMPTY_GEOMETRY = new SplatGeometry(new Uint32Array(1), 0);\ndynoBlock(\n  { packedSplats: TPackedSplats, index: \"int\" },\n  { gsplat: Gsplat },\n  ({ packedSplats, index }) => {\n    if (!packedSplats || !index) {\n      throw new Error(\"Invalid input\");\n    }\n    const gsplat = readPackedSplat(packedSplats, index);\n    return { gsplat };\n  }\n);\nfunction averageOriginToWorlds(originToWorlds) {\n  if (originToWorlds.length === 0) {\n    return null;\n  }\n  const position = new THREE.Vector3();\n  const quaternion = new THREE.Quaternion();\n  const scale = new THREE.Vector3();\n  const positions = [];\n  const quaternions = [];\n  for (const matrix of originToWorlds) {\n    matrix.decompose(position, quaternion, scale);\n    positions.push(position);\n    quaternions.push(quaternion);\n  }\n  return new THREE.Matrix4().compose(\n    averagePositions(positions),\n    averageQuaternions(quaternions),\n    new THREE.Vector3(1, 1, 1)\n  );\n}\nfunction decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n  const numSplats = Math.floor(fileBytes.length / 32);\n  if (numSplats * 32 !== fileBytes.length) {\n    throw new Error(\"Invalid .splat file size\");\n  }\n  const f32 = new Float32Array(fileBytes.buffer);\n  for (let i = 0; i < numSplats; ++i) {\n    const i322 = i * 32;\n    const i8 = i * 8;\n    const x = f32[i8 + 0];\n    const y = f32[i8 + 1];\n    const z = f32[i8 + 2];\n    const scaleX = f32[i8 + 3];\n    const scaleY = f32[i8 + 4];\n    const scaleZ = f32[i8 + 5];\n    const r = fileBytes[i322 + 24] / 255;\n    const g = fileBytes[i322 + 25] / 255;\n    const b = fileBytes[i322 + 26] / 255;\n    const opacity = fileBytes[i322 + 27] / 255;\n    const quatW = (fileBytes[i322 + 28] - 128) / 128;\n    const quatX = (fileBytes[i322 + 29] - 128) / 128;\n    const quatY = (fileBytes[i322 + 30] - 128) / 128;\n    const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n    splatCallback(\n      i,\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      scaleZ,\n      quatX,\n      quatY,\n      quatZ,\n      quatW,\n      opacity,\n      r,\n      g,\n      b\n    );\n  }\n}\nconst KSPLAT_COMPRESSION = {\n  0: {\n    bytesPerCenter: 12,\n    bytesPerScale: 12,\n    bytesPerRotation: 16,\n    bytesPerColor: 4,\n    bytesPerSphericalHarmonicsComponent: 4,\n    scaleOffsetBytes: 12,\n    rotationOffsetBytes: 24,\n    colorOffsetBytes: 40,\n    sphericalHarmonicsOffsetBytes: 44,\n    scaleRange: 1\n  },\n  1: {\n    bytesPerCenter: 6,\n    bytesPerScale: 6,\n    bytesPerRotation: 8,\n    bytesPerColor: 4,\n    bytesPerSphericalHarmonicsComponent: 2,\n    scaleOffsetBytes: 6,\n    rotationOffsetBytes: 12,\n    colorOffsetBytes: 20,\n    sphericalHarmonicsOffsetBytes: 24,\n    scaleRange: 32767\n  },\n  2: {\n    bytesPerCenter: 6,\n    bytesPerScale: 6,\n    bytesPerRotation: 8,\n    bytesPerColor: 4,\n    bytesPerSphericalHarmonicsComponent: 1,\n    scaleOffsetBytes: 6,\n    rotationOffsetBytes: 12,\n    colorOffsetBytes: 20,\n    sphericalHarmonicsOffsetBytes: 24,\n    scaleRange: 32767\n  }\n};\nconst KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n  0: 0,\n  1: 9,\n  2: 24,\n  3: 45\n};\nfunction decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n  var _a2;\n  const HEADER_BYTES = 4096;\n  const SECTION_BYTES = 1024;\n  let headerOffset = 0;\n  const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n  headerOffset += HEADER_BYTES;\n  const versionMajor = header.getUint8(0);\n  const versionMinor = header.getUint8(1);\n  if (versionMajor !== 0 || versionMinor < 1) {\n    throw new Error(\n      `Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\n    );\n  }\n  const maxSectionCount = header.getUint32(4, true);\n  header.getUint32(16, true);\n  const compressionLevel = header.getUint16(20, true);\n  if (compressionLevel < 0 || compressionLevel > 2) {\n    throw new Error(`Invalid .ksplat compression level: ${compressionLevel}`);\n  }\n  const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n  const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n  let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n  for (let section = 0; section < maxSectionCount; ++section) {\n    let getSh = function(splatOffset, component) {\n      if (compressionLevel === 0) {\n        return data.getFloat32(\n          splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n          true\n        );\n      }\n      if (compressionLevel === 1) {\n        return fromHalf(\n          data.getUint16(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n            true\n          )\n        );\n      }\n      const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n      return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n    };\n    const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n    headerOffset += SECTION_BYTES;\n    const sectionSplatCount = section2.getUint32(0, true);\n    const sectionMaxSplatCount = section2.getUint32(4, true);\n    const bucketSize = section2.getUint32(8, true);\n    const bucketCount = section2.getUint32(12, true);\n    const bucketBlockSize = section2.getFloat32(16, true);\n    const bucketStorageSizeBytes = section2.getUint16(20, true);\n    const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n    const fullBucketCount = section2.getUint32(32, true);\n    const fullBucketSplats = fullBucketCount * bucketSize;\n    const partiallyFilledBucketCount = section2.getUint32(36, true);\n    const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n    const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n    const sphericalHarmonicsDegree = section2.getUint16(40, true);\n    const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n    const {\n      bytesPerCenter,\n      bytesPerScale,\n      bytesPerRotation,\n      bytesPerColor,\n      bytesPerSphericalHarmonicsComponent,\n      scaleOffsetBytes,\n      rotationOffsetBytes,\n      colorOffsetBytes,\n      sphericalHarmonicsOffsetBytes\n    } = KSPLAT_COMPRESSION[compressionLevel];\n    const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n    const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n    const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n    const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n    const sh2Index = [\n      9,\n      14,\n      19,\n      10,\n      15,\n      20,\n      11,\n      16,\n      21,\n      12,\n      17,\n      22,\n      13,\n      18,\n      23\n    ];\n    const sh3Index = [\n      24,\n      31,\n      38,\n      25,\n      32,\n      39,\n      26,\n      33,\n      40,\n      27,\n      34,\n      41,\n      28,\n      35,\n      42,\n      29,\n      36,\n      43,\n      30,\n      37,\n      44\n    ];\n    const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n    const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n    const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n    const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n    const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n    const dataBase = sectionBase + bucketsStorageSizeBytes;\n    const data = new DataView(\n      fileBytes.buffer,\n      dataBase,\n      splatDataStorageSizeBytes\n    );\n    const bucketArray = new Float32Array(\n      fileBytes.buffer,\n      bucketsBase,\n      bucketCount * 3\n    );\n    const partiallyFilledBucketLengths = new Uint32Array(\n      fileBytes.buffer,\n      sectionBase,\n      partiallyFilledBucketCount\n    );\n    let partialBucketIndex = fullBucketCount;\n    let partialBucketBase = fullBucketSplats;\n    for (let i = 0; i < sectionSplatCount; ++i) {\n      const splatOffset = i * bytesPerSplat;\n      let bucketIndex;\n      if (i < fullBucketSplats) {\n        bucketIndex = Math.floor(i / bucketSize);\n      } else {\n        const bucketLength = partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n        if (i >= partialBucketBase + bucketLength) {\n          partialBucketIndex += 1;\n          partialBucketBase += bucketLength;\n        }\n        bucketIndex = partialBucketIndex;\n      }\n      const x = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n      const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n      const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n      const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n      const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n      const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n      const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n        data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n      );\n      const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n        data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n      );\n      const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n        data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n      );\n      const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n        data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n      );\n      const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n      const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n      const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n      const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n      splatCallback(\n        i,\n        x,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n      if (sphericalHarmonicsDegree >= 1 && sh1) {\n        for (const [i2, key] of sh1Index.entries()) {\n          sh1[i2] = getSh(splatOffset, key);\n        }\n        if (sh2) {\n          for (const [i2, key] of sh2Index.entries()) {\n            sh2[i2] = getSh(splatOffset, key);\n          }\n        }\n        if (sh3) {\n          for (const [i2, key] of sh3Index.entries()) {\n            sh3[i2] = getSh(splatOffset, key);\n          }\n        }\n        shCallback == null ? void 0 : shCallback(i, sh1, sh2, sh3);\n      }\n    }\n    sectionBase += storageSizeBytes;\n  }\n}\nclass SpzReader {\n  constructor({ fileBytes }) {\n    this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n    const header = new DataView(this.reader.read(16).buffer);\n    if (header.getUint32(0, true) !== 1347635022) {\n      throw new Error(\"Invalid SPZ file\");\n    }\n    this.version = header.getUint32(4, true);\n    if (this.version < 1 || this.version > 2) {\n      throw new Error(`Unsupported SPZ version: ${this.version}`);\n    }\n    this.numSplats = header.getUint32(8, true);\n    this.shDegree = header.getUint8(12);\n    this.fractionalBits = header.getUint8(13);\n    this.flags = header.getUint8(14);\n    this.flagAntiAlias = (this.flags & 1) !== 0;\n    this.reserved = header.getUint8(15);\n    this.parsed = false;\n  }\n  parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n    if (this.parsed) {\n      throw new Error(\"SPZ file already parsed\");\n    }\n    this.parsed = true;\n    if (this.version === 1) {\n      const centerBytes = this.reader.read(this.numSplats * 3 * 2);\n      const centerUint16 = new Uint16Array(centerBytes.buffer);\n      for (let i = 0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n        const x = fromHalf(centerUint16[i3]);\n        const y = fromHalf(centerUint16[i3 + 1]);\n        const z = fromHalf(centerUint16[i3 + 2]);\n        centerCallback == null ? void 0 : centerCallback(i, x, y, z);\n      }\n    } else if (this.version === 2) {\n      const fixed = 1 << this.fractionalBits;\n      const centerBytes = this.reader.read(this.numSplats * 3 * 3);\n      for (let i = 0; i < this.numSplats; i++) {\n        const i9 = i * 9;\n        const x = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n        const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n        const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n        centerCallback == null ? void 0 : centerCallback(i, x, y, z);\n      }\n    } else {\n      throw new Error(\"Unreachable\");\n    }\n    {\n      const bytes = this.reader.read(this.numSplats);\n      for (let i = 0; i < this.numSplats; i++) {\n        alphaCallback == null ? void 0 : alphaCallback(i, bytes[i] / 255);\n      }\n    }\n    {\n      const rgbBytes = this.reader.read(this.numSplats * 3);\n      const scale = SH_C0 / 0.15;\n      for (let i = 0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n        const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n        const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n        const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n        rgbCallback == null ? void 0 : rgbCallback(i, r, g, b);\n      }\n    }\n    {\n      const scalesBytes = this.reader.read(this.numSplats * 3);\n      for (let i = 0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n        const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n        const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n        const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n        scalesCallback == null ? void 0 : scalesCallback(i, scaleX, scaleY, scaleZ);\n      }\n    }\n    {\n      const quatBytes = this.reader.read(this.numSplats * 3);\n      for (let i = 0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n        const quatX = quatBytes[i3] / 127.5 - 1;\n        const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n        const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n        const quatW = Math.sqrt(\n          Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n        );\n        quatCallback == null ? void 0 : quatCallback(i, quatX, quatY, quatZ, quatW);\n      }\n    }\n    if (shCallback && this.shDegree >= 1) {\n      const sh1 = new Float32Array(3 * 3);\n      const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const shBytes = this.reader.read(\n        this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n      );\n      let offset = 0;\n      for (let i = 0; i < this.numSplats; i++) {\n        for (let j = 0; j < 9; ++j) {\n          sh1[j] = (shBytes[offset + j] - 128) / 128;\n        }\n        offset += 9;\n        if (sh2) {\n          for (let j = 0; j < 15; ++j) {\n            sh2[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 15;\n        }\n        if (sh3) {\n          for (let j = 0; j < 21; ++j) {\n            sh3[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 21;\n        }\n        shCallback == null ? void 0 : shCallback(i, sh1, sh2, sh3);\n      }\n    }\n  }\n}\nconst SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\nconst SH_C0 = 0.28209479177387814;\nconst SPZ_MAGIC = 1347635022;\nconst SPZ_VERSION = 2;\nconst FLAG_ANTIALIASED = 1;\nclass SpzWriter {\n  constructor({\n    numSplats,\n    shDegree,\n    fractionalBits = 12,\n    flagAntiAlias = true\n  }) {\n    this.clippedCount = 0;\n    const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n    const bufferSize = 16 + numSplats * splatSize;\n    this.buffer = new ArrayBuffer(bufferSize);\n    this.view = new DataView(this.buffer);\n    this.view.setUint32(0, SPZ_MAGIC, true);\n    this.view.setUint32(4, SPZ_VERSION, true);\n    this.view.setUint32(8, numSplats, true);\n    this.view.setUint8(12, shDegree);\n    this.view.setUint8(13, fractionalBits);\n    this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n    this.view.setUint8(15, 0);\n    this.numSplats = numSplats;\n    this.shDegree = shDegree;\n    this.fractionalBits = fractionalBits;\n    this.fraction = 1 << fractionalBits;\n    this.flagAntiAlias = flagAntiAlias;\n  }\n  setCenter(index, x, y, z) {\n    const xRounded = Math.round(x * this.fraction);\n    const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n    const yRounded = Math.round(y * this.fraction);\n    const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n    const zRounded = Math.round(z * this.fraction);\n    const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n    const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n    if (clipped) {\n      this.clippedCount += 1;\n    }\n    const i9 = index * 9;\n    const base = 16 + i9;\n    this.view.setUint8(base, xInt & 255);\n    this.view.setUint8(base + 1, xInt >> 8 & 255);\n    this.view.setUint8(base + 2, xInt >> 16 & 255);\n    this.view.setUint8(base + 3, yInt & 255);\n    this.view.setUint8(base + 4, yInt >> 8 & 255);\n    this.view.setUint8(base + 5, yInt >> 16 & 255);\n    this.view.setUint8(base + 6, zInt & 255);\n    this.view.setUint8(base + 7, zInt >> 8 & 255);\n    this.view.setUint8(base + 8, zInt >> 16 & 255);\n  }\n  setAlpha(index, alpha) {\n    const base = 16 + this.numSplats * 9 + index;\n    this.view.setUint8(\n      base,\n      Math.max(0, Math.min(255, Math.round(alpha * 255)))\n    );\n  }\n  static scaleRgb(r) {\n    const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n    return Math.max(0, Math.min(255, Math.round(v)));\n  }\n  setRgb(index, r, g, b) {\n    const base = 16 + this.numSplats * 10 + index * 3;\n    this.view.setUint8(base, SpzWriter.scaleRgb(r));\n    this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n    this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n  }\n  setScale(index, scaleX, scaleY, scaleZ) {\n    const base = 16 + this.numSplats * 13 + index * 3;\n    this.view.setUint8(\n      base,\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n    );\n    this.view.setUint8(\n      base + 1,\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n    );\n    this.view.setUint8(\n      base + 2,\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n    );\n  }\n  setQuat(index, quatX, quatY, quatZ, quatW) {\n    const base = 16 + this.numSplats * 16 + index * 3;\n    const quatNeg = quatW < 0;\n    this.view.setUint8(\n      base,\n      Math.max(\n        0,\n        Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))\n      )\n    );\n    this.view.setUint8(\n      base + 1,\n      Math.max(\n        0,\n        Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))\n      )\n    );\n    this.view.setUint8(\n      base + 2,\n      Math.max(\n        0,\n        Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))\n      )\n    );\n  }\n  static quantizeSh(sh, bits2) {\n    const value = Math.round(sh * 128) + 128;\n    const bucketSize = 1 << 8 - bits2;\n    const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n    return Math.max(0, Math.min(255, quantized));\n  }\n  setSh(index, sh1, sh2, sh3) {\n    const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n    const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;\n    for (let j = 0; j < 9; ++j) {\n      this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n    }\n    if (sh2) {\n      const base2 = base1 + 9;\n      for (let j = 0; j < 15; ++j) {\n        this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n      }\n      if (sh3) {\n        const base3 = base2 + 15;\n        for (let j = 0; j < 21; ++j) {\n          this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n        }\n      }\n    }\n  }\n  async finalize() {\n    const input = new Uint8Array(this.buffer);\n    const stream = new ReadableStream({\n      async start(controller) {\n        controller.enqueue(input);\n        controller.close();\n      }\n    });\n    const compressed = stream.pipeThrough(new CompressionStream(\"gzip\"));\n    const response = new Response(compressed);\n    const buffer = await response.arrayBuffer();\n    console.log(\n      \"Compressed\",\n      input.length,\n      \"bytes to\",\n      buffer.byteLength,\n      \"bytes\"\n    );\n    return new Uint8Array(buffer);\n  }\n}\nasync function transcodeSpz(input) {\n  var _a2, _b2, _c;\n  const splats = new SplatData();\n  const {\n    inputs,\n    clipXyz,\n    maxSh,\n    fractionalBits = 12,\n    opacityThreshold\n  } = input;\n  for (const input2 of inputs) {\n    let transformPos2 = function(pos) {\n      pos.multiplyScalar(scale);\n      pos.applyQuaternion(quaternion);\n      pos.add(translate);\n      return pos;\n    }, transformScales = function(scales) {\n      scales.multiplyScalar(scale);\n      return scales;\n    }, transformQuaternion = function(quat) {\n      quat.premultiply(quaternion);\n      return quat;\n    }, withinClip = function(p) {\n      return !clip || clip.containsPoint(p);\n    }, withinOpacity = function(opacity) {\n      return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n    };\n    const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n    const quaternion = new THREE.Quaternion().fromArray(\n      ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n    );\n    const translate = new THREE.Vector3().fromArray(\n      ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n    );\n    const clip = clipXyz ? new THREE.Box3(\n      new THREE.Vector3().fromArray(clipXyz.min),\n      new THREE.Vector3().fromArray(clipXyz.max)\n    ) : void 0;\n    let fileType = input2.fileType;\n    if (!fileType) {\n      fileType = getSplatFileType(input2.fileBytes);\n      if (!fileType && input2.pathOrUrl) {\n        fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n      }\n    }\n    switch (fileType) {\n      case SplatFileType.PLY: {\n        const ply = new PlyReader({ fileBytes: input2.fileBytes });\n        await ply.parseHeader();\n        let lastIndex = null;\n        ply.parseSplats(\n          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n            const center = transformPos2(new THREE.Vector3(x, y, z));\n            if (withinClip(center) && withinOpacity(opacity)) {\n              lastIndex = splats.pushSplat();\n              splats.setCenter(lastIndex, center.x, center.y, center.z);\n              const scales = transformScales(\n                new THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n              const quaternion2 = transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW)\n              );\n              splats.setQuaternion(\n                lastIndex,\n                quaternion2.x,\n                quaternion2.y,\n                quaternion2.z,\n                quaternion2.w\n              );\n              splats.setOpacity(lastIndex, opacity);\n              splats.setColor(lastIndex, r, g, b);\n            } else {\n              lastIndex = null;\n            }\n          },\n          (index, sh1, sh2, sh3) => {\n            if (sh1 && lastIndex !== null) {\n              splats.setSh1(lastIndex, sh1);\n            }\n            if (sh2 && lastIndex !== null) {\n              splats.setSh2(lastIndex, sh2);\n            }\n            if (sh3 && lastIndex !== null) {\n              splats.setSh3(lastIndex, sh3);\n            }\n          }\n        );\n        break;\n      }\n      case SplatFileType.SPZ: {\n        const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n        const mapping = new Int32Array(spz2.numSplats);\n        mapping.fill(-1);\n        const centers = new Float32Array(spz2.numSplats * 3);\n        const center = new THREE.Vector3();\n        spz2.parseSplats(\n          (index, x, y, z) => {\n            const center2 = transformPos2(new THREE.Vector3(x, y, z));\n            centers[index * 3] = center2.x;\n            centers[index * 3 + 1] = center2.y;\n            centers[index * 3 + 2] = center2.z;\n          },\n          (index, alpha) => {\n            center.fromArray(centers, index * 3);\n            if (withinClip(center) && withinOpacity(alpha)) {\n              mapping[index] = splats.pushSplat();\n              splats.setCenter(mapping[index], center.x, center.y, center.z);\n              splats.setOpacity(mapping[index], alpha);\n            }\n          },\n          (index, r, g, b) => {\n            if (mapping[index] >= 0) {\n              splats.setColor(mapping[index], r, g, b);\n            }\n          },\n          (index, scaleX, scaleY, scaleZ) => {\n            if (mapping[index] >= 0) {\n              const scales = transformScales(\n                new THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n            }\n          },\n          (index, quatX, quatY, quatZ, quatW) => {\n            if (mapping[index] >= 0) {\n              const quaternion2 = transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW)\n              );\n              splats.setQuaternion(\n                mapping[index],\n                quaternion2.x,\n                quaternion2.y,\n                quaternion2.z,\n                quaternion2.w\n              );\n            }\n          },\n          (index, sh1, sh2, sh3) => {\n            if (mapping[index] >= 0) {\n              splats.setSh1(mapping[index], sh1);\n              if (sh2) {\n                splats.setSh2(mapping[index], sh2);\n              }\n              if (sh3) {\n                splats.setSh3(mapping[index], sh3);\n              }\n            }\n          }\n        );\n        break;\n      }\n      case SplatFileType.SPLAT:\n        decodeAntiSplat(\n          input2.fileBytes,\n          (numSplats) => {\n          },\n          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n            const center = transformPos2(new THREE.Vector3(x, y, z));\n            if (withinClip(center) && withinOpacity(opacity)) {\n              const index2 = splats.pushSplat();\n              splats.setCenter(index2, center.x, center.y, center.z);\n              const scales = transformScales(\n                new THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              splats.setScale(index2, scales.x, scales.y, scales.z);\n              const quaternion2 = transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW)\n              );\n              splats.setQuaternion(\n                index2,\n                quaternion2.x,\n                quaternion2.y,\n                quaternion2.z,\n                quaternion2.w\n              );\n              splats.setOpacity(index2, opacity);\n              splats.setColor(index2, r, g, b);\n            }\n          }\n        );\n        break;\n      case SplatFileType.KSPLAT: {\n        let lastIndex = null;\n        decodeKsplat(\n          input2.fileBytes,\n          (numSplats) => {\n          },\n          (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n            const center = transformPos2(new THREE.Vector3(x, y, z));\n            if (withinClip(center) && withinOpacity(opacity)) {\n              lastIndex = splats.pushSplat();\n              splats.setCenter(lastIndex, center.x, center.y, center.z);\n              const scales = transformScales(\n                new THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n              const quaternion2 = transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, quatZ, quatW)\n              );\n              splats.setQuaternion(\n                lastIndex,\n                quaternion2.x,\n                quaternion2.y,\n                quaternion2.z,\n                quaternion2.w\n              );\n              splats.setOpacity(lastIndex, opacity);\n              splats.setColor(lastIndex, r, g, b);\n            } else {\n              lastIndex = null;\n            }\n          },\n          (index, sh1, sh2, sh3) => {\n            if (lastIndex !== null) {\n              splats.setSh1(lastIndex, sh1);\n              if (sh2) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          }\n        );\n        break;\n      }\n      default:\n        throw new Error(`transcodeSpz not implemented for ${fileType}`);\n    }\n  }\n  const shDegree = Math.min(\n    maxSh ?? 3,\n    splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n  );\n  const spz = new SpzWriter({\n    numSplats: splats.numSplats,\n    shDegree,\n    fractionalBits,\n    flagAntiAlias: true\n  });\n  for (let i = 0; i < splats.numSplats; ++i) {\n    const i3 = i * 3;\n    const i4 = i * 4;\n    spz.setCenter(\n      i,\n      splats.centers[i3],\n      splats.centers[i3 + 1],\n      splats.centers[i3 + 2]\n    );\n    spz.setScale(\n      i,\n      splats.scales[i3],\n      splats.scales[i3 + 1],\n      splats.scales[i3 + 2]\n    );\n    spz.setQuat(\n      i,\n      splats.quaternions[i4],\n      splats.quaternions[i4 + 1],\n      splats.quaternions[i4 + 2],\n      splats.quaternions[i4 + 3]\n    );\n    spz.setAlpha(i, splats.opacities[i]);\n    spz.setRgb(\n      i,\n      splats.colors[i3],\n      splats.colors[i3 + 1],\n      splats.colors[i3 + 2]\n    );\n    if (splats.sh1 && shDegree >= 1) {\n      spz.setSh(\n        i,\n        splats.sh1.slice(i * 9, (i + 1) * 9),\n        shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i * 15, (i + 1) * 15) : void 0,\n        shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i * 21, (i + 1) * 21) : void 0\n      );\n    }\n  }\n  const spzBytes = await spz.finalize();\n  return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n}\nclass SplatSkinning {\n  constructor(options) {\n    this.mesh = options.mesh;\n    this.numSplats = options.numSplats ?? this.mesh.numSplats;\n    const { width, height, depth, maxSplats } = getTextureSize(this.numSplats);\n    this.skinData = new Uint16Array(maxSplats * 4);\n    this.skinTexture = new THREE.DataArrayTexture(\n      this.skinData,\n      width,\n      height,\n      depth\n    );\n    this.skinTexture.format = THREE.RGBAIntegerFormat;\n    this.skinTexture.type = THREE.UnsignedShortType;\n    this.skinTexture.internalFormat = \"RGBA16UI\";\n    this.skinTexture.needsUpdate = true;\n    this.numBones = options.numBones ?? 256;\n    this.boneData = new Float32Array(this.numBones * 16);\n    this.boneTexture = new THREE.DataTexture(\n      this.boneData,\n      4,\n      this.numBones,\n      THREE.RGBAFormat,\n      THREE.FloatType\n    );\n    this.boneTexture.internalFormat = \"RGBA32F\";\n    this.boneTexture.needsUpdate = true;\n    this.uniform = new DynoUniform({\n      key: \"skinning\",\n      type: GsplatSkinning,\n      globals: () => [defineGsplatSkinning],\n      value: {\n        numSplats: this.numSplats,\n        numBones: this.numBones,\n        skinTexture: this.skinTexture,\n        boneTexture: this.boneTexture\n      }\n    });\n  }\n  // Apply the skeletal animation to a Gsplat in a dyno program.\n  modify(gsplat) {\n    return applyGsplatSkinning(gsplat, this.uniform);\n  }\n  // Set the \"rest\" pose for a bone with position and quaternion orientation.\n  setRestQuatPos(boneIndex, quat, pos) {\n    const i16 = boneIndex * 16;\n    this.boneData[i16 + 0] = quat.x;\n    this.boneData[i16 + 1] = quat.y;\n    this.boneData[i16 + 2] = quat.z;\n    this.boneData[i16 + 3] = quat.w;\n    this.boneData[i16 + 4] = pos.x;\n    this.boneData[i16 + 5] = pos.y;\n    this.boneData[i16 + 6] = pos.z;\n    this.boneData[i16 + 7] = 0;\n    this.boneData[i16 + 8] = 0;\n    this.boneData[i16 + 9] = 0;\n    this.boneData[i16 + 10] = 0;\n    this.boneData[i16 + 11] = 1;\n    this.boneData[i16 + 12] = 0;\n    this.boneData[i16 + 13] = 0;\n    this.boneData[i16 + 14] = 0;\n    this.boneData[i16 + 15] = 0;\n  }\n  // Set the \"current\" position and orientation of a bone.\n  setBoneQuatPos(boneIndex, quat, pos) {\n    const i16 = boneIndex * 16;\n    const origQuat = new THREE.Quaternion(\n      this.boneData[i16 + 0],\n      this.boneData[i16 + 1],\n      this.boneData[i16 + 2],\n      this.boneData[i16 + 3]\n    );\n    const origPos = new THREE.Vector3(\n      this.boneData[i16 + 4],\n      this.boneData[i16 + 5],\n      this.boneData[i16 + 6]\n    );\n    const relQuat = origQuat.clone().invert();\n    const relPos = pos.clone().sub(origPos);\n    relPos.applyQuaternion(relQuat);\n    relQuat.multiply(quat);\n    const dual = new THREE.Quaternion(\n      relPos.x,\n      relPos.y,\n      relPos.z,\n      0\n    ).multiply(origQuat);\n    this.boneData[i16 + 8] = relQuat.x;\n    this.boneData[i16 + 9] = relQuat.y;\n    this.boneData[i16 + 10] = relQuat.z;\n    this.boneData[i16 + 11] = relQuat.w;\n    this.boneData[i16 + 12] = 0.5 * dual.x;\n    this.boneData[i16 + 13] = 0.5 * dual.y;\n    this.boneData[i16 + 14] = 0.5 * dual.z;\n    this.boneData[i16 + 15] = 0.5 * dual.w;\n  }\n  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,\n  // you can set the remaining weights to 0 (and index=0).\n  setSplatBones(splatIndex, boneIndices, weights) {\n    const i4 = splatIndex * 4;\n    this.skinData[i4 + 0] = Math.min(255, Math.max(0, Math.round(weights.x * 255))) + (boneIndices.x << 8);\n    this.skinData[i4 + 1] = Math.min(255, Math.max(0, Math.round(weights.y * 255))) + (boneIndices.y << 8);\n    this.skinData[i4 + 2] = Math.min(255, Math.max(0, Math.round(weights.z * 255))) + (boneIndices.z << 8);\n    this.skinData[i4 + 3] = Math.min(255, Math.max(0, Math.round(weights.w * 255))) + (boneIndices.w << 8);\n  }\n  // Call this to indicate that the bones have changed and the Gsplats need to be\n  // re-generated with updated skinning.\n  updateBones() {\n    this.boneTexture.needsUpdate = true;\n    this.mesh.needsUpdate = true;\n  }\n}\nconst GsplatSkinning = { type: \"GsplatSkinning\" };\nconst defineGsplatSkinning = unindent(`\n  struct GsplatSkinning {\n    int numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    sampler2D boneTexture;\n  };\n`);\nconst defineApplyGsplatSkinning = unindent(`\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n    usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) {\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if (boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the opposite direction\n          boneQuat = -boneQuat;\n          boneDual = -boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual += weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, quaternion);\n  }\n`);\nfunction applyGsplatSkinning(gsplat, skinning) {\n  const dyno2 = new Dyno({\n    inTypes: { gsplat: Gsplat, skinning: GsplatSkinning },\n    outTypes: { gsplat: Gsplat },\n    globals: () => [defineGsplatSkinning, defineApplyGsplatSkinning],\n    inputs: { gsplat, skinning },\n    statements: ({ inputs, outputs }) => {\n      const { skinning: skinning2 } = inputs;\n      const { gsplat: gsplat2 } = outputs;\n      return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          applyGsplatSkinning(\n            ${skinning2}.numSplats, ${skinning2}.numBones,\n            ${skinning2}.skinTexture, ${skinning2}.boneTexture,\n            ${gsplat2}.index, ${gsplat2}.center, ${gsplat2}.quaternion\n          );\n        }\n      `);\n    }\n  });\n  return dyno2.outputs.gsplat;\n}\nfunction constructGrid({\n  // PackedSplats object to add splats to\n  splats,\n  // min and max box extents of the grid\n  extents,\n  // step size along each grid axis\n  stepSize = 1,\n  // spherical radius of each Gsplat\n  pointRadius = 0.01,\n  // relative size of the \"shadow copy\" of each Gsplat placed behind it\n  pointShadowScale = 2,\n  // Gsplat opacity\n  opacity = 1,\n  // Gsplat color (THREE.Color) or function to set color for position:\n  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)\n  color\n}) {\n  const EPSILON = 1e-6;\n  const center = new THREE.Vector3();\n  const scales = new THREE.Vector3();\n  const quaternion = new THREE.Quaternion(0, 0, 0, 1);\n  if (color == null) {\n    color = (color2, point) => color2.set(\n      0.55 + 0.45 * Math.cos(point.x * 1),\n      0.55 + 0.45 * Math.cos(point.y * 1),\n      0.55 + 0.45 * Math.cos(point.z * 1)\n    );\n  }\n  const pointColor = new THREE.Color();\n  for (let z = extents.min.z; z < extents.max.z + EPSILON; z += stepSize) {\n    for (let y = extents.min.y; y < extents.max.y + EPSILON; y += stepSize) {\n      for (let x = extents.min.x; x < extents.max.x + EPSILON; x += stepSize) {\n        center.set(x, y, z);\n        for (let layer = 0; layer < 2; ++layer) {\n          scales.setScalar(pointRadius * (layer ? 1 : pointShadowScale));\n          if (!layer) {\n            pointColor.setScalar(0);\n          } else if (typeof color === \"function\") {\n            color(pointColor, center);\n          } else {\n            pointColor.copy(color);\n          }\n          splats.pushSplat(center, scales, quaternion, opacity, pointColor);\n        }\n      }\n    }\n  }\n}\nfunction constructAxes({\n  // PackedSplats object to add splats to\n  splats,\n  // scale (Gsplat scale along axis)\n  scale = 0.25,\n  // radius of the axes (Gsplat scale orthogonal to axis)\n  axisRadius = 75e-4,\n  // relative size of the \"shadow copy\" of each Gsplat placed behind it\n  axisShadowScale = 2,\n  // origins of the axes (default single axis at origin)\n  origins = [new THREE.Vector3()]\n}) {\n  const center = new THREE.Vector3();\n  const scales = new THREE.Vector3();\n  const quaternion = new THREE.Quaternion(0, 0, 0, 1);\n  const color = new THREE.Color();\n  const opacity = 1;\n  for (const origin of origins) {\n    for (let axis = 0; axis < 3; ++axis) {\n      center.set(\n        origin.x + (axis === 0 ? scale : 0),\n        origin.y + (axis === 1 ? scale : 0),\n        origin.z + (axis === 2 ? scale : 0)\n      );\n      for (let layer = 0; layer < 2; ++layer) {\n        scales.set(\n          (axis === 0 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),\n          (axis === 1 ? scale : axisRadius) * (layer ? 1 : axisShadowScale),\n          (axis === 2 ? scale : axisRadius) * (layer ? 1 : axisShadowScale)\n        );\n        color.setRGB(\n          layer === 0 ? 0 : axis === 0 ? 1 : 0,\n          layer === 0 ? 0 : axis === 1 ? 1 : 0,\n          layer === 0 ? 0 : axis === 2 ? 1 : 0\n        );\n        splats.pushSplat(center, scales, quaternion, opacity, color);\n      }\n    }\n  }\n}\nfunction constructSpherePoints({\n  // PackedSplats object to add splats to\n  splats,\n  // center of the sphere (default: origin)\n  origin = new THREE.Vector3(),\n  // radius of the sphere\n  radius = 1,\n  // maximum depth of recursion for subdividing the sphere\n  // Warning: Gsplat count grows exponentially with depth\n  maxDepth = 3,\n  // filter function to apply to each point, for example to select\n  // points in a certain direction or other function ((THREE.Vector3) => boolean)\n  // (default: null)\n  filter = null,\n  // radius of each oriented Gsplat\n  pointRadius = 0.02,\n  // flatness of each oriented Gsplat\n  pointThickness = 1e-3,\n  // color of each Gsplat (THREE.Color) or function to set color for point:\n  // ((THREE.Color, THREE.Vector3) => void) (default: white)\n  color = new THREE.Color(1, 1, 1)\n}) {\n  const pointsHash = {};\n  function addPoint(p) {\n    if (filter && !filter(p)) {\n      return;\n    }\n    const key = `${p.x},${p.y},${p.z}`;\n    if (!pointsHash[key]) {\n      pointsHash[key] = p;\n    }\n  }\n  function recurse(depth, p0, p1, p2) {\n    addPoint(p0);\n    addPoint(p1);\n    addPoint(p2);\n    if (depth >= maxDepth) {\n      return;\n    }\n    const p01 = new THREE.Vector3().addVectors(p0, p1).normalize();\n    const p12 = new THREE.Vector3().addVectors(p1, p2).normalize();\n    const p20 = new THREE.Vector3().addVectors(p2, p0).normalize();\n    recurse(depth + 1, p0, p01, p20);\n    recurse(depth + 1, p01, p1, p12);\n    recurse(depth + 1, p20, p12, p2);\n    recurse(depth + 1, p01, p12, p20);\n  }\n  for (const x of [-1, 1]) {\n    for (const y of [-1, 1]) {\n      for (const z of [-1, 1]) {\n        const p0 = new THREE.Vector3(x, 0, 0);\n        const p1 = new THREE.Vector3(0, y, 0);\n        const p2 = new THREE.Vector3(0, 0, z);\n        recurse(0, p0, p1, p2);\n      }\n    }\n  }\n  const points = Object.values(pointsHash);\n  const scales = new THREE.Vector3(pointRadius, pointRadius, pointThickness);\n  const quaternion = new THREE.Quaternion();\n  const pointColor = typeof color === \"function\" ? new THREE.Color() : color;\n  for (const point of points) {\n    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), point);\n    if (typeof color === \"function\") {\n      color(pointColor, point);\n    }\n    point.multiplyScalar(radius);\n    point.add(origin);\n    splats.pushSplat(point, scales, quaternion, 1, pointColor);\n  }\n}\nfunction textSplats({\n  // text string to display\n  text,\n  // browser font to render text with (default: \"Arial\")\n  font,\n  // font size in pixels/Gsplats (default: 32)\n  fontSize,\n  // SplatMesh.recolor tint assuming white Gsplats (default: white)\n  color,\n  // Individual Gsplat color (default: white)\n  rgb,\n  // Gsplat radius (default: 0.8 covers 1-unit spacing well)\n  dotRadius,\n  // text alignment: \"left\", \"center\", \"right\", \"start\", \"end\" (default: \"start\")\n  textAlign,\n  // line spacing multiplier, lines delimited by \"\\n\" (default: 1.0)\n  lineHeight,\n  // Coordinate scale in object-space (default: 1.0)\n  objectScale\n}) {\n  font = font ?? \"Arial\";\n  fontSize = fontSize ?? 32;\n  color = color ?? new THREE.Color(1, 1, 1);\n  dotRadius = dotRadius ?? 0.8;\n  textAlign = textAlign ?? \"start\";\n  lineHeight = lineHeight ?? 1;\n  objectScale = objectScale ?? 1;\n  const lines = text.split(\"\\n\");\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new Error(\"Failed to create canvas context\");\n  }\n  ctx.font = `${fontSize}px ${font}`;\n  ctx.textAlign = textAlign;\n  const metrics = ctx.measureText(\"\");\n  const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;\n  let minLeft = Number.POSITIVE_INFINITY;\n  let maxRight = Number.NEGATIVE_INFINITY;\n  let minTop = Number.POSITIVE_INFINITY;\n  let maxBottom = Number.NEGATIVE_INFINITY;\n  for (let line = 0; line < lines.length; ++line) {\n    const metrics2 = ctx.measureText(lines[line]);\n    const y = fontHeight * lineHeight * line;\n    minLeft = Math.min(minLeft, -metrics2.actualBoundingBoxLeft);\n    maxRight = Math.max(maxRight, metrics2.actualBoundingBoxRight);\n    minTop = Math.min(minTop, y - metrics2.actualBoundingBoxAscent);\n    maxBottom = Math.max(maxBottom, y + metrics2.actualBoundingBoxDescent);\n  }\n  const originLeft = Math.floor(minLeft);\n  const originTop = Math.floor(minTop);\n  const width = Math.ceil(maxRight) - originLeft;\n  const height = Math.ceil(maxBottom) - originTop;\n  canvas.width = width;\n  canvas.height = height;\n  ctx.font = `${fontSize}px ${font}`;\n  ctx.textAlign = textAlign;\n  ctx.textBaseline = \"alphabetic\";\n  ctx.fillStyle = \"#FFFFFF\";\n  for (let i = 0; i < lines.length; ++i) {\n    const y = fontHeight * lineHeight * i - originTop;\n    ctx.fillText(lines[i], -originLeft, y);\n  }\n  const imageData = ctx.getImageData(0, 0, width, height);\n  const rgba = new Uint8Array(imageData.data.buffer);\n  const splats = new PackedSplats();\n  const center = new THREE.Vector3();\n  const scales = new THREE.Vector3().setScalar(dotRadius * objectScale);\n  const quaternion = new THREE.Quaternion(0, 0, 0, 1);\n  rgb = rgb ?? new THREE.Color(1, 1, 1);\n  let offset = 0;\n  for (let y = 0; y < height; ++y) {\n    for (let x = 0; x < width; ++x) {\n      const a = rgba[offset + 3];\n      if (a > 0) {\n        const opacity = a / 255;\n        center.set(x - 0.5 * (width - 1), 0.5 * (height - 1) - y, 0);\n        center.multiplyScalar(objectScale);\n        splats.pushSplat(center, scales, quaternion, opacity, rgb);\n      }\n      offset += 4;\n    }\n  }\n  const mesh = new SplatMesh({ packedSplats: splats });\n  mesh.recolor = color;\n  return mesh;\n}\nfunction imageSplats({\n  // URL of the image to convert to splats (example: `url: \"./image.png\"`)\n  url,\n  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)\n  dotRadius,\n  // Subsampling factor for the image. Higher values reduce resolution,\n  // for example 2 will halve the width and height by averaging (default: 1)\n  subXY,\n  // Optional callback function to modify each Gsplat before it's added.\n  // Return null to skip adding the Gsplat, or a number to set the opacity\n  // and add the Gsplat with parameter values in the objects center, rgba etc. were\n  // passed into the forEachSplat callback. Ending the callback in `return opacity;`\n  // will retain the original opacity.\n  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)\n  forEachSplat\n}) {\n  dotRadius = dotRadius ?? 0.8;\n  subXY = Math.max(1, Math.floor(subXY ?? 1));\n  return new SplatMesh({\n    constructSplats: async (splats) => {\n      return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.onerror = reject;\n        img.onload = () => {\n          const { width, height } = img;\n          const canvas = document.createElement(\"canvas\");\n          canvas.width = width;\n          canvas.height = height;\n          const ctx = canvas.getContext(\"2d\");\n          if (!ctx) {\n            reject(new Error(\"Failed to create canvas context\"));\n            return;\n          }\n          ctx.imageSmoothingEnabled = true;\n          ctx.imageSmoothingQuality = \"high\";\n          const destWidth = Math.round(width / subXY);\n          const destHeight = Math.round(height / subXY);\n          ctx.drawImage(img, 0, 0, destWidth, destHeight);\n          try {\n            const imageData = ctx.getImageData(0, 0, destWidth, destHeight);\n            const rgba = new Uint8Array(imageData.data.buffer);\n            const center = new THREE.Vector3();\n            const scales = new THREE.Vector3().setScalar(dotRadius);\n            const quaternion = new THREE.Quaternion(0, 0, 0, 1);\n            const rgb = new THREE.Color();\n            let index = 0;\n            for (let y = 0; y < destHeight; ++y) {\n              for (let x = 0; x < destWidth; ++x) {\n                const offset = index * 4;\n                const a = rgba[offset + 3];\n                if (a > 0) {\n                  let opacity = a / 255;\n                  rgb.set(\n                    rgba[offset + 0] / 255,\n                    rgba[offset + 1] / 255,\n                    rgba[offset + 2] / 255\n                  );\n                  center.set(\n                    x - 0.5 * (destWidth - 1),\n                    0.5 * (destHeight - 1) - y,\n                    0\n                  );\n                  scales.setScalar(dotRadius);\n                  quaternion.set(0, 0, 0, 1);\n                  let push = true;\n                  if (forEachSplat) {\n                    const maybeOpacity = forEachSplat(\n                      destWidth,\n                      destHeight,\n                      index,\n                      center,\n                      scales,\n                      quaternion,\n                      opacity,\n                      rgb\n                    );\n                    opacity = maybeOpacity ?? opacity;\n                    push = maybeOpacity !== null;\n                  }\n                  if (push) {\n                    splats.pushSplat(center, scales, quaternion, opacity, rgb);\n                  }\n                }\n                index += 1;\n              }\n            }\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        };\n        img.src = url;\n      });\n    }\n  });\n}\nfunction staticBox({\n  box,\n  cells,\n  dotScale,\n  color,\n  opacity\n}) {\n  cells.x = Math.max(1, Math.round(cells.x));\n  cells.y = Math.max(1, Math.round(cells.y));\n  cells.z = Math.max(1, Math.round(cells.z));\n  opacity = opacity ?? 1;\n  const numSplats = cells.x * cells.y * cells.z;\n  const dynoX = dynoConst(\"int\", cells.x);\n  const dynoY = dynoConst(\"int\", cells.y);\n  dynoConst(\"int\", cells.z);\n  const dynoTime = dynoFloat(0);\n  const generator = new SplatGenerator({\n    numSplats,\n    generator: dynoBlock(\n      { index: \"int\" },\n      { gsplat: Gsplat },\n      ({ index }) => {\n        if (!index) {\n          throw new Error(\"index is undefined\");\n        }\n        const cellX = imod(index, dynoX);\n        const index2 = div(index, dynoX);\n        const cellY = imod(index2, dynoY);\n        const cellZ = div(index2, dynoY);\n        const cell = combine({\n          vectorType: \"ivec3\",\n          x: cellX,\n          y: cellY,\n          z: cellZ\n        });\n        const intTime = floatBitsToInt(dynoTime);\n        const inputs = combine({ vectorType: \"ivec2\", x: index, y: intTime });\n        const random = hashVec3(inputs);\n        const min2 = dynoConst(\"vec3\", box.min);\n        const max2 = dynoConst(\"vec3\", box.max);\n        const size = sub(max2, min2);\n        const coord = div(add(vec3(cell), random), dynoConst(\"vec3\", cells));\n        let r;\n        let g;\n        let b;\n        if (color) {\n          r = dynoConst(\"float\", color.r);\n          g = dynoConst(\"float\", color.g);\n          b = dynoConst(\"float\", color.b);\n        } else {\n          ({ r, g, b } = split(coord).outputs);\n        }\n        const rgba = combine({\n          vectorType: \"vec4\",\n          r,\n          g,\n          b,\n          a: dynoConst(\"float\", opacity)\n        });\n        const center = add(min2, mul(size, coord));\n        const scales = vec3(dynoConst(\"float\", dotScale));\n        const quaternion = dynoConst(\"vec4\", new THREE.Quaternion(0, 0, 0, 1));\n        let gsplat = combineGsplat({\n          flags: dynoLiteral(\"uint\", \"GSPLAT_FLAG_ACTIVE\"),\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba\n        });\n        gsplat = transformer.applyGsplat(gsplat);\n        return { gsplat };\n      },\n      {\n        globals: () => [defineGsplat]\n      }\n    ),\n    update: ({ time }) => {\n      dynoTime.value = time;\n      transformer.update(generator);\n      generator.updateVersion();\n    }\n  });\n  const transformer = new SplatTransformer();\n  return generator;\n}\nconst DEFAULT_SNOW = {\n  box: new THREE.Box3(\n    new THREE.Vector3(-1, -1, -1),\n    new THREE.Vector3(1, 1, 1)\n  ),\n  density: 100,\n  fallDirection: new THREE.Vector3(-1, -3, 1).normalize(),\n  fallVelocity: 0.02,\n  wanderScale: 0.04,\n  wanderVariance: 2,\n  color1: new THREE.Color(1, 1, 1),\n  color2: new THREE.Color(0.5, 0.5, 1),\n  minScale: 1e-3,\n  maxScale: 5e-3,\n  anisoScale: new THREE.Vector3(1, 1, 1)\n};\nconst DEFAULT_RAIN = {\n  box: new THREE.Box3(\n    new THREE.Vector3(-2, -1, -2),\n    new THREE.Vector3(2, 5, 2)\n  ),\n  density: 10,\n  fallDirection: new THREE.Vector3(0, -1, 0),\n  fallVelocity: 2,\n  wanderScale: 0.1,\n  wanderVariance: 1,\n  color1: new THREE.Color(1, 1, 1),\n  color2: new THREE.Color(0.25, 0.25, 0.5),\n  minScale: 5e-3,\n  maxScale: 0.01,\n  anisoScale: new THREE.Vector3(0.1, 1, 0.1)\n};\nfunction snowBox({\n  // min and max box extents of the snowBox\n  box,\n  // minimum y-coordinate to clamp particle position, which can be used to\n  // fake hitting a ground plane and lingering there for a bit\n  minY,\n  // number of Gsplats to generate (default: calculated from box and density)\n  numSplats,\n  // density of Gsplats per unit volume (default: 100)\n  density,\n  // The xyz anisotropic scale of the Gsplat, which can be used for example\n  // to elongate rain particles (default: (1, 1, 1))\n  anisoScale,\n  // Minimum Gsplat particle scale (default: 0.001)\n  minScale,\n  // Maximum Gsplat particle scale (default: 0.005)\n  maxScale,\n  // The average direction of fall (default: (0, -1, 0))\n  fallDirection,\n  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)\n  fallVelocity,\n  // The world scale of wandering overlay motion (default: 0.01)\n  wanderScale,\n  // Controls how uniformly the particles wander in sync, more variance mean\n  // more randomness in the motion (default: 2)\n  wanderVariance,\n  // Color 1 of the two colors interpolated between (default: (1, 1, 1))\n  color1,\n  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))\n  color2,\n  // The base opacity of the Gsplats (default: 1)\n  opacity,\n  // Optional callback function to call each frame.\n  onFrame\n}) {\n  box = box ?? new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));\n  const volume = (box.max.x - box.min.x) * (box.max.y - box.min.y) * (box.max.z - box.min.z);\n  density = density ?? 100;\n  numSplats = numSplats ?? Math.max(1, Math.min(1e6, Math.round(volume * density)));\n  const dynoMinScale = dynoFloat(minScale ?? 1e-3);\n  const dynoMaxScale = dynoFloat(maxScale ?? 5e-3);\n  const dynoAnisoScale = dynoVec3(\n    ((anisoScale == null ? void 0 : anisoScale.clone()) ?? new THREE.Vector3(1, 1, 1)).normalize()\n  );\n  const dynoFallDirection = dynoVec3(\n    (fallDirection ?? new THREE.Vector3(0, -1, 0)).normalize()\n  );\n  const dynoFallVelocity = dynoFloat(fallVelocity ?? 0.02);\n  const dynoWanderScale = dynoFloat(wanderScale ?? 0.01);\n  const dynoWanderVariance = dynoFloat(wanderVariance ?? 2);\n  const dynoColor1 = dynoVec3(color1 ?? new THREE.Color(1, 1, 1));\n  const dynoColor2 = dynoVec3(color2 ?? new THREE.Color(0.5, 0.5, 1));\n  const dynoOpacity = dynoFloat(opacity ?? 1);\n  const dynoTime = dynoFloat(0);\n  const globalOffset = dynoVec3(new THREE.Vector3(0, 0, 0));\n  const dynoMin = dynoVec3(box.min);\n  const dynoMax = dynoVec3(box.max);\n  const dynoMinY = dynoFloat(minY ?? Number.NEGATIVE_INFINITY);\n  const minMax = sub(dynoMax, dynoMin);\n  const snow = new SplatGenerator({\n    numSplats,\n    generator: dynoBlock(\n      { index: \"int\" },\n      { gsplat: Gsplat },\n      ({ index }) => {\n        if (!index) {\n          throw new Error(\"index not defined\");\n        }\n        const random = hashVec4(index);\n        const randomW = split(random).outputs.w;\n        let position = vec3(random);\n        let size = fract(mul(randomW, dynoConst(\"float\", 100)));\n        size = sin(mul(dynoLiteral(\"float\", \"PI\"), size));\n        size = add(dynoMinScale, mul(size, sub(dynoMaxScale, dynoMinScale)));\n        const scales = mul(size, dynoAnisoScale);\n        const intensity = fract(mul(randomW, dynoConst(\"float\", 10)));\n        const hue = fract(randomW);\n        const color = mix(dynoColor1, dynoColor2, hue);\n        const rgb = mul(color, intensity);\n        const random2 = hashVec4(\n          combine({\n            vectorType: \"ivec2\",\n            x: index,\n            y: dynoConst(\"int\", 6837)\n          })\n        );\n        let perturb = vec3(random2);\n        let timeOffset = mul(split(random2).outputs.w, dynoWanderVariance);\n        timeOffset = add(dynoTime, timeOffset);\n        position = add(position, globalOffset);\n        const modulo = mod(\n          position,\n          dynoConst(\"vec3\", new THREE.Vector3(1, 1, 1))\n        );\n        position = add(dynoMin, mul(minMax, modulo));\n        const quaternion = dynoConst(\"vec4\", new THREE.Quaternion(0, 0, 0, 1));\n        perturb = sin(add(vec3(timeOffset), perturb));\n        perturb = mul(perturb, dynoWanderScale);\n        let center = add(position, perturb);\n        let centerY = split(center).outputs.y;\n        centerY = max(dynoMinY, centerY);\n        center = combine({ vector: center, y: centerY });\n        let gsplat = combineGsplat({\n          flags: dynoLiteral(\"uint\", \"GSPLAT_FLAG_ACTIVE\"),\n          index,\n          center,\n          scales,\n          quaternion,\n          rgb,\n          opacity: dynoOpacity\n        });\n        gsplat = transformer.applyGsplat(gsplat);\n        return { gsplat };\n      },\n      {\n        globals: () => [defineGsplat]\n      }\n    ),\n    update: ({ object, time, deltaTime }) => {\n      dynoTime.value = time;\n      transformer.update(snow);\n      const fallDelta = dynoFallDirection.value.clone().multiplyScalar(dynoFallVelocity.value * deltaTime);\n      globalOffset.value.add(fallDelta);\n      object.visible = dynoOpacity.value > 0;\n      onFrame == null ? void 0 : onFrame({ object, time, deltaTime });\n      snow.updateVersion();\n    }\n  });\n  const transformer = new SplatTransformer();\n  return {\n    snow,\n    min: dynoMin,\n    max: dynoMax,\n    minY: dynoMinY,\n    color1: dynoColor1,\n    color2: dynoColor2,\n    opacity: dynoOpacity,\n    fallVelocity: dynoFallVelocity,\n    wanderVariance: dynoWanderVariance,\n    wanderScale: dynoWanderScale,\n    fallDirection: dynoFallDirection,\n    minScale: dynoMinScale,\n    maxScale: dynoMaxScale,\n    anisoScale: dynoAnisoScale\n  };\n}\nconst generators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  DEFAULT_RAIN,\n  DEFAULT_SNOW,\n  snowBox,\n  staticBox\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction makeNormalColorModifier(splatToView) {\n  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {\n    if (!gsplat) {\n      throw new Error(\"No gsplat input\");\n    }\n    let normal = gsplatNormal(gsplat);\n    const viewGsplat = splatToView.applyGsplat(gsplat);\n    const viewCenter = splitGsplat(viewGsplat).outputs.center;\n    const viewNormal = gsplatNormal(viewGsplat);\n    const splatDot = dot(viewCenter, viewNormal);\n    const sameDir = greaterThanEqual(splatDot, dynoConst(\"float\", 0));\n    normal = select(sameDir, neg(normal), normal);\n    const rgb = add(\n      mul(normal, dynoConst(\"float\", 0.5)),\n      dynoConst(\"float\", 0.5)\n    );\n    gsplat = combineGsplat({ gsplat, rgb });\n    return { gsplat };\n  });\n}\nfunction setWorldNormalColor(splats) {\n  splats.enableWorldToView = true;\n  splats.worldModifier = makeNormalColorModifier(splats.context.worldToView);\n  splats.updateGenerator();\n}\nfunction makeDepthColorModifier(splatToView, minDepth, maxDepth, reverse) {\n  return dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {\n    if (!gsplat) {\n      throw new Error(\"No gsplat input\");\n    }\n    let { center } = splitGsplat(gsplat).outputs;\n    center = splatToView.apply(center);\n    const { z } = split(center).outputs;\n    let depth = normalizedDepth(neg(z), minDepth, maxDepth);\n    depth = select(reverse, sub(dynoConst(\"float\", 1), depth), depth);\n    gsplat = combineGsplat({ gsplat, r: depth, g: depth, b: depth });\n    return { gsplat };\n  });\n}\nfunction setDepthColor(splats, minDepth, maxDepth, reverse) {\n  splats.enableWorldToView = true;\n  const dynoMinDepth = dynoConst(\"float\", minDepth);\n  const dynoMaxDepth = dynoConst(\"float\", maxDepth);\n  const dynoReverse = dynoConst(\"bool\", reverse ?? false);\n  splats.worldModifier = makeDepthColorModifier(\n    splats.context.worldToView,\n    dynoMinDepth,\n    dynoMaxDepth,\n    dynoReverse\n  );\n  splats.updateGenerator();\n  return {\n    minDepth: dynoMinDepth,\n    maxDepth: dynoMaxDepth,\n    reverse: dynoReverse\n  };\n}\nconst modifiers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  makeDepthColorModifier,\n  makeNormalColorModifier,\n  setDepthColor,\n  setWorldNormalColor\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst _VRButton = class _VRButton {\n  static createButton(renderer, sessionInit = {}) {\n    const navigatorXr = navigator.xr;\n    if (!navigatorXr) {\n      return null;\n    }\n    const xr = navigatorXr;\n    const button = document.createElement(\"button\");\n    renderer.xr.enabled = true;\n    renderer.xr.setReferenceSpaceType(\"local\");\n    function showEnterVR() {\n      let currentSession = null;\n      async function onSessionStarted(session) {\n        console.log(\"onSessionStarted\");\n        session.addEventListener(\"end\", onSessionEnded);\n        await renderer.xr.setSession(session);\n        button.textContent = \"EXIT VR\";\n        currentSession = session;\n      }\n      function onSessionEnded() {\n        console.log(\"onSessionEnded\");\n        currentSession == null ? void 0 : currentSession.removeEventListener(\"end\", onSessionEnded);\n        button.textContent = \"ENTER VR\";\n        currentSession = null;\n      }\n      button.style.display = \"\";\n      button.style.cursor = \"pointer\";\n      button.style.left = \"calc(50% - 100px)\";\n      button.style.width = \"200px\";\n      button.style.height = \"100px\";\n      button.textContent = \"ENTER VR\";\n      const sessionOptions = {\n        ...sessionInit,\n        optionalFeatures: [\n          // \"local-floor\",\n          // \"bounded-floor\",\n          // \"layers\",\n          ...sessionInit.optionalFeatures || []\n        ]\n      };\n      button.onmouseenter = () => {\n        button.style.opacity = \"1.0\";\n      };\n      button.onmouseleave = () => {\n        button.style.opacity = \"0.5\";\n      };\n      button.onclick = () => {\n        if (currentSession === null) {\n          console.log(\"requesting session\");\n          xr.requestSession(\"immersive-vr\", sessionOptions).then(\n            onSessionStarted\n          );\n        } else {\n          console.log(\"ending session\");\n          currentSession.end();\n        }\n      };\n    }\n    function disableButton() {\n      button.style.display = \"none\";\n      button.style.cursor = \"auto\";\n      button.style.left = \"calc(50% - 75px)\";\n      button.style.width = \"150px\";\n      button.onmouseenter = null;\n      button.onmouseleave = null;\n      button.onclick = null;\n    }\n    function showWebXRNotFound() {\n      disableButton();\n      button.textContent = \"VR NOT SUPPORTED\";\n    }\n    function showVRNotAllowed(exception) {\n      disableButton();\n      console.warn(\n        \"Exception when trying to call xr.isSessionSupported\",\n        exception\n      );\n      button.textContent = \"VR NOT ALLOWED\";\n    }\n    function stylizeElement(element) {\n      element.style.position = \"absolute\";\n      element.style.bottom = \"20px\";\n      element.style.padding = \"12px 6px\";\n      element.style.border = \"1px solid #fff\";\n      element.style.borderRadius = \"4px\";\n      element.style.background = \"rgba(0,0,0,0.1)\";\n      element.style.color = \"#fff\";\n      element.style.font = \"normal 13px sans-serif\";\n      element.style.textAlign = \"center\";\n      element.style.opacity = \"0.5\";\n      element.style.outline = \"none\";\n      element.style.zIndex = \"999\";\n    }\n    button.id = \"VRButton\";\n    button.style.display = \"none\";\n    stylizeElement(button);\n    xr.isSessionSupported(\"immersive-vr\").then((supported) => {\n      supported ? showEnterVR() : showWebXRNotFound();\n      if (supported && _VRButton.xrSessionIsGranted) {\n        button.click();\n      }\n    }).catch(showVRNotAllowed);\n    return button;\n  }\n  static registerSessionGrantedListener() {\n    const navigatorXr = navigator.xr;\n    if (!navigatorXr) {\n      return null;\n    }\n    const xr = navigatorXr;\n    if (/WebXRViewer\\//i.test(navigator.userAgent)) return;\n    xr.addEventListener(\"sessiongranted\", () => {\n      _VRButton.xrSessionIsGranted = true;\n    });\n  }\n};\n_VRButton.xrSessionIsGranted = false;\nlet VRButton = _VRButton;\nVRButton.registerSessionGrantedListener();\nconst DEFAULT_MOVE_INERTIA$1 = 0.5;\nconst DEFAULT_ROTATE_INERTIA$1 = 0.5;\nconst TOUCH_BIAS = 0;\nvar JointEnum = /* @__PURE__ */ ((JointEnum2) => {\n  JointEnum2[\"w\"] = \"wrist\";\n  JointEnum2[\"t0\"] = \"thumb-metacarpal\";\n  JointEnum2[\"t1\"] = \"thumb-phalanx-proximal\";\n  JointEnum2[\"t2\"] = \"thumb-phalanx-distal\";\n  JointEnum2[\"t3\"] = \"thumb-tip\";\n  JointEnum2[\"i0\"] = \"index-finger-metacarpal\";\n  JointEnum2[\"i1\"] = \"index-finger-phalanx-proximal\";\n  JointEnum2[\"i2\"] = \"index-finger-phalanx-intermediate\";\n  JointEnum2[\"i3\"] = \"index-finger-phalanx-distal\";\n  JointEnum2[\"i4\"] = \"index-finger-tip\";\n  JointEnum2[\"m0\"] = \"middle-finger-metacarpal\";\n  JointEnum2[\"m1\"] = \"middle-finger-phalanx-proximal\";\n  JointEnum2[\"m2\"] = \"middle-finger-phalanx-intermediate\";\n  JointEnum2[\"m3\"] = \"middle-finger-phalanx-distal\";\n  JointEnum2[\"m4\"] = \"middle-finger-tip\";\n  JointEnum2[\"r0\"] = \"ring-finger-metacarpal\";\n  JointEnum2[\"r1\"] = \"ring-finger-phalanx-proximal\";\n  JointEnum2[\"r2\"] = \"ring-finger-phalanx-intermediate\";\n  JointEnum2[\"r3\"] = \"ring-finger-phalanx-distal\";\n  JointEnum2[\"r4\"] = \"ring-finger-tip\";\n  JointEnum2[\"p0\"] = \"pinky-finger-metacarpal\";\n  JointEnum2[\"p1\"] = \"pinky-finger-phalanx-proximal\";\n  JointEnum2[\"p2\"] = \"pinky-finger-phalanx-intermediate\";\n  JointEnum2[\"p3\"] = \"pinky-finger-phalanx-distal\";\n  JointEnum2[\"p4\"] = \"pinky-finger-tip\";\n  return JointEnum2;\n})(JointEnum || {});\nconst JOINT_IDS = Object.keys(JointEnum);\nconst NUM_JOINTS = JOINT_IDS.length;\nconst JOINT_INDEX = {\n  w: 0,\n  t0: 1,\n  t1: 2,\n  t2: 3,\n  t3: 4,\n  i0: 5,\n  i1: 6,\n  i2: 7,\n  i3: 8,\n  i4: 9,\n  m0: 10,\n  m1: 11,\n  m2: 12,\n  m3: 13,\n  m4: 14,\n  r0: 15,\n  r1: 16,\n  r2: 17,\n  r3: 18,\n  r4: 19,\n  p0: 20,\n  p1: 21,\n  p2: 22,\n  p3: 23,\n  p4: 24\n};\nconst JOINT_RADIUS = {\n  w: 0.02,\n  t0: 0.02,\n  t1: 0.014,\n  t2: 0.0115,\n  t3: 85e-4,\n  i0: 0.022,\n  i1: 0.012,\n  i2: 85e-4,\n  i3: 75e-4,\n  i4: 65e-4,\n  m0: 0.021,\n  m1: 0.012,\n  m2: 8e-3,\n  m3: 75e-4,\n  m4: 65e-4,\n  r0: 0.019,\n  r1: 0.011,\n  r2: 75e-4,\n  r3: 7e-3,\n  r4: 6e-3,\n  p0: 0.012,\n  p1: 0.01,\n  p2: 7e-3,\n  p3: 65e-4,\n  p4: 55e-4\n};\nconst JOINT_SEGMENTS = [\n  [\"w\", \"t0\", \"t1\", \"t2\", \"t3\"],\n  [\"w\", \"i0\", \"i1\", \"i2\", \"i3\", \"i4\"],\n  [\"w\", \"m0\", \"m1\", \"m2\", \"m3\", \"m4\"],\n  [\"w\", \"r0\", \"r1\", \"r2\", \"r3\", \"r4\"],\n  [\"w\", \"p0\", \"p1\", \"p2\", \"p3\", \"p4\"]\n];\nconst JOINT_SEGMENT_STEPS = [\n  [8, 10, 8, 6],\n  [8, 19, 14, 8, 6],\n  [8, 19, 14, 8, 6],\n  [8, 19, 14, 8, 6],\n  [8, 19, 14, 8, 6]\n];\nconst JOINT_TIPS = [\"t3\", \"i4\", \"m4\", \"r4\", \"p4\"];\nconst FINGER_TIPS = [\"i4\", \"m4\", \"r4\", \"p4\"];\nvar Hand = /* @__PURE__ */ ((Hand2) => {\n  Hand2[\"left\"] = \"left\";\n  Hand2[\"right\"] = \"right\";\n  return Hand2;\n})(Hand || {});\nconst HANDS = Object.keys(Hand);\nclass XrHands {\n  constructor() {\n    this.hands = {};\n    this.last = {};\n    this.values = {};\n    this.tests = {};\n    this.lastTests = {};\n    this.updated = false;\n  }\n  update({ xr, xrFrame }) {\n    const xrSession = xr.getSession();\n    if (!xrSession) {\n      return;\n    }\n    const referenceSpace = xr.getReferenceSpace();\n    if (!referenceSpace) {\n      return;\n    }\n    if (!xrFrame.getJointPose) {\n      return;\n    }\n    this.last = this.hands;\n    this.lastTests = this.tests;\n    this.hands = {};\n    this.values = {};\n    this.tests = {};\n    for (const inputSource of xrSession.inputSources) {\n      if (!inputSource.hand) {\n        continue;\n      }\n      const hand = inputSource.handedness;\n      this.hands[hand] = {};\n      for (const jointId of JOINT_IDS) {\n        const jointSpace = inputSource.hand.get(JointEnum[jointId]);\n        if (jointSpace) {\n          const jointPose = xrFrame.getJointPose(jointSpace, referenceSpace);\n          if (jointPose) {\n            const { position, orientation } = jointPose.transform;\n            this.hands[hand][jointId] = {\n              position: new Vector3(position.x, position.y, position.z),\n              quaternion: new Quaternion(\n                orientation.x,\n                orientation.y,\n                orientation.z,\n                orientation.w\n              ),\n              radius: jointPose.radius || 1e-3\n            };\n          }\n        }\n      }\n    }\n    for (const hand of HANDS) {\n      for (const { key, value } of [\n        { key: `${hand}AllTips`, value: this.allTipsTouching(hand) },\n        {\n          key: `${hand}IndexThumb`,\n          value: this.touching(hand, \"i4\", hand, \"t3\")\n        },\n        {\n          key: `${hand}MiddleThumb`,\n          value: this.touching(hand, \"m4\", hand, \"t3\")\n        },\n        {\n          key: `${hand}RingThumb`,\n          value: this.touching(hand, \"r4\", hand, \"t3\")\n        },\n        {\n          key: `${hand}PinkyThumb`,\n          value: this.touching(hand, \"p4\", hand, \"t3\")\n        },\n        { key: `${hand}TriTips`, value: this.triTipsTouching(hand) }\n      ]) {\n        this.values[key] = value;\n        this.tests[key] = value === 1 ? true : value === 0 ? false : this.lastTests[key] ?? false;\n      }\n    }\n  }\n  makeGhostMesh() {\n    const center = new Vector3();\n    const scales = new Vector3(0.01, 0.01, 0.01);\n    const quaternion = new Quaternion(0, 0, 0, 1);\n    const color = new Color(1, 1, 1);\n    const CYCLE = Math.PI * 3;\n    new Color(1, 1, 1);\n    let opacity = 1;\n    const mesh = new SplatMesh({\n      onFrame: () => {\n        let splatIndex = 0;\n        for (const handedness of HANDS) {\n          const xrHand = this.hands[handedness];\n          for (const [index, segment] of JOINT_SEGMENTS.entries()) {\n            for (let i = 1; i < segment.length; ++i) {\n              const segmentSplats = JOINT_SEGMENT_STEPS[index][i - 1] * 2;\n              const lastSegment = i + 1 === segment.length;\n              const jointA = xrHand == null ? void 0 : xrHand[segment[i - 1]];\n              const jointB = xrHand == null ? void 0 : xrHand[segment[i]];\n              for (let j = 0; j < segmentSplats; ++j) {\n                const t = (j + 0.5) / segmentSplats;\n                opacity = 0;\n                if (jointA && jointB) {\n                  center.copy(jointA.position).lerp(jointB.position, t);\n                  quaternion.copy(jointA.quaternion).slerp(jointB.quaternion, t);\n                  const radiusA = JOINT_RADIUS[segment[i - 1]];\n                  const radiusB = JOINT_RADIUS[segment[i]];\n                  let radius = (1 - t) * radiusA + t * radiusB;\n                  if (lastSegment && t > 0.8) {\n                    radius *= Math.sqrt(1 - ((t - 0.8) / 0.2) ** 2);\n                  }\n                  scales.set(0.65 * radius, 0.5 * radius, 3e-3);\n                  color.set(\n                    0.55 + 0.45 * Math.sin(center.x * CYCLE),\n                    0.55 + 0.45 * Math.sin(center.y * CYCLE),\n                    0.55 + 0.45 * Math.sin(center.z * CYCLE)\n                  );\n                  if (handedness === \"right\") {\n                    color.set(1 - color.r, 1 - color.g, 1 - color.b);\n                  }\n                  opacity = 0.75;\n                }\n                mesh.packedSplats.setSplat(\n                  splatIndex,\n                  center,\n                  scales,\n                  quaternion,\n                  opacity,\n                  color\n                );\n                splatIndex += 1;\n              }\n            }\n          }\n        }\n        mesh.packedSplats.numSplats = splatIndex;\n        mesh.packedSplats.needsUpdate = true;\n        mesh.numSplats = splatIndex;\n        mesh.updateVersion();\n      }\n    });\n    return mesh;\n  }\n  distance(handA, jointA, handB, jointB, last = false) {\n    const hA = last ? this.last[handA] : this.hands[handA];\n    const hB = last ? this.last[handB] : this.hands[handB];\n    const jA = hA == null ? void 0 : hA[jointA];\n    const jB = hB == null ? void 0 : hB[jointB];\n    if (!jA || !jB) {\n      return Number.POSITIVE_INFINITY;\n    }\n    return jA.position.distanceTo(jB.position);\n  }\n  separation(handA, jointA, handB, jointB, last = false) {\n    const d = this.distance(handA, jointA, handB, jointB, last);\n    if (d === Number.POSITIVE_INFINITY) {\n      return Number.POSITIVE_INFINITY;\n    }\n    return d - JOINT_RADIUS[jointA] - JOINT_RADIUS[jointB];\n  }\n  touching(handA, jointA, handB, jointB, last = false) {\n    const d = this.separation(handA, jointA, handB, jointB, last);\n    if (d === Number.POSITIVE_INFINITY) {\n      return Number.POSITIVE_INFINITY;\n    }\n    return 1 - Math.max(0, Math.min(1, d / 0.01 - TOUCH_BIAS));\n  }\n  allTipsTouching(hand, last = false) {\n    return Math.min(\n      this.touching(hand, \"t3\", hand, \"i4\", last),\n      this.touching(hand, \"i4\", hand, \"m4\", last),\n      this.touching(hand, \"m4\", hand, \"r4\", last),\n      this.touching(hand, \"r4\", hand, \"p4\", last)\n      // this.touching(hand, \"p4\", hand, \"t3\", last),\n    );\n  }\n  triTipsTouching(hand, last = false) {\n    return Math.min(\n      this.touching(hand, \"t3\", hand, \"i4\", last),\n      this.touching(hand, \"i4\", hand, \"m4\", last),\n      this.touching(hand, \"m4\", hand, \"t3\", last)\n    );\n  }\n}\nclass HandMovement {\n  constructor({\n    xrHands,\n    control,\n    moveInertia,\n    rotateInertia\n  }) {\n    this.lastGrip = {};\n    this.lastPivot = new Vector3();\n    this.rotateVelocity = 0;\n    this.velocity = new Vector3();\n    this.xrHands = xrHands;\n    this.control = control;\n    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA$1;\n    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA$1;\n  }\n  update(deltaTime) {\n    var _a2, _b2, _c, _d, _e;\n    const grip = {};\n    for (const handedness of HANDS) {\n      const hand = this.xrHands.hands[handedness];\n      if (hand && this.xrHands.tests[`${handedness}MiddleThumb`]) {\n        grip[handedness] = new Vector3().add(((_a2 = hand.t3) == null ? void 0 : _a2.position) ?? new Vector3()).add(((_b2 = hand.i4) == null ? void 0 : _b2.position) ?? new Vector3()).add(((_c = hand.m4) == null ? void 0 : _c.position) ?? new Vector3()).add(((_d = hand.r4) == null ? void 0 : _d.position) ?? new Vector3()).add(((_e = hand.p4) == null ? void 0 : _e.position) ?? new Vector3()).multiplyScalar(1 / 5);\n      }\n    }\n    if (grip.left && grip.right && this.lastGrip.left && this.lastGrip.right) {\n      const mid = grip.left.clone().add(grip.right).multiplyScalar(0.5);\n      const lastMid = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);\n      this.lastPivot = mid;\n      const delta = mid.clone().applyMatrix4(this.control.matrix);\n      delta.sub(lastMid.clone().applyMatrix4(this.control.matrix));\n      delta.multiplyScalar(1 / deltaTime);\n      this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\n      const angle = Math.atan2(grip.left.z - mid.z, grip.left.x - mid.x);\n      const lastAngle = Math.atan2(\n        this.lastGrip.left.z - lastMid.z,\n        this.lastGrip.left.x - lastMid.x\n      );\n      let closestAngle = angle - lastAngle;\n      if (closestAngle > Math.PI) {\n        closestAngle -= Math.PI * 2;\n      } else if (closestAngle < -Math.PI) {\n        closestAngle += Math.PI * 2;\n      }\n      const rotateVelocity = closestAngle / deltaTime;\n      const blend = Math.exp(-20 * deltaTime);\n      this.rotateVelocity = this.rotateVelocity * blend + rotateVelocity * (1 - blend);\n    } else {\n      this.rotateVelocity *= Math.exp(-deltaTime / this.rotateInertia);\n      if (grip.left && this.lastGrip.left) {\n        const delta = grip.left.clone().applyMatrix4(this.control.matrix);\n        delta.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix));\n        delta.multiplyScalar(1 / deltaTime);\n        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\n      } else if (grip.right && this.lastGrip.right) {\n        const delta = grip.right.clone().applyMatrix4(this.control.matrix);\n        delta.sub(\n          this.lastGrip.right.clone().applyMatrix4(this.control.matrix)\n        );\n        delta.multiplyScalar(1 / deltaTime);\n        this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\n      } else {\n        this.velocity.multiplyScalar(Math.exp(-deltaTime / this.moveInertia));\n      }\n    }\n    const negPivot = this.lastPivot.clone().negate();\n    const rotate = new Matrix4().makeTranslation(negPivot).premultiply(new Matrix4().makeRotationY(this.rotateVelocity * deltaTime)).premultiply(new Matrix4().makeTranslation(this.lastPivot));\n    this.control.matrix.multiply(rotate);\n    this.control.matrix.decompose(\n      this.control.position,\n      this.control.quaternion,\n      this.control.scale\n    );\n    this.control.updateMatrixWorld(true);\n    this.control.position.sub(this.velocity.clone().multiplyScalar(deltaTime));\n    this.lastGrip = grip;\n  }\n}\nconst DEFAULT_MOVEMENT_SPEED = 1;\nconst DEFAULT_ROLL_SPEED = 2;\nconst DEFAULT_ROTATE_SPEED = 2e-3;\nconst DEFAULT_SLIDE_SPEED = 6e-3;\nconst DEFAULT_SCROLL_SPEED = 15e-4;\nconst DEFAULT_ROTATE_INERTIA = 0.15;\nconst DEFAULT_MOVE_INERTIA = 0.15;\nconst DEFAULT_STICK_THRESHOLD = 0.1;\nconst DEFAULT_FPS_ROTATE_SPEED = 2;\nconst DEFAULT_POINTER_ROLL_SCALE = 1;\nconst DUAL_PRESS_MS = 200;\nconst DOUBLE_PRESS_LIMIT_MS = 400;\nconst DOUBLE_PRESS_DISTANCE = 50;\nconst WASD_KEYCODE_MOVE = {\n  KeyW: new THREE.Vector3(0, 0, -1),\n  KeyS: new THREE.Vector3(0, 0, 1),\n  KeyA: new THREE.Vector3(-1, 0, 0),\n  KeyD: new THREE.Vector3(1, 0, 0),\n  KeyR: new THREE.Vector3(0, 1, 0),\n  KeyF: new THREE.Vector3(0, -1, 0)\n};\nconst ARROW_KEYCODE_MOVE = {\n  ArrowUp: new THREE.Vector3(0, 0, -1),\n  ArrowDown: new THREE.Vector3(0, 0, 1),\n  ArrowLeft: new THREE.Vector3(-1, 0, 0),\n  ArrowRight: new THREE.Vector3(1, 0, 0),\n  PageUp: new THREE.Vector3(0, 1, 0),\n  PageDown: new THREE.Vector3(0, -1, 0)\n};\nconst QE_KEYCODE_ROTATE = {\n  KeyQ: new THREE.Vector3(0, 0, 1),\n  KeyE: new THREE.Vector3(0, 0, -1)\n};\nconst ARROW_KEYCODE_ROTATE = {\n  Home: new THREE.Vector3(0, -1, 0),\n  End: new THREE.Vector3(0, 1, 0),\n  Insert: new THREE.Vector3(-1, 0, 0),\n  Delete: new THREE.Vector3(1, 0, 0)\n};\nclass SparkControls {\n  constructor({ canvas }) {\n    this.lastTime = 0;\n    this.fpsMovement = new FpsMovement({});\n    this.pointerControls = new PointerControls({ canvas });\n  }\n  update(control) {\n    const time = performance.now();\n    const deltaTime = (time - (this.lastTime || time)) / 1e3;\n    this.lastTime = time;\n    this.fpsMovement.update(deltaTime, control);\n    this.pointerControls.update(deltaTime, control);\n  }\n}\nclass FpsMovement {\n  constructor({\n    moveSpeed,\n    rollSpeed,\n    stickThreshold,\n    rotateSpeed,\n    keycodeMoveMapping,\n    keycodeRotateMapping,\n    gamepadMapping,\n    capsMultiplier,\n    shiftMultiplier,\n    ctrlMultiplier,\n    xr\n  } = {}) {\n    this.enable = true;\n    this.moveSpeed = moveSpeed ?? DEFAULT_MOVEMENT_SPEED;\n    this.rollSpeed = rollSpeed ?? DEFAULT_ROLL_SPEED;\n    this.stickThreshold = stickThreshold ?? DEFAULT_STICK_THRESHOLD;\n    this.rotateSpeed = rotateSpeed ?? DEFAULT_FPS_ROTATE_SPEED;\n    this.keycodeMoveMapping = keycodeMoveMapping ?? {\n      ...WASD_KEYCODE_MOVE,\n      ...ARROW_KEYCODE_MOVE\n    };\n    this.keycodeRotateMapping = keycodeRotateMapping ?? {\n      ...QE_KEYCODE_ROTATE,\n      ...ARROW_KEYCODE_ROTATE\n    };\n    this.gamepadMapping = gamepadMapping ?? {\n      4: \"rollLeft\",\n      5: \"rollRight\",\n      6: \"ctrl\",\n      7: \"shift\"\n    };\n    this.capsMultiplier = capsMultiplier ?? 10;\n    this.shiftMultiplier = shiftMultiplier ?? 5;\n    this.ctrlMultiplier = ctrlMultiplier ?? 1 / 5;\n    this.xr = xr;\n    this.keydown = {};\n    this.keycode = {};\n    document.addEventListener(\"keydown\", (event) => {\n      this.keydown[event.key] = true;\n      this.keycode[event.code] = true;\n    });\n    document.addEventListener(\"keyup\", (event) => {\n      this.keydown[event.key] = false;\n      this.keycode[event.code] = false;\n    });\n    window.addEventListener(\"blur\", () => {\n      this.keydown = {};\n      this.keycode = {};\n    });\n  }\n  // Call this method in your render loop with `control` set to the object to control\n  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`\n  // in seconds since the last update.\n  update(deltaTime, control) {\n    var _a2, _b2;\n    if (!this.enable) {\n      return;\n    }\n    const sticks = [new THREE.Vector2(), new THREE.Vector2()];\n    const gamepad = navigator.getGamepads()[0];\n    if (gamepad) {\n      sticks[0].set(gamepad.axes[0], gamepad.axes[1]);\n      sticks[1].set(gamepad.axes[2], gamepad.axes[3]);\n    }\n    const gamepadButtons = (gamepad == null ? void 0 : gamepad.buttons.map((button) => button.pressed)) || [];\n    const xrSources = Array.from(((_b2 = (_a2 = this.xr) == null ? void 0 : _a2.getSession()) == null ? void 0 : _b2.inputSources) ?? []);\n    for (const source of xrSources) {\n      const gamepad2 = source.gamepad;\n      if (gamepad2) {\n        switch (source.handedness) {\n          case \"none\": {\n            sticks[0].x += gamepad2.axes[0];\n            sticks[0].y += gamepad2.axes[1];\n            sticks[1].x += gamepad2.axes[2];\n            sticks[1].y += gamepad2.axes[3];\n            break;\n          }\n          case \"left\": {\n            sticks[0].x += gamepad2.axes[2];\n            sticks[0].y += gamepad2.axes[3];\n            break;\n          }\n          case \"right\": {\n            sticks[1].x += gamepad2.axes[2];\n            sticks[1].y += gamepad2.axes[3];\n            break;\n          }\n        }\n      }\n    }\n    for (const stick of sticks) {\n      stick.x = Math.abs(stick.x) >= this.stickThreshold ? stick.x : 0;\n      stick.y = Math.abs(stick.y) >= this.stickThreshold ? stick.y : 0;\n    }\n    const rotate = new THREE.Vector3(\n      sticks[1].x,\n      sticks[1].y,\n      0\n    ).multiplyScalar(this.rotateSpeed);\n    for (const [keycode, rot] of Object.entries(this.keycodeRotateMapping)) {\n      if (this.keycode[keycode]) {\n        rotate.add(rot);\n      }\n    }\n    for (const button in this.gamepadMapping) {\n      if (gamepadButtons[Number.parseInt(button)]) {\n        switch (this.gamepadMapping[button]) {\n          case \"rollLeft\":\n            rotate.z += 1;\n            break;\n          case \"rollRight\":\n            rotate.z -= 1;\n            break;\n        }\n      }\n    }\n    rotate.multiply(\n      new THREE.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)\n    );\n    if (rotate.manhattanLength() > 0) {\n      rotate.multiplyScalar(deltaTime);\n      const eulers = new THREE.Euler().setFromQuaternion(\n        control.quaternion,\n        \"YXZ\"\n      );\n      eulers.y -= rotate.x;\n      eulers.x = Math.max(\n        -Math.PI / 2,\n        Math.min(Math.PI / 2, eulers.x - rotate.y)\n      );\n      eulers.z = Math.max(-Math.PI, Math.min(Math.PI, eulers.z + rotate.z));\n      control.quaternion.setFromEuler(eulers);\n    }\n    const moveVector = new THREE.Vector3(sticks[0].x, 0, sticks[0].y);\n    for (const [keycode, move] of Object.entries(this.keycodeMoveMapping)) {\n      if (this.keycode[keycode]) {\n        moveVector.add(move);\n      }\n    }\n    let speedMultiplier = 1;\n    if (this.keydown.CapsLock) {\n      speedMultiplier *= this.capsMultiplier;\n    }\n    if (this.keycode.ShiftLeft || this.keycode.ShiftRight) {\n      speedMultiplier *= this.shiftMultiplier;\n    }\n    if (this.keycode.ControlLeft || this.keycode.ControlRight) {\n      speedMultiplier *= this.ctrlMultiplier;\n    }\n    for (const button in this.gamepadMapping) {\n      if (gamepadButtons[Number.parseInt(button)]) {\n        switch (this.gamepadMapping[button]) {\n          case \"shift\":\n            speedMultiplier *= this.shiftMultiplier;\n            break;\n          case \"ctrl\":\n            speedMultiplier *= this.ctrlMultiplier;\n            break;\n        }\n      }\n    }\n    moveVector.applyQuaternion(control.quaternion);\n    control.position.add(\n      moveVector.multiplyScalar(this.moveSpeed * speedMultiplier * deltaTime)\n    );\n  }\n}\nclass PointerControls {\n  constructor({\n    // The HTML canvas element to attach pointer events to\n    canvas,\n    // Speed of rotation (default DEFAULT_ROTATE_SPEED)\n    rotateSpeed,\n    // Speed of sliding when dragging with right/middle mouse button or two fingers\n    // (default DEFAULT_SLIDE_SPEED)\n    slideSpeed,\n    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)\n    scrollSpeed,\n    // Swap the direction of rotation and sliding (default: false)\n    swapRotateSlide,\n    // Reverse the direction of rotation (default: false)\n    reverseRotate,\n    // Reverse the direction of sliding (default: false)\n    reverseSlide,\n    // Reverse the direction of swipe gestures (default: false)\n    reverseSwipe,\n    // Reverse the direction of scroll wheel movement (default: false)\n    reverseScroll,\n    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)\n    moveInertia,\n    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)\n    rotateInertia,\n    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)\n    pointerRollScale,\n    // Callback for double press events (default: () => {})\n    doublePress\n  }) {\n    this.enable = true;\n    this.canvas = canvas;\n    this.rotateSpeed = rotateSpeed ?? DEFAULT_ROTATE_SPEED;\n    this.slideSpeed = slideSpeed ?? DEFAULT_SLIDE_SPEED;\n    this.scrollSpeed = scrollSpeed ?? DEFAULT_SCROLL_SPEED;\n    this.swapRotateSlide = swapRotateSlide ?? false;\n    this.reverseRotate = reverseRotate ?? false;\n    this.reverseSlide = reverseSlide ?? false;\n    this.reverseSwipe = reverseSwipe ?? false;\n    this.reverseScroll = reverseScroll ?? false;\n    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA;\n    this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA;\n    this.pointerRollScale = pointerRollScale ?? DEFAULT_POINTER_ROLL_SCALE;\n    this.doublePress = doublePress ?? (() => {\n    });\n    this.doublePressLimitMs = DOUBLE_PRESS_LIMIT_MS;\n    this.doublePressDistance = DOUBLE_PRESS_DISTANCE;\n    this.lastUp = null;\n    this.rotating = null;\n    this.sliding = null;\n    this.dualPress = false;\n    this.scroll = new THREE.Vector3();\n    this.rotateVelocity = new THREE.Vector3();\n    this.moveVelocity = new THREE.Vector3();\n    canvas.addEventListener(\"pointerdown\", (event) => {\n      const position = this.getPointerPosition(event);\n      const initial = position.clone();\n      const last = position.clone();\n      const isRotate = !this.swapRotateSlide && !this.rotating && (event.pointerType !== \"mouse\" || event.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (event.pointerType !== \"mouse\" || event.button === 1);\n      const { pointerId, timeStamp } = event;\n      if (isRotate) {\n        this.rotating = { initial, last, position, pointerId, timeStamp };\n        canvas.setPointerCapture(event.pointerId);\n        this.dualPress = false;\n      } else if (!this.sliding) {\n        const button = event.pointerType === \"mouse\" ? event.button : void 0;\n        this.sliding = {\n          initial,\n          last,\n          position,\n          pointerId,\n          button,\n          timeStamp\n        };\n        canvas.setPointerCapture(event.pointerId);\n        this.dualPress = this.rotating != null && timeStamp - this.rotating.timeStamp < DUAL_PRESS_MS;\n      }\n    });\n    const pointerUp = (event) => {\n      var _a2, _b2;\n      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === event.pointerId) {\n        this.rotating = null;\n        canvas.releasePointerCapture(event.pointerId);\n        if (this.dualPress && this.sliding) {\n          canvas.releasePointerCapture(this.sliding.pointerId);\n          this.sliding = null;\n        }\n      } else if (((_b2 = this.sliding) == null ? void 0 : _b2.pointerId) === event.pointerId) {\n        this.sliding = null;\n        canvas.releasePointerCapture(event.pointerId);\n        if (this.dualPress && this.rotating) {\n          canvas.releasePointerCapture(this.rotating.pointerId);\n          this.rotating = null;\n        }\n      }\n      const position = this.getPointerPosition(event);\n      const lastUp = this.lastUp;\n      this.lastUp = { position, time: event.timeStamp };\n      if (lastUp) {\n        const distance2 = lastUp.position.distanceTo(position);\n        if (distance2 < this.doublePressDistance) {\n          const intervalMs = event.timeStamp - lastUp.time;\n          if (intervalMs < this.doublePressLimitMs) {\n            this.lastUp = null;\n            this.doublePress({ position, intervalMs });\n          }\n        }\n      }\n    };\n    document.addEventListener(\"pointerup\", pointerUp);\n    document.addEventListener(\"pointercancel\", pointerUp);\n    document.addEventListener(\"pointermove\", (event) => {\n      var _a2, _b2;\n      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === event.pointerId) {\n        this.rotating.position = this.getPointerPosition(event);\n      } else if (((_b2 = this.sliding) == null ? void 0 : _b2.pointerId) === event.pointerId) {\n        this.sliding.position = this.getPointerPosition(event);\n      }\n    });\n    canvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n    canvas.addEventListener(\"wheel\", (event) => {\n      this.scroll.add(\n        new THREE.Vector3(event.deltaX, event.deltaY, event.deltaZ)\n      );\n      event.preventDefault();\n    });\n  }\n  getPointerPosition(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    return new THREE.Vector2(\n      event.clientX - rect.left,\n      event.clientY - rect.top\n    );\n  }\n  update(deltaTime, control) {\n    if (!this.enable) {\n      return;\n    }\n    if (this.dualPress && this.rotating && this.sliding) {\n      const motion = [\n        this.rotating.position.clone().sub(this.rotating.last),\n        this.sliding.position.clone().sub(this.sliding.last)\n      ];\n      const coincidence = motion[0].dot(motion[1]);\n      if (coincidence >= 0.2) {\n        const totalMotion = motion[0].clone().add(motion[1]);\n        const slide = new THREE.Vector3(totalMotion.x, -totalMotion.y, 0);\n        slide.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1));\n        slide.applyQuaternion(control.quaternion);\n        control.position.add(slide);\n        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);\n      } else if (coincidence <= -0.2) {\n        const deltaDir = this.sliding.last.clone().sub(this.rotating.last);\n        const deltaDist = deltaDir.length();\n        deltaDir.multiplyScalar(1 / deltaDist).normalize();\n        const orthoDir = new THREE.Vector2(-deltaDir.y, deltaDir.x);\n        const motionDir = [motion[0].dot(deltaDir), motion[1].dot(deltaDir)];\n        const motionOrtho = [motion[0].dot(orthoDir), motion[1].dot(orthoDir)];\n        const midpoint = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);\n        let midpointDir = new THREE.Vector3();\n        if (control instanceof THREE.Camera) {\n          const ndcMidpoint = new THREE.Vector2(\n            midpoint.x / this.canvas.clientWidth * 2 - 1,\n            -(midpoint.y / this.canvas.clientHeight) * 2 + 1\n          );\n          const raycaster = new THREE.Raycaster();\n          raycaster.setFromCamera(ndcMidpoint, control);\n          midpointDir = raycaster.ray.direction;\n        }\n        const pinchOut = motionDir[1] - motionDir[0];\n        const slide = midpointDir.multiplyScalar(pinchOut * this.slideSpeed);\n        control.position.add(slide);\n        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);\n        const angles = [\n          Math.atan(motionOrtho[0] / (-0.5 * deltaDist)),\n          Math.atan(motionOrtho[1] / (0.5 * deltaDist))\n        ];\n        const rotate = 0.5 * (angles[0] + angles[1]) * this.pointerRollScale;\n        const eulers = new THREE.Euler().setFromQuaternion(\n          control.quaternion,\n          \"YXZ\"\n        );\n        eulers.z = Math.max(\n          -Math.PI,\n          Math.min(Math.PI, eulers.z + 0.5 * rotate)\n        );\n        control.quaternion.setFromEuler(eulers);\n      }\n      this.rotating.last.copy(this.rotating.position);\n      this.sliding.last.copy(this.sliding.position);\n    } else {\n      const rotate = new THREE.Vector3();\n      if (this.rotating && !this.dualPress) {\n        const delta = this.rotating.position.clone().sub(this.rotating.last);\n        this.rotating.last.copy(this.rotating.position);\n        rotate.set(delta.x, delta.y, 0);\n        rotate.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1));\n        this.rotateVelocity = rotate.clone().multiplyScalar(1 / deltaTime);\n      } else {\n        this.rotateVelocity.multiplyScalar(\n          Math.exp(-deltaTime / this.rotateInertia)\n        );\n        rotate.addScaledVector(this.rotateVelocity, deltaTime);\n      }\n      const eulers = new THREE.Euler().setFromQuaternion(\n        control.quaternion,\n        \"YXZ\"\n      );\n      eulers.y -= rotate.x;\n      eulers.x = Math.max(\n        -Math.PI / 2,\n        Math.min(Math.PI / 2, eulers.x - rotate.y)\n      );\n      eulers.z *= Math.exp(-0 * deltaTime);\n      control.quaternion.setFromEuler(eulers);\n      if (this.sliding && !this.dualPress) {\n        const delta = this.sliding.position.clone().sub(this.sliding.last);\n        this.sliding.last.copy(this.sliding.position);\n        const slide = this.sliding.button !== 2 ? new THREE.Vector3(delta.x, 0, delta.y) : new THREE.Vector3(delta.x, -delta.y, 0);\n        slide.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1));\n        slide.applyQuaternion(control.quaternion);\n        control.position.add(slide);\n        this.moveVelocity = slide.clone().multiplyScalar(1 / deltaTime);\n      } else {\n        this.moveVelocity.multiplyScalar(\n          Math.exp(-deltaTime / this.moveInertia)\n        );\n        control.position.addScaledVector(this.moveVelocity, deltaTime);\n      }\n    }\n    const scroll = this.scroll.multiplyScalar(this.scrollSpeed);\n    scroll.set(scroll.x, scroll.z, scroll.y);\n    if (this.reverseScroll) {\n      scroll.multiplyScalar(-1);\n    }\n    scroll.applyQuaternion(control.quaternion);\n    control.position.add(scroll);\n    this.scroll.set(0, 0, 0);\n  }\n}\nexport {\n  FINGER_TIPS,\n  FpsMovement,\n  HANDS,\n  Hand,\n  HandMovement,\n  JOINT_IDS,\n  JOINT_INDEX,\n  JOINT_RADIUS,\n  JOINT_SEGMENTS,\n  JOINT_SEGMENT_STEPS,\n  JOINT_TIPS,\n  JointEnum,\n  LN_SCALE_MAX,\n  LN_SCALE_MIN,\n  NUM_JOINTS,\n  PackedSplats,\n  PlyReader,\n  PointerControls,\n  Readback,\n  Sint8ToFloat,\n  SparkControls,\n  SparkRenderer,\n  SparkViewpoint,\n  SplatAccumulator,\n  SplatEdit,\n  SplatEditRgbaBlendMode,\n  SplatEditSdf,\n  SplatEditSdfType,\n  SplatEdits,\n  SplatFileType,\n  SplatGenerator,\n  SplatLoader,\n  SplatMesh,\n  SplatModifier,\n  SplatSkinning,\n  SplatTransformer,\n  SpzReader,\n  SpzWriter,\n  Uint8ToFloat,\n  VRButton,\n  XrHands,\n  constructAxes,\n  constructGrid,\n  constructSpherePoints,\n  defines,\n  dyno,\n  flipPixels,\n  floatToSint8,\n  floatToUint8,\n  fromHalf,\n  generators,\n  getSplatFileType,\n  imageSplats,\n  isAndroid,\n  isMobile,\n  isOculus,\n  isPcSogs,\n  modifiers,\n  pixelsToPngUrl,\n  setPackedSplat,\n  textSplats,\n  toHalf,\n  transcodeSpz,\n  unpackSplat,\n  unpackSplats,\n  utils\n};\n//# sourceMappingURL=spark.module.js.map\n"],"names":["_camera","OrthographicCamera","FullscreenTriangleGeometry","BufferGeometry","Float32BufferAttribute","_geometry","FullScreenQuad","material","Mesh","renderer","value","u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","i","r","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max$1","a","bits","d","p","o","bits16","shft","slc","e","ec","err","ind","msg","nt","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","l2","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","n","lt","dt","t","lms","dms","lpos","sym","add2","dsym","end","shift","dend","et","b2","b4","b8","gzs","flg","zs","Inflate","Inflate2","opts","cb","bts","chunk","inflateSync","data","Gunzip","Gunzip2","td","tds","dutf8","strFromU8","latin1","_a2","slzh","zh","z","fnl","fn","es","bs","z64e","sc","su","off","unzipSync","files","ze","fltr","c_2","no","wasm","cachedTextDecoder","cachedUint8ArrayMemory0","getUint8ArrayMemory0","getStringFromWasm0","ptr","len","raycast_splats","origin_x","origin_y","origin_z","dir_x","dir_y","dir_z","near","far","num_splats","packed_splats","raycast_ellipsoid","ln_scale_min","ln_scale_max","__wbg_load","module","imports","bytes","instance","__wbg_get_imports","arg0","arg1","arg2","table","offset","__wbg_finalize_init","__wbg_init","module_or_path","LN_SCALE_MIN","LN_SCALE_MAX","LN_SCALE_ZERO","SCALE_ZERO","SPLAT_TEX_WIDTH_BITS","SPLAT_TEX_HEIGHT_BITS","SPLAT_TEX_WIDTH","SPLAT_TEX_HEIGHT","SPLAT_TEX_MIN_HEIGHT","isBoolType","isIntType","isUintType","isFloatType","isMatFloatType","isAllFloatType","isMat2","isMat3","isMat4","vectorElementType","vectorDim","numberAsInt","numberAsUint","numberAsFloat","valType","val","DynoValue","DynoOutput","dyno2","key","DynoLiteral","literal","DynoConst","THREE.Vector2","THREE.Vector3","THREE.Vector4","THREE.Quaternion","THREE.Matrix2","arg","_","THREE.Matrix3","THREE.Matrix4","dynoConst","literalZero","typeString","DEFAULT_INDENT","Compilation","indent","Dyno","inTypes","outTypes","inputs","update","globals","statements","generate","inputs2","outputs","compile","_b2","result","declares","name","uniforms","global","dynoDeclare","line","DynoBlock","construct","args","blockInputs","blockOutputs","options","returned","ordering","nodeOuts","visit","node","outKey","outName","outs","input","root","steps","outputs2","source","newSteps","literalOutputs","step2","index","dynoBlock","dyno$1","count","typeStr","unindentLines","seenNonEmpty","lines","trimmedLine","regex","unindent","UnaryOp","outTypeFunc","outType","BinaryOp","Gsplat","TPackedSplats","readPackedSplat","packedSplats","ReadPackedSplat","readPackedSplatRange","base","ReadPackedSplatRange","splitGsplat","gsplat","SplitGsplat","combineGsplat","flags","center","scales","quaternion","rgba","rgb","opacity","y","g","CombineGsplat","transformGsplat","scale","rotate","translate","recolor","TransformGsplat","defineGsplat","definePackedSplats","defineReadPackedSplat","packedSplats2","index2","base2","count2","gsplat2","active","outGsplat","flags2","center2","scales2","quaternion2","rgba2","rgb2","opacity2","x2","y2","z2","r2","g2","b22","scale2","rotate2","translate2","recolor2","outputPackedSplat","rgbMinMaxLnScaleMinMax","OutputPackedSplat","output","rgbMinMaxLnScaleMinMax2","OutputRgba8","rgba8","DynoUniform","value2","allGlobals","DynoBool","DynoInt","DynoFloat","DynoVec2","DynoVec3","DynoVec4","DynoUsampler2DArray","f32buffer","u32buffer","toHalf","f","bits2","sign2","exp3","frac","halfSign","newExp","subFrac","halfFrac","fromHalf","h","f32bits","mant","newFrac","floatToUint8","getArrayBuffers","ctx","buffers","seen","traverse","obj","FreeList","allocate","dispose","valid","item","setPackedSplat","scaleX","scaleY","scaleZ","quatX","quatY","quatZ","quatW","encoding","rgbMin","rgbRange","uR","uG","uB","uA","uQuat","encodeQuatOctXy88R8","uQuatX","uQuatY","uQuatZ","lnScaleMin","lnScaleScale","uScaleX","uScaleY","uScaleZ","uCenterX","uCenterY","uCenterZ","i4","packedCenter","packedScales","packedQuaternion","packedColor","THREE.Color","packedFields","unpackSplat","word0","word1","word2","word3","uScalesX","uScalesY","uScalesZ","decodeQuatOctXy88R8","getTextureSize","numSplats","width","height","depth","maxSplats","cloneClock","clock","newClock","THREE.Clock","IDENT_VERTEX_SHADER","averagePositions","positions","sum","position","averageQuaternions","quaternions","coorientDist","matrix1","matrix2","origin1","rotate1","origin2","distance2","coorient","withinCoorientDist","maxDistance","minCoorient","q","qnorm","theta","xyz_norm","axis","p_x","p_y","tmp","u_f","v_f","quantU","quantV","encoded","out","angleInt","f_x","f_y","f_z","halfTheta","w","decompressPartialGzip","fileBytes","numBytes","chunks","totalBytes","gunzip","allBytes","offset2","CHUNK_SIZE","DynoProgram","graph","template","getMaterial","updater","DynoProgramTemplate","programMaterial","program","THREE.RawShaderMaterial","THREE.GLSL3","addOutputType","operation","error","subOutputType","mulOutputType","add","Add","sub","Sub","mul","Mul","floatBitsToUint","FloatBitsToUint","packHalf2x16","PackHalf2x16","uintToRgba8","UintToRgba8","normalize","Normalize","split","vector","Split","combine","vectorType","Combine","extendVec","ExtendVec","aType","extendVecOutputType","splitOutTypes","vector2","vType","elType","dim","w2","a2","transformPos","TransformPosition","transformDir","dir","TransformDir","position2","dir2","computeVec4_default","_Readback","buffer","newBuffer","ctor","capacity","THREE.WebGLArrayRenderTarget","THREE.NearestFilter","THREE.RGBAFormat","THREE.UnsignedByteType","reader","state","layerSize","baseIndex","layer","layerBase","layerYEnd","readback","roundedCount","readbackUint8","promises","readbackSize","subReadback","promise","renderState","Readback","_RgbaArray","TRgbaArray","defineRgbaArray","newArray2","texture2","THREE.DataArrayTexture","dynoSplats","dynoBase","dynoCount","emptyArray","DynoPackedSplats","RgbaArray","readRgbaArray","sdfTypeToNumber","rgbaBlendModeToNumber","mode","SplatEditSdf","THREE.Object3D","invert","color","displace","radius","_SplatEdit","rgbaBlendMode","sdfSmooth","softEdge","sdfs","sdf","SplatEdit","SplatEdits","maxSdfs","maxEdits","SdfArray","defineSdfArray","uniform2","THREE.DataTexture","THREE.RGBAIntegerFormat","THREE.UnsignedIntType","defineEdit","dynoUpdated","updated","tempFloat32","editIndex","sdfFirst","sdfCount","sdfIndex","sdfType","sizes","values","nValues","vBase","edits","total","edit","sdfUpdated","applyGsplatRgbaDisplaceEdits","sdfArray","numEdits","rgbaDisplaceEdits","sdfArray2","numEdits2","rgbaDisplaceEdits2","SplatModifier","modifier","generator","modified","SplatTransformer","transform","newScale","object","SplatGenerator","constructed","_SplatMesh","viewToWorld","worldToView","viewToObject","time","deltaTime","context","time2","deltaTime2","viewToWorld2","globalEdits","PackedSplats","DEFAULT_SPLAT_ENCODING","maybePromise","url","fileType","fileName","constructSplats","splatEncoding","packedSplatsOptions","callback","centers_only","minVec","maxVec","corners","signs","_index","_opacity","_color","THREE.Box3","sh1Texture","sh2Texture","sh3Texture","rescaleSh","sNorm","minMax","min2","max2","mid","viewCenterInObject","viewDir","sh1Snorm","evaluateSH1","sh2Snorm","evaluateSH2","sh3Snorm","evaluateSH3","recolorRgba","viewToObjectMatrix","newRecolor","editsSdfs","edits2","editResult","raycaster","intersects","ray","worldToMesh","worldToMeshRot","origin","direction","distances","point","sh1","newSh1","THREE.RGIntegerFormat","sh2","newSh2","sh3","newSh3","SplatMesh","defineEvaluateSH1","defineEvaluateSH2","defineEvaluateSH3","_PlyReader","decoder","controller","headerTerminator","done","endHeader","headerLen","curElement","lineIndex","fields","elementCallback","elementName","element","properties","parsers","propertyName","property","list","PARSE_FIELD","FIELD_BYTES","parser","splatCallback","shCallback","isSuperSplat","ssChunks","numSh","sh1Props","sh2Props","sh3Props","prepareSh","num_f_rest","NUM_SH_TO_NUM_F_REST","k","_2","ssShCallback","initSuperSplat","min_x","min_y","min_z","max_x","max_y","max_z","min_scale_x","min_scale_y","min_scale_z","max_scale_x","max_scale_y","max_scale_z","min_x2","min_y2","min_z2","max_x2","max_y2","max_z2","min_scale_x2","min_scale_y2","min_scale_z2","max_scale_x2","max_scale_y2","max_scale_z2","min_r","min_g","min_b","max_r","max_g","max_b","decodeSuperSplat","getNumSh","packed_position","packed_rotation","packed_scale","packed_color","SQRT2","packed_position2","packed_rotation2","packed_scale2","packed_color2","r0","r1","rr","rOrder","scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","f_dc_0","f_dc_1","f_dc_2","red","green","blue","alpha","hasScales","hasRots","alphaDiv","FIELD_SCALE","redDiv","greenDiv","blueDiv","op","SH_C0$1","rgbaOffset","isVertex","length2","component","SET_FIELD","PlyReader","littleEndian","NUM_F_REST_TO_NUM_SH","jsContent","blob","WorkerWrapper","objURL","worker","SplatWorker","event","id","resolve","reject","handler","maxWorkers","numWorkers","freeWorkers","workerQueue","allocWorker","worker2","freeWorker","waiter","withWorker","SplatLoader","Loader","manager","FileLoader","onLoad","onProgress","onError","resolvedURL","headers","credentials","request","fetchWithProgress","progresses","updateProgresses","lengthComputable","loaded","extraFiles","pcSogsJson","tryPcSogs","prop","file","fileUrl","progressIndex","request2","progress","decoded","unpackSplats","response","contentLength","getSplatFileType","view","header","tryPcSogsZip","getFileExtension","pathOrUrl","noTrailing","lastSlash","filename","lastDot","getSplatFileTypeFromPath","extension","text","json","metaFilename","unzipped","splatFileType","ply","packedArray","numSplats2","extra","computeUvec4_default","_PackedSplats","_c","_d","loader","unpacked","targetSize","currentSize","level","wordsPerSplat","textureSize2","splatCounts","mapping","rounded","nextBase","layerYStart","_e","_f","_g","_h","_i","_j","SplatGeometry","THREE.InstancedBufferGeometry","activeSplats","THREE.BufferAttribute","QUAD_VERTICES","QUAD_INDICES","THREE.InstancedBufferAttribute","THREE.DynamicDrawUsage","_SparkViewpoint","doubleBuffer","superXY","THREE.WebGLRenderTarget","THREE.SRGBColorSpace","autoUpdate","scene","camera","forceOrigin","originToWorld","accumulator","target","THREE.PerspectiveCamera","newCam","byteSize","subWidth","subHeight","subSize","superPixels","pixels","super2","row","superCol","sy","superRow","sx","superIndex","pixelIndex","needsSort","displayed","mappingVersion","latestView","doubleSortReader","sort32Reader","dynoSortRadial","dynoOrigin","dynoDirection","dynoDepthBias","dynoSort360","sort32","halfMaxSplats","worldToOrigin","viewToOrigin","sortReader","rpcName","oldOrdering","sortParams","gsplat0","metric0","computeSortMetric","gsplat1","metric1","combined","metric","THREE.Texture","SparkViewpoint","defineComputeSortMetric","sortRadial","sortOrigin","sortDirection","sortDepthBias","sort360","sortRadial2","sortOrigin2","sortDirection2","sortDepthBias2","sort3602","SplatAccumulator","generators2","forceUpdate","map","record","version","current","modGenerator","other","otherNode","otherBase","otherCount","splatDefines_default","splatFragment_default","splatVertex_default","shaders","getShaders","THREE.ShaderChunk","MAX_ACCUMULATORS","hasSplatMesh","hasSparkRenderer","sparkRendererInstance","containsSplatMesh","object3D","hasSplatMesh2","child","sceneAdd","THREE.Scene","SparkRenderer","sceneOnBeforeRender","spark","_SparkRenderer","THREE.Mesh","shaders2","premultipliedAlpha","THREE.ShaderMaterial","THREE.DoubleSide","EMPTY_GEOMETRY","frame","isNewFrame","viewpoint","cameras","camera2","averageOriginToWorlds","renderSize","baseLayer","typedCamera","enable","multiply","accumToWorld","worldToCamera","geometry","scene2","originToWorld2","activeMapping","visibleGenerators","visibleGenHash","originUpdate","needsUpdate","_a3","originChanged","genOrder","gIndex","lastGen","_version","_seq","newGenerators","hasCorrespondence","ancestor","worldCenter","size","hideObjects","target2","THREE.WebGLCubeRenderTarget","THREE.LinearMipMapLinearFilter","THREE.CubeCamera","THREE.PMREMGenerator","objectVisibility","visible","envMap","THREE.MeshStandardMaterial","THREE.Data3DTexture","originToWorlds","matrix","_VRButton","sessionInit","navigatorXr","xr","button","showEnterVR","currentSession","onSessionStarted","session","onSessionEnded","sessionOptions","disableButton","showWebXRNotFound","showVRNotAllowed","exception","stylizeElement","supported","VRButton","JointEnum","JointEnum2","JOINT_IDS"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GACvBC,GAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GACxBC,GAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","x_google_ignoreList":[0]}